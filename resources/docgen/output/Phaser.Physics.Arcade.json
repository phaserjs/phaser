{"class":{"name":"Phaser.Physics.Arcade","extends":"","static":false,"constructor":true,"parameters":[{"name":"game","type":["Phaser.Game"],"help":"reference to the current game instance.","optional":false,"default":null}],"help":"The Arcade Physics world. Contains Arcade Physics related collision, overlap and motion methods."},"consts":[],"methods":{"public":[{"name":"accelerateToObject","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new trajectory."},"help":"Sets the acceleration.x\/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\\nYou must give a maximum speed value, beyond which the display object won't go any faster.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.","line":1615,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"destination","type":["any"],"help":"The display object to move towards. Can be any object but must have visible x\/y properties.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will accelerate in pixels per second.","optional":true,"default":"60"},{"name":"xSpeedMax","type":["number"],"help":"The maximum x velocity the display object can reach.","optional":true,"default":"500"},{"name":"ySpeedMax","type":["number"],"help":"The maximum y velocity the display object can reach.","optional":true,"default":"500"}],"inherited":false,"inheritedFrom":""},{"name":"accelerateToPointer","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new trajectory."},"help":"Sets the acceleration.x\/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\\nYou must give a maximum speed value, beyond which the display object won't go any faster.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.","line":1644,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"pointer","type":["Phaser.Pointer"],"help":"The pointer to move towards. Defaults to Phaser.Input.activePointer.","optional":true,"default":null},{"name":"speed","type":["number"],"help":"The speed it will accelerate in pixels per second.","optional":true,"default":"60"},{"name":"xSpeedMax","type":["number"],"help":"The maximum x velocity the display object can reach.","optional":true,"default":"500"},{"name":"ySpeedMax","type":["number"],"help":"The maximum y velocity the display object can reach.","optional":true,"default":"500"}],"inherited":false,"inheritedFrom":""},{"name":"accelerateToXY","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new trajectory."},"help":"Sets the acceleration.x\/y property on the display object so it will move towards the x\/y coordinates at the given speed (in pixels per second sq.)\\nYou must give a maximum speed value, beyond which the display object won't go any faster.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.","line":1675,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"x","type":["number"],"help":"The x coordinate to accelerate towards.","optional":false,"default":null},{"name":"y","type":["number"],"help":"The y coordinate to accelerate towards.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will accelerate in pixels per second.","optional":true,"default":"60"},{"name":"xSpeedMax","type":["number"],"help":"The maximum x velocity the display object can reach.","optional":true,"default":"500"},{"name":"ySpeedMax","type":["number"],"help":"The maximum y velocity the display object can reach.","optional":true,"default":"500"}],"inherited":false,"inheritedFrom":""},{"name":"accelerationFromRotation","static":false,"returns":{"types":["Phaser.Point"],"help":"- A Point where point.x contains the acceleration x value and point.y contains the acceleration y value."},"help":"Given the rotation (in radians) and speed calculate the acceleration and return it as a Point object, or set it to the given point object.\\nOne way to use this is: accelerationFromRotation(rotation, 200, sprite.acceleration) which will set the values directly to the sprites acceleration and not create a new Point object.","line":1592,"public":true,"protected":false,"private":false,"parameters":[{"name":"rotation","type":["number"],"help":"The angle in radians.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second sq.","optional":true,"default":"60"},{"name":"point","type":["Phaser.Point","object"],"help":"The Point object in which the x and y properties will be set to the calculated acceleration.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"angleBetween","static":false,"returns":{"types":["number"],"help":"The angle in radians between the source and target display objects."},"help":"Find the angle in radians between two display objects (like Sprites).","line":1756,"public":true,"protected":false,"private":false,"parameters":[{"name":"source","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"target","type":["any"],"help":"The Display Object to test to.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"angleToPointer","static":false,"returns":{"types":["number"],"help":"The angle in radians between displayObject.x\/y to Pointer.x\/y"},"help":"Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x\/y and center into account.","line":1791,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"pointer","type":["Phaser.Pointer"],"help":"The Phaser.Pointer to test to. If none is given then Input.activePointer is used.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"angleToXY","static":false,"returns":{"types":["number"],"help":"The angle in radians between displayObject.x\/y to Pointer.x\/y"},"help":"Find the angle in radians between a display object (like a Sprite) and the given x\/y coordinate.","line":1774,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"x","type":["number"],"help":"The x coordinate to get the angle to.","optional":false,"default":null},{"name":"y","type":["number"],"help":"The y coordinate to get the angle to.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collide","static":false,"returns":{"types":["boolean"],"help":"True if a collision occured otherwise false."},"help":"Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.\\nBoth the first and second parameter can be arrays of objects, of differing types.\\nIf two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.\\nThe objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.\\nAn optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\\ngiving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\\nThe collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.\\nNOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups or Tilemaps within other Groups).","line":414,"public":true,"protected":false,"private":false,"parameters":[{"name":"object1","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","Phaser.TilemapLayer","array"],"help":"The first object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.TilemapLayer.","optional":false,"default":null},{"name":"object2","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","Phaser.TilemapLayer","array"],"help":"The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.TilemapLayer.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are colliding Group vs. Sprite, in which case Sprite will always be the first parameter.","optional":true,"default":"null"},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":true,"default":"null"},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"computeVelocity","static":false,"returns":{"types":["number"],"help":"The altered Velocity value."},"help":"A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.\\nBased on a function in Flixel by @ADAMATOMIC","line":290,"public":true,"protected":false,"private":false,"parameters":[{"name":"axis","type":["number"],"help":"0 for nothing, 1 for horizontal, 2 for vertical.","optional":false,"default":null},{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to be updated.","optional":false,"default":null},{"name":"velocity","type":["number"],"help":"Any component of velocity (e.g. 20).","optional":false,"default":null},{"name":"acceleration","type":["number"],"help":"Rate at which the velocity is changing.","optional":false,"default":null},{"name":"drag","type":["number"],"help":"Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.","optional":false,"default":null},{"name":"max","type":["number"],"help":"An absolute value cap for the velocity.","optional":true,"default":"10000"}],"inherited":false,"inheritedFrom":""},{"name":"distanceBetween","static":false,"returns":{"types":["number"],"help":"The distance between the source and target objects."},"help":"Find the distance between two display objects (like Sprites).","line":1698,"public":true,"protected":false,"private":false,"parameters":[{"name":"source","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"target","type":["any"],"help":"The Display Object to test to.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"distanceToPointer","static":false,"returns":{"types":["number"],"help":"The distance between the object and the Pointer."},"help":"Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.\\nThe calculation is made from the display objects x\/y coordinate. This may be the top-left if its anchor hasn't been changed.\\nIf you need to calculate from the center of a display object instead use the method distanceBetweenCenters()","line":1737,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"pointer","type":["Phaser.Pointer"],"help":"The Phaser.Pointer to test to. If none is given then Input.activePointer is used.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"distanceToXY","static":false,"returns":{"types":["number"],"help":"The distance between the object and the x\/y coordinates."},"help":"Find the distance between a display object (like a Sprite) and the given x\/y coordinates.\\nThe calculation is made from the display objects x\/y coordinate. This may be the top-left if its anchor hasn't been changed.\\nIf you need to calculate from the center of a display object instead use the method distanceBetweenCenters()","line":1718,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The Display Object to test from.","optional":false,"default":null},{"name":"x","type":["number"],"help":"The x coordinate to move towards.","optional":false,"default":null},{"name":"y","type":["number"],"help":"The y coordinate to move towards.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"enable","static":false,"returns":null,"help":"This will create an Arcade Physics body on the given game object or array of game objects.\\nA game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.","line":196,"public":true,"protected":false,"private":false,"parameters":[{"name":"object","type":["object","array","Phaser.Group"],"help":"The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.","optional":false,"default":null},{"name":"children","type":["boolean"],"help":"Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.","optional":true,"default":"true"}],"inherited":false,"inheritedFrom":""},{"name":"enableBody","static":false,"returns":null,"help":"Creates an Arcade Physics body on the given game object.\\nA game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.","line":251,"public":true,"protected":false,"private":false,"parameters":[{"name":"object","type":["object"],"help":"The game object to create the physics body on. A body will only be created if this object has a null `body` property.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"getObjectsUnderPointer","static":false,"returns":{"types":["array"],"help":"An array of the Sprites from the Group that overlapped the Pointer coordinates."},"help":"Given a Group and a Pointer this will check to see which Group children overlap with the Pointer coordinates.\\nEach child will be sent to the given callback for further processing.\\nNote that the children are not checked for depth order, but simply if they overlap the Pointer or not.","line":1403,"public":true,"protected":false,"private":false,"parameters":[{"name":"pointer","type":["Phaser.Pointer"],"help":"The Pointer to check.","optional":false,"default":null},{"name":"group","type":["Phaser.Group"],"help":"The Group to check.","optional":false,"default":null},{"name":"callback","type":["function"],"help":"A callback function that is called if the object overlaps with the Pointer. The callback will be sent two parameters: the Pointer and the Object that overlapped with it.","optional":true,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callback.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"intersects","static":false,"returns":{"types":["boolean"],"help":"True if they intersect, otherwise false."},"help":"Check for intersection against two bodies.","line":854,"public":true,"protected":false,"private":false,"parameters":[{"name":"body1","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to check.","optional":false,"default":null},{"name":"body2","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to check.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"moveToObject","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new velocity."},"help":"Move the given display object towards the destination object at a steady velocity.\\nIf you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.\\nNote: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)","line":1453,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"destination","type":["any"],"help":"The display object to move towards. Can be any object but must have visible x\/y properties.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second (default is 60 pixels\/sec)","optional":true,"default":"60"},{"name":"maxTime","type":["number"],"help":"Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.","optional":true,"default":"0"}],"inherited":false,"inheritedFrom":""},{"name":"moveToPointer","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new velocity."},"help":"Move the given display object towards the pointer at a steady velocity. If no pointer is given it will use Phaser.Input.activePointer.\\nIf you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.","line":1487,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second (default is 60 pixels\/sec)","optional":true,"default":"60"},{"name":"pointer","type":["Phaser.Pointer"],"help":"The pointer to move towards. Defaults to Phaser.Input.activePointer.","optional":true,"default":null},{"name":"maxTime","type":["number"],"help":"Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.","optional":true,"default":"0"}],"inherited":false,"inheritedFrom":""},{"name":"moveToXY","static":false,"returns":{"types":["number"],"help":"The angle (in radians) that the object should be visually set to in order to match its new velocity."},"help":"Move the given display object towards the x\/y coordinates at a steady velocity.\\nIf you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\\nTimings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\\nNote: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\\nNote: The display object doesn't stop moving once it reaches the destination coordinates.\\nNote: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)","line":1524,"public":true,"protected":false,"private":false,"parameters":[{"name":"displayObject","type":["any"],"help":"The display object to move.","optional":false,"default":null},{"name":"x","type":["number"],"help":"The x coordinate to move towards.","optional":false,"default":null},{"name":"y","type":["number"],"help":"The y coordinate to move towards.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second (default is 60 pixels\/sec)","optional":true,"default":"60"},{"name":"maxTime","type":["number"],"help":"Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.","optional":true,"default":"0"}],"inherited":false,"inheritedFrom":""},{"name":"overlap","static":false,"returns":{"types":["boolean"],"help":"True if an overlap occurred otherwise false."},"help":"Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.\\nYou can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.\\nUnlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\\nBoth the first and second parameter can be arrays of objects, of differing types.\\nIf two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.\\nNOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups within Groups).","line":354,"public":true,"protected":false,"private":false,"parameters":[{"name":"object1","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","array"],"help":"The first object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.","optional":false,"default":null},{"name":"object2","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","array"],"help":"The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.","optional":false,"default":null},{"name":"overlapCallback","type":["function"],"help":"An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them.","optional":true,"default":"null"},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then overlapCallback will only be called if processCallback returns true.","optional":true,"default":"null"},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"setBounds","static":false,"returns":null,"help":"Updates the size of this physics world.","line":171,"public":true,"protected":false,"private":false,"parameters":[{"name":"x","type":["number"],"help":"Top left most corner of the world.","optional":false,"default":null},{"name":"y","type":["number"],"help":"Top left most corner of the world.","optional":false,"default":null},{"name":"width","type":["number"],"help":"New width of the world. Can never be smaller than the Game.width.","optional":false,"default":null},{"name":"height","type":["number"],"help":"New height of the world. Can never be smaller than the Game.height.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"setBoundsToWorld","static":false,"returns":null,"help":"Updates the size of this physics world to match the size of the game world.","line":182,"public":true,"protected":false,"private":false,"parameters":[],"inherited":false,"inheritedFrom":""},{"name":"updateMotion","static":false,"returns":null,"help":"Called automatically by a Physics body, it updates all motion related values on the Body.","line":266,"public":true,"protected":false,"private":false,"parameters":[{"name":"The","type":["Phaser.Physics.Arcade.Body"],"help":" Body object to be updated.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"velocityFromAngle","static":false,"returns":{"types":["Phaser.Point"],"help":"- A Point where point.x contains the velocity x value and point.y contains the velocity y value."},"help":"Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\\nOne way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.","line":1554,"public":true,"protected":false,"private":false,"parameters":[{"name":"angle","type":["number"],"help":"The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second sq.","optional":true,"default":"60"},{"name":"point","type":["Phaser.Point","object"],"help":"The Point object in which the x and y properties will be set to the calculated velocity.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"velocityFromRotation","static":false,"returns":{"types":["Phaser.Point"],"help":"- A Point where point.x contains the velocity x value and point.y contains the velocity y value."},"help":"Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\\nOne way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.","line":1573,"public":true,"protected":false,"private":false,"parameters":[{"name":"rotation","type":["number"],"help":"The angle in radians.","optional":false,"default":null},{"name":"speed","type":["number"],"help":"The speed it will move, in pixels per second sq.","optional":true,"default":"60"},{"name":"point","type":["Phaser.Point","object"],"help":"The Point object in which the x and y properties will be set to the calculated velocity.","optional":true,"default":null}],"inherited":false,"inheritedFrom":""}],"protected":[],"private":[{"name":"collideGroupVsGroup","static":false,"returns":null,"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":680,"public":false,"protected":false,"private":true,"parameters":[{"name":"group1","type":["Phaser.Group"],"help":"The first Group to check.","optional":false,"default":null},{"name":"group2","type":["Phaser.Group"],"help":"The second Group to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideGroupVsSelf","static":false,"returns":{"types":["boolean"],"help":"True if there was a collision, otherwise false."},"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":646,"public":false,"protected":false,"private":true,"parameters":[{"name":"group","type":["Phaser.Group"],"help":"The Group to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideGroupVsTilemapLayer","static":false,"returns":null,"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":780,"public":false,"protected":false,"private":true,"parameters":[{"name":"group","type":["Phaser.Group"],"help":"The Group to check.","optional":false,"default":null},{"name":"tilemapLayer","type":["Phaser.TilemapLayer"],"help":"The layer to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideHandler","static":false,"returns":null,"help":"Internal collision handler.","line":468,"public":false,"protected":false,"private":true,"parameters":[{"name":"object1","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","Phaser.TilemapLayer"],"help":"The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.TilemapLayer.","optional":false,"default":null},{"name":"object2","type":["Phaser.Sprite","Phaser.Group","Phaser.Particles.Emitter","Phaser.TilemapLayer"],"help":"The second object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.TilemapLayer. Can also be an array of objects to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideSpriteVsGroup","static":false,"returns":null,"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":589,"public":false,"protected":false,"private":true,"parameters":[{"name":"sprite","type":["Phaser.Sprite"],"help":"The sprite to check.","optional":false,"default":null},{"name":"group","type":["Phaser.Group"],"help":"The Group to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideSpriteVsSprite","static":false,"returns":{"types":["boolean"],"help":"True if there was a collision, otherwise false."},"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":556,"public":false,"protected":false,"private":true,"parameters":[{"name":"sprite1","type":["Phaser.Sprite"],"help":"The first sprite to check.","optional":false,"default":null},{"name":"sprite2","type":["Phaser.Sprite"],"help":"The second sprite to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"collideSpriteVsTilemapLayer","static":false,"returns":null,"help":"An internal function. Use Phaser.Physics.Arcade.collide instead.","line":716,"public":false,"protected":false,"private":true,"parameters":[{"name":"sprite","type":["Phaser.Sprite"],"help":"The sprite to check.","optional":false,"default":null},{"name":"tilemapLayer","type":["Phaser.TilemapLayer"],"help":"The layer to check.","optional":false,"default":null},{"name":"collideCallback","type":["function"],"help":"An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.","optional":false,"default":null},{"name":"callbackContext","type":["object"],"help":"The context in which to run the callbacks.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"processTileSeparationX","static":false,"returns":{"types":["boolean"],"help":"Returns true as a pass-thru to the separateTile method."},"help":"Internal function to process the separation of a physics body from a tile.","line":1335,"public":false,"protected":false,"private":true,"parameters":[{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"x","type":["number"],"help":"The x separation amount.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"processTileSeparationY","static":false,"returns":null,"help":"Internal function to process the separation of a physics body from a tile.","line":1367,"public":false,"protected":false,"private":true,"parameters":[{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"y","type":["number"],"help":"The y separation amount.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"separate","static":false,"returns":{"types":["boolean"],"help":"Returns true if the bodies collided, otherwise false."},"help":"The core separation function to separate two physics bodies.","line":809,"public":false,"protected":false,"private":true,"parameters":[{"name":"body1","type":["Phaser.Physics.Arcade.Body"],"help":"The first Body object to separate.","optional":false,"default":null},{"name":"body2","type":["Phaser.Physics.Arcade.Body"],"help":"The second Body object to separate.","optional":false,"default":null},{"name":"processCallback","type":["function"],"help":"A callback function that lets you perform additional checks against the two objects if they overlap. If this function is set then the sprites will only be collided if it returns true.","optional":true,"default":"null"},{"name":"callbackContext","type":["object"],"help":"The context in which to run the process callback.","optional":true,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"Just run an overlap or a full collision.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"separateTile","static":false,"returns":{"types":["boolean"],"help":"Returns true if the body was separated, otherwise false."},"help":"The core separation function to separate a physics body and a tile.","line":1134,"public":false,"protected":false,"private":true,"parameters":[{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"tile","type":["Phaser.Tile"],"help":"The tile to collide against.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"separateX","static":false,"returns":{"types":["boolean"],"help":"Returns true if the bodies were separated, otherwise false."},"help":"The core separation function to separate two physics bodies on the x axis.","line":890,"public":false,"protected":false,"private":true,"parameters":[{"name":"body1","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"body2","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"separateY","static":false,"returns":{"types":["boolean"],"help":"Returns true if the bodies were separated, otherwise false."},"help":"The core separation function to separate two physics bodies on the y axis.","line":1006,"public":false,"protected":false,"private":true,"parameters":[{"name":"body1","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"body2","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"overlapOnly","type":["boolean"],"help":"If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"tileCheckX","static":false,"returns":{"types":["number"],"help":"The amount of separation that occured."},"help":"Check the body against the given tile on the X axis.","line":1237,"public":false,"protected":false,"private":true,"parameters":[{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"tile","type":["Phaser.Tile"],"help":"The tile to check.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""},{"name":"tileCheckY","static":false,"returns":{"types":["number"],"help":"The amount of separation that occured."},"help":"Check the body against the given tile on the Y axis.","line":1286,"public":false,"protected":false,"private":true,"parameters":[{"name":"body","type":["Phaser.Physics.Arcade.Body"],"help":"The Body object to separate.","optional":false,"default":null},{"name":"tile","type":["Phaser.Tile"],"help":"The tile to check.","optional":false,"default":null}],"inherited":false,"inheritedFrom":""}],"static":[]},"properties":{"public":[{"name":"OVERLAP_BIAS","type":["number"],"help":"","inlineHelp":"A value added to the delta values during collision checks.","line":51,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"TILE_BIAS","type":["number"],"help":"","inlineHelp":"A value added to the delta values during collision with tiles. Adjust this if you get tunnelling.","line":56,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"bounds","type":["Phaser.Rectangle"],"help":"","inlineHelp":"The bounds inside of which the physics world exists. Defaults to match the world bounds.","line":29,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"checkCollision","type":["object"],"help":"Set the checkCollision properties to control for which bounds collision is processed.\\nFor example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.","inlineHelp":"An object containing allowed collision flags.","line":36,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"forceX","type":["boolean"],"help":"","inlineHelp":"If true World.separate will always separate on the X axis before Y. Otherwise it will check gravity totals first.","line":61,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"game","type":["Phaser.Game"],"help":"","inlineHelp":"Local reference to game.","line":19,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"gravity","type":["Phaser.Point"],"help":"","inlineHelp":"The World gravity setting. Defaults to x: 0, y: 0, or no gravity.","line":24,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"maxLevels","type":["number"],"help":"","inlineHelp":"Used by the QuadTree to set the maximum number of iteration levels.","line":46,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"maxObjects","type":["number"],"help":"","inlineHelp":"Used by the QuadTree to set the maximum number of objects per quad.","line":41,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"quadTree","type":["Phaser.QuadTree"],"help":"","inlineHelp":"The world QuadTree.","line":71,"default":null,"public":true,"protected":false,"private":false,"readOnly":false},{"name":"skipQuadTree","type":["boolean"],"help":"","inlineHelp":"If true a QuadTree will never be used for any collision. Handy for tightly packed games. See also Body.skipQuadTree.","line":66,"default":null,"public":true,"protected":false,"private":false,"readOnly":false}],"protected":[],"private":[{"name":"_angle","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":139,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_average","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":115,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_dx","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":145,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_dy","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":151,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_mapData","type":["array"],"help":"","inlineHelp":"Internal cache var.","line":121,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_maxOverlap","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":85,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_newVelocity1","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":103,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_newVelocity2","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":109,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_overlap","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":79,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_result","type":["boolean"],"help":"","inlineHelp":"Internal cache var.","line":127,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_total","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":133,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_velocity1","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":91,"default":null,"public":false,"protected":false,"private":true,"readOnly":false},{"name":"_velocity2","type":["number"],"help":"","inlineHelp":"Internal cache var.","line":97,"default":null,"public":false,"protected":false,"private":true,"readOnly":false}]}}