/// <reference path="pixi.d.ts" />
// Type definitions for Phaser dev2.2.0 RC12 2014-12-02
// Project: https://github.com/photonstorm/phaser

declare class Phaser {

    static VERSION: string;

    static DEV_VERSION: string;

    static GAMES: Phaser.Game[];

    static AUTO: number;

    static CANVAS: number;

    static WEBGL: number;

    static HEADLESS: number;

    static BITMAPDATA: number;

    static BITMAPTEXT: number;

    static BUTTON: number;

    static CANVAS_FILTER: number;

    static ELLIPSE: number;

    static EMITTER: number;

    static GRAPHICS: number;

    static GROUP: number;

    static IMAGE: number;

    static POINTER: number;

    static POLYGON: number;

    static RENDERTEXTURE: number;

    static RETROFONT: number;

    static SPRITE: number;

    static SPRITEBATCH: number;

    static TEXT: number;

    static TILEMAP: number;

    static TILEMAPLAYER: number;

    static TILESPRITE: number;

    static WEBGL_FILTER: number;

    static ROPE: number;

    static NONE: number;

    static LEFT: number;

    static RIGHT: number;

    static UP: number;

    static DOWN: number;

}
declare module Phaser {

    /**
    * The Animation Manager is used to add, play and update Phaser Animations.
    * Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.
    *
    * @class Phaser.AnimationManager
    * @constructor
    * @param {Phaser.Sprite} sprite - A reference to the Game Object that owns this AnimationManager.
    */
    class Animation {

        constructor(game: Phaser.Game, parent: Phaser.Sprite, name: string, frameData: Phaser.FrameData, frames: any[], frameRate?: number, loop?: boolean);

        /**
        * @property {Phaser.Animation} currentAnim - The currently displayed animation, if any.
        * @default
        */
        currentAnim: Phaser.Animation;

        /**
        * @property {Phaser.Frame} currentFrame - The currently displayed Frame of animation, if any.
        * @default
        */
        currentFrame: Phaser.Frame;

        /**
        * @property {number} delay - The amount to delay by until the Tween starts (in ms).
        * @default
        */
        delay: number;

        /**
        * @name Phaser.Animation#enableUpdate
        * @property {boolean} enableUpdate - Gets or sets if this animation will dispatch the onUpdate events upon changing frame.
        */
        enableUpdate: boolean;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: number;

        /**
        * @name Phaser.AnimationManager#frameTotal
        * @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.
        * @readonly
        */
        frameTotal: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isFinished - The finished state of the Animation. Set to true once playback completes, false during playback.
        * @default
        */
        isFinished: boolean;

        /**
        * @property {boolean} isPaused - Is this Tween paused or not?
        * @default
        */
        isPaused: boolean;

        /**
        * @property {boolean} isPlaying - The playing state of the Animation. Set to false once playback completes, true during playback.
        * @default
        */
        isPlaying: boolean;

        /**
        * @property {boolean} killOnComplete - Should the parent of this Animation be killed when the animation completes?
        * @default
        */
        killOnComplete: boolean;

        /**
        * @property {boolean} loop - True if this TimerEvent loops, otherwise false.
        */
        loop: boolean;

        /**
        * @property {number} loopCount - The number of times the animation has looped since it was last started.
        */
        loopCount: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Signal} onComplete - This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onAnimationLoop instead.
        */
        onComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onLoop - This event is dispatched when this Animation loops.
        */
        onLoop: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onStart - This event is dispatched when this Animation starts playback.
        */
        onStart: Phaser.Signal;

        /**
        * @property {Phaser.Signal|null} onUpdate - This event is dispatched when the Animation changes frame. By default this event is disabled due to its intensive nature. Enable it with: `Animation.enableUpdate = true`.
        * @default
        */
        onUpdate: Phaser.Signal;

        /**
        * The paused state of the Game. A paused game doesn't update any of its subsystems.
        * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
        * @name Phaser.Game#paused
        * @property {boolean} paused - Gets and sets the paused state of the Game.
        */
        paused: boolean;

        /**
        * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
        */
        speed: number;

        /**
        * Called internally when the animation finishes playback.
        * Sets the isPlaying and isFinished states and dispatches the onAnimationComplete event if it exists on the parent and local onComplete event.
        *
        * @method Phaser.Animation#complete
        */
        complete(): void;

        /**
        * Cleans up this animation ready for deletion. Nulls all values and references.
        *
        * @method Phaser.Animation#destroy
        */
        destroy(): void;

        /**
        * Really handy function for when you are creating arrays of animation data but it's using frame names and not numbers.
        * For example imagine you've got 30 frames named: 'explosion_0001-large' to 'explosion_0030-large'
        * You could use this function to generate those by doing: Phaser.Animation.generateFrameNames('explosion_', 1, 30, '-large', 4);
        *
        * @method Phaser.Animation.generateFrameNames
        * @static
        * @param {string} prefix - The start of the filename. If the filename was 'explosion_0001-large' the prefix would be 'explosion_'.
        * @param {number} start - The number to start sequentially counting from. If your frames are named 'explosion_0001' to 'explosion_0034' the start is 1.
        * @param {number} stop - The number to count to. If your frames are named 'explosion_0001' to 'explosion_0034' the stop value is 34.
        * @param {string} [suffix=''] - The end of the filename. If the filename was 'explosion_0001-large' the prefix would be '-large'.
        * @param {number} [zeroPad=0] - The number of zeroes to pad the min and max values with. If your frames are named 'explosion_0001' to 'explosion_0034' then the zeroPad is 4.
        * @return {string[]} An array of framenames.
        */
        static generateFrameNames(prefix: string, start: number, stop: number, suffix?: string, zeroPad?: number): string[];

        /**
        * Advances by the given number of frames in the Animation, taking the loop value into consideration.
        *
        * @method Phaser.Animation#next
        * @param {number} [quantity=1] - The number of frames to advance.
        */
        next(quantity?: number): void;

        /**
        * Called when the Game enters a paused state.
        *
        * @method Phaser.Animation#onPause
        */
        onPause(): void;

        /**
        * Called when the Game resumes from a paused state.
        *
        * @method Phaser.Animation#onResume
        */
        onResume(): void;

        /**
        * Plays this animation.
        *
        * @method Phaser.Animation#play
        * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.
        * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.
        * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.
        * @return {Phaser.Animation} - A reference to this Animation instance.
        */
        play(frameRate?: number, loop?: boolean, killOnComplete?: boolean): Phaser.Animation;

        /**
        * Moves backwards the given number of frames in the Animation, taking the loop value into consideration.
        *
        * @method Phaser.Animation#previous
        * @param {number} [quantity=1] - The number of frames to move back.
        */
        previous(quantity?: number): void;

        /**
        * Sets this animation back to the first frame and restarts the animation.
        *
        * @method Phaser.Animation#restart
        */
        restart(): void;

        /**
        * Sets this animations playback to a given frame with the given ID.
        *
        * @method Phaser.Animation#setFrame
        * @param {string|number} [frameId] - The identifier of the frame to set. Can be the name of the frame, the sprite index of the frame, or the animation-local frame index.
        * @param {boolean} [useLocalFrameIndex=false] - If you provide a number for frameId, should it use the numeric indexes of the frameData, or the 0-indexed frame index local to the animation.
        */
        setFrame(frameId?: any, useLocalFrameIndex?: boolean): void;

        /**
        * Stops playback of this animation and set it to a finished state. If a resetFrame is provided it will stop playback and set frame to the first in the animation.
        * If `dispatchComplete` is true it will dispatch the complete events, otherwise they'll be ignored.
        *
        * @method Phaser.Animation#stop
        * @param {boolean} [resetFrame=false] - If true after the animation stops the currentFrame value will be set to the first frame in this animation.
        * @param {boolean} [dispatchComplete=false] - Dispatch the Animation.onComplete and parent.onAnimationComplete events?
        */
        stop(resetFrame?: boolean, dispatchComplete?: boolean): void;

        /**
        * Updates this animation. Called automatically by the AnimationManager.
        *
        * @method Phaser.Animation#update
        */
        update(): boolean;

        /**
        * Changes the FrameData object this Animation is using.
        *
        * @method Phaser.Animation#updateFrameData
        * @param {Phaser.FrameData} frameData - The FrameData object that contains all frames used by this Animation.
        */
        updateFrameData(frameData: FrameData): void;

    }
    /**
    * The Animation Manager is used to add, play and update Phaser Animations.
    * Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.
    *
    * @class Phaser.AnimationManager
    * @constructor
    * @param {Phaser.Sprite} sprite - A reference to the Game Object that owns this AnimationManager.
    */
    class AnimationManager {

        constructor(sprite: Phaser.Sprite);

        /**
        * @property {Phaser.Animation} currentAnim - The currently displayed animation, if any.
        * @default
        */
        currentAnim: Phaser.Animation;

        /**
        * @property {Phaser.Frame} currentFrame - The currently displayed Frame of animation, if any.
        * @default
        */
        currentFrame: Phaser.Frame;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: number;

        /**
        * @property {Phaser.FrameData} frameData - The FrameData representing this Retro Font.
        */
        frameData: Phaser.FrameData;

        /**
        * @name Phaser.Sprite#frameName
        * @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.
        */
        frameName: string;

        /**
        * @name Phaser.AnimationManager#frameTotal
        * @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.
        * @readonly
        */
        frameTotal: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isLoaded - Set to true once animation data has been loaded.
        * @default
        */
        isLoaded: boolean;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * The paused state of the Game. A paused game doesn't update any of its subsystems.
        * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
        * @name Phaser.Game#paused
        * @property {boolean} paused - Gets and sets the paused state of the Game.
        */
        paused: boolean;

        /**
        * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
        */
        sprite: Phaser.Sprite;

        /**
        * @property {boolean} updateIfVisible - Should the animation data continue to update even if the Sprite.visible is set to false.
        * @default
        */
        updateIfVisible: boolean;

        /**
        * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.
        * Animations added in this way are played back with the play function.
        *
        * @method Phaser.AnimationManager#add
        * @param {string} name - The unique (within this Sprite) name for the animation, i.e. "run", "fire", "walk".
        * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.
        * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.
        * @param {boolean} [loop=false] - Whether or not the animation is looped or just plays once.
        * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings?
        * @return {Phaser.Animation} The Animation object that was created.
        */
        add(name: string, frames?: any[], frameRate?: number, loop?: boolean, useNumericIndex?: boolean): Phaser.Animation;

        /**
        * Loads FrameData into the internal temporary vars and resets the frame index to zero.
        * This is called automatically when a new Sprite is created.
        *
        * @method Phaser.AnimationManager#copyFrameData
        * @private
        * @param {Phaser.FrameData} frameData - The FrameData set to load.
        * @param {string|number} frame - The frame to default to.
        * @return {boolean} Returns `true` if the frame data was loaded successfully, otherwise `false`
        */
        copyFrameData(frameData: Phaser.FrameData, frame: any): boolean;

        /**
        * Destroys all references this AnimationManager contains.
        * Iterates through the list of animations stored in this manager and calls destroy on each of them.
        *
        * @method Phaser.AnimationManager#destroy
        */
        destroy(): void;

        /**
        * Returns an animation that was previously added by name.
        *
        * @method Phaser.AnimationManager#getAnimation
        * @param {string} name - The name of the animation to be returned, e.g. "fire".
        * @return {Phaser.Animation} The Animation instance, if found, otherwise null.
        */
        getAnimation(name: string): Phaser.Animation;

        /**
        * Advances by the given number of frames in the current animation, taking the loop value into consideration.
        *
        * @method Phaser.AnimationManager#next
        * @param {number} [quantity=1] - The number of frames to advance.
        */
        next(quantity?: number): void;

        /**
        * Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()
        * If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.
        *
        * @method Phaser.AnimationManager#play
        * @param {string} name - The name of the animation to be played, e.g. "fire", "walk", "jump".
        * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.
        * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.
        * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.
        * @return {Phaser.Animation} A reference to playing Animation instance.
        */
        play(name: string, frameRate?: number, loop?: boolean, killOnComplete?: boolean): Phaser.Animation;

        /**
        * Moves backwards the given number of frames in the current animation, taking the loop value into consideration.
        *
        * @method Phaser.AnimationManager#previous
        * @param {number} [quantity=1] - The number of frames to move back.
        */
        previous(quantity?: number): void;

        /**
        * Refreshes the current frame data back to the parent Sprite and also resets the texture data.
        *
        * @method Phaser.AnimationManager#refreshFrame
        */
        refreshFrame(): void;

        /**
        * Stop playback of an animation. If a name is given that specific animation is stopped, otherwise the current animation is stopped.
        * The currentAnim property of the AnimationManager is automatically set to the animation given.
        *
        * @method Phaser.AnimationManager#stop
        * @param {string} [name=null] - The name of the animation to be stopped, e.g. "fire". If none is given the currently running animation is stopped.
        * @param {boolean} [resetFrame=false] - When the animation is stopped should the currentFrame be set to the first frame of the animation (true) or paused on the last frame displayed (false)
        */
        stop(name?: string, resetFrame?: boolean): void;

        /**
        * The main update function is called by the Sprites update loop. It's responsible for updating animation frames and firing related events.
        *
        * @method Phaser.AnimationManager#update
        * @protected
        * @return {boolean} True if a new animation frame has been set, otherwise false.
        */
        update(): boolean;

        /**
        * Check whether the frames in the given array are valid and exist.
        *
        * @method Phaser.AnimationManager#validateFrames
        * @param {Array} frames - An array of frames to be validated.
        * @param {boolean} [useNumericIndex=true] - Validate the frames based on their numeric index (true) or string index (false)
        * @return {boolean} True if all given Frames are valid, otherwise false.
        */
        validateFrames(frames: Phaser.Frame[], useNumericIndex?: boolean): boolean;

    }
    /**
    * Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.
    *
    * @class Phaser.AnimationParser
    * @static
    */
    class AnimationParser {

        /**
        * Parse the JSON data and extract the animation frame data from it.
        *
        * @method Phaser.AnimationParser.JSONData
        * @param {Phaser.Game} game - A reference to the currently running game.
        * @param {object} json - The JSON data from the Texture Atlas. Must be in Array format.
        * @param {string} cacheKey - The Game.Cache asset key of the texture image.
        * @return {Phaser.FrameData} A FrameData object containing the parsed frames.
        */
        static JSONData(game: Phaser.Game, json: any, cacheKey: string): Phaser.FrameData;

        /**
        * Parse the JSON data and extract the animation frame data from it.
        *
        * @method Phaser.AnimationParser.JSONDataHash
        * @param {Phaser.Game} game - A reference to the currently running game.
        * @param {object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
        * @param {string} cacheKey - The Game.Cache asset key of the texture image.
        * @return {Phaser.FrameData} A FrameData object containing the parsed frames.
        */
        static JSONDataHash(game: Phaser.Game, json: any, cacheKey: string): Phaser.FrameData;

        /**
        * Parse a Sprite Sheet and extract the animation frame data from it.
        *
        * @method Phaser.AnimationParser.spriteSheet
        * @param {Phaser.Game} game - A reference to the currently running game.
        * @param {string} key - The Game.Cache asset key of the Sprite Sheet image.
        * @param {number} frameWidth - The fixed width of each frame of the animation.
        * @param {number} frameHeight - The fixed height of each frame of the animation.
        * @param {number} [frameMax=-1] - The total number of animation frames to extact from the Sprite Sheet. The default value of -1 means "extract all frames".
        * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
        * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
        * @return {Phaser.FrameData} A FrameData object containing the parsed frames.
        */
        static spriteSheet(game: Phaser.Game, key: string, frameWidth: number, frameHeight: number, frameMax?: number, margin?: number, spacing?: number): Phaser.FrameData;

        /**
        * Parse the XML data and extract the animation frame data from it.
        *
        * @method Phaser.AnimationParser.XMLData
        * @param {Phaser.Game} game - A reference to the currently running game.
        * @param {object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
        * @param {string} cacheKey - The Game.Cache asset key of the texture image.
        * @return {Phaser.FrameData} A FrameData object containing the parsed frames.
        */
        static XMLData(game: Phaser.Game, xml: any, cacheKey: string): Phaser.FrameData;

    }
    /**
    * Audio Sprites are a combination of audio files and a JSON configuration.
    * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
    *
    * @class Phaser.AudioSprite
    * @constructor
    * @param {Phaser.Game} game - Reference to the current game instance.
    * @param {string} key - Asset key for the sound.
    */
    class AudioSprite {

        constructor(game: Phaser.Game, key: string);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: string;

        /**
        * @property {object} config - The Phaser.Game configuration object.
        */
        config: any;

        autoplayKey: string;

        /**
        * @property {boolean} autoplay - Boolean indicating whether the sound should start automatically.
        */
        autoplay: boolean;

        sounds: any;

        /**
        * Get a sound with the given name.
        * 
        * @method Phaser.AudioSprite#get
        * @param {string} marker - The name of sound to get.
        * @return {Phaser.Sound} The sound instance.
        */
        get(marker: string): Phaser.Sound;

        /**
        * Play a sound with the given name.
        * 
        * @method Phaser.AudioSprite#play
        * @param {string} [marker] - The name of sound to play
        * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).
        * @return {Phaser.Sound} This sound instance.
        */
        play(marker: string, volume?: number): Phaser.Sound;

        /**
        * Stop a sound with the given name.
        * 
        * @method Phaser.AudioSprite#stop
        * @param {string} [marker=''] - The name of sound to stop. If none is given it will stop all sounds in the audio sprite.
        */
        stop(marker: string): Phaser.Sound;

    }
    /**
    * ArraySet is a Set data structure (items must be unique within the set) that also maintains order.
    * This allows specific items to be easily added or removed from the Set.
    *
    * Item equality (and uniqueness) is determined by the behavior of `Array.indexOf`.
    *
    * This used primarily by the Input subsystem.
    *
    * @class Phaser.ArraySet
    * @constructor
    * @param {any[]} [list=(new array)] - The backing array: if specified the items in the list _must_ be unique, per `Array.indexOf`, and the ownership of the array _should_ be relinquished to the ArraySet.
    */
    class ArraySet {

        constructor(list: any[]);

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: number;

        list: any[];

        /**
        * @name Phaser.FrameData#total
        * @property {number} total - The total number of frames in this FrameData set.
        * @readonly
        */
        total: number;

        first: any;

        /**
        * @name Phaser.Timer#next
        * @property {number} next - The time at which the next event will occur.
        * @readonly
        */
        next: any;

        /**
        * Adds a new element to the end of the list.
        * If the item already exists in the list it is not moved.
        *
        * @method Phaser.ArraySet#add
        * @param {any} item - The element to add to this list.
        * @return {any} The item that was added.
        */
        add(item: any): any;

        /**
        * Gets the index of the item in the list, or -1 if it isn't in the list.
        *
        * @method Phaser.ArraySet#getIndex
        * @param {any} item - The element to get the list index for.
        * @return {integer} The index of the item or -1 if not found.
        */
        getIndex(item: any): number;

        /**
        * Checks for the item within this list.
        *
        * @method Phaser.ArraySet#exists
        * @param {any} item - The element to get the list index for.
        * @return {boolean} True if the item is found in the list, otherwise false.
        */
        exists(item: any): boolean;

        /**
        * Removes all the items.
        *
        * @method Phaser.ArraySet#reset
        */
        reset(): void;

        /**
        * Removes the given element from this list if it exists.
        *
        * @method Phaser.ArraySet#remove
        * @param {any} item - The item to be removed from the list.
        * @return {any} item - The item that was removed.
        */
        remove(item: any): any;

        /**
        * Sets the property `key` to the given value on all members of this list.
        *
        * @method Phaser.ArraySet#setAll
        * @param {any} key - The propety of the item to set.
        * @param {any} value - The value to set the property to.
        */
        setAll(key: any, value: any): void;

        /**
        * Calls a function on all members of this list, using the member as the context for the callback.
        *
        * If the `key` property is present it must be a function.
        * The function is invoked using the item as the context.
        *
        * @method Phaser.ArraySet#callAll
        * @param {string} key - The name of the property with the function to call.
        * @param {...*} parameter - Additional parameters that will be passed to the callback.
        */
        callAll(key: string, ...parameter: any[]): void;

    }
    /**
    * Utility functions for dealing with Arrays.
    *
    * @class Phaser.ArrayUtils
    * @static
    */
    class ArrayUtils {

        static getRandomItem<T>(objects: T[], startIndex?: number, length?: number): T;

        static removeRandomItem<T>(objects: T[], startIndex?: number, length?: number): T;

        static shuffle<T>(array: T[]): T[];

        static transposeMatrix<T>(array: T[]): T;

        static rotateMatrix(matrix: any, direction: number): any;

        static findClosest(value: number, arr: number[]): number;

        /**
        * Moves the element from the start of the array to the end, shifting all items in the process.
        * The "rotation" happens to the left.
        *
        * @method Phaser.ArrayUtils.rotate
        * @param {any[]} array - The array to shift/rotate. The array is modified.
        * @return {any} The shifted value.
        */
        static rotate(array: any[]): any;

        static numberArray(start: number, end: number): number[];

        static numberArrayStep(start: number, end: number, step?: number): number[];

    }
    /**
    * A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.
    * A single BitmapData can be used as the texture for one or many Images/Sprites. 
    * So if you need to dynamically create a Sprite texture then they are a good choice.
    *
    * @class Phaser.BitmapData
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {string} key - Internal Phaser reference key for the render texture.
    * @param {number} [width=256] - The width of the BitmapData in pixels.
    * @param {number} [height=256] - The height of the BitmapData in pixels.
    */
    class BitmapData {

        constructor(game: Phaser.Game, key: string, width?: number, height?: number);

        /**
        * @property {PIXI.BaseTexture} baseTexture - The PIXI.BaseTexture.
        * @default
        */
        baseTexture: PIXI.BaseTexture;

        /**
        * @property {ArrayBuffer} buffer - An ArrayBuffer the same size as the context ImageData.
        */
        buffer: ArrayBuffer;

        /**
        * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
        */
        canvas: HTMLCanvasElement;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: CanvasRenderingContext2D;

        /**
        * @property {CanvasRenderingContext2D} ctx - A reference to BitmapData.context.
        */
        ctx: CanvasRenderingContext2D;

        /**
        * @property {Uint8ClampedArray} data - A Uint8ClampedArray view into BitmapData.buffer.
        */
        data: Uint8Array;

        /**
        * @property {boolean} dirty - Internal PIXI var.
        * @default
        */
        dirty: boolean;

        /**
        * @property {boolean} disableTextureUpload - If disableTextureUpload is true this BitmapData will never send its image data to the GPU when its dirty flag is true.
        */
        disableTextureUpload: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {ImageData} imageData - The context image data.
        */
        imageData: ImageData;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: string;

        /**
        * @property {Uint32Array} pixels - An Uint32Array view into BitmapData.buffer.
        */
        pixels: Uint32Array;

        /**
        * Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.
        *
        * @name Phaser.Stage#smoothed
        * @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
        */
        smoothed: boolean;

        /**
        * @property {PIXI.Texture} texture - The PIXI.Texture.
        * @default
        */
        texture: PIXI.Texture;

        /**
        * @property {Phaser.Frame} textureFrame - The Frame this BitmapData uses for rendering.
        * @default
        */
        textureFrame: Phaser.Frame;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * Gets a JavaScript object that has 6 properties set that are used by BitmapData in a transform.
        *
        * @method Phaser.BitmapData.getTransform
        * @param {number} translateX - The x translate value.
        * @param {number} translateY - The y translate value.
        * @param {number} scaleX - The scale x value.
        * @param {number} scaleY - The scale y value.
        * @param {number} skewX - The skew x value.
        * @param {number} skewY - The skew y value.
        * @return {object} A JavaScript object containing all of the properties BitmapData needs for transforms.
        */
        static getTransform(translateX: number, translateY: number, scaleX: number, scaleY: number, skewX: number, skewY: number): any;

        /**
        * Updates the given objects so that they use this BitmapData as their texture. This will replace any texture they will currently have set.
        *
        * @method Phaser.BitmapData#add
        * @param {Phaser.Sprite|Phaser.Sprite[]|Phaser.Image|Phaser.Image[]} object - Either a single Sprite/Image or an Array of Sprites/Images.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        add(object: any): Phaser.BitmapData;

        /**
        * Creates a new Phaser.Image object, assigns this BitmapData to be its texture, adds it to the world then returns it.
        *
        * @method Phaser.BitmapData#addToWorld
        * @param {number} [x=0] - The x coordinate to place the Image at.
        * @param {number} [y=0] - The y coordinate to place the Image at.
        * @param {number} [anchorX=0] - Set the x anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.
        * @param {number} [anchorY=0] - Set the y anchor point of the Image. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.
        * @param {number} [scaleX=1] - The horizontal scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.
        * @param {number} [scaleY=1] - The vertical scale factor of the Image. A value of 1 means no scaling. 2 would be twice the size, and so on.
        * @return {Phaser.Image} The newly added Image object.
        */
        addToWorld(x?: number, y?: number, anchorX?: number, anchorY?: number, scaleX?: number, scaleY?: number): Phaser.Image;

        /**
        * Draws the image onto this BitmapData using an image as an alpha mask.
        *
        * @method Phaser.BitmapData#alphaMask
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} source - The source to copy from. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself.
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} [mask] - The object to be used as the mask. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself. If you don't provide a mask it will use this BitmapData as the mask.
        * @param {Phaser.Rectangle} [sourceRect] - A Rectangle where x/y define the coordinates to draw the Source image to and width/height define the size.
        * @param {Phaser.Rectangle} [maskRect] - A Rectangle where x/y define the coordinates to draw the Mask image to and width/height define the size.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        alphaMask(source: any, mask: any, sourceRect?: Phaser.Rectangle, maskRect?: Phaser.Rectangle): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'lighter'
        *
        * @method Phaser.BitmapData#blendAdd
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendAdd(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'color-dodge'
        *
        * @method Phaser.BitmapData#blendColorDodge
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendColor(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'color-burn'
        *
        * @method Phaser.BitmapData#blendColorBurn
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendColorBurn(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'color-dodge'
        *
        * @method Phaser.BitmapData#blendColorDodge
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendColorDodge(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'darken'
        *
        * @method Phaser.BitmapData#blendDarken
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDarken(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'destination-atop'
        *
        * @method Phaser.BitmapData#blendDestinationAtop
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDestinationAtop(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'destination-in'
        *
        * @method Phaser.BitmapData#blendDestinationIn
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDestinationIn(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'destination-out'
        *
        * @method Phaser.BitmapData#blendDestinationOut
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDestinationOut(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'destination-over'
        *
        * @method Phaser.BitmapData#blendDestinationOver
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDestinationOver(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'difference'
        *
        * @method Phaser.BitmapData#blendDifference
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendDifference(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'exclusion'
        *
        * @method Phaser.BitmapData#blendExclusion
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendExclusion(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'hard-light'
        *
        * @method Phaser.BitmapData#blendHardLight
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendHardLight(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'hue'
        *
        * @method Phaser.BitmapData#blendHue
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendHue(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'lighten'
        *
        * @method Phaser.BitmapData#blendLighten
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendLighten(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'luminosity'
        *
        * @method Phaser.BitmapData#blendLuminosity
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendLuminosity(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'multiply'
        *
        * @method Phaser.BitmapData#blendMultiply
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendMultiply(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'overlay'
        *
        * @method Phaser.BitmapData#blendOverlay
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendOverlay(): Phaser.BitmapData;

        /**
        * Resets the blend mode (effectively sets it to 'source-over')
        *
        * @method Phaser.BitmapData#blendReset
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendReset(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'saturation'
        *
        * @method Phaser.BitmapData#blendSaturation
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSaturation(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'screen'
        *
        * @method Phaser.BitmapData#blendScreen
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendScreen(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'soft-light'
        *
        * @method Phaser.BitmapData#blendSoftLight
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSoftLight(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'source-atop'
        *
        * @method Phaser.BitmapData#blendSourceAtop
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSourceAtop(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'source-in'
        *
        * @method Phaser.BitmapData#blendSourceIn
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSourceIn(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'source-out'
        *
        * @method Phaser.BitmapData#blendSourceOut
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSourceOut(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'source-over'
        *
        * @method Phaser.BitmapData#blendSourceOver
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendSourceOver(): Phaser.BitmapData;

        /**
        * Sets the blend mode to 'xor'
        *
        * @method Phaser.BitmapData#blendXor
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        blendXor(): Phaser.BitmapData;

        /**
        * Draws a filled Circle to the BitmapData at the given x, y coordinates and radius in size.
        *
        * @method Phaser.BitmapData#circle
        * @param {number} x - The x coordinate to draw the Circle at. This is the center of the circle.
        * @param {number} y - The y coordinate to draw the Circle at. This is the center of the circle.
        * @param {number} radius - The radius of the Circle in pixels. The radius is half the diameter.
        * @param {string} [fillStyle] - If set the context fillStyle will be set to this value before the circle is drawn.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        circle(x: number, y: number, radius: number, fillStyle?: string): Phaser.BitmapData;

        /**
        * Clears the BitmapData context using a clearRect.
        *
        * @method Phaser.BitmapData#clear
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        clear(): Phaser.BitmapData;

        /**
        * Clears the BitmapData context using a clearRect.
        *
        * @method Phaser.BitmapData#cls
        */
        cls(): Phaser.BitmapData;

        /**
        * Copies a rectangular area from the source object to this BitmapData. If you give `null` as the source it will copy from itself.
        * You can optionally resize, translate, rotate, scale, alpha or blend as it's drawn.
        * All rotation, scaling and drawing takes place around the regions center point by default, but can be changed with the anchor parameters.
        * Note that the source image can also be this BitmapData, which can create some interesting effects.
        * 
        * This method has a lot of parameters for maximum control.
        * You can use the more friendly methods like `copyRect` and `draw` to avoid having to remember them all.
        *
        * @method Phaser.BitmapData#copy
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} [source] - The source to copy from. If you give a string it will try and find the Image in the Game.Cache first. This is quite expensive so try to provide the image itself.
        * @param {number} [x=0] - The x coordinate representing the top-left of the region to copy from the source image.
        * @param {number} [y=0] - The y coordinate representing the top-left of the region to copy from the source image.
        * @param {number} [width] - The width of the region to copy from the source image. If not specified it will use the full source image width.
        * @param {number} [height] - The height of the region to copy from the source image. If not specified it will use the full source image height.
        * @param {number} [tx] - The x coordinate to translate to before drawing. If not specified it will default to the `x` parameter.
        * @param {number} [ty] - The y coordinate to translate to before drawing. If not specified it will default to the `y` parameter.
        * @param {number} [newWidth] - The new width of the block being copied. If not specified it will default to the `width` parameter.
        * @param {number} [newHeight] - The new height of the block being copied. If not specified it will default to the `height` parameter.
        * @param {number} [rotate=0] - The angle in radians to rotate the block to before drawing. Rotation takes place around the center by default, but can be changed with the `anchor` parameters.
        * @param {number} [anchorX=0] - The anchor point around which the block is rotated and scaled. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.
        * @param {number} [anchorY=0] - The anchor point around which the block is rotated and scaled. A value between 0 and 1, where 0 is the top-left and 1 is bottom-right.
        * @param {number} [scaleX=1] - The horizontal scale factor of the block. A value of 1 means no scaling. 2 would be twice the size, and so on.
        * @param {number} [scaleY=1] - The vertical scale factor of the block. A value of 1 means no scaling. 2 would be twice the size, and so on.
        * @param {number} [alpha=1] - The alpha that will be set on the context before drawing. A value between 0 (fully transparent) and 1, opaque.
        * @param {number} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all.
        * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        copy(source?: any, x?: number, y?: number, width?: number, height?: number, tx?: number, ty?: number, newWidth?: number, newHeight?: number, rotate?: number, anchorX?: number, anchorY?: number, scaleX?: number, scaleY?: number, alpha?: number, blendMode?: string, roundPx?: boolean): Phaser.BitmapData;

        copyPixels(source: any, area: Phaser.Rectangle, x: number, y: number, alpha?: number): void;

        /**
        * Copies the area defined by the Rectangle parameter from the source image to this BitmapData at the given location.
        *
        * @method Phaser.BitmapData#copyRect
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|string} source - The Image to copy from. If you give a string it will try and find the Image in the Game.Cache.
        * @param {Phaser.Rectangle} area - The Rectangle region to copy from the source image.
        * @param {number} x - The destination x coordinate to copy the image to.
        * @param {number} y - The destination y coordinate to copy the image to.
        * @param {number} [alpha=1] - The alpha that will be set on the context before drawing. A value between 0 (fully transparent) and 1, opaque.
        * @param {number} [blendMode=null] - The composite blend mode that will be used when drawing. The default is no blend mode at all.
        * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        copyRect(source: any, area: Phaser.Rectangle, x?: number, y?: number, alpha?: number, blendMode?: string, roundPx?: boolean): Phaser.BitmapData;

        /**
        * Draws the given Phaser.Sprite, Phaser.Image or Phaser.Text to this BitmapData at the coordinates specified.
        * You can use the optional width and height values to 'stretch' the sprite as it is drawn. This uses drawImage stretching, not scaling.
        * When drawing it will take into account the Sprites rotation, scale and alpha values.
        *
        * @method Phaser.BitmapData#draw
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text} source - The Sprite, Image or Text object to draw onto this BitmapData.
        * @param {number} [x=0] - The x coordinate to translate to before drawing. If not specified it will default to `source.x`.
        * @param {number} [y=0] - The y coordinate to translate to before drawing. If not specified it will default to `source.y`.
        * @param {number} [width] - The new width of the Sprite being copied. If not specified it will default to `source.width`.
        * @param {number} [height] - The new height of the Sprite being copied. If not specified it will default to `source.height`.
        * @param {number} [blendMode=null] - The composite blend mode that will be used when drawing the Sprite. The default is no blend mode at all.
        * @param {boolean} [roundPx=false] - Should the x and y values be rounded to integers before drawing? This prevents anti-aliasing in some instances.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        draw(source: any, x?: number, y?: number, width?: number, height?: number, blendMode?: string, roundPx?: boolean): Phaser.BitmapData;

        /**
        * Scans this BitmapData for all pixels matching the given r,g,b values and then draws them into the given destination BitmapData.
        * The original BitmapData remains unchanged.
        * The destination BitmapData must be large enough to receive all of the pixels that are scanned unless the 'resize' parameter is true.
        * Although the destination BitmapData is returned from this method, it's actually modified directly in place, meaning this call is perfectly valid:
        * `picture.extract(mask, r, g, b)`
        * You can specify optional r2, g2, b2 color values. If given the pixel written to the destination bitmap will be of the r2, g2, b2 color.
        * If not given it will be written as the same color it was extracted. You can provide one or more alternative colors, allowing you to tint
        * the color during extraction.
        *
        * @method Phaser.BitmapData#extract
        * @param {Phaser.BitmapData} destination - The BitmapData that the extracted pixels will be drawn to.
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {number} [a=255] - The alpha color component, in the range 0 - 255 that the new pixel will be drawn at.
        * @param {boolean} [resize=false] - Should the destination BitmapData be resized to match this one before the pixels are copied?
        * @param {number} [r2] - An alternative red color component to be written to the destination, in the range 0 - 255.
        * @param {number} [g2] - An alternative green color component to be written to the destination, in the range 0 - 255.
        * @param {number} [b2] - An alternative blue color component to be written to the destination, in the range 0 - 255.
        * @returns {Phaser.BitmapData} The BitmapData that the extract pixels were drawn on.
        */
        extract(destination: Phaser.BitmapData, r: number, g: number, b: number, a?: number, resize?: boolean, r2?: number, g2?: number, b2?: number): Phaser.BitmapData;

        /**
        * Fills the BitmapData with the given color.
        *
        * @method Phaser.BitmapData#fill
        * @param {number} r - The red color value, between 0 and 0xFF (255).
        * @param {number} g - The green color value, between 0 and 0xFF (255).
        * @param {number} b - The blue color value, between 0 and 0xFF (255).
        * @param {number} [a=1] - The alpha color value, between 0 and 1.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        fill(r: number, g: number, b: number, a?: number): Phaser.BitmapData;

        /**
        * Scans the BitmapData and calculates the bounds. This is a rectangle that defines the extent of all non-transparent pixels.
        * The rectangle returned will extend from the top-left of the image to the bottom-right, exluding transparent pixels.
        *
        * @method Phaser.BitmapData#getBounds
        * @param {Phaser.Rectangle} [rect] - If provided this Rectangle object will be populated with the bounds, otherwise a new object will be created.
        * @return {Phaser.Rectangle} A Rectangle whose dimensions encompass the full extent of non-transparent pixels in this BitmapData.
        */
        getBounds(rect?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Scans the BitmapData, pixel by pixel, until it encounters a pixel that isn't transparent (i.e. has an alpha value > 0).
        * It then stops scanning and returns an object containing the colour of the pixel in r, g and b properties and the location in the x and y properties.
        * 
        * The direction parameter controls from which direction it should start the scan:
        * 
        * 0 = top to bottom
        * 1 = bottom to top
        * 2 = left to right
        * 3 = right to left
        *
        * @method Phaser.BitmapData#getFirstPixel
        * @param {number} [direction=0] - The direction in which to scan for the first pixel. 0 = top to bottom, 1 = bottom to top, 2 = left to right and 3 = right to left.
        * @return {object} Returns an object containing the colour of the pixel in the `r`, `g` and `b` properties and the location in the `x` and `y` properties.
        */
        getFirstPixel(direction: number): { r: number; g: number; b: number; x: number; y: number; };

        /**
        * Get the color of a specific pixel in the context into a color object.
        * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,
        * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
        *
        * @method Phaser.BitmapData#getPixel
        * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.
        * @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
        */
        getPixel(x: number, y: number, out?: any): number;

        /**
        * Get the color of a specific pixel including its alpha value as a color object containing r,g,b,a and rgba properties.
        * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,
        * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
        *
        * @method Phaser.BitmapData#getPixelRGB
        * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.
        * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?
        * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?
        * @return {object} An object with the red, green and blue values set in the r, g and b properties.
        */
        getPixelRGB(x: number, y: number, out?: any, hsl?: boolean, hsv?: boolean): any;

        /**
        * Get the color of a specific pixel including its alpha value.
        * If you have drawn anything to the BitmapData since it was created you must call BitmapData.update to refresh the array buffer,
        * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.
        * Note that on little-endian systems the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA.
        *
        * @method Phaser.BitmapData#getPixel32
        * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @return {number} A native color value integer (format: 0xAARRGGBB)
        */
        getPixel32(x: number, y: number): number;

        /**
        * Gets all the pixels from the region specified by the given Rectangle object.
        *
        * @method Phaser.BitmapData#getPixels
        * @param {Phaser.Rectangle} rect - The Rectangle region to get.
        * @return {ImageData} Returns a ImageData object containing a Uint8ClampedArray data property.
        */
        getPixels(rect: Phaser.Rectangle): ImageData;

        getTransform(translateX: number, translateY: number, scaleX: number, scaleY: number, skewX: number, skewY: number): any;

        /**
        * Takes the given Game Object, resizes this BitmapData to match it and then draws it into this BitmapDatas canvas, ready for further processing.
        * The source game object is not modified by this operation.
        * If the source object uses a texture as part of a Texture Atlas or Sprite Sheet, only the current frame will be used for sizing.
        * If a string is given it will assume it's a cache key and look in Phaser.Cache for an image key matching the string.
        *
        * @method Phaser.BitmapData#load
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapData|Image|HTMLCanvasElement|string} source - The object that will be used to populate this BitmapData. If you give a string it will try and find the Image in the Game.Cache first.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        load(source: any): Phaser.BitmapData;

        /**
        * Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.
        * The callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.
        * Where r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.
        * The `color` property is an Int32 of the full color. Note the endianess of this will change per system.
        * The `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.
        * The callback will also be sent the pixels x and y coordinates respectively.
        * The callback must return either `false`, in which case no change will be made to the pixel, or a new color object.
        * If a new color object is returned the pixel will be set to the r, g, b and a color values given within it.
        *
        * @method Phaser.BitmapData#processPixelRGB
        * @param {function} callback - The callback that will be sent each pixel color object to be processed.
        * @param {object} callbackContext - The context under which the callback will be called.
        * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.
        * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.
        * @param {number} [width] - The width of the region to process.
        * @param {number} [height] - The height of the region to process.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        processPixel(callback: Function, callbackContext: any, x?: number, y?: Number, width?: number, height?: number): Phaser.BitmapData;

        /**
        * Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.
        * The callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.
        * Where r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.
        * The `color` property is an Int32 of the full color. Note the endianess of this will change per system.
        * The `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.
        * The callback will also be sent the pixels x and y coordinates respectively.
        * The callback must return either `false`, in which case no change will be made to the pixel, or a new color object.
        * If a new color object is returned the pixel will be set to the r, g, b and a color values given within it.
        *
        * @method Phaser.BitmapData#processPixelRGB
        * @param {function} callback - The callback that will be sent each pixel color object to be processed.
        * @param {object} callbackContext - The context under which the callback will be called.
        * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.
        * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.
        * @param {number} [width] - The width of the region to process.
        * @param {number} [height] - The height of the region to process.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        processPixelRGB(callback: Function, callbackContext: any, x?: number, y?: Number, width?: number, height?: number): Phaser.BitmapData;

        /**
        * Draws a filled Rectangle to the BitmapData at the given x, y coordinates and width / height in size.
        *
        * @method Phaser.BitmapData#rect
        * @param {number} x - The x coordinate of the top-left of the Rectangle.
        * @param {number} y - The y coordinate of the top-left of the Rectangle.
        * @param {number} width - The width of the Rectangle.
        * @param {number} height - The height of the Rectangle.
        * @param {string} [fillStyle] - If set the context fillStyle will be set to this value before the rect is drawn.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        rect(x: number, y: number, width: number, height: number, fillStyle?: string): Phaser.BitmapData;

        /**
        * If the game is running in WebGL this will push the texture up to the GPU if it's dirty.
        * This is called automatically if the BitmapData is being used by a Sprite, otherwise you need to remember to call it in your render function.
        * If you wish to suppress this functionality set BitmapData.disableTextureUpload to `true`.
        *
        * @method Phaser.BitmapData#render
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        render(): Phaser.BitmapData;

        /**
        * Replaces all pixels matching one color with another. The color values are given as two sets of RGBA values.
        * An optional region parameter controls if the replacement happens in just a specific area of the BitmapData or the entire thing. 
        *
        * @method Phaser.BitmapData#replaceRGB
        * @param {number} r1 - The red color value to be replaced. Between 0 and 255.
        * @param {number} g1 - The green color value to be replaced. Between 0 and 255.
        * @param {number} b1 - The blue color value to be replaced. Between 0 and 255.
        * @param {number} a1 - The alpha color value to be replaced. Between 0 and 255.
        * @param {number} r2 - The red color value that is the replacement color. Between 0 and 255.
        * @param {number} g2 - The green color value that is the replacement color. Between 0 and 255.
        * @param {number} b2 - The blue color value that is the replacement color. Between 0 and 255.
        * @param {number} a2 - The alpha color value that is the replacement color. Between 0 and 255.
        * @param {Phaser.Rectangle} [region] - The area to perform the search over. If not given it will replace over the whole BitmapData.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        replaceRGB(r1: number, g1: number, b1: number, a1: number, r2: number, g2: number, b2: number, a2: number, region: Phaser.Rectangle): Phaser.BitmapData;

        /**
        * Resizes the BitmapData. This changes the size of the underlying canvas and refreshes the buffer.
        *
        * @method Phaser.BitmapData#resize
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        resize(width: number, height: number): Phaser.BitmapData;

        /**
        * Sets the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.
        *
        * @method Phaser.BitmapData#setHSL
        * @param {number} [h=null] - The hue, in the range 0 - 1.
        * @param {number} [s=null] - The saturation, in the range 0 - 1.
        * @param {number} [l=null] - The lightness, in the range 0 - 1.
        * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        setHSL(h?: number, s?: number, l?: number, region?: Phaser.Rectangle): Phaser.BitmapData;

        /**
        * Sets the color of the given pixel to the specified red, green, blue and alpha values.
        *
        * @method Phaser.BitmapData#setPixel32
        * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} red - The red color value, between 0 and 0xFF (255).
        * @param {number} green - The green color value, between 0 and 0xFF (255).
        * @param {number} blue - The blue color value, between 0 and 0xFF (255).
        * @param {number} alpha - The alpha color value, between 0 and 0xFF (255).
        * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        setPixel(x: number, y: number, red: number, green: number, blue: number, immediate?: boolean): Phaser.BitmapData;

        /**
        * Sets the color of the given pixel to the specified red, green, blue and alpha values.
        *
        * @method Phaser.BitmapData#setPixel32
        * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.
        * @param {number} red - The red color value, between 0 and 0xFF (255).
        * @param {number} green - The green color value, between 0 and 0xFF (255).
        * @param {number} blue - The blue color value, between 0 and 0xFF (255).
        * @param {number} alpha - The alpha color value, between 0 and 0xFF (255).
        * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        setPixel32(x: number, y: number, red: number, green: number, blue: number, alpha: number, immediate?: boolean): Phaser.BitmapData;

        /**
        * Sets the shadow properties of this BitmapDatas context which will affect all draw operations made to it.
        * You can cancel an existing shadow by calling this method and passing no parameters.
        * Note: At the time of writing (October 2014) Chrome still doesn't support shadowBlur used with drawImage.
        *
        * @method Phaser.BitmapData#shadow
        * @param {string} color - The color of the shadow, given in a CSS format, i.e. `#000000` or `rgba(0,0,0,1)`. If `null` or `undefined` the shadow will be reset.
        * @param {number} [blur=5] - The amount the shadow will be blurred by. Low values = a crisp shadow, high values = a softer shadow.
        * @param {number} [x=10] - The horizontal offset of the shadow in pixels.
        * @param {number} [y=10] - The vertical offset of the shadow in pixels.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        shadow(color: string, blur?: number, x?: number, y?: number): Phaser.BitmapData;

        /**
        * Shifts any or all of the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.
        * Shifting will add the given value onto the current h, s and l values, not replace them.
        * The hue is wrapped to keep it within the range 0 to 1. Saturation and lightness are clamped to not exceed 1.
        *
        * @method Phaser.BitmapData#shiftHSL
        * @param {number} [h=null] - The amount to shift the hue by.
        * @param {number} [s=null] - The amount to shift the saturation by.
        * @param {number} [l=null] - The amount to shift the lightness by.
        * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        shiftHSL(h?: number, s?: number, l?: number, region?: Phaser.Rectangle): Phaser.BitmapData;

        /**
        * Takes the given Line object and image and renders it to this BitmapData as a repeating texture line.
        *
        * @method Phaser.BitmapData#textureLine
        * @param {Phaser.Line} line - A Phaser.Line object that will be used to plot the start and end of the line.
        * @param {string|Image} image - The key of an image in the Phaser.Cache to use as the texture for this line, or an actual Image.
        * @param {string} [repeat='repeat-x'] - The pattern repeat mode to use when drawing the line. Either `repeat`, `repeat-x` or `no-repeat`.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        textureLine(line: Phaser.Line, key: string, repeat?: string): Phaser.BitmapData;

        /**
        * This re-creates the BitmapData.imageData from the current context.
        * It then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.
        * If not given the dimensions defaults to the full size of the context.
        *
        * @method Phaser.BitmapData#update
        * @param {number} [x=0] - The x coordinate of the top-left of the image data area to grab from.
        * @param {number} [y=0] - The y coordinate of the top-left of the image data area to grab from.
        * @param {number} [width] - The width of the image data area.
        * @param {number} [height] - The height of the image data area.
        * @return {Phaser.BitmapData} This BitmapData object for method chaining.
        */
        update(x: number, y: number, width: number, height: number): Phaser.BitmapData;

    }
    /**
    * BitmapText objects work by taking a texture file and an XML file that describes the font layout.
    *
    * On Windows you can use the free app BMFont: http://www.angelcode.com/products/bmfont/
    * On OS X we recommend Glyph Designer: http://www.71squared.com/en/glyphdesigner
    * For Web there is the great Littera: http://kvazars.com/littera/
    *
    * @class Phaser.BitmapText
    * @constructor
    * @extends PIXI.BitmapText
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - X position of the new bitmapText object.
    * @param {number} y - Y position of the new bitmapText object.
    * @param {string} font - The key of the BitmapFont as stored in Game.Cache.
    * @param {string} [text=''] - The actual text that will be rendered. Can be set later via BitmapText.text.
    * @param {number} [size=32] - The size the font will be rendered in, in pixels.
    */
    class BitmapText extends PIXI.BitmapText {

        constructor(game: Phaser.Game, x: number, y: number, font: string, text?: string, size?: number);

        /**
        * @name Phaser.Text#align
        * @property {string} align - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.
        */
        align: string;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Text#font
        * @property {string} font - The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.
        */
        font: string;

        /**
        * @name Phaser.Text#fontSize
        * @property {number} fontSize - The size of the font in pixels.
        */
        fontSize: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * The text string to be displayed by this Text object, taking into account the style settings.
        * @name Phaser.Text#text
        * @property {string} text - The text string to be displayed by this Text object, taking into account the style settings.
        */
        text: string;

        /**
        * @name Phaser.BitmapText#tint
        * @property {number} tint - The tint applied to the BitmapText. This is a hex value. Set to white to disable (0xFFFFFF)
        */
        tint: number;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        destroy(destroyChildren?: boolean): void;

        postUpdate(): void;

        preUpdate(): void;

        update(): void;

        updateText(): void;

        updateTransform(): void;

    }
    /**
    * Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically.
    *
    * The four states a Button responds to are:
    *
    * * 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.
    * * 'Out' - when the Pointer that was previously over the Button moves out of it.
    * * 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.
    * * 'Up' - when the Pointer that was pressed down on the Button is released again.
    *
    * A different texture/frame and activation sound can be specified for any of the states.
    *
    * Frames can be specified as either an integer (the frame ID) or a string (the frame name); the same values that can be used with a Sprite constructor.
    *
    * @class Phaser.Button
    * @constructor
    * @extends Phaser.Image
    * @param {Phaser.Game} game Current game instance.
    * @param {number} [x=0] - X position of the Button.
    * @param {number} [y=0] - Y position of the Button.
    * @param {string} [key] - The image key (in the Game.Cache) to use as the texture for this Button.
    * @param {function} [callback] - The function to call when this Button is pressed.
    * @param {object} [callbackContext] - The context in which the callback will be called (usually 'this').
    * @param {string|integer} [overFrame] - The frame / frameName when the button is in the Over state.
    * @param {string|integer} [outFrame] - The frame / frameName when the button is in the Out state.
    * @param {string|integer} [downFrame] - The frame / frameName when the button is in the Down state.
    * @param {string|integer} [upFrame] - The frame / frameName when the button is in the Up state.
    */
    class Button extends Phaser.Image {

        constructor(game: Phaser.Game, x?: number, y?: number, key?: string, callback?: Function, callbackContext?: any, overFrame?: any, outFrame?: any, downFrame?: any, upFrame?: any);

        forceOut: boolean;

        freezeFrames: boolean;

        onDownSound: any;

        onDownSoundMarker: string;

        /**
        * @property {Phaser.Signal} onInputDown - This signal is dispatched if the parent is inputEnabled and receives a down event from a Pointer.
        */
        onInputDown: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputOut - This signal is dispatched if the parent is inputEnabled and receives an out event from a Pointer.
        */
        onInputOut: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputOver - This signal is dispatched if the parent is inputEnabled and receives an over event from a Pointer.
        */
        onInputOver: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputUp - This signal is dispatched if the parent is inputEnabled and receives an up event from a Pointer.
        */
        onInputUp: Phaser.Signal;

        onOutSound: any;

        onOutSoundMarker: string;

        onOverSound: any;

        onOverSoundMarker: string;

        onOverMouseOnly: boolean;

        onUpSound: any;

        onUpSoundMaker: string;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * Clears all of the frames set on this Button.
        *
        * @method Phaser.Button#clearFrames
        */
        clearFrames(): void;

        /**
        * The Sound to be played when a Pointer presses down on this Button.
        *
        * @method Phaser.Button#setDownSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setDownSound(sound: Phaser.Sound, marker?: string): void;

        /**
        * The Sound to be played when a Pointer presses down on this Button.
        *
        * @method Phaser.Button#setDownSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setDownSound(sound: Phaser.AudioSprite, marker?: string): void;

        /**
        * Used to manually set the frames that will be used for the different states of the Button.
        *
        * Frames can be specified as either an integer (the frame ID) or a string (the frame name); these are the same values that can be used with a Sprite constructor.
        *
        * @method Phaser.Button#setFrames
        * @public
        * @param {string|integer} [overFrame] - The frame / frameName when the button is in the Over state.
        * @param {string|integer} [outFrame] - The frame / frameName when the button is in the Out state.
        * @param {string|integer} [downFrame] - The frame / frameName when the button is in the Down state.
        * @param {string|integer} [upFrame] - The frame / frameName when the button is in the Up state.
        */
        setFrames(overFrame?: any, outFrame?: any, downFrame?: any, upFrame?: any): void;

        /**
        * Internal function that handles input events.
        *
        * @method Phaser.Button#onInputDownHandler
        * @protected
        * @param {Phaser.Button} sprite - The Button that the event occured on.
        * @param {Phaser.Pointer} pointer - The Pointer that activated the Button.
        */
        onInputDownHandler(sprite: Phaser.Button, pointer: Phaser.Pointer): void;

        /**
        * Internal function that handles input events.
        *
        * @method Phaser.Button#onInputUpHandler
        * @protected
        * @param {Phaser.Button} sprite - The Button that the event occured on.
        * @param {Phaser.Pointer} pointer - The Pointer that activated the Button.
        */
        onInputUpHandler(sprite: Phaser.Button, pointer: Phaser.Pointer, isOver: boolean): void;

        /**
        * Called when this Button is removed from the World.
        *
        * @method Phaser.Button#removedFromWorld
        * @protected
        */
        removedFromWorld(): void;

        /**
        * The Sound to be played when a Pointer moves out of this Button.
        *
        * @method Phaser.Button#setOutSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setOutSound(sound: Phaser.Sound, marker?: string): void;

        /**
        * The Sound to be played when a Pointer moves out of this Button.
        *
        * @method Phaser.Button#setOutSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setOutSound(sound: Phaser.AudioSprite, marker?: string): void;

        /**
        * The Sound to be played when a Pointer moves over this Button.
        *
        * @method Phaser.Button#setOverSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setOverSound(sound: Phaser.Sound, marker?: string): void;

        /**
        * The Sound to be played when a Pointer moves over this Button.
        *
        * @method Phaser.Button#setOverSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setOverSound(sound: Phaser.AudioSprite, marker?: string): void;

        /**
        * Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.
        * The most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.
        *
        * Call this function with no parameters to reset all sounds on this Button.
        *
        * @method Phaser.Button#setSounds
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} [overSound] - Over Button Sound.
        * @param {string} [overMarker] - Over Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [downSound] - Down Button Sound.
        * @param {string} [downMarker] - Down Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [outSound] - Out Button Sound.
        * @param {string} [outMarker] - Out Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [upSound] - Up Button Sound.
        * @param {string} [upMarker] - Up Button Sound Marker.
        */
        setSounds(overSound?: Phaser.Sound, overMarker?: string, downSound?: Phaser.Sound, downMarker?: string, outSound?: Phaser.Sound, outMarker?: string, upSound?: Phaser.Sound, upMarker?: string): void;

        /**
        * Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.
        * The most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.
        *
        * Call this function with no parameters to reset all sounds on this Button.
        *
        * @method Phaser.Button#setSounds
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} [overSound] - Over Button Sound.
        * @param {string} [overMarker] - Over Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [downSound] - Down Button Sound.
        * @param {string} [downMarker] - Down Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [outSound] - Out Button Sound.
        * @param {string} [outMarker] - Out Button Sound Marker.
        * @param {Phaser.Sound|Phaser.AudioSprite} [upSound] - Up Button Sound.
        * @param {string} [upMarker] - Up Button Sound Marker.
        */
        setSounds(overSound?: Phaser.AudioSprite, overMarker?: string, downSound?: Phaser.AudioSprite, downMarker?: string, outSound?: Phaser.AudioSprite, outMarker?: string, upSound?: Phaser.AudioSprite, upMarker?: string): void;

        /**
        * Set the frame name/ID for the given state.
        *
        * @method Phaser.Button#setStateFrame
        * @private
        * @param {object} state - See `STATE_*`
        * @param {number|string} frame - The number or string representing the frame.
        * @param {boolean} switchImmediately - Immediately switch to the frame if it was set - and this is true.
        */
        setState(newState: number): void;

        /**
        * The Sound to be played when a Pointer has pressed down and is released from this Button.
        *
        * @method Phaser.Button#setUpSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setUpSound(sound: Phaser.Sound, marker?: string): void;

        /**
        * The Sound to be played when a Pointer has pressed down and is released from this Button.
        *
        * @method Phaser.Button#setUpSound
        * @public
        * @param {Phaser.Sound|Phaser.AudioSprite} sound - The Sound that will be played.
        * @param {string} [marker] - A Sound Marker that will be used in the playback.
        */
        setUpSound(sound: Phaser.AudioSprite, marker?: string): void;

    }
    /**
    * A game only has one instance of a Cache and it is used to store all externally loaded assets such as images, sounds
    * and data files as a result of Loader calls. Cached items use string based keys for look-up.
    *
    * @class Phaser.Cache
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Cache {

        constructor(game: Phaser.Game);

        static BINARY: number;

        static BITMAPDATA: number;

        static BITMAPFONT: number;

        static CANVAS: number;

        static IMAGE: number;

        static JSON: number;

        static PHYSICS: number;

        static SOUND: number;

        static TEXT: number;

        static TEXTURE: number;

        static TILEMAP: number;

        static XML: number;

        /**
        * @property {boolean} autoResolveURL - Automatically resolve resource URLs to absolute paths for use with the Cache.getURL method.
        */
        autoResolveURL: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Signal} onSoundUnlock - This event is dispatched when the sound system is unlocked via a touch event on cellular devices.
        */
        onSoundUnlock: Phaser.Signal;

        /**
        * Add a binary object in to the cache.
        *
        * @method Phaser.Cache#addBinary
        * @param {string} key - Asset key for this binary data.
        * @param {object} binaryData - The binary object to be addded to the cache.
        */
        addBinary(key: string, binaryData: any): void;

        /**
        * Add a BitmapData object to the cache.
        *
        * @method Phaser.Cache#addBitmapData
        * @param {string} key - Asset key for this BitmapData.
        * @param {Phaser.BitmapData} bitmapData - The BitmapData object to be addded to the cache.
        * @param {Phaser.FrameData|null} [frameData=(auto create)] - Optional FrameData set associated with the given BitmapData. If not specified (or `undefined`) a new FrameData object is created containing the Bitmap's Frame. If `null` is supplied then no FrameData will be created.
        * @return {Phaser.BitmapData} The BitmapData object to be addded to the cache.
        */
        addBitmapData(key: string, bitmapData: Phaser.BitmapData, frameData?: Phaser.FrameData): Phaser.BitmapData;

        /**
        * Add a new Bitmap Font to the Cache.
        *
        * @method Phaser.Cache#addBitmapFont
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this font xml file.
        * @param {object} data - Extra font data.
        * @param {object} xmlData - Texture atlas frames data.
        * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.
        * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.
        */
        addBitmapFont(key: string, texture: Phaser.RetroFont): void;

        /**
        * Add a new Bitmap Font to the Cache.
        *
        * @method Phaser.Cache#addBitmapFont
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this font xml file.
        * @param {object} data - Extra font data.
        * @param {object} xmlData - Texture atlas frames data.
        * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.
        * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.
        */
        addBitmapFont(key: string, url: string, data: any, xmlData: any, xSpacing?: number, ySpacing?: number): void;

        /**
        * Add a new canvas object in to the cache.
        *
        * @method Phaser.Cache#addCanvas
        * @param {string} key - Asset key for this canvas.
        * @param {HTMLCanvasElement} canvas - Canvas DOM element.
        * @param {CanvasRenderingContext2D} context - Render context of this canvas.
        */
        addCanvas(key: string, canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

        /**
        * Adds a default image to be used in special cases such as WebGL Filters. Is mapped to the key __default.
        *
        * @method Phaser.Cache#addDefaultImage
        * @protected
        */
        addDefaultImage(): void;

        /**
        * Adds an Image file into the Cache. The file must have already been loaded, typically via Phaser.Loader, but can also have been loaded into the DOM.
        *
        * @method Phaser.Cache#addImage
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this image file.
        * @param {object} data - Extra image data.
        */
        addImage(key: string, url: string, data: any): void;

        /**
        * Add a new json object into the cache.
        *
        * @method Phaser.Cache#addJSON
        * @param {string} key - Asset key for the json data.
        * @param {string} url - URL of this json data file.
        * @param {object} data - Extra json data.
        */
        addJSON(key: string, urL: string, data: any): void;

        addMisingImage(): void;

        /**
        * Add a new physics data object to the Cache.
        *
        * @method Phaser.Cache#addPhysicsData
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of the physics json data.
        * @param {object} JSONData - The physics data object (a JSON file).
        * @param {number} format - The format of the physics data.
        */
        addPhysicsData(key: string, url: string, JSONData: any, format: number): void;

        /**
        * Add a new Phaser.RenderTexture in to the cache.
        *
        * @method Phaser.Cache#addRenderTexture
        * @param {string} key - The unique key by which you will reference this object.
        * @param {Phaser.RenderTexture} texture - The texture to use as the base of the RenderTexture.
        */
        addRenderTexture(key: string, texture: RenderTexture): void;

        /**
        * Adds a Sound file into the Cache. The file must have already been loaded, typically via Phaser.Loader.
        *
        * @method Phaser.Cache#addSound
        * @param {string} key - Asset key for the sound.
        * @param {string} url - URL of this sound file.
        * @param {object} data - Extra sound data.
        * @param {boolean} webAudio - True if the file is using web audio.
        * @param {boolean} audioTag - True if the file is using legacy HTML audio.
        */
        addSound(key: string, url: string, data: any, webAudio: boolean, audioTag: boolean): void;

        /**
        * Add a new sprite sheet in to the cache.
        *
        * @method Phaser.Cache#addSpriteSheet
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this sprite sheet file.
        * @param {object} data - Extra sprite sheet data.
        * @param {number} frameWidth - Width of the sprite sheet.
        * @param {number} frameHeight - Height of the sprite sheet.
        * @param {number} [frameMax=-1] - How many frames stored in the sprite sheet. If -1 then it divides the whole sheet evenly.
        * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
        * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
        */
        addSpriteSheet(key: string, url: string, data: any, frameWidth: number, frameHeight: number, frameMax?: number, margin?: number, spacing?: number): void;

        /**
        * Add a new texture atlas to the Cache.
        *
        * @method Phaser.Cache#addTextureAtlas
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this texture atlas file.
        * @param {object} data - Extra texture atlas data.
        * @param {object} atlasData  - Texture atlas frames data.
        * @param {number} format - The format of the texture atlas.
        */
        addText(key: string, url: string, data: any): void;

        /**
        * Add a new texture atlas to the Cache.
        *
        * @method Phaser.Cache#addTextureAtlas
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of this texture atlas file.
        * @param {object} data - Extra texture atlas data.
        * @param {object} atlasData  - Texture atlas frames data.
        * @param {number} format - The format of the texture atlas.
        */
        addTextureAtlas(key: string, url: string, data: any, atlasData: any, format: number): void;

        /**
        * Add a new tilemap to the Cache.
        *
        * @method Phaser.Cache#addTilemap
        * @param {string} key - The unique key by which you will reference this object.
        * @param {string} url - URL of the tilemap image.
        * @param {object} mapData - The tilemap data object (either a CSV or JSON file).
        * @param {number} format - The format of the tilemap data.
        */
        addTilemap(key: string, url: string, mapData: any, format: number): void;

        /**
        * Add a new xml object into the cache.
        *
        * @method Phaser.Cache#addXML
        * @param {string} key - Asset key for the xml file.
        * @param {string} url - URL of this xml file.
        * @param {object} data - Extra text data.
        */
        addXML(key: string, url: string, data: any): void;

        /**
        * Checks if the given key exists in the Binary Cache.
        *
        * @method Phaser.Cache#checkBinaryKey
        * @param {string} key - Asset key of the binary file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkBinaryKey(key: string): boolean;

        /**
        * Checks if the given key exists in the BitmapData Cache.
        *
        * @method Phaser.Cache#checkBitmapDataKey
        * @param {string} key - Asset key of the BitmapData to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkBitmapDataKey(key: string): boolean;

        /**
        * Checks if the given key exists in the BitmapFont Cache.
        *
        * @method Phaser.Cache#checkBitmapFontKey
        * @param {string} key - Asset key of the BitmapFont to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkBitmapFontKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Canvas Cache.
        *
        * @method Phaser.Cache#checkCanvasKey
        * @param {string} key - Asset key of the canvas to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkCanvasKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Image Cache. Note that this also includes Texture Atlases, Sprite Sheets and Retro Fonts.
        *
        * @method Phaser.Cache#checkImageKey
        * @param {string} key - Asset key of the image to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkImageKey(key: string): boolean;

        /**
        * Checks if the given key exists in the JSON Cache.
        *
        * @method Phaser.Cache#checkJSONKey
        * @param {string} key - Asset key of the JSON file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkJSONKey(key: string): boolean;

        /**
        * Checks if a key for the given cache object type exists.
        *
        * @method Phaser.Cache#checkKey
        * @param {number} type - The Cache type to check against. I.e. Phaser.Cache.CANVAS, Phaser.Cache.IMAGE, Phaser.Cache.JSON, etc.
        * @param {string} key - Asset key of the image to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkKey(type: number, key: string): boolean;

        /**
        * Checks if the given key exists in the Physics Cache.
        *
        * @method Phaser.Cache#checkPhysicsKey
        * @param {string} key - Asset key of the physics data file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkPhysicsKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Sound Cache.
        *
        * @method Phaser.Cache#checkSoundKey
        * @param {string} key - Asset key of the sound file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkSoundKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Text Cache.
        *
        * @method Phaser.Cache#checkTextKey
        * @param {string} key - Asset key of the text file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkTextKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Texture Cache.
        *
        * @method Phaser.Cache#checkTextureKey
        * @param {string} key - Asset key of the image to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkTextureKey(key: string): boolean;

        /**
        * Checks if the given key exists in the Tilemap Cache.
        *
        * @method Phaser.Cache#checkTilemapKey
        * @param {string} key - Asset key of the Tilemap to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkTilemapKey(key: string): boolean;

        /**
        * Checks if the given URL has been loaded into the Cache.
        * This method will only work if Cache.autoResolveURL was set to `true` before any preloading took place.
        * The method will make a DOM src call to the URL given, so please be aware of this for certain file types, such as Sound files on Firefox
        * which may cause double-load instances.
        *
        * @method Phaser.Cache#checkURL
        * @param {string} url - The url to check for in the cache.
        * @return {boolean} True if the url exists, otherwise false.
        */
        checkURL(url: string): any;

        checkUrl(url: string): any;

        /**
        * Checks if the given key exists in the XML Cache.
        *
        * @method Phaser.Cache#checkXMLKey
        * @param {string} key - Asset key of the XML file to check is in the Cache.
        * @return {boolean} True if the key exists, otherwise false.
        */
        checkXMLKey(key: string): boolean;

        /**
        * Add a new decoded sound.
        *
        * @method Phaser.Cache#decodedSound
        * @param {string} key - Asset key for the sound.
        * @param {object} data - Extra sound data.
        */
        decodedSound(key: string, data: any): void;

        /**
        * Clears the cache. Removes every local cache object reference.
        *
        * @method Phaser.Cache#destroy
        */
        destroy(): void;

        /**
        * Get binary data by key.
        *
        * @method Phaser.Cache#getBinary
        * @param {string} key - Asset key of the binary data object to retrieve from the Cache.
        * @return {object} The binary data object.
        */
        getBinary(key: string): any;

        /**
        * Get a BitmapData object from the cache by its key.
        *
        * @method Phaser.Cache#getBitmapData
        * @param {string} key - Asset key of the BitmapData object to retrieve from the Cache.
        * @return {Phaser.BitmapData} The requested BitmapData object if found, or null if not.
        */
        getBitmapData(key: string): Phaser.BitmapData;

        /**
        * Get a BitmapFont object from the cache by its key.
        *
        * @method Phaser.Cache#getBitmapFont
        * @param {string} key - Asset key of the BitmapFont object to retrieve from the Cache.
        * @return {Phaser.BitmapFont} The requested BitmapFont object if found, or null if not.
        */
        getBitmapFont(key: string): Phaser.RetroFont;

        /**
        * Get a canvas object from the cache by its key.
        *
        * @method Phaser.Cache#getCanvas
        * @param {string} key - Asset key of the canvas to retrieve from the Cache.
        * @return {object} The canvas object.
        */
        getCanvas(key: string): any;

        /**
        * Get frame data by key.
        *
        * @method Phaser.Cache#getFrameData
        * @param {string} key - Asset key of the frame data to retrieve from the Cache.
        * @param {string} [map=Phaser.Cache.IMAGE] - The asset map to get the frameData from, for example `Phaser.Cache.IMAGE`.
        * @return {Phaser.FrameData} The frame data.
        */
        getFrame(key: string): Phaser.Frame;

        /**
        * Get a single frame out of a frameData set by key.
        *
        * @method Phaser.Cache#getFrameByIndex
        * @param {string} key - Asset key of the frame data to retrieve from the Cache.
        * @return {Phaser.Frame} The frame object.
        */
        getFrameByIndex(key: string, frame: string): Phaser.Frame;

        /**
        * Get a single frame out of a frameData set by key.
        *
        * @method Phaser.Cache#getFrameByName
        * @param {string} key - Asset key of the frame data to retrieve from the Cache.
        * @return {Phaser.Frame} The frame object.
        */
        getFrameByName(key: string, frame: string): Phaser.Frame;

        /**
        * Get the number of frames in this image.
        *
        * @method Phaser.Cache#getFrameCount
        * @param {string} key - Asset key of the image you want.
        * @return {number} Then number of frames. 0 if the image is not found.
        */
        getFrameCount(key: string): number;

        /**
        * Get frame data by key.
        *
        * @method Phaser.Cache#getFrameData
        * @param {string} key - Asset key of the frame data to retrieve from the Cache.
        * @param {string} [map=Phaser.Cache.IMAGE] - The asset map to get the frameData from, for example `Phaser.Cache.IMAGE`.
        * @return {Phaser.FrameData} The frame data.
        */
        getFrameData(key: string, map?: string): Phaser.FrameData;

        /**
        * Gets an image by its key. Note that this returns a DOM Image object, not a Phaser object.
        *
        * @method Phaser.Cache#getImage
        * @param {string} key - Asset key of the image to retrieve from the Cache.
        * @return {Image} The Image object if found in the Cache, otherwise `null`.
        */
        getImage(key: string): Phaser.Image;

        /**
        * Get a JSON object by key from the cache.
        *
        * @method Phaser.Cache#getJSON
        * @param {string} key - Asset key of the json object to retrieve from the Cache.
        * @return {object} The JSON object.
        */
        getJSON(key: string): any;

        /**
        * Gets all keys used by the Cache for the given data type.
        *
        * @method Phaser.Cache#getKeys
        * @param {number} [type=Phaser.Cache.IMAGE] - The type of Cache keys you wish to get. Can be Cache.CANVAS, Cache.IMAGE, Cache.SOUND, etc.
        * @return {Array} The array of item keys.
        */
        getKeys(array: string[]): string[];

        /**
        * Get a physics data object from the cache by its key. You can get either the entire data set, a single object or a single fixture of an object from it.
        *
        * @method Phaser.Cache#getPhysicsData
        * @param {string} key - Asset key of the physics data object to retrieve from the Cache.
        * @param {string} [object=null] - If specified it will return just the physics object that is part of the given key, if null it will return them all.
        * @param {string} fixtureKey - Fixture key of fixture inside an object. This key can be set per fixture with the Phaser Exporter.
        * @return {object} The requested physics object data if found.
        */
        getPhysicsData(key: string, object?: string, fixtureKey?: string): any[];

        /**
        * Get a RenderTexture by key.
        *
        * @method Phaser.Cache#getRenderTexture
        * @param {string} key - Asset key of the RenderTexture to retrieve from the Cache.
        * @return {Phaser.RenderTexture} The RenderTexture object.
        */
        getRenderTexture(key: string): Phaser.RenderTexture;

        /**
        * Get sound by key.
        *
        * @method Phaser.Cache#getSound
        * @param {string} key - Asset key of the sound to retrieve from the Cache.
        * @return {Phaser.Sound} The sound object.
        */
        getSound(key: string): Phaser.Sound;

        /**
        * Get sound data by key.
        *
        * @method Phaser.Cache#getSoundData
        * @param {string} key - Asset key of the sound to retrieve from the Cache.
        * @return {object} The sound data.
        */
        getSoundData(key: string): any;

        /**
        * Get a single texture frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.
        *
        * @method Phaser.Cache#getTextureFrame
        * @param {string} key - Asset key of the frame to retrieve from the Cache.
        * @return {Phaser.Frame} The frame data.
        */
        getText(key: string): string;

        getTextKeys(): string[];

        /**
        * Get a single texture frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.
        *
        * @method Phaser.Cache#getTextureFrame
        * @param {string} key - Asset key of the frame to retrieve from the Cache.
        * @return {Phaser.Frame} The frame data.
        */
        getTexture(key: string): Phaser.RenderTexture;

        /**
        * Get a single texture frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.
        *
        * @method Phaser.Cache#getTextureFrame
        * @param {string} key - Asset key of the frame to retrieve from the Cache.
        * @return {Phaser.Frame} The frame data.
        */
        getTextureFrame(key: string): Phaser.Frame;

        /**
        * Get tilemap data by key.
        *
        * @method Phaser.Cache#getTilemapData
        * @param {string} key - Asset key of the tilemap data to retrieve from the Cache.
        * @return {object} The raw tilemap data in CSV or JSON format.
        */
        getTilemap(key: string): any;

        /**
        * Get tilemap data by key.
        *
        * @method Phaser.Cache#getTilemapData
        * @param {string} key - Asset key of the tilemap data to retrieve from the Cache.
        * @return {object} The raw tilemap data in CSV or JSON format.
        */
        getTilemapData(key: string): any;

        /**
        * Get a cached object by the URL.
        * This only returns a value if you set Cache.autoResolveURL to `true` *before* starting the preload of any assets.
        * Be aware that every call to this function makes a DOM src query, so use carefully and double-check for implications in your target browsers/devices.
        *
        * @method Phaser.Cache#getURL
        * @param {string} url - The url for the object loaded to get from the cache.
        * @return {object} The cached object.
        */
        getURL(url: string): any;

        /**
        * DEPRECATED: Please use Cache.getURL instead.
        * Get a cached object by the URL.
        * This only returns a value if you set Cache.autoResolveURL to `true` *before* starting the preload of any assets.
        * Be aware that every call to this function makes a DOM src query, so use carefully and double-check for implications in your target browsers/devices.
        *
        * @method Phaser.Cache#getUrl
        * @deprecated Please use Cache.getURL instead.
        * @param {string} url - The url for the object loaded to get from the cache.
        * @return {object} The cached object.
        */
        getUrl(url: string): any;

        /**
        * Get a XML object by key from the cache.
        *
        * @method Phaser.Cache#getXML
        * @param {string} key - Asset key of the XML object to retrieve from the Cache.
        * @return {object} The XML object.
        */
        getXML(key: string): any;

        /**
        * Check if the given sound has finished decoding.
        *
        * @method Phaser.Cache#isSoundDecoded
        * @param {string} key - Asset key of the sound in the Cache.
        * @return {boolean} The decoded state of the Sound object.
        */
        isSoundDecoded(key: string): boolean;

        /**
        * Check if the given sound is ready for playback. A sound is considered ready when it has finished decoding and the device is no longer touch locked.
        *
        * @method Phaser.Cache#isSoundReady
        * @param {string} key - Asset key of the sound in the Cache.
        * @return {boolean} True if the sound is decoded and the device is not touch locked.
        */
        isSoundReady(key: string): boolean;

        isSpriteSheet(key: string): boolean;

        /**
        * Reload a Sound file from the server.
        *
        * @method Phaser.Cache#reloadSound
        * @param {string} key - Asset key for the sound.
        */
        reloadSound(key: string): void;

        /**
        * Fires the onSoundUnlock event when the sound has completed reloading.
        *
        * @method Phaser.Cache#reloadSoundComplete
        * @param {string} key - Asset key for the sound.
        */
        reloadSoundComplete(key: string): void;

        /**
        * Removes a binary file from the cache.
        *
        * @method Phaser.Cache#removeBinary
        * @param {string} key - Key of the asset you want to remove.
        */
        removeBinary(key: string): void;

        /**
        * Removes a bitmap data from the cache.
        *
        * @method Phaser.Cache#removeBitmapData
        * @param {string} key - Key of the asset you want to remove.
        */
        removeBitmapData(key: string): void;

        /**
        * Removes a bitmap font from the cache.
        *
        * @method Phaser.Cache#removeBitmapFont
        * @param {string} key - Key of the asset you want to remove.
        */
        removeBitmapFont(key: string): void;

        /**
        * Removes a canvas from the cache.
        *
        * @method Phaser.Cache#removeCanvas
        * @param {string} key - Key of the asset you want to remove.
        */
        removeCanvas(key: string): void;

        /**
        * Removes an image from the cache and optionally from the Pixi.BaseTextureCache as well.
        *
        * @method Phaser.Cache#removeImage
        * @param {string} key - Key of the asset you want to remove.
        * @param {boolean} [removeFromPixi=true] - Should this image also be removed from the Pixi BaseTextureCache?
        */
        removeImage(key: string, removeFromPixi?: boolean): void;

        /**
        * Removes a json object from the cache.
        *
        * @method Phaser.Cache#removeJSON
        * @param {string} key - Key of the asset you want to remove.
        */
        removeJSON(key: string): void;

        /**
        * Removes a physics data file from the cache.
        *
        * @method Phaser.Cache#removePhysics
        * @param {string} key - Key of the asset you want to remove.
        */
        removePhysics(key: string): void;

        /**
        * Removes a sound from the cache.
        *
        * @method Phaser.Cache#removeSound
        * @param {string} key - Key of the asset you want to remove.
        */
        removeSound(key: string): void;

        /**
        * Removes a text from the cache.
        *
        * @method Phaser.Cache#removeText
        * @param {string} key - Key of the asset you want to remove.
        */
        removeText(key: string): void;

        /**
        * Removes a tilemap from the cache.
        *
        * @method Phaser.Cache#removeTilemap
        * @param {string} key - Key of the asset you want to remove.
        */
        removeTilemap(key: string): void;

        /**
        * Removes a xml object from the cache.
        *
        * @method Phaser.Cache#removeXML
        * @param {string} key - Key of the asset you want to remove.
        */
        removeXML(key: string): void;

        /**
        * Replaces a set of frameData with a new Phaser.FrameData object.
        *
        * @method Phaser.Cache#updateFrameData
        * @param {string} key - The unique key by which you will reference this object.
        * @param {number} frameData - The new FrameData.
        */
        updateFrameData(key: string, frameData: any): void;

        /**
        * Updates the sound object in the cache.
        *
        * @method Phaser.Cache#updateSound
        * @param {string} key - Asset key for the sound.
        */
        updateSound(key: string, property: string, value: Phaser.Sound): void;

    }
    /**
    * A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
    * The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
    *
    * @class Phaser.Camera
    * @constructor
    * @param {Phaser.Game} game - Game reference to the currently running game.
    * @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera
    * @param {number} x - Position of the camera on the X axis
    * @param {number} y - Position of the camera on the Y axis
    * @param {number} width - The width of the view rectangle
    * @param {number} height - The height of the view rectangle
    */
    class Camera {

        constructor(game: Phaser.Game, id: number, x: number, y: number, width: number, height: number);

        static FOLLOW_LOCKON: number;

        static FOLLOW_PLATFORMER: number;

        static FOLLOW_TOPDOWN: number;

        static FOLLOW_TOPDOWN_TIGHT: number;

        /**
        * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.
        */
        atLimit: { x: boolean; y: boolean; };

        /**
        * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
        * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
        * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
        * 
        * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
        */
        bounds: Phaser.Rectangle;

        /**
        * @property {Phaser.Rectangle} deadzone - Moving inside this Rectangle will not cause the camera to move.
        */
        deadzone: Phaser.Rectangle;

        /**
        * @property {PIXI.DisplayObject} displayObject - The display object to which all game objects are added. Set by World.boot
        */
        displayObject: PIXI.DisplayObject;

        /**
        * @property {number} id - Reserved for future multiple camera set-ups.
        * @default
        */
        id: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {boolean} roundPx - If a Camera has roundPx set to `true` it will call `view.floor` as part of its update loop, keeping its boundary to integer values. Set this to `false` to disable this from happening.
        * @default
        */
        roundPx: boolean;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * @property {Phaser.Rectangle} screenView - Used by Sprites to work out Camera culling.
        * @deprecated No longer used for camera culling. Uses Camera.view instead.
        */
        screenView: Phaser.Rectangle;

        /**
        * @property {Phaser.Sprite} target - If the camera is tracking a Sprite, this is a reference to it, otherwise null.
        * @default
        */
        target: Phaser.Sprite;

        /**
        * @property {number} totalInView - The total number of Sprites with `autoCull` set to `true` that are visible by this Camera.
        * @readonly
        */
        totalInView: number;

        view: Phaser.Rectangle;

        /**
        * @property {boolean} visible - Whether this camera is visible or not.
        * @default
        */
        visible: boolean;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.World;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        checkBounds(): void;

        /**
        * Move the camera focus on a display object instantly.
        * @method Phaser.Camera#focusOn
        * @param {any} displayObject - The display object to focus the camera on. Must have visible x/y properties.
        */
        focusOn(displayObject: any): void;

        /**
        * Move the camera focus on a location instantly.
        * @method Phaser.Camera#focusOnXY
        * @param {number} x - X position.
        * @param {number} y - Y position.
        */
        focusOnXY(x: number, y: number): void;

        /**
        * Tells this camera which sprite to follow.
        * @method Phaser.Camera#follow
        * @param {Phaser.Sprite|Phaser.Image|Phaser.Text} target - The object you want the camera to track. Set to null to not follow anything.
        * @param {number} [style] - Leverage one of the existing "deadzone" presets. If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling follow().
        */
        follow(target: Phaser.Sprite, style?: number): void;

        /**
        * Resets the camera back to 0,0 and un-follows any object it may have been tracking.
        *
        * @method Phaser.Camera#reset
        */
        reset(): void;

        /**
        * Update the Camera bounds to match the game world.
        * @method Phaser.Camera#setBoundsToWorld
        */
        setBoundsToWorld(): void;

        /**
        * A helper function to set both the X and Y properties of the camera at once
        * without having to use game.camera.x and game.camera.y.
        *
        * @method Phaser.Camera#setPosition
        * @param {number} x - X position.
        * @param {number} y - Y position.
        */
        setPosition(x: number, y: number): void;

        /**
        * Sets the size of the view rectangle given the width and height in parameters.
        *
        * @method Phaser.Camera#setSize
        * @param {number} width - The desired width.
        * @param {number} height - The desired height.
        */
        setSize(width: number, height: number): void;

        /**
        * Update focusing and scrolling.
        * @method Phaser.Camera#update
        */
        update(): void;

    }
    /**
    * The Canvas class handles everything related to creating the `canvas` DOM tag that Phaser will use, including styles, offset and aspect ratio.
    *
    * @class Phaser.Canvas
    * @static
    */
    class Canvas {

        /**
        * Adds the given canvas element to the DOM. The canvas will be added as a child of the given parent.
        * If no parent is given it will be added as a child of the document.body.
        *
        * @method Phaser.Canvas.addToDOM
        * @param {HTMLCanvasElement} canvas - The canvas to be added to the DOM.
        * @param {string|HTMLElement} parent - The DOM element to add the canvas to.
        * @param {boolean} [overflowHidden=true] - If set to true it will add the overflow='hidden' style to the parent DOM element.
        * @return {HTMLCanvasElement} Returns the source canvas.
        */
        static addToDOM(canvas: HTMLCanvasElement, parent: any, overflowHidden?: boolean): HTMLCanvasElement;

        /**
        * Creates a `canvas` DOM element. The element is not automatically added to the document.
        *
        * @method Phaser.Canvas.create
        * @param {number} [width=256] - The width of the canvas element.
        * @param {number} [height=256] - The height of the canvas element..
        * @param {string} [id=''] - If given this will be set as the ID of the canvas element, otherwise no ID will be set.
        * @return {HTMLCanvasElement} The newly created canvas element.
        */
        static create(width?: number, height?: number, id?: string): HTMLCanvasElement;

        /**
        * Returns the aspect ratio of the given canvas.
        *
        * @method Phaser.Canvas.getAspectRatio
        * @param {HTMLCanvasElement} canvas - The canvas to get the aspect ratio from.
        * @return {number} The ratio between canvas' width and height.
        * @deprecated 2.1.4 - User {@link Phaser.DOM.getAspectRatio}
        */
        static getAspectRatio(canvas: HTMLCanvasElement): number;

        /**
        * Get the DOM offset values of any given element
        *
        * @method Phaser.Canvas.getOffset
        * @param {HTMLElement} element - The targeted element that we want to retrieve the offset.
        * @param {Phaser.Point} [point] - The point we want to take the x/y values of the offset.
        * @return {Phaser.Point} - A point objet with the offsetX and Y as its properties.
        * @deprecated 2.1.4 - Use {@link Phaser.DOM.getOffset}
        */
        static getOffset(element: HTMLElement, point?: Phaser.Point): Phaser.Point;

        static getSmoothngEnabled(context: CanvasRenderingContext2D): boolean;

        /**
        * Removes the given canvas element from the DOM.
        *
        * @method Phaser.Canvas.removeFromDOM
        * @param {HTMLCanvasElement} canvas - The canvas to be removed from the DOM.
        */
        static removeFromDOM(canvas: HTMLCanvasElement): void;

        /**
        * Sets the background color behind the canvas. This changes the canvas style property.
        *
        * @method Phaser.Canvas.setBackgroundColor
        * @param {HTMLCanvasElement} canvas - The canvas to set the background color on.
        * @param {string} [color] - The color to set. Can be in the format 'rgb(r,g,b)', or '#RRGGBB' or any valid CSS color.
        * @return {HTMLCanvasElement} Returns the source canvas.
        */
        static setBackgroundColor(canvas: HTMLCanvasElement, color: string): HTMLCanvasElement;

        /**
        * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
        * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
        *
        * @method Phaser.Canvas.setImageRenderingBicubic
        * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.
        * @return {HTMLCanvasElement} Returns the source canvas.
        */
        static setImageRenderingBicubic(canvas: HTMLCanvasElement): HTMLCanvasElement;

        /**
        * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
        * Note that if this doesn't given the desired result then see the setSmoothingEnabled.
        *
        * @method Phaser.Canvas.setImageRenderingCrisp
        * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.
        * @return {HTMLCanvasElement} Returns the source canvas.
        */
        static setImageRenderingCrisp(canvas: HTMLCanvasElement): HTMLCanvasElement;

        /**
        * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
        * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
        * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
        * drawn to the context will be affected. This sets the property across all current browsers but support is
        * patchy on earlier browsers, especially on mobile.
        *
        * @method Phaser.Canvas.setSmoothingEnabled
        * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.
        * @param {boolean} value - If set to true it will enable image smoothing, false will disable it.
        * @return {CanvasRenderingContext2D} Returns the source context.
        */
        static setSmoothingEnabled(context: CanvasRenderingContext2D, value: boolean): CanvasRenderingContext2D;

        /**
        * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
        *
        * @method Phaser.Canvas.setTouchAction
        * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
        * @param {string} [value] - The touch action to set. Defaults to 'none'.
        * @return {HTMLCanvasElement} The source canvas.
        */
        static setTouchAction(canvas: HTMLCanvasElement, value: string): HTMLCanvasElement;

        /**
        * Sets the transform of the given canvas to the matrix values provided.
        *
        * @method Phaser.Canvas.setTransform
        * @param {CanvasRenderingContext2D} context - The context to set the transform on.
        * @param {number} translateX - The value to translate horizontally by.
        * @param {number} translateY - The value to translate vertically by.
        * @param {number} scaleX - The value to scale horizontally by.
        * @param {number} scaleY - The value to scale vertically by.
        * @param {number} skewX - The value to skew horizontaly by.
        * @param {number} skewY - The value to skew vertically by.
        * @return {CanvasRenderingContext2D} Returns the source context.
        */
        static setTransform(context: CanvasRenderingContext2D, translateX: number, translateY: number, scaleX: number, scaleY: number, skewX: number, skewY: number): CanvasRenderingContext2D;

        /**
        * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
        *
        * @method Phaser.Canvas.setUserSelect
        * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.
        * @param {string} [value] - The touch action to set. Defaults to 'none'.
        * @return {HTMLCanvasElement} The source canvas.
        */
        static setUserSelect(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement;

    }
    /**
    * Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter.
    * If you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.
    * 
    * @class Phaser.Circle
    * @constructor
    * @param {number} [x=0] - The x coordinate of the center of the circle.
    * @param {number} [y=0] - The y coordinate of the center of the circle.
    * @param {number} [diameter=0] - The diameter of the circle.
    */
    class Circle {

        constructor(x?: number, y?: number, diameter?: number);

        /**
        * The area of this Circle.
        * @name Phaser.Circle#area
        * @property {number} area - The area of this circle.
        * @readonly
        */
        area: number;

        /**
        * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#bottom
        * @property {number} bottom - Gets or sets the bottom of the circle.
        */
        bottom: number;

        /**
        * The largest distance between any two points on the circle. The same as the radius * 2.
        * @name Phaser.Circle#diameter
        * @property {number} diameter - Gets or sets the diameter of the circle.
        */
        diameter: number;

        /**
        * Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
        * If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0.
        * @name Phaser.Circle#empty
        * @property {boolean} empty - Gets or sets the empty state of the circle.
        */
        empty: boolean;

        /**
        * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
        * @name Phaser.Rectangle#left
        * @property {number} left - The x coordinate of the left of the Rectangle.
        */
        left: number;

        /**
        * The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter.
        * @name Phaser.Circle#radius
        * @property {number} radius - Gets or sets the radius of the circle.
        */
        radius: number;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#top
        * @property {number} top - Gets or sets the top of the circle.
        */
        top: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
        * @method Phaser.Circle.circumferencePoint
        * @param {Phaser.Circle} a - The first Circle object.
        * @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
        * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?
        * @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
        * @return {Phaser.Point} The Point object holding the result.
        */
        static circumferencePoint(a: Phaser.Circle, angle: number, asDegrees: boolean, out?: Phaser.Point): Phaser.Point;

        /**
        * Return true if the given x/y coordinates are within the Circle object.
        * @method Phaser.Circle.contains
        * @param {Phaser.Circle} a - The Circle to be checked.
        * @param {number} x - The X value of the coordinate to test.
        * @param {number} y - The Y value of the coordinate to test.
        * @return {boolean} True if the coordinates are within this circle, otherwise false.
        */
        static contains(a: Phaser.Circle, x: number, y: number): boolean;

        /**
        * Determines whether the two Circle objects match. This method compares the x, y and diameter properties.
        * @method Phaser.Circle.equals
        * @param {Phaser.Circle} a - The first Circle object.
        * @param {Phaser.Circle} b - The second Circle object.
        * @return {boolean} A value of true if the object has exactly the same values for the x, y and diameter properties as this Circle object; otherwise false.
        */
        static equals(a: Phaser.Circle, b: Phaser.Circle): boolean;

        /**
        * Determines whether the two Circle objects intersect.
        * This method checks the radius distances between the two Circle objects to see if they intersect.
        * @method Phaser.Circle.intersects
        * @param {Phaser.Circle} a - The first Circle object.
        * @param {Phaser.Circle} b - The second Circle object.
        * @return {boolean} A value of true if the specified object intersects with this Circle object; otherwise false.
        */
        static intersects(a: Phaser.Circle, b: Phaser.Circle): boolean;

        /**
        * Checks if the given Circle and Rectangle objects intersect.
        * @method Phaser.Circle.intersectsRectangle
        * @param {Phaser.Circle} c - The Circle object to test.
        * @param {Phaser.Rectangle} r - The Rectangle object to test.
        * @return {boolean} True if the two objects intersect, otherwise false.
        */
        static intersectsRectangle(c: Phaser.Circle, r: Phaser.Rectangle): boolean;

        /**
        * The circumference of the circle.
        * @method Phaser.Circle#circumference
        * @return {number}
        */
        circumference(): number;

        /**
        * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
        * @method Phaser.Circle#circumferencePoint
        * @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.
        * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?
        * @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.
        * @return {Phaser.Point} The Point object holding the result.
        */
        circumferencePoint(angle: number, asDegrees?: boolean, out?: Phaser.Point): Phaser.Point;

        /**
        * Returns a new Circle object with the same values for the x, y, width, and height properties as this Circle object.
        * @method Phaser.Circle#clone
        * @param {Phaser.Circle} output - Optional Circle object. If given the values will be set into the object, otherwise a brand new Circle object will be created and returned.
        * @return {Phaser.Circle} The cloned Circle object.
        */
        clone(output: Phaser.Circle): Phaser.Circle;

        /**
        * Return true if the given x/y coordinates are within this Circle object.
        * @method Phaser.Circle#contains
        * @param {number} x - The X value of the coordinate to test.
        * @param {number} y - The Y value of the coordinate to test.
        * @return {boolean} True if the coordinates are within this circle, otherwise false.
        */
        contains(x: number, y: number): boolean;

        /**
        * Copies the x, y and diameter properties from any given object to this Circle.
        * @method Phaser.Circle#copyFrom
        * @param {any} source - The object to copy from.
        * @return {Circle} This Circle object.
        */
        copyFrom(source: any): Circle;

        /**
        * Copies the x, y and diameter properties from this Circle to any given object.
        * @method Phaser.Circle#copyTo
        * @param {any} dest - The object to copy to.
        * @return {object} This dest object.
        */
        copyTo(dest: any): any;

        /**
        * Returns the distance from the center of the Circle object to the given object
        * (can be Circle, Point or anything with x/y properties)
        * @method Phaser.Circle#distance
        * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.
        * @param {boolean} [round=false] - Round the distance to the nearest integer.
        * @return {number} The distance between this Point object and the destination Point object.
        */
        distance(dest: any, round?: boolean): number;

        /**
        * Returns the framing rectangle of the circle as a Phaser.Rectangle object
        * @method Phaser.Circle#getBounds
        * @return {Phaser.Rectangle} The bounds of the Circle.
        */
        getBounds(): Phaser.Rectangle;

        /**
        * Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.
        * @method Phaser.Circle#offset
        * @param {number} dx - Moves the x value of the Circle object by this amount.
        * @param {number} dy - Moves the y value of the Circle object by this amount.
        * @return {Circle} This Circle object.
        */
        offset(dx: number, dy: number): Phaser.Circle;

        /**
        * Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.
        * @method Phaser.Circle#offsetPoint
        * @param {Point} point A Point object to use to offset this Circle object (or any valid object with exposed x and y properties).
        * @return {Circle} This Circle object.
        */
        offsetPoint(point: Phaser.Point): Phaser.Circle;

        scale(x: number, y?: number): Phaser.Rectangle;

        /**
        * Sets the members of Circle to the specified values.
        * @method Phaser.Circle#setTo
        * @param {number} x - The x coordinate of the center of the circle.
        * @param {number} y - The y coordinate of the center of the circle.
        * @param {number} diameter - The diameter of the circle.
        * @return {Circle} This circle object.
        */
        setTo(x: number, y: number, diameter: number): Circle;

        /**
        * Returns a string representation of this object.
        * @method Phaser.Circle#toString
        * @return {string} a string representation of the instance.
        */
        toString(): string;

    }
    /**
    * The Phaser.Color class is a set of static methods that assist in color manipulation and conversion.
    *
    * @class Phaser.Color
    */
    class Color {

        /**
        * Return a string containing a hex representation of the given color component.
        *
        * @method Phaser.Color.componentToHex
        * @static
        * @param {number} color - The color channel to get the hex value for, must be a value between 0 and 255.
        * @returns {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.
        */
        static componentToHex(color: number): string;

        /**
        * A utility function to create a lightweight 'color' object with the default components.
        * Any components that are not specified will default to zero.
        *
        * This is useful when you want to use a shared color object for the getPixel and getPixelAt methods.
        *
        * @author Matt DesLauriers (@mattdesl)
        * @method Phaser.Color.createColor
        * @static
        * @param {number} [r=0] - The red color component, in the range 0 - 255.
        * @param {number} [g=0] - The green color component, in the range 0 - 255.
        * @param {number} [b=0] - The blue color component, in the range 0 - 255.
        * @param {number} [a=1] - The alpha color component, in the range 0 - 1.
        * @param {number} [h=0] - The hue, in the range 0 - 1.
        * @param {number} [s=0] - The saturation, in the range 0 - 1.
        * @param {number} [l=0] - The lightness, in the range 0 - 1.
        * @param {number} [v=0] - The value, in the range 0 - 1.
        * @return {object} The resulting object with r, g, b, a properties and h, s, l and v.
        */
        static createColor(r?: number, g?: number, b?: number, a?: number, h?: number, s?: number, l?: number, v?: number): any;

        /**
        * A utility to convert an integer in 0xRRGGBBAA format to a color object.
        * This does not rely on endianness.
        *
        * @author Matt DesLauriers (@mattdesl)
        * @method Phaser.Color.fromRGBA
        * @static
        * @param {number} rgba - An RGBA hex
        * @param {object} [out] - The object to use, optional.
        * @return {object} A color object.
        */
        static fromRGBA(rgba: number, out?: any): any;

        /**
        * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255.
        *
        * @method Phaser.Color.getAlpha
        * @static
        * @param {number} color - In the format 0xAARRGGBB.
        * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).
        */
        static getAlpha(color: number): number;

        /**
        * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1.
        *
        * @method Phaser.Color.getAlphaFloat
        * @static
        * @param {number} color - In the format 0xAARRGGBB.
        * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).
        */
        static getAlphaFloat(color: number): number;

        /**
        * Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255.
        *
        * @method Phaser.Color.getBlue
        * @static
        * @param {number} color - In the format 0xAARRGGBB.
        * @returns {number} The Blue component of the color, will be between 0 and 255 (0 being no color, 255 full Blue).
        */
        static getBlue(color: number): number;

        /**
        * Given an alpha and 3 color values this will return an integer representation of it.
        *
        * @method Phaser.Color.getColor32
        * @static
        * @param {number} a - The alpha color component, in the range 0 - 255.
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @returns {number} A native color value integer (format: 0xAARRGGBB).
        */
        static getColor(red: number, green: number, blue: number): number;

        /**
        * Given an alpha and 3 color values this will return an integer representation of it.
        *
        * @method Phaser.Color.getColor32
        * @static
        * @param {number} a - The alpha color component, in the range 0 - 255.
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @returns {number} A native color value integer (format: 0xAARRGGBB).
        */
        static getColor32(alpha: number, red: number, green: number, blue: number): number;

        /**
        * Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255.
        *
        * @method Phaser.Color.getGreen
        * @static
        * @param {number} color - In the format 0xAARRGGBB.
        * @returns {number} The Green component of the color, will be between 0 and 255 (0 being no color, 255 full Green).
        */
        static getGreen(color: number): number;

        /**
        * Returns a random color value between black and white
        * Set the min value to start each channel from the given offset.
        * Set the max value to restrict the maximum color used per channel.
        *
        * @method Phaser.Color.getRandomColor
        * @static
        * @param {number} min - The lowest value to use for the color.
        * @param {number} max - The highest value to use for the color.
        * @param {number} alpha - The alpha value of the returning color (default 255 = fully opaque).
        * @returns {number} 32-bit color value with alpha.
        */
        static getRandomColor(min?: number, max?: number, alpha?: number): number;

        /**
        * Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255.
        *
        * @method Phaser.Color.getRed
        * @static
        * @param {number} color In the format 0xAARRGGBB.
        * @returns {number} The Red component of the color, will be between 0 and 255 (0 being no color, 255 full Red).
        */
        static getRed(color: number): number;

        /**
        * Return the component parts of a color as an Object with the properties alpha, red, green, blue.
        *
        * Alpha will only be set if it exist in the given color (0xAARRGGBB)
        *
        * @method Phaser.Color.getRGB
        * @static
        * @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).
        * @returns {object} An Object with properties: alpha, red, green, blue (also r, g, b and a). Alpha will only be present if a color value > 16777215 was given.
        */
        static getRGB(color: number): any;

        /**
        * Returns a CSS friendly string value from the given color.
        *
        * @method Phaser.Color.getWebRGB
        * @static
        * @param {number|Object} color - Color in RGB (0xRRGGBB), ARGB format (0xAARRGGBB) or an Object with r, g, b, a properties.
        * @returns {string} A string in the format: 'rgba(r,g,b,a)'
        */
        static getWebRGB(color: any): string;

        /**
        * Converts a hex string into an integer color value.
        *
        * @method Phaser.Color.hexToRGB
        * @static
        * @param {string} hex - The hex string to convert. Can be in the short-hand format `#03f` or `#0033ff`.
        * @return {number} The rgb color value in the format 0xAARRGGBB.
        */
        static hexToRGB(h: string): number;

        /**
        * Converts a hex string into a Phaser Color object.
        *
        * The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.    
        *
        * An alpha channel is _not_ supported.
        *
        * @method Phaser.Color.hexToColor
        * @static
        * @param {string} hex - The color string in a hex format.
        * @param {object} [out] - An object into which 3 properties will be created or set: r, g and b. If not provided a new object will be created.
        * @return {object} An object with the red, green and blue values set in the r, g and b properties.
        */
        static hexToColor(hex: string, out?: any): any;

        /**
        * Converts an HSL (hue, saturation and lightness) color value to RGB.
        * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
        * Assumes HSL values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
        * Based on code by Michael Jackson (https://github.com/mjijackson)
        *
        * @method Phaser.Color.HSLtoRGB
        * @static
        * @param {number} h - The hue, in the range 0 - 1.
        * @param {number} s - The saturation, in the range 0 - 1.
        * @param {number} l - The lightness, in the range 0 - 1.
        * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.
        * @return {object} An object with the red, green and blue values set in the r, g and b properties.
        */
        static HSLtoRGB(h: number, s: number, l: number, out?: any): any;

        /**
        * Get HSL color wheel values in an array which will be 360 elements in size.
        *
        * @method Phaser.Color.HSLColorWheel
        * @static
        * @param {number} [s=0.5] - The saturation, in the range 0 - 1.
        * @param {number} [l=0.5] - The lightness, in the range 0 - 1.
        * @return {array} An array containing 360 elements corresponding to the HSL color wheel.
        */
        static HSLColorWheel(s?: number, l?: number): any[];

        /**
        * Converts an HSV (hue, saturation and value) color value to RGB.
        * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
        * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
        * Based on code by Michael Jackson (https://github.com/mjijackson)
        *
        * @method Phaser.Color.HSVtoRGB
        * @static
        * @param {number} h - The hue, in the range 0 - 1.
        * @param {number} s - The saturation, in the range 0 - 1.
        * @param {number} v - The value, in the range 0 - 1.
        * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.
        * @return {object} An object with the red, green and blue values set in the r, g and b properties.
        */
        static HSVtoRGB(h: number, s: number, v: number, out?: any): any;

        /**
        * Get HSV color wheel values in an array which will be 360 elements in size.
        *
        * @method Phaser.Color.HSVColorWheel
        * @static
        * @param {number} [s=1] - The saturation, in the range 0 - 1.
        * @param {number} [v=1] - The value, in the range 0 - 1.
        * @return {array} An array containing 360 elements corresponding to the HSV color wheel.
        */
        static HSVColorWheel(s?: number, v?: number): any[];

        /**
        * Converts a hue to an RGB color.
        * Based on code by Michael Jackson (https://github.com/mjijackson)
        *
        * @method Phaser.Color.hueToColor
        * @static
        * @param {number} p
        * @param {number} q
        * @param {number} t
        * @return {number} The color component value.
        */
        static hueToColor(p: number, q: number, t: number): number;

        /**
        * Interpolates the two given colours based on the supplied step and currentStep properties.
        *
        * @method Phaser.Color.interpolateColor
        * @static
        * @param {number} color1 - The first color value.
        * @param {number} color2 - The second color value.
        * @param {number} steps - The number of steps to run the interpolation over.
        * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.
        * @param {number} alpha - The alpha of the returned color.
        * @returns {number} The interpolated color value.
        */
        static interpolateColor(color1: number, color2: number, steps: number, currentStep: number, alpha: number): number;

        /**
        * Interpolates the two given colours based on the supplied step and currentStep properties.
        *
        * @method Phaser.Color.interpolateColorWithRGB
        * @static
        * @param {number} color - The first color value.
        * @param {number} r - The red color value, between 0 and 0xFF (255).
        * @param {number} g - The green color value, between 0 and 0xFF (255).
        * @param {number} b - The blue color value, between 0 and 0xFF (255).
        * @param {number} steps - The number of steps to run the interpolation over.
        * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.
        * @returns {number} The interpolated color value.
        */
        static interpolateColorWithRGB(color: number, r: number, g: number, b: number, steps: number, currentStep: number): number;

        /**
        * Interpolates the two given colours based on the supplied step and currentStep properties.
        * @method Phaser.Color.interpolateRGB
        * @static
        * @param {number} r1 - The red color value, between 0 and 0xFF (255).
        * @param {number} g1 - The green color value, between 0 and 0xFF (255).
        * @param {number} b1 - The blue color value, between 0 and 0xFF (255).
        * @param {number} r2 - The red color value, between 0 and 0xFF (255).
        * @param {number} g2 - The green color value, between 0 and 0xFF (255).
        * @param {number} b2 - The blue color value, between 0 and 0xFF (255).
        * @param {number} steps - The number of steps to run the interpolation over.
        * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.
        * @returns {number} The interpolated color value.
        */
        static interpolateRGB(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number, steps: number, currentStep: number): number;

        /**
        * Packs the r, g, b, a components into a single integer, for use with Int32Array.
        * If device is little endian then ABGR order is used. Otherwise RGBA order is used.
        *
        * @author Matt DesLauriers (@mattdesl)
        * @method Phaser.Color.packPixel
        * @static
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {number} a - The alpha color component, in the range 0 - 255.
        * @return {number} The packed color as uint32
        */
        static packPixel(r: number, g: number, b: number, a: number): number;

        /**
        * Converts an RGB color value to HSL (hue, saturation and lightness).
        * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
        * Assumes RGB values are contained in the set [0, 255] and returns h, s and l in the set [0, 1].
        * Based on code by Michael Jackson (https://github.com/mjijackson)
        *
        * @method Phaser.Color.RGBtoHSL
        * @static
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {object} [out] - An object into which 3 properties will be created, h, s and l. If not provided a new object will be created.
        * @return {object} An object with the hue, saturation and lightness values set in the h, s and l properties.
        */
        static RGBtoHSL(r: number, g: number, b: number, out?: any): any;

        /**
        * Converts an RGB color value to HSV (hue, saturation and value).
        * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
        * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
        * Based on code by Michael Jackson (https://github.com/mjijackson)
        *
        * @method Phaser.Color.RGBtoHSV
        * @static
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {object} [out] - An object into which 3 properties will be created, h, s and v. If not provided a new object will be created.
        * @return {object} An object with the hue, saturation and value set in the h, s and v properties.
        */
        static RGBtoHSV(r: number, g: number, b: number, out?: any): any;

        /**
        * Converts the given color values into a string.
        * If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.
        *
        * @method Phaser.Color.RGBtoString
        * @static
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {number} [a=255] - The alpha color component, in the range 0 - 255.
        * @param {string} [prefix='#'] - The prefix used in the return string. If '#' it will return `#RRGGBB`, else `0xAARRGGBB`.
        * @return {string} A string containing the color values. If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.
        */
        static RGBtoString(r: number, g: number, b: number, a?: number, prefix?: string): string;

        /**
        * A utility to convert RGBA components to a 32 bit integer in RRGGBBAA format.
        *
        * @author Matt DesLauriers (@mattdesl)
        * @method Phaser.Color.toRGBA
        * @static
        * @param {number} r - The red color component, in the range 0 - 255.
        * @param {number} g - The green color component, in the range 0 - 255.
        * @param {number} b - The blue color component, in the range 0 - 255.
        * @param {number} a - The alpha color component, in the range 0 - 255.
        * @return {number} A RGBA-packed 32 bit integer
        */
        static toRGBA(r: number, g: number, b: number, a: number): number;

        /**
        * Unpacks the r, g, b, a components into the specified color object, or a new
        * object, for use with Int32Array. If little endian, then ABGR order is used when
        * unpacking, otherwise, RGBA order is used. The resulting color object has the
        * `r, g, b, a` properties which are unrelated to endianness.
        *
        * Note that the integer is assumed to be packed in the correct endianness. On little-endian
        * the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA. If you want a
        * endian-independent method, use fromRGBA(rgba) and toRGBA(r, g, b, a).
        *
        * @author Matt DesLauriers (@mattdesl)
        * @method Phaser.Color.unpackPixel
        * @static
        * @param {number} rgba - The integer, packed in endian order by packPixel.
        * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.
        * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?
        * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?
        * @return {object} An object with the red, green and blue values set in the r, g and b properties.
        */
        static unpackPixel(rgba: number, out?: any, hsl?: boolean, hsv?: boolean): any;

        /**
        * Takes a color object and updates the rgba property.
        *
        * @method Phaser.Color.updateColor
        * @static
        * @param {object} out - The color object to update.
        * @returns {number} A native color value integer (format: 0xAARRGGBB).
        */
        static updateColor(out: any): number;

        /**
        * Converts a value - a "hex" string, a "CSS 'web' string", or a number - into red, green, blue, and alpha components.
        *
        * The value can be a string (see `hexToColor` and `webToColor` for the supported formats) or a packed integer (see `getRGB`).
        *
        * An alpha channel is _not_ supported when specifying a hex string.
        *
        * @method Phaser.Color.valueToColor
        * @static
        * @param {string|number} value - The color expressed as a recognized string format or a packed integer.
        * @param {object} [out] - The object to use for the output. If not provided a new object will be created.
        * @return {object} The (`out`) object with the red, green, blue, and alpha values set as the r/g/b/a properties.
        */
        static valueToColor(value: string, out?: any): { r: number; g: number; b: number; a: number; };

        /**
        * Converts a CSS 'web' string into a Phaser Color object.
        *
        * The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
        *
        * @method Phaser.Color.webToColor
        * @static
        * @param {string} web - The color string in CSS 'web' format.
        * @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.
        * @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.
        */
        static webToColor(web: string, out?: any): { r: number; g: number; b: number; a: number; };

    }
    class ComplexPrimitiveShader {

        //where is WebGLContext in TypeScript? "any" is used
        constructor(gl: any);

        gl: any;

        program: any;

        /**
        * @property {array} fragmentSrc - The fragment shader code.
        */
        fragmentSrc: any[];

        vertexSrc: any[];

        destroy(): void;

        init(): void;

    }
    interface CursorKeys {
        up: Phaser.Key;
        down: Phaser.Key;
        left: Phaser.Key;
        right: Phaser.Key;
    }
    class Device {

        /**
        * @property {boolean} LITTLE_ENDIAN - Same value as `littleEndian`.
        * @default
        */
        static LITTLE_ENDIAN: boolean;

        /**
        * @property {boolean} android - Is running on android?
        * @default
        */
        android: boolean;

        /**
        * @property {boolean} arora - Set to true if running in Arora.
        * @default
        */
        arora: boolean;

        /**
        * @property {boolean} audioData - Are Audio tags available?
        * @default
        */
        audioData: boolean;

        cancelFullScreen: string;

        /**
        * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
        */
        canvas: boolean;

        /**
        * @property {boolean} chrome - Set to true if running in Chrome.
        * @default
        */
        chrome: boolean;

        /**
        * @property {boolean} chromeOS - Is running on chromeOS?
        * @default
        */
        chromeOS: boolean;

        /**
        * @property {boolean} cocoonJS - Is the game running under CocoonJS?
        * @default
        */
        cocoonJS: boolean;

        /**
        * @property {boolean} cocoonJSApp - Is this game running with CocoonJS.App?
        * @default
        */
        cocoonJSApp: boolean;

        /**
        * @property {boolean} cordova - Is the game running under Apache Cordova?
        * @default
        */
        cordova: boolean;

        /**
        * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?
        * @default
        */
        crosswalk: boolean;

        /**
        * @property {boolean} css3D - Is css3D available?
        * @default
        */
        css3D: boolean;

        /**
        * @property {boolean} desktop - Is running on a desktop?
        * @default
        */
        desktop: boolean;

        deviceReadyAt: number;

        /**
        * @property {boolean} ejecta - Is the game running under Ejecta?
        * @default
        */
        ejecta: boolean;

        /**
        * @property {boolean} epiphany - Set to true if running in Epiphany.
        * @default
        */
        epiphany: boolean;

        /**
        * @property {boolean} file - Is file available?
        * @default
        */
        file: boolean;

        /**
        * @property {boolean} fileSystem - Is fileSystem available?
        * @default
        */
        fileSystem: boolean;

        /**
        * @property {boolean} firefox - Set to true if running in Firefox.
        * @default
        */
        firefox: boolean;

        fullScreen: boolean;

        fullScreenKeyboard: boolean;

        /**
        * @property {boolean} getUserMedia - Does the device support the getUserMedia API?
        * @default
        */
        getUserMedia: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} ie - Set to true if running in Internet Explorer.
        * @default
        */
        ie: boolean;

        /**
        * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
        * @default
        */
        ieVersion: number;

        /**
        * @property {boolean} iOS - Is running on iOS?
        * @default
        */
        iOS: boolean;

        initialized: boolean;

        /**
        * @property {boolean} iPad - Is running on iPad?
        * @default
        */
        iPad: boolean;

        /**
        * @property {boolean} iPhone - Is running on iPhone?
        * @default
        */
        iPhone: boolean;

        /**
        * @property {boolean} iPhone4 - Is running on iPhone4?
        * @default
        */
        iPhone4: boolean;

        kindle: boolean;

        /**
        * @property {boolean} linux - Is running on linux?
        * @default
        */
        linux: boolean;

        /**
        * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)
        * @default
        */
        littleEndian: boolean;

        /**
        * @property {boolean} localStorage - Is localStorage available?
        * @default
        */
        localStorage: boolean;

        /**
        * Can this device play m4a files?
        * @property {boolean} m4a - True if this device can play m4a files.
        * @default
        */
        m4a: boolean;

        /**
        * @property {boolean} macOS - Is running on macOS?
        * @default
        */
        macOS: boolean;

        /**
        * @property {boolean} midori - Set to true if running in Midori.
        * @default
        */
        midori: boolean;

        /**
        * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.
        * @default
        */
        mobileSafari: boolean;

        /**
        * @property {boolean} mp3 - Can this device play mp3 files?
        * @default
        */
        mp3: boolean;

        /**
        * @property {Phaser.MSPointer} mspointer - The MSPointer Input manager.
        */
        mspointer: boolean;

        /**
        * @property {boolean} node - Is the game running under Node.js?
        * @default
        */
        node: boolean;

        /**
        * @property {boolean} nodeWebkit - Is the game running under Node-Webkit?
        * @default
        */
        nodeWebkit: boolean;

        /**
        * @property {boolean} ogg - Can this device play ogg files?
        * @default
        */
        ogg: boolean;

        onInitialized: Phaser.Signal;

        /**
        * @property {boolean} opera - Set to true if running in Opera.
        * @default
        */
        opera: boolean;

        /**
        * @property {boolean} opus - Can this device play opus files?
        * @default
        */
        opus: boolean;

        /**
        * @property {number} pixelRatio - PixelRatio of the host device?
        * @default
        */
        pixelRatio: number;

        /**
        * @property {Phaser.Signal} pointerLock - This event is dispatched when the browser enters or leaves pointer lock state.
        * @default
        */
        pointerLock: boolean;

        /**
        * @property {boolean} quirksMode - Is the browser running in strict mode (false) or quirks mode? (true)
        * @default
        */
        quirksMode: boolean;

        requestFullScreen: string;

        /**
        * @property {boolean} safari - Set to true if running in Safari.
        * @default
        */
        safari: boolean;

        /**
        * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)
        * @default
        */
        silk: boolean;

        /**
        * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?
        * @default
        */
        support32bit: boolean;

        /**
        * @property {Phaser.Touch} touch - the Touch Input manager.
        */
        touch: boolean;

        /**
        * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)
        * @default
        */
        trident: boolean;

        /**
        * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
        * @default
        */
        tridentVersion: number;

        /**
        * @property {boolean} typedArray - Does the browser support TypedArrays?
        * @default
        */
        typedArray: boolean;

        /**
        * @property {boolean} vibration - Does the device support the Vibration API?
        * @default
        */
        vibration: boolean;

        vita: boolean;

        /**
        * @property {boolean} wav - Can this device play wav files?
        * @default
        */
        wav: boolean;

        /**
        * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView
        * @default
        */
        webApp: boolean;

        /**
        * @property {boolean} webAudio - Is the WebAudio API available?
        * @default
        */
        webAudio: boolean;

        /**
        * @property {boolean} webGL - Is webGL available?
        * @default
        */
        webGL: boolean;

        /**
        * @property {boolean} webm - Can this device play webm files?
        * @default
        */
        webm: boolean;

        /**
        * @property {boolean} windows - Is running on windows?
        * @default
        */
        windows: boolean;

        /**
        * @property {boolean} windowsPhone - Is running on a Windows Phone?
        * @default
        */
        windowsPhone: boolean;

        wheelEvent: string;

        /**
        * @property {boolean} worker - Is worker available?
        * @default
        */
        worker: boolean;

        checkFullScreenSupport(): void;

        _checkAudio(): void;

        _checkBrowser(): void;

        _checkCSS3D(): void;

        _checkDevice(): void;

        _checkFeatures(): void;

        _checkFullScreenSupport(): void;

        _checkInput(): void;

        _checkIsLittleEndian(): void;

        _checkIsUint8ClampedImageData(): boolean;

        _checkOS(): void;

        canPlayAudio(type: string): boolean;

        _initialze(): void;

        isConsoleOpen(): boolean;

        isAndroidStockBrowser(): string;

        _readyCheck(): void;

        whenReady: (callback: Function, context?: any) => void;

    }
    class DOMSprite {

        //constructor
        constructor(game: Phaser.Game, id: string, x: number, y: number, text: string, style: any);

        //members
        /**
        * @property {boolean} alive - A useful boolean to control if the Sprite is alive or dead (in terms of your gameplay, it doesn't effect rendering). Also linked to Sprite.health and Sprite.damage.
        * @default
        */
        alive: boolean;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        group: Phaser.Group;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {boolean} visible - Whether this camera is visible or not.
        * @default
        */
        visible: boolean;

    }
    module Easing {

        var Default: Function;

        var Power0: Function;

        var Power1: Function;

        var power2: Function;

        var power3: Function;

        var power4: Function;

        /**
        * Back easing.
        *
        * @class Phaser.Easing.Back
        */
        class Back {

            /**
            * Back ease-in.
            *
            * @method Phaser.Easing.Back.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Back ease-out.
            *
            * @method Phaser.Easing.Back.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Back ease-in/out.
            *
            * @method Phaser.Easing.Back.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Bounce easing.
        *
        * @class Phaser.Easing.Bounce
        */
        class Bounce {

            /**
            * Bounce ease-in.
            *
            * @method Phaser.Easing.Bounce.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Bounce ease-out.
            *
            * @method Phaser.Easing.Bounce.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Bounce ease-in/out.
            *
            * @method Phaser.Easing.Bounce.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Circular easing.
        *
        * @class Phaser.Easing.Circular
        */
        class Circular {

            /**
            * Circular ease-in.
            *
            * @method Phaser.Easing.Circular.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Circular ease-out.
            *
            * @method Phaser.Easing.Circular.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Circular ease-in/out.
            *
            * @method Phaser.Easing.Circular.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Cubic easing.
        *
        * @class Phaser.Easing.Cubic
        */
        class Cubic {

            /**
            * Cubic ease-in.
            *
            * @method Phaser.Easing.Cubic.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Cubic ease-out.
            *
            * @method Phaser.Easing.Cubic.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Cubic ease-in/out.
            *
            * @method Phaser.Easing.Cubic.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Elastic easing.
        *
        * @class Phaser.Easing.Elastic
        */
        class Elastic {

            /**
            * Elastic ease-in.
            *
            * @method Phaser.Easing.Elastic.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Elastic ease-out.
            *
            * @method Phaser.Easing.Elastic.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Elastic ease-in/out.
            *
            * @method Phaser.Easing.Elastic.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Exponential easing.
        *
        * @class Phaser.Easing.Exponential
        */
        class Exponential {

            /**
            * Exponential ease-in.
            *
            * @method Phaser.Easing.Exponential.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Exponential ease-out.
            *
            * @method Phaser.Easing.Exponential.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Exponential ease-in/out.
            *
            * @method Phaser.Easing.Exponential.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Linear easing.
        *
        * @class Phaser.Easing.Linear
        */
        class Linear {

            /**
            * Linear Easing (no variation).
            *
            * @method Phaser.Easing.Linear.None
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} k.
            */
            static None(k: number): number;

        }
        /**
        * Quadratic easing.
        *
        * @class Phaser.Easing.Quadratic
        */
        class Quadratic {

            /**
            * Ease-in.
            *
            * @method Phaser.Easing.Quadratic.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} k^2.
            */
            static In(k: number): number;

            /**
            * Ease-out.
            *
            * @method Phaser.Easing.Quadratic.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} k* (2-k).
            */
            static Out(k: number): number;

            /**
            * Ease-in/out.
            *
            * @method Phaser.Easing.Quadratic.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Quartic easing.
        *
        * @class Phaser.Easing.Quartic
        */
        class Quartic {

            /**
            * Quartic ease-in.
            *
            * @method Phaser.Easing.Quartic.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Quartic ease-out.
            *
            * @method Phaser.Easing.Quartic.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Quartic ease-in/out.
            *
            * @method Phaser.Easing.Quartic.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Quintic easing.
        *
        * @class Phaser.Easing.Quintic
        */
        class Quintic {

            /**
            * Quintic ease-in.
            *
            * @method Phaser.Easing.Quintic.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Quintic ease-out.
            *
            * @method Phaser.Easing.Quintic.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Quintic ease-in/out.
            *
            * @method Phaser.Easing.Quintic.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
        /**
        * Sinusoidal easing.
        *
        * @class Phaser.Easing.Sinusoidal
        */
        class Sinusoidal {

            /**
            * Sinusoidal ease-in.
            *
            * @method Phaser.Easing.Sinusoidal.In
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static In(k: number): number;

            /**
            * Sinusoidal ease-out.
            *
            * @method Phaser.Easing.Sinusoidal.Out
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static Out(k: number): number;

            /**
            * Sinusoidal ease-in/out.
            *
            * @method Phaser.Easing.Sinusoidal.InOut
            * @param {number} k - The value to be tweened.
            * @static
            * @returns {number} The tweened value.
            */
            static InOut(k: number): number;

        }
    }
    /**
    * Creates a Ellipse object. A curve on a plane surrounding two focal points.
    * 
    * @class Phaser.Ellipse
    * @constructor
    * @param {number} [x=0] - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.
    * @param {number} [y=0] - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.
    * @param {number} [width=0] - The overall width of this ellipse.
    * @param {number} [height=0] - The overall height of this ellipse.
    */
    class Ellipse {

        constructor(x?: number, y?: number, width?: number, height?: number);

        /**
        * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#bottom
        * @property {number} bottom - Gets or sets the bottom of the circle.
        */
        bottom: number;

        /**
        * Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
        * If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0.
        * @name Phaser.Circle#empty
        * @property {boolean} empty - Gets or sets the empty state of the circle.
        */
        empty: boolean;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
        * @name Phaser.Rectangle#left
        * @property {number} left - The x coordinate of the left of the Rectangle.
        */
        left: number;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#top
        * @property {number} top - Gets or sets the top of the circle.
        */
        top: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        static constains(a: Phaser.Ellipse, x: number, y: number): boolean;

        /**
        * Returns a new Ellipse object with the same values for the x, y, width, and height properties as this Ellipse object.
        * @method Phaser.Ellipse#clone
        * @param {Phaser.Ellipse} output - Optional Ellipse object. If given the values will be set into the object, otherwise a brand new Ellipse object will be created and returned.
        * @return {Phaser.Ellipse} The cloned Ellipse object.
        */
        clone(output: Phaser.Ellipse): Phaser.Ellipse;

        /**
        * Return true if the given x/y coordinates are within this Ellipse object.
        * @method Phaser.Ellipse#contains
        * @param {number} x - The X value of the coordinate to test.
        * @param {number} y - The Y value of the coordinate to test.
        * @return {boolean} True if the coordinates are within this ellipse, otherwise false.
        */
        contains(x: number, y: number): boolean;

        /**
        * Copies the x, y, width and height properties from any given object to this Ellipse.
        * @method Phaser.Ellipse#copyFrom
        * @param {any} source - The object to copy from.
        * @return {Phaser.Ellipse} This Ellipse object.
        */
        copyFrom(source: any): Phaser.Ellipse;

        /**
        * Copies the x, y, width and height properties from this Ellipse to any given object.
        * @method Phaser.Ellipse#copyTo
        * @param {any} dest - The object to copy to.
        * @return {object} This dest object.
        */
        copyTo(dest: any): any;

        /**
        * Returns the framing rectangle of the ellipse as a Phaser.Rectangle object.
        * @method Phaser.Ellipse#getBounds
        * @return {Phaser.Rectangle} The bounds of the Circle.
        */
        getBounds(): Phaser.Rectangle;

        /**
        * Sets the members of the Ellipse to the specified values.
        * @method Phaser.Ellipse#setTo
        * @param {number} x - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.
        * @param {number} y - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.
        * @param {number} width - The overall width of this ellipse.
        * @param {number} height - The overall height of this ellipse.
        * @return {Phaser.Ellipse} This Ellipse object.
        */
        setTo(x: number, y: number, width: number, height: number): Phaser.Ellipse;

        /**
        * Returns a string representation of this object.
        * @method Phaser.Ellipse#toString
        * @return {string} A string representation of the instance.
        */
        toString(): string;

    }
    /**
    * The Events component is a collection of events fired by the parent game object.
    *
    * For example to tell when a Sprite has been added to a new group:
    *
    * `sprite.events.onAddedToGroup.add(yourFunction, this);`
    *
    * Where `yourFunction` is the function you want called when this event occurs.
    *
    * The Input-related events will only be dispatched if the Sprite has had `inputEnabled` set to `true`
    * and the Animation-related events only apply to game objects with animations like {@link Phaser.Sprite}.
    *
    * @class Phaser.Events
    * @constructor
    * @param {Phaser.Sprite} sprite - A reference to the game object / Sprite that owns this Events object.
    */
    class Events {

        constructor(sprite: Phaser.Sprite);

        /**
        * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
        */
        parent: Phaser.Sprite;

        /**
        * @property {Phaser.Signal} onAddedToGroup - This signal is dispatched when the parent is added to a new Group.
        */
        onAddedToGroup: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onRemovedFromGroup - This signal is dispatched when the parent is removed from a Group.
        */
        onRemovedFromGroup: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onRemovedFromWorld - This signal is dispatched if this item or any of its parents are removed from the game world.
        */
        onRemovedFromWorld: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onKilled - This signal is dispatched when the parent is killed.
        */
        onKilled: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onRevived - This signal is dispatched when the parent is revived.
        */
        onRevived: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onOutOfBounds - This signal is dispatched when the parent leaves the world bounds (only if Sprite.checkWorldBounds is true).
        */
        onOutOfBounds: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputOver - This signal is dispatched if the parent is inputEnabled and receives an over event from a Pointer.
        */
        onInputOver: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputOut - This signal is dispatched if the parent is inputEnabled and receives an out event from a Pointer.
        */
        onInputOut: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputDown - This signal is dispatched if the parent is inputEnabled and receives a down event from a Pointer.
        */
        onInputDown: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onInputUp - This signal is dispatched if the parent is inputEnabled and receives an up event from a Pointer.
        */
        onInputUp: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onDestroy - This signal is dispatched when the parent is destoyed.
        */
        onDestroy: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onDragStart - This signal is dispatched if the parent is inputEnabled and receives a drag start event from a Pointer.
        */
        onDragStart: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onDragStop - This signal is dispatched if the parent is inputEnabled and receives a drag stop event from a Pointer.
        */
        onDragStop: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onAnimationStart - This signal is dispatched when the parent has an animation that is played.
        */
        onAnimationStart: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onAnimationComplete - This signal is dispatched when the parent has an animation that finishes playing.
        */
        onAnimationComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onAnimationLoop - This signal is dispatched when the parent has an animation that loops playback.
        */
        onAnimationLoop: Phaser.Signal;

        /**
        * Removes all events.
        *
        * @method Phaser.Events#destroy
        */
        destroy(): void;

    }
    /**
    * This is a base Filter class to use for any Phaser filter development.
    *
    * @class Phaser.Filter
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {object} uniforms - Uniform mappings object
    * @param {Array} fragmentSrc - The fragment shader code.
    */
    class Filter extends PIXI.AbstractFilter {

        constructor(game: Phaser.Game, ...args: any[]);

        /**
        * @property {boolean} dirty - Internal PIXI var.
        * @default
        */
        dirty: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {array} fragmentSrc - The fragment shader code.
        */
        fragmentSrc: any[];

        /**
        * @property {number} padding - Internal PIXI var.
        * @default
        */
        padding: number;

        /**
        * @property {Phaser.Point} prevPoint - The previous position of the pointer (we don't update the uniform if the same)
        */
        prevPoint: Phaser.Point;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {object} uniforms - Default uniform mappings. Compatible with ShaderToy and GLSLSandbox.
        */
        uniforms: any;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        apply(frameBuffer: WebGLFramebuffer): void;

        /**
        * Clear down this Filter and null out references
        * @method Phaser.Filter#destroy
        */
        destroy(): void;

        /**
        * Should be over-ridden.
        * @method Phaser.Filter#init
        */
        init(...args: any[]): void;

        /**
        * Set the resolution uniforms on the filter.
        * @method Phaser.Filter#setResolution
        * @param {number} width - The width of the display.
        * @param {number} height - The height of the display.
        */
        setResolution(width: number, height: number): void;

        syncUniforms(): void;

        /**
        * Updates the filter.
        * @method Phaser.Filter#update
        * @param {Phaser.Pointer} [pointer] - A Pointer object to use for the filter. The coordinates are mapped to the mouse uniform.
        */
        update(pointer?: Phaser.Pointer): void;

    }
    module Filter {

        class BinarySerpents extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, march?: number, maxDistance?: number);

            fog: number;

        }
        class BlurX extends Phaser.Filter {

            blur: number;

        }
        class BlurY extends Phaser.Filter {

            blur: number;

        }
        class CausticLight extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, divisor?: number);

            init(width: number, height: number, divisor?: number): void;

        }
        class CheckerWave extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            cameraX: number;

            cameraY: number;

            cameraZ: number;

            init(width: number, height: number): void;

            setColor1(red: number, green: number, blue: number): void;

            setColor2(red: number, green: number, blue: number): void;

        }
        class ColorBars extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            init(width: number, height: number): void;

        }
        class Fire extends Phaser.Filter {

            constructor(width: number, height: number, alpha?: number, shift?: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            shift: number;

            /**
            * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
            */
            speed: number;

            init(width: number, height: number, alpha?: number, shift?: number): void;

        }
        class Gray extends Phaser.Filter {

            gray: number;

        }
        class HueRotate extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, texture: any);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            init(width: number, height: number, texture: any): void;

        }
        class LazerBeam extends Phaser.Filter {

            init(width: number, height: number, divisor?: number): void;

        }
        class LightBeam extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            blue: number;

            green: number;

            red: number;

            thickness: number;

            /**
            * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
            */
            speed: number;

            init(width: number, height: number): void;

        }
        class Marble extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, speed?: number, intensity?: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            intensity: number;

            /**
            * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
            */
            speed: number;

            init(width: number, height: number, speed?: number, intensity?: number): void;

        }
        class Pixelate extends Phaser.Filter {

            size: number;

        }
        class Plasma extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, alpha?: number, size?: number);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            blueShift: number;

            greenShift: number;

            redShift: number;

            size: number;

            init(width: number, height: number, alpha?: number, size?: number): void;

        }
        class SampleFilter extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, divisor?: number);

            init(width: number, height: number, divisor?: number): void;

        }
        class Tunnel extends Phaser.Filter {

            constructor(game: Phaser.Game, width: number, height: number, texture: any);

            /**
            * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
            */
            alpha: number;

            origin: number;

            init(width: number, height: number, texture: any): void;

        }
    }
    /**
    * WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
    * Please try to avoid using in production games with a long time to build.
    * This is also why the documentation is incomplete.
    * 
    * FlexGrid is a a responsive grid manager that works in conjunction with the ScaleManager RESIZE scaling mode and FlexLayers
    * to provide for game object positioning in a responsive manner.
    *
    * @class Phaser.FlexGrid
    * @constructor
    * @param {Phaser.ScaleManager} manager - The ScaleManager.
    * @param {number} width - The width of the game.
    * @param {number} height - The height of the game.
    */
    class FlexGrid {

        constructor(manager: Phaser.ScaleManager, width: number, height: number);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.TweenManager} manager - Reference to the TweenManager responsible for updating this Tween.
        */
        manager: Phaser.ScaleManager;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        boundsCustom: Phaser.Rectangle;

        boundsFluid: Phaser.Rectangle;

        boundsFull: Phaser.Rectangle;

        boundsNone: Phaser.Rectangle;

        customWidth: number;

        customHeight: number;

        customOffsetX: number;

        customOffsetY: number;

        positionCustom: Phaser.Point;

        positionFluid: Phaser.Point;

        positionFull: Phaser.Point;

        positionNone: Phaser.Point;

        scaleCustom: Phaser.Point;

        scaleFluid: Phaser.Point;

        scaleFluidInversed: Phaser.Point;

        scaleFull: Phaser.Point;

        scaleNone: Phaser.Point;

        ratioH: number;

        ratioV: number;

        multiplier: number;

        /**
        * A custom layer is centered on the game and maintains its aspect ratio as it scales up and down.
        *
        * @method Phaser.FlexGrid#createCustomLayer
        * @param {number} width - Width of this layer in pixels.
        * @param {number} height - Height of this layer in pixels.
        * @param {PIXI.DisplayObject[]} [children] - An array of children that are used to populate the FlexLayer.
        * @return {Phaser.FlexLayer} The Layer object.
        */
        createCustomLayer(width: number, height: number, children?: PIXI.DisplayObject[], addToWorld?: boolean): Phaser.FlexLayer;

        /**
        * A fluid layer is centered on the game and maintains its aspect ratio as it scales up and down.
        *
        * @method Phaser.FlexGrid#createFluidLayer
        * @param {array} [children] - An array of children that are used to populate the FlexLayer.
        * @return {Phaser.FlexLayer} The Layer object.
        */
        createFluidLayer(children: PIXI.DisplayObject[]): Phaser.FlexLayer;

        /**
        * A full layer is placed at 0,0 and extends to the full size of the game. Children are scaled according to the fluid ratios.
        *
        * @method Phaser.FlexGrid#createFullLayer
        * @param {array} [children] - An array of children that are used to populate the FlexLayer.
        * @return {Phaser.FlexLayer} The Layer object.
        */
        createFullLayer(children: PIXI.DisplayObject[]): Phaser.FlexLayer;

        /**
        * A fixed layer is centered on the game and is the size of the required dimensions and is never scaled.
        *
        * @method Phaser.FlexGrid#createFixedLayer
        * @param {PIXI.DisplayObject[]} [children] - An array of children that are used to populate the FlexLayer.
        * @return {Phaser.FlexLayer} The Layer object.
        */
        createFixedLayer(children: PIXI.DisplayObject[]): Phaser.FlexLayer;

        /**
        * Call in the render function to output the bounds rects.
        *
        * @method Phaser.FlexGrid#debug
        */
        debug(): void;

        /**
        * Called when the game container changes dimensions.
        *
        * @method Phaser.FlexGrid#onResize
        * @param {number} width - The new width of the game container.
        * @param {number} height - The new height of the game container.
        */
        onResize(width: number, height: number): void;

        /**
        * Updates all internal vars such as the bounds and scale values.
        *
        * @method Phaser.FlexGrid#refresh
        */
        refresh(): void;

        /**
        * Resets the layer children references
        *
        * @method Phaser.FlexGrid#reset
        */
        reset(): void;

        /**
        * Sets the core game size. This resets the w/h parameters and bounds.
        *
        * @method Phaser.FlexGrid#setSize
        * @param {number} width - The new dimensions.
        * @param {number} height - The new dimensions.
        */
        setSize(width: number, height: number): void;

    }
    /**
    * WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
    * Please try to avoid using in production games with a long time to build.
    * This is also why the documentation is incomplete.
    * 
    * A responsive grid layer.
    *
    * @class Phaser.FlexLayer
    * @extends Phaser.Group
    * @constructor
    * @param {Phaser.FlexGrid} manager - The FlexGrid that owns this FlexLayer.
    * @param {Phaser.Point} position - A reference to the Point object used for positioning.
    * @param {Phaser.Rectangle} bounds - A reference to the Rectangle used for the layer bounds.
    * @param {Phaser.Point} scale - A reference to the Point object used for layer scaling.
    */
    class FlexLayer extends Phaser.Group {

        constructor(manager: Phaser.ScaleManager, position: Phaser.Point, bounds: Phaser.Rectangle, scale: Phaser.Point);

        /**
        * @property {Phaser.FlexGrid} grid - A reference to the FlexGrid that owns this layer.
        */
        grid: Phaser.FlexGrid;

        /**
        * @property {Phaser.TweenManager} manager - Reference to the TweenManager responsible for updating this Tween.
        */
        manager: Phaser.ScaleManager;

        bottomLeft: Phaser.Point;

        bottomMiddle: Phaser.Point;

        /**
        * The location of the Rectangles bottom right corner as a Point object.
        * @name Phaser.Rectangle#bottom
        * @property {Phaser.Point} bottomRight - Gets or sets the location of the Rectangles bottom right corner as a Point object.
        */
        bottomRight: Phaser.Point;

        /**
        * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
        * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
        * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
        * 
        * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
        */
        bounds: Phaser.Rectangle;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * The location of the Rectangles top left corner as a Point object.
        * @name Phaser.Rectangle#topLeft
        * @property {Phaser.Point} topLeft - The location of the Rectangles top left corner as a Point object.
        */
        topLeft: Phaser.Point;

        topMiddle: Phaser.Point;

        /**
        * The location of the Rectangles top right corner as a Point object.
        * @name Phaser.Rectangle#topRight
        * @property {Phaser.Point} topRight - The location of the Rectangles top left corner as a Point object.
        */
        topRight: Phaser.Point;

        /**
        * Debug.
        *
        * @method Phaser.FlexLayer#debug
        */
        debug(): void;

        /**
        * Resize.
        *
        * @method Phaser.FlexLayer#resize
        */
        resize(): void;

    }
    /**
    * A Frame is a single frame of an animation and is part of a FrameData collection.
    *
    * @class Phaser.Frame
    * @constructor
    * @param {number} index - The index of this Frame within the FrameData set it is being added to.
    * @param {number} x - X position of the frame within the texture image.
    * @param {number} y - Y position of the frame within the texture image.
    * @param {number} width - Width of the frame within the texture image.
    * @param {number} height - Height of the frame within the texture image.
    * @param {string} name - The name of the frame. In Texture Atlas data this is usually set to the filename.
    * @param {string} uuid - Internal UUID key.
    */
    class Frame {

        constructor(index: number, x: number, y: number, width: number, height: number, name: string, uuid: string);

        /**
        * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#bottom
        * @property {number} bottom - Gets or sets the bottom of the circle.
        */
        bottom: number;

        /**
        * The x coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerX
        * @property {number} centerX - The x coordinate of the center of the Rectangle.
        */
        centerX: number;

        /**
        * The y coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerY
        * @property {number} centerY - The y coordinate of the center of the Rectangle.
        */
        centerY: number;

        /**
        * @property {number} distance - The distance from the top left to the bottom-right of this Frame.
        */
        distance: number;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {number} index - The gamepad index as per browsers data
        * @readonly
        */
        index: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * @property {boolean} rotated - Rotated? (not yet implemented)
        * @default
        */
        rotated: boolean;

        /**
        * @property {string} rotationDirection - Either 'cw' or 'ccw', rotation is always 90 degrees.
        * @default 'cw'
        */
        rotationDirection: string;

        /**
        * @property {number} sourceSizeH - Height of the original sprite.
        */
        sourceSizeH: number;

        /**
        * @property {number} sourceSizeW - Width of the original sprite.
        */
        sourceSizeW: number;

        /**
        * @property {number} spriteSourceSizeH - Height of the trimmed sprite.
        * @default
        */
        spriteSourceSizeH: number;

        /**
        * @property {number} spriteSourceSizeW - Width of the trimmed sprite.
        * @default
        */
        spriteSourceSizeW: number;

        /**
        * @property {number} spriteSourceSizeX - X position of the trimmed sprite inside original sprite.
        * @default
        */
        spriteSourceSizeX: number;

        /**
        * @property {number} spriteSourceSizeY - Y position of the trimmed sprite inside original sprite.
        * @default
        */
        spriteSourceSizeY: number;

        /**
        * @property {boolean} trimmed - Was it trimmed when packed?
        * @default
        */
        trimmed: boolean;

        /**
        * @property {string} uuid - DEPRECATED: A link to the PIXI.TextureCache entry.
        */
        uuid: string;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Clones this Frame into a new Phaser.Frame object and returns it.
        * Note that all properties are cloned, including the name, index and UUID.
        *
        * @method Phaser.Frame#clone
        * @return {Phaser.Frame} An exact copy of this Frame object.
        */
        clone(): Phaser.Frame;

        /**
        * Returns a Rectangle set to the dimensions of this Frame.
        *
        * @method Phaser.Frame#getRect
        * @param {Phaser.Rectangle} [out] - A rectangle to copy the frame dimensions to.
        * @return {Phaser.Rectangle} A rectangle.
        */
        getRect(out?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * If the frame was trimmed when added to the Texture Atlas this records the trim and source data.
        *
        * @method Phaser.Frame#setTrim
        * @param {boolean} trimmed - If this frame was trimmed or not.
        * @param {number} actualWidth - The width of the frame before being trimmed.
        * @param {number} actualHeight - The height of the frame before being trimmed.
        * @param {number} destX - The destination X position of the trimmed frame for display.
        * @param {number} destY - The destination Y position of the trimmed frame for display.
        * @param {number} destWidth - The destination width of the trimmed frame for display.
        * @param {number} destHeight - The destination height of the trimmed frame for display.
        */
        setTrim(trimmed: boolean, actualWidth: number, actualHeight: number, destX: number, destY: number, destWidth: number, destHeight: number): void;

    }
    /**
    * FrameData is a container for Frame objects, which are the internal representation of animation data in Phaser.
    *
    * @class Phaser.FrameData
    * @constructor
    */
    class FrameData {

        /**
        * @name Phaser.FrameData#total
        * @property {number} total - The total number of frames in this FrameData set.
        * @readonly
        */
        total: number;

        /**
        * Adds a new Frame to this FrameData collection. Typically called by the Animation.Parser and not directly.
        *
        * @method Phaser.FrameData#addFrame
        * @param {Phaser.Frame} frame - The frame to add to this FrameData set.
        * @return {Phaser.Frame} The frame that was just added.
        */
        addFrame(frame: Frame): Phaser.Frame;

        /**
        * Check if there is a Frame with the given name.
        *
        * @method Phaser.FrameData#checkFrameName
        * @param {string} name - The name of the frame you want to check.
        * @return {boolean} True if the frame is found, otherwise false.
        */
        checkFrameName(name: string): boolean;

        /**
        * Makes a copy of this FrameData including copies (not references) to all of the Frames it contains.
        *
        * @method Phaser.FrameData#clone
        * @return {Phaser.FrameData} A clone of this object, including clones of the Frame objects it contains.
        */
        clone(): Phaser.FrameData;

        /**
        * Get a Frame by its numerical index.
        *
        * @method Phaser.FrameData#getFrame
        * @param {number} index - The index of the frame you want to get.
        * @return {Phaser.Frame} The frame, if found.
        */
        getFrame(index: number): Phaser.Frame;

        /**
        * Get a Frame by its frame name.
        *
        * @method Phaser.FrameData#getFrameByName
        * @param {string} name - The name of the frame you want to get.
        * @return {Phaser.Frame} The frame, if found.
        */
        getFrameByName(name: string): Phaser.Frame;

        /**
        * Returns all of the Frame indexes in this FrameData set.
        * The frames indexes are returned in the output array, or if none is provided in a new Array object.
        *
        * @method Phaser.FrameData#getFrameIndexes
        * @param {Array} frames - An Array containing the indexes of the frames to retrieve. If the array is empty then all frames in the FrameData are returned.
        * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)
        * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.
        * @return {Array} An array of all Frame indexes matching the given names or IDs.
        */
        getFrameIndexes(frames: number[], useNumericIndex?: boolean, output?: number[]): number[];

        /**
        * Returns a range of frames based on the given start and end frame indexes and returns them in an Array.
        *
        * @method Phaser.FrameData#getFrameRange
        * @param {number} start - The starting frame index.
        * @param {number} end - The ending frame index.
        * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.
        * @return {Array} An array of Frames between the start and end index values, or an empty array if none were found.
        */
        getFrameRange(start: number, end: number, output: Phaser.Frame[]): Phaser.Frame[];

        /**
        * Returns all of the Frames in this FrameData set where the frame index is found in the input array.
        * The frames are returned in the output array, or if none is provided in a new Array object.
        *
        * @method Phaser.FrameData#getFrames
        * @param {Array} frames - An Array containing the indexes of the frames to retrieve. If the array is empty then all frames in the FrameData are returned.
        * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)
        * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.
        * @return {Array} An array of all Frames in this FrameData set matching the given names or IDs.
        */
        getFrames(frames: number[], useNumericIndex?: boolean, output?: Phaser.Frame[]): Phaser.Frame[];

    }
    interface IGameConfig {
        enableDebug?: boolean;
        width?: number;
        height?: number;
        renderer?: number;
        parent?: any;
        transparent?: boolean;
        antialias?: boolean;
        preserveDrawingBuffer?: boolean;
        physicsConfig?: any;
        seed?: string;
        state?: Phaser.State;
    }
    /**
    * This is where the magic happens. The Game object is the heart of your game,
    * providing quick access to common functions and handling the boot process.
    * 
    * "Hell, there are no rules here - we're trying to accomplish something."
    *                                                       Thomas A. Edison
    *
    * @class Phaser.Game
    * @constructor
    * @param {number|string} [width=800] - The width of your game in game pixels. If given as a string the value must be between 0 and 100 and will be used as the percentage width of the parent container, or the browser window if no parent is given.
    * @param {number|string} [height=600] - The height of your game in game pixels. If given as a string the value must be between 0 and 100 and will be used as the percentage height of the parent container, or the browser window if no parent is given.
    * @param {number} [renderer=Phaser.AUTO] - Which renderer to use: Phaser.AUTO will auto-detect, Phaser.WEBGL, Phaser.CANVAS or Phaser.HEADLESS (no rendering at all).
    * @param {string|HTMLElement} [parent=''] - The DOM element into which this games canvas will be injected. Either a DOM ID (string) or the element itself.
    * @param {object} [state=null] - The default state object. A object consisting of Phaser.State functions (preload, create, update, render) or null.
    * @param {boolean} [transparent=false] - Use a transparent canvas background or not.
    * @param {boolean} [antialias=true] - Draw all image textures anti-aliased or not. The default is for smooth textures, but disable if your game features pixel art.
    * @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.
    */
    class Game {

        constructor(width?: number, height?: number, renderer?: number, parent?: any, state?: any, transparent?: boolean, antialias?: boolean, physicsConfig?: any);

        constructor(config: IGameConfig);

        /**
        * @property {Phaser.GameObjectFactory} add - A reference to the GameObjectFactory which can be used to add new objects to the World.
        */
        add: Phaser.GameObjectFactory;

        /**
        * @property {boolean} antialias - Anti-alias graphics. By default scaled images are smoothed in Canvas and WebGL, set anti-alias to false to disable this globally.
        * @default
        */
        antialias: boolean;

        /**
        * @property {Phaser.Cache} cache - A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.
        */
        cache: Phaser.Cache;

        /**
        * @property {Phaser.Camera} camera - A handy reference to World.camera.
        */
        camera: Phaser.Camera;

        /**
        * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
        */
        canvas: HTMLCanvasElement;

        /**
        * @property {object} config - The Phaser.Game configuration object.
        */
        config: IGameConfig;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: any;

        count: number;

        /**
        * @property {Phaser.Utils.Debug} debug - A set of useful debug utilitie.
        */
        debug: Phaser.Utils.Debug;

        /**
        * @property {Phaser.Device} device - Contains device information and capabilities.
        */
        device: Phaser.Device;

        /**
        * @property {boolean} forceSingleUpdate - Should the game loop force a logic update, regardless of the delta timer? Set to true if you know you need this. You can toggle it on the fly.
        */
        forceSingleUpdate: boolean;

        fpsProblemNotifier: Phaser.Signal;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {number} id - Reserved for future multiple camera set-ups.
        * @default
        */
        id: number;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.Input;

        /**
        * @property {boolean} isBooted - Whether the game engine is booted, aka available.
        * @readonly
        */
        isBooted: boolean;

        /**
        * @property {boolean} isRunning - Is game running or paused?
        * @readonly
        */
        isRunning: boolean;

        /**
        * @property {Phaser.Loader} load - A reference to the Loader, which you mostly use in the preload method of your state to load external assets.
        */
        load: Phaser.Loader;

        lockRender: boolean;

        /**
        * @property {Phaser.GameObjectCreator} make - A reference to the GameObjectCreator which can be used to make new objects.
        */
        make: Phaser.GameObjectCreator;

        /**
        * @property {Phaser.Math} math - A reference to Math class with lots of helpful functions.
        */
        math: Phaser.Math;

        /**
        * @property {Phaser.Net} net - Reference to the network class.
        */
        net: Phaser.Net;

        /**
        * @property {Phaser.Signal} onBlur - This event is fired when the game no longer has focus (typically on page hide).
        */
        onBlur: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onFocus - This event is fired when the game has focus (typically on page show).
        */
        onFocus: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onPause - This event is fired when the game pauses.
        */
        onPause: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onResume - This event is fired when the game resumes from a paused state.
        */
        onResume: Phaser.Signal;

        /**
        * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
        */
        parent: HTMLElement;

        /**
        * @property {Phaser.Particles} particles - The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.
        */
        particles: Phaser.Particles;

        /**
        * The paused state of the Game. A paused game doesn't update any of its subsystems.
        * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
        * @name Phaser.Game#paused
        * @property {boolean} paused - Gets and sets the paused state of the Game.
        */
        paused: boolean;

        /**
        * @property {boolean} pendingStep - An internal property used by enableStep, but also useful to query from your own game objects.
        * @default
        * @readonly
        */
        pendingStep: boolean;

        /**
        * @property {Phaser.Physics} physics - A reference to the physics manager which looks after the different physics systems available within Phaser.
        */
        physics: Phaser.Physics;

        /**
        * @property {object} physicsConfig - The Phaser.Physics.World configuration object.
        */
        physicsConfig: any;

        /**
        * @property {boolean} preserveDrawingBuffer - The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
        * @default
        */
        preserveDrawingBuffer: Boolean;

        /**
        * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout
        * @protected
        */
        raf: Phaser.RequestAnimationFrame;

        /**
        * @property {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The Pixi Renderer.
        * @protected
        */
        renderer: number;

        /**
        * @property {number} renderType - The Renderer this game will use. Either Phaser.AUTO, Phaser.CANVAS or Phaser.WEBGL.
        * @readonly
        */
        renderType: number;

        /**
        * @property {Phaser.RandomDataGenerator} rnd - A reference to the seeded and repeatable random data generator.
        */
        rnd: Phaser.RandomDataGenerator;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.ScaleManager;

        scratch: Phaser.BitmapData;

        /**
        * @property {Phaser.SoundManager} sound - A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.
        */
        sound: Phaser.SoundManager;

        /**
        * @property {Phaser.Stage} stage - A reference to the Stage.
        */
        stage: Phaser.Stage;

        /**
        * @property {Phaser.StateManager} state - The StateManager.
        */
        state: Phaser.StateManager;

        /**
        * @property {number} stepCount - When stepping is enabled this contains the current step cycle.
        * @default
        * @readonly
        */
        stepCount: number;

        /**
        * @property {boolean} stepping - Enable core loop stepping with Game.enableStep().
        * @default
        * @readonly
        */
        stepping: boolean;

        /**
        * @property {Phaser.Time} time - A reference to the game clock and timed events system.
        */
        time: Phaser.Time;

        /**
        * @property {boolean} transparent - Use a transparent canvas background or not.
        * @default
        */
        transparent: boolean;

        /**
        * @property {Phaser.TweenManager} tweens - A reference to the tween manager.
        */
        tweens: Phaser.TweenManager;

        currentUpdateID: number;

        updatesThisFrame: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.World;

        /**
        * Initialize engine sub modules and start the game.
        *
        * @method Phaser.Game#boot
        * @protected
        */
        boot(): void;

        /**
        * Nukes the entire game from orbit.
        *
        * @method Phaser.Game#destroy
        */
        destroy(): void;

        /**
        * Disables core game loop stepping.
        *
        * @method Phaser.Game#disableStep
        */
        disableStep(): void;

        /**
        * Enable core game loop stepping. When enabled you must call game.step() directly (perhaps via a DOM button?)
        * Calling step will advance the game loop by one frame. This is extremely useful for hard to track down errors!
        *
        * @method Phaser.Game#enableStep
        */
        enableStep(): void;

        /**
        * Called by the Stage visibility handler.
        *
        * @method Phaser.Game#focusGain
        * @param {object} event - The DOM event that caused the game to pause, if any.
        * @protected
        */
        focusGain(event: any): void;

        /**
        * Called by the Stage visibility handler.
        *
        * @method Phaser.Game#focusLoss
        * @param {object} event - The DOM event that caused the game to pause, if any.
        * @protected
        */
        focusLoss(event: any): void;

        /**
        * Called by the Stage visibility handler.
        *
        * @method Phaser.Game#gamePaused
        * @param {object} event - The DOM event that caused the game to pause, if any.
        * @protected
        */
        gamePaused(event: any): void;

        /**
        * Called by the Stage visibility handler.
        *
        * @method Phaser.Game#gameResumed
        * @param {object} event - The DOM event that caused the game to pause, if any.
        * @protected
        */
        gameResumed(event: any): void;

        /**
        * Parses a Game configuration object.
        *
        * @method Phaser.Game#parseConfig
        * @protected
        */
        parseConfig(config: any): void;

        removeFromDOM(canvas: HTMLCanvasElement): void;

        /**
        * Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
        *
        * @method Phaser.Game#setUpRenderer
        * @protected
        */
        setUpRenderer(): void;

        /**
        * Displays a Phaser version debug header in the console.
        *
        * @method Phaser.Game#showDebugHeader
        * @protected
        */
        showDebugHeader(): void;

        /**
        * When stepping is enabled you must call this function directly (perhaps via a DOM button?) to advance the game loop by one frame.
        * This is extremely useful to hard to track down errors! Use the internal stepCount property to monitor progress.
        *
        * @method Phaser.Game#step
        */
        step(): void;

        /**
        * The core game loop.
        *
        * @method Phaser.Game#update
        * @protected
        * @param {number} time - The current time as provided by RequestAnimationFrame.
        */
        update(time: number): void;

        /**
        * Updates all logic subsystems in Phaser. Called automatically by Game.update.
        *
        * @method Phaser.Game#updateLogic
        * @protected
        * @param {number} timeStep - The current timeStep value as determined by Game.update.
        */
        updateLogic(timeStep: number): void;

        /**
        * Runs the Render cycle.
        * It starts by calling State.preRender. In here you can do any last minute adjustments of display objects as required.
        * It then calls the renderer, which renders the entire display list, starting from the Stage object and working down.
        * It then calls plugin.render on any loaded plugins, in the order in which they were enabled.
        * After this State.render is called. Any rendering that happens here will take place on-top of the display list.
        * Finally plugin.postRender is called on any loaded plugins, in the order in which they were enabled.
        * This method is called automatically by Game.update, you don't need to call it directly.
        * Should you wish to have fine-grained control over when Phaser renders then use the `Game.lockRender` boolean.
        * Phaser will only render when this boolean is `false`.
        *
        * @method Phaser.Game#updateRender
        * @protected
        * @param {number} elapsedTime - The time elapsed since the last update.
        */
        updateRender(timeStep: number): void;

    }
    /**
    * The GameObjectCreator is a quick way to create common game objects _without_ adding them to the game world.
    * The object creator can be accessed with {@linkcode Phaser.Game#make `game.make`}.
    *
    * @class Phaser.GameObjectCreator
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class GameObjectCreator {

        constructor(game: Phaser.Game);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.World;

        /**
        * Creates a new Sound object.
        *
        * @method Phaser.GameObjectCreator#audio
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @param {number} [volume=1] - The volume at which the sound will be played.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.
        * @return {Phaser.Sound} The newly created text object.
        */
        audio(key: string, volume?: number, loop?: boolean, connect?: boolean): Phaser.Sound;

        /**
        * Creates a new AudioSprite object.
        *
        * @method Phaser.GameObjectCreator#audioSprite
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @return {Phaser.AudioSprite} The newly created AudioSprite object.
        */
        audioSprite(key: string): Phaser.AudioSprite;

        /**
        * Create a BitmpaData object.
        *
        * A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.
        *
        * @method Phaser.GameObjectCreator#bitmapData
        * @param {number} [width=256] - The width of the BitmapData in pixels.
        * @param {number} [height=256] - The height of the BitmapData in pixels.
        * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).
        * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)
        * @return {Phaser.BitmapData} The newly created BitmapData object.
        */
        bitmapData(width?: number, height?: number, key?: string, addToCache?: boolean): Phaser.BitmapData;

        /**
        * Create a new BitmapText object.
        *
        * @method Phaser.GameObjectCreator#bitmapText
        * @param {number} x - X position of the new bitmapText object.
        * @param {number} y - Y position of the new bitmapText object.
        * @param {string} font - The key of the BitmapText font as stored in Game.Cache.
        * @param {string} [text] - The actual text that will be rendered. Can be set later via BitmapText.text.
        * @param {number} [size] - The size the font will be rendered in, in pixels.
        * @return {Phaser.BitmapText} The newly created bitmapText object.
        */
        bitmapText(x: number, y: number, font: string, text?: string, size?: number): Phaser.BitmapText;

        /**
        * Creates a new Button object.
        *
        * @method Phaser.GameObjectCreator#button
        * @param {number} [x] X position of the new button object.
        * @param {number} [y] Y position of the new button object.
        * @param {string} [key] The image key as defined in the Game.Cache to use as the texture for this button.
        * @param {function} [callback] The function to call when this button is pressed
        * @param {object} [callbackContext] The context in which the callback will be called (usually 'this')
        * @param {string|number} [overFrame] This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [outFrame] This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [downFrame] This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [upFrame] This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.
        * @return {Phaser.Button} The newly created button object.
        */
        button(x?: number, y?: number, key?: string, callback?: Function, callbackContext?: any, overFrame?: any, outFrame?: any, downFrame?: any, upFrame?: any): Phaser.Button;

        /**
        * Creat a new Emitter.
        *
        * An Emitter is a lightweight particle emitter. It can be used for one-time explosions or for
        * continuous effects like rain and fire. All it really does is launch Particle objects out
        * at set intervals, and fixes their positions and velocities accorindgly.
        *
        * @method Phaser.GameObjectCreator#emitter
        * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.
        * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.
        * @param {number} [maxParticles=50] - The total number of particles in this emitter.
        * @return {Phaser.Emitter} The newly created emitter object.
        */
        emitter(x?: number, y?: number, maxParticles?: number): Phaser.Particles.Arcade.Emitter;

        /**
        * A WebGL shader/filter that can be applied to Sprites.
        *
        * @method Phaser.GameObjectCreator#filter
        * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.
        * @param {any} - Whatever parameters are needed to be passed to the filter init function.
        * @return {Phaser.Filter} The newly created Phaser.Filter object.
        */
        filter(filter: any, ...args: any[]): Phaser.Filter;

        /**
        * Creates a new Graphics object.
        *
        * @method Phaser.GameObjectCreator#graphics
        * @param {number} x - X position of the new graphics object.
        * @param {number} y - Y position of the new graphics object.
        * @return {Phaser.Graphics} The newly created graphics object.
        */
        graphics(x: number, y: number): Phaser.Graphics;

        /**
        * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
        *
        * @method Phaser.GameObjectCreator#group
        * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.
        * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.
        * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.
        * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.
        * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.
        * @return {Phaser.Group} The newly created Group.
        */
        group(parent?: any, name?: string, addToStage?: boolean, enableBody?: boolean, physicsBodyType?: number): Phaser.Group;

        /**
        * Create a new Image object.
        *
        * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
        * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
        *
        * @method Phaser.GameObjectCreator#image
        * @param {number} x - X position of the image.
        * @param {number} y - Y position of the image.
        * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.
        * @returns {Phaser.Image} the newly created sprite object.
        */
        image(x: number, y: number, key: any, frame?: any): Phaser.Image;

        /**
        * A dynamic initially blank canvas to which images can be drawn.
        *
        * @method Phaser.GameObjectCreator#renderTexture
        * @param {number} [width=100] - the width of the RenderTexture.
        * @param {number} [height=100] - the height of the RenderTexture.
        * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).
        * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)
        * @return {Phaser.RenderTexture} The newly created RenderTexture object.
        */
        renderTexture(width?: number, height?: number, key?: any, addToCache?: boolean): Phaser.RenderTexture;

        /**
        * Create a new RetroFont object.
        *
        * A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.
        * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.
        * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText
        * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.
        * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,
        * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.
        *
        * @method Phaser.GameObjectCreator#retroFont
        * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.
        * @param {number} characterWidth - The width of each character in the font set.
        * @param {number} characterHeight - The height of each character in the font set.
        * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
        * @param {number} charsPerRow - The number of characters per row in the font set.
        * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.
        * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.
        * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
        * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
        * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.
        */
        retroFont(font: string, characterWidth: number, characterHeight: number, chars: string, charsPerRow: number, xSpacing?: number, ySpacing?: number, xOffset?: number, yOffset?: number): Phaser.RetroFont;

        /**
        * Creates a new Rope object.
        *
        * @method Phaser.GameObjectCreator#rope
        * @param {number} x - The x coordinate (in world space) to position the Rope at.
        * @param {number} y - The y coordinate (in world space) to position the Rope at.
        * @param {number} width - The width of the Rope.
        * @param {number} height - The height of the Rope.
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} frame - If this Rope is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        * @return {Phaser.Rope} The newly created rope object.
        */
        rope(x: number, y: number, key: any, frame?: any, points?: Phaser.Point[]): Phaser.Rope;

        /**
        * Creates a new Sound object.
        *
        * @method Phaser.GameObjectCreator#sound
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @param {number} [volume=1] - The volume at which the sound will be played.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.
        * @return {Phaser.Sound} The newly created text object.
        */
        sound(key: string, volume?: number, loop?: boolean, connect?: boolean): Phaser.Sound;

        /**
        * Create a new Sprite with specific position and sprite sheet key.
        *
        * @method Phaser.GameObjectCreator#sprite
        * @param {number} x - X position of the new sprite.
        * @param {number} y - Y position of the new sprite.
        * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.
        * @returns {Phaser.Sprite} the newly created sprite object.
        */
        sprite(x: number, y: number, key?: any, frame?: any): Phaser.Sprite;

        /**
        * Create a new SpriteBatch.
        *
        * @method Phaser.GameObjectCreator#spriteBatch
        * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.
        * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.
        * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.
        * @return {Phaser.SpriteBatch} The newly created group.
        */
        spriteBatch(parent: any, name?: String, addToStage?: boolean): Phaser.SpriteBatch;

        /**
        * Creates a new Text object.
        *
        * @method Phaser.GameObjectCreator#text
        * @param {number} x - X position of the new text object.
        * @param {number} y - Y position of the new text object.
        * @param {string} text - The actual text that will be written.
        * @param {object} style - The style object containing style attributes like font, font size , etc.
        * @return {Phaser.Text} The newly created text object.
        */
        text(x: number, y: number, text?: string, style?: any): Phaser.Text;

        tileMap(key: string, tileWidth?: number, tileHeight?: number, width?: number, height?: number): Phaser.Tilemap;

        /**
        * Creates a new TileSprite object.
        *
        * @method Phaser.GameObjectCreator#tileSprite
        * @param {number} x - The x coordinate (in world space) to position the TileSprite at.
        * @param {number} y - The y coordinate (in world space) to position the TileSprite at.
        * @param {number} width - The width of the TileSprite.
        * @param {number} height - The height of the TileSprite.
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        * @return {Phaser.TileSprite} The newly created tileSprite object.
        */
        tileSprite(x: number, y: number, width: number, height: number, key: any, frame: any): Phaser.TileSprite;

        /**
        * Create a tween object for a specific object.
        *
        * The object can be any JavaScript object or Phaser object such as Sprite.
        *
        * @method Phaser.GameObjectCreator#tween
        * @param {object} obj - Object the tween will be run on.
        * @return {Phaser.Tween} The Tween object.
        */
        tween(obj: any): Phaser.Tween;

    }
    /**
    * The GameObjectFactory is a quick way to create mamy common game objects
    * using {@linkcode Phaser.Game#add `game.add`}.
    *
    * Created objects are _automtically added_ to the appropriate Manager, World, or manually specified parent Group.
    *
    * @class Phaser.GameObjectFactory
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class GameObjectFactory {

        constructor(game: Phaser.Game);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.World;

        /**
        * Creates a new Sound object.
        *
        * @method Phaser.GameObjectFactory#audio
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @param {number} [volume=1] - The volume at which the sound will be played.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.
        * @return {Phaser.Sound} The newly created text object.
        */
        audio(key: string, volume?: number, loop?: boolean, connect?: boolean): Phaser.Sound;

        /**
        * Creates a new AudioSprite object.
        *
        * @method Phaser.GameObjectFactory#audioSprite
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @return {Phaser.AudioSprite} The newly created AudioSprite object.
        */
        audioSprite(key: string): Phaser.AudioSprite;

        /**
        * Create a BitmapData object.
        *
        * A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.
        *
        * @method Phaser.GameObjectFactory#bitmapData
        * @param {number} [width=256] - The width of the BitmapData in pixels.
        * @param {number} [height=256] - The height of the BitmapData in pixels.
        * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).
        * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)
        * @return {Phaser.BitmapData} The newly created BitmapData object.
        */
        bitmapData(width?: number, height?: number, key?: string, addToCache?: boolean): Phaser.BitmapData;

        /**
        * Create a new BitmapText object.
        *
        * @method Phaser.GameObjectFactory#bitmapText
        * @param {number} x - X position of the new bitmapText object.
        * @param {number} y - Y position of the new bitmapText object.
        * @param {string} font - The key of the BitmapText font as stored in Game.Cache.
        * @param {string} [text] - The actual text that will be rendered. Can be set later via BitmapText.text.
        * @param {number} [size] - The size the font will be rendered in, in pixels.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.BitmapText} The newly created bitmapText object.
        */
        bitmapText(x: number, y: number, font: string, text?: string, size?: number, group?: Phaser.Group): Phaser.BitmapText;

        /**
        * Creates a new Button object.
        *
        * @method Phaser.GameObjectFactory#button
        * @param {number} [x] - X position of the new button object.
        * @param {number} [y] - Y position of the new button object.
        * @param {string} [key] - The image key as defined in the Game.Cache to use as the texture for this button.
        * @param {function} [callback] - The function to call when this button is pressed
        * @param {object} [callbackContext] - The context in which the callback will be called (usually 'this')
        * @param {string|number} [overFrame] - This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [outFrame] - This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [downFrame] - This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.
        * @param {string|number} [upFrame] - This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.Button} The newly created button object.
        */
        button(x?: number, y?: number, key?: string, callback?: Function, callbackContext?: any, overFrame?: any, outFrame?: any, downFrame?: any, upFrame?: any, group?: Phaser.Group): Phaser.Button;

        /**
        * Create a new Emitter.
        *
        * A particle emitter can be used for one-time explosions or for
        * continuous effects like rain and fire. All it really does is launch Particle objects out
        * at set intervals, and fixes their positions and velocities accorindgly.
        *
        * @method Phaser.GameObjectFactory#emitter
        * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.
        * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.
        * @param {number} [maxParticles=50] - The total number of particles in this emitter.
        * @return {Phaser.Emitter} The newly created emitter object.
        */
        emitter(x?: number, y?: number, maxParticles?: number): Phaser.Particles.Arcade.Emitter;

        /**
        * Adds an existing object to the game world.
        * @method Phaser.GameObjectFactory#existing
        * @param {any} object - An instance of Phaser.Sprite, Phaser.Button or any other display object..
        * @return {any} The child that was added to the Group.
        */
        existing(object: any): any;

        /**
        * A WebGL shader/filter that can be applied to Sprites.
        *
        * @method Phaser.GameObjectFactory#filter
        * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.
        * @param {any} - Whatever parameters are needed to be passed to the filter init function.
        * @return {Phaser.Filter} The newly created Phaser.Filter object.
        */
        filter(filter: string, ...args: any[]): Phaser.Filter;

        /**
        * Creates a new Graphics object.
        *
        * @method Phaser.GameObjectFactory#graphics
        * @param {number} x - X position of the new graphics object.
        * @param {number} y - Y position of the new graphics object.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.Graphics} The newly created graphics object.
        */
        graphics(x: number, y: number, group?: Phaser.Group): Phaser.Graphics;

        /**
        * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
        *
        * @method Phaser.GameObjectFactory#group
        * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.
        * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.
        * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.
        * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.
        * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.
        * @return {Phaser.Group} The newly created group.
        */
        group(parent?: any, name?: string, addToStage?: boolean, enableBody?: boolean, physicsBodyType?: number): Phaser.Group;

        /**
        * Create a new `Image` object. An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
        * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
        *
        * @method Phaser.GameObjectFactory#image
        * @param {number} x - X position of the image.
        * @param {number} y - Y position of the image.
        * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @returns {Phaser.Sprite} the newly created sprite object.
        */
        image(x: number, y: number, key: any, frame?: any, group?: Phaser.Group): Phaser.Image;

        /**
        * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
        * A Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates
        * are automatically given a physics body.
        *
        * @method Phaser.GameObjectFactory#physicsGroup
        * @param {number} [physicsBodyType=Phaser.Physics.ARCADE] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.
        * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.
        * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.
        * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.
        * @return {Phaser.Group} The newly created group.
        */
        physicsGroup(physicsBodyType: number, parent?: any, name?: string, addToStage?: boolean): Phaser.Group;

        /**
        * Add a new Plugin into the PluginManager.
        *
        * The Plugin must have 2 properties: `game` and `parent`. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.
        *
        * @method Phaser.GameObjectFactory#plugin
        * @param {object|Phaser.Plugin} plugin - The Plugin to add into the PluginManager. This can be a function or an existing object.
        * @param {...*} parameter - Additional parameters that will be passed to the Plugin.init method.
        * @return {Phaser.Plugin} The Plugin that was added to the manager.
        */
        plugin(plugin: Phaser.Plugin, ...parameter: any[]): Phaser.Plugin;

        /**
        * A dynamic initially blank canvas to which images can be drawn.
        *
        * @method Phaser.GameObjectFactory#renderTexture
        * @param {number} [width=100] - the width of the RenderTexture.
        * @param {number} [height=100] - the height of the RenderTexture.
        * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).
        * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)
        * @return {Phaser.RenderTexture} The newly created RenderTexture object.
        */
        renderTexture(width?: number, height?: number, key?: string, addToCache?: boolean): Phaser.RenderTexture;

        /**
        * Create a new RetroFont object.
        *
        * A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.
        * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.
        * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText
        * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.
        * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,
        * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.
        *
        * @method Phaser.GameObjectFactory#retroFont
        * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.
        * @param {number} characterWidth - The width of each character in the font set.
        * @param {number} characterHeight - The height of each character in the font set.
        * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
        * @param {number} charsPerRow - The number of characters per row in the font set.
        * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.
        * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.
        * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
        * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
        * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.
        */
        retroFont(font: string, characterWidth: number, characterHeight: number, chars: string, charsPerRow: number, xSpacing?: number, ySpacing?: number, xOffset?: number, yOffset?: number): Phaser.RetroFont;

        /**
        * Creates a new Rope object.
        *
        * @method Phaser.GameObjectFactory#rope
        * @param {number} x - The x coordinate (in world space) to position the TileSprite at.
        * @param {number} y - The y coordinate (in world space) to position the TileSprite at.
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        * @param {Array} points - An array of {Phaser.Point}.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.TileSprite} The newly created tileSprite object.
        * Example usage: https://github.com/codevinsky/phaser-rope-demo/blob/master/dist/demo.js
        */
        rope(x: number, y: number, key: any, frame?: any, points?: Phaser.Point[]): Phaser.Rope;

        /**
        * Creates a new Sound object.
        *
        * @method Phaser.GameObjectFactory#sound
        * @param {string} key - The Game.cache key of the sound that this object will use.
        * @param {number} [volume=1] - The volume at which the sound will be played.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.
        * @return {Phaser.Sound} The newly created text object.
        */
        sound(key: string, volume?: number, loop?: number, connect?: boolean): Phaser.Sound;

        /**
        * Create a new Sprite with specific position and sprite sheet key.
        *
        * @method Phaser.GameObjectFactory#sprite
        * @param {number} x - X position of the new sprite.
        * @param {number} y - Y position of the new sprite.
        * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @returns {Phaser.Sprite} the newly created sprite object.
        */
        sprite(x: number, y: number, key?: any, frame?: any, group?: Phaser.Group): Phaser.Sprite;

        /**
        * A SpriteBatch is a really fast version of a Phaser Group built solely for speed.
        * Use when you need a lot of sprites or particles all sharing the same texture.
        * The speed gains are specifically for WebGL. In Canvas mode you won't see any real difference.
        *
        * @method Phaser.GameObjectFactory#spriteBatch
        * @param {Phaser.Group|null} parent - The parent Group that will hold this Sprite Batch. Set to `undefined` or `null` to add directly to game.world.
        * @param {string} [name='group'] - A name for this Sprite Batch. Not used internally but useful for debugging.
        * @param {boolean} [addToStage=false] - If set to true this Sprite Batch will be added directly to the Game.Stage instead of the parent.
        * @return {Phaser.Group} The newly created group.
        */
        spriteBatch(parent: any, name?: string, addToStage?: boolean): Phaser.Group;

        /**
        * Creates a new Text object.
        *
        * @method Phaser.GameObjectFactory#text
        * @param {number} x - X position of the new text object.
        * @param {number} y - Y position of the new text object.
        * @param {string} text - The actual text that will be written.
        * @param {object} style - The style object containing style attributes like font, font size , etc.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.Text} The newly created text object.
        */
        text(x: number, y: number, text: string, style: any, group?: Phaser.Group): Phaser.Text;

        /**
        * Creates a new Phaser.Tilemap object.
        *
        * The map can either be populated with data from a Tiled JSON file or from a CSV file.
        * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
        * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
        * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
        * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
        *
        * @method Phaser.GameObjectFactory#tilemap
        * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.
        * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
        * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
        * @return {Phaser.Tilemap} The newly created tilemap object.
        */
        tilemap(key?: string, tileWidth?: number, tileHeight?: number, width?: number, height?: number): Phaser.Tilemap;

        /**
        * Creates a new TileSprite object.
        *
        * @method Phaser.GameObjectFactory#tileSprite
        * @param {number} x - The x coordinate (in world space) to position the TileSprite at.
        * @param {number} y - The y coordinate (in world space) to position the TileSprite at.
        * @param {number} width - The width of the TileSprite.
        * @param {number} height - The height of the TileSprite.
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
        * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.TileSprite} The newly created tileSprite object.
        */
        tileSprite(x: number, y: number, width: number, height: number, key?: any, frame?: any, group?: Phaser.Group): Phaser.TileSprite;

        /**
        * Create a tween on a specific object. The object can be any JavaScript object or Phaser object such as Sprite.
        *
        * @method Phaser.GameObjectFactory#tween
        * @param {object} obj - Object the tween will be run on.
        * @return {Phaser.Tween} The newly created Phaser.Tween object.
        */
        tween(obj: any): Phaser.Tween;

    }
    /**
    * The Gamepad class handles gamepad input and dispatches gamepad events.
    *
    * Remember to call `gamepad.start()`.
    *
    * HTML5 GAMEPAD API SUPPORT IS AT AN EXPERIMENTAL STAGE!
    * At moment of writing this (end of 2013) only Chrome supports parts of it out of the box. Firefox supports it
    * via prefs flags (about:config, search gamepad). The browsers map the same controllers differently.
    * This class has constants for Windows 7 Chrome mapping of XBOX 360 controller.
    *
    * @class Phaser.Gamepad
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Gamepad {

        constructor(game: Phaser.Game);

        static BUTTON_0: number;

        static BUTTON_1: number;

        static BUTTON_2: number;

        static BUTTON_3: number;

        static BUTTON_4: number;

        static BUTTON_5: number;

        static BUTTON_6: number;

        static BUTTON_7: number;

        static BUTTON_8: number;

        static BUTTON_9: number;

        static BUTTON_10: number;

        static BUTTON_11: number;

        static BUTTON_12: number;

        static BUTTON_13: number;

        static BUTTON_14: number;

        static BUTTON_15: number;

        static AXIS_0: number;

        static AXIS_1: number;

        static AXIS_2: number;

        static AXIS_3: number;

        static AXIS_4: number;

        static AXIS_5: number;

        static AXIS_6: number;

        static AXIS_7: number;

        static AXIS_8: number;

        static AXIS_9: number;

        static XBOX360_A: number;

        static XBOX360_B: number;

        static XBOX360_X: number;

        static XBOX360_Y: number;

        static XBOX360_LEFT_BUMPER: number;

        static XBOX360_RIGHT_BUMPER: number;

        static XBOX360_LEFT_TRIGGER: number;

        static XBOX360_RIGHT_TRIGGER: number;

        static XBOX360_BACK: number;

        static XBOX360_START: number;

        static XBOX360_STICK_LEFT_BUTTON: number;

        static XBOX360_STICK_RIGHT_BUTTON: number;

        static XBOX360_DPAD_LEFT: number;

        static XBOX360_DPAD_RIGHT: number;

        static XBOX360_DPAD_UP: number;

        static XBOX360_DPAD_DOWN: number;

        static XBOX360_STICK_LEFT_X: number;

        static XBOX360_STICK_LEFT_Y: number;

        static XBOX360_STICK_RIGHT_X: number;

        static XBOX360_STICK_RIGHT_Y: number;

        static PS3XC_X: number;

        static PS3XC_CIRCLE: number;

        static PS3XC_SQUARE: number;

        static PS3XC_TRIANGLE: number;

        static PS3XC_L1: number;

        static PS3XC_R1: number;

        static PS3XC_L2: number;

        static PS3XC_R2: number;

        static PS3XC_SELECT: number;

        static PS3XC_START: number;

        static PS3XC_STICK_LEFT_BUTTON: number;

        static PS3XC_STICK_RIGHT_BUTTON: number;

        static PS3XC_DPAD_UP: number;

        static PS3XC_DPAD_DOWN: number;

        static PS3XC_DPAD_LEFT: number;

        static PS3XC_DPAD_RIGHT: number;

        static PS3XC_STICK_LEFT_X: number;

        static PS3XC_STICK_LEFT_Y: number;

        static PS3XC_STICK_RIGHT_X: number;

        static PS3XC_STICK_RIGHT_Y: number;

        /**
        * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
        * @default
        */
        active: boolean;

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        disabled: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        onAxisCallBack: Function;

        /**
        * @property {function} onConnectCallback - This callback is invoked every time any gamepad is connected
        */
        onConnectCallback: Function;

        /**
        * @property {function} onDisconnectCallback - This callback is invoked every time any gamepad is disconnected
        */
        onDisconnectCallback: Function;

        /**
        * @property {function} onDownCallback - This callback is invoked every time a key is pressed down, including key repeats when a key is held down.
        */
        onDownCallback: Function;

        /**
        * @property {function} onFloatCallback - This callback is invoked every time any gamepad button is changed to a value where value > 0 and value < 1.
        */
        onFloatCallback: Function;

        /**
        * @property {function} onUpCallback - This callback is invoked every time a key is released.
        */
        onUpCallback: Function;

        /**
        * Gamepad #1
        * @name Phaser.Gamepad#pad1
        * @property {Phaser.SinglePad} pad1 - Gamepad #1;
        * @readonly
        */
        pad1: Phaser.SinglePad;

        /**
        * Gamepad #2
        * @name Phaser.Gamepad#pad2
        * @property {Phaser.SinglePad} pad2 - Gamepad #2
        * @readonly
        */
        pad2: Phaser.SinglePad;

        /**
        * Gamepad #3
        * @name Phaser.Gamepad#pad3
        * @property {Phaser.SinglePad} pad3 - Gamepad #3
        * @readonly
        */
        pad3: Phaser.SinglePad;

        /**
        * Gamepad #4
        * @name Phaser.Gamepad#pad4
        * @property {Phaser.SinglePad} pad4 - Gamepad #4
        * @readonly
        */
        pad4: Phaser.SinglePad;

        /**
        * How many live gamepads are currently connected.
        * @name Phaser.Gamepad#padsConnected
        * @property {number} padsConnected - How many live gamepads are currently connected.
        * @readonly
        */
        padsConnected: number;

        /**
        * Whether or not gamepads are supported in current browser.
        * @name Phaser.Gamepad#supported
        * @property {boolean} supported - Whether or not gamepads are supported in current browser.
        * @readonly
        */
        supported: boolean;

        /**
        * Add callbacks to the main Gamepad handler to handle connect/disconnect/button down/button up/axis change/float value buttons.
        * 
        * @method Phaser.Gamepad#addCallbacks
        * @param {object} context - The context under which the callbacks are run.
        * @param {object} callbacks - Object that takes six different callback methods:
        * onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback
        */
        addCallbacks(context: any, callbacks: any): void;

        /**
        * Returns true if the button is currently pressed down, on ANY gamepad.
        * @method Phaser.Gamepad#isDown
        * @param {number} buttonCode - The buttonCode of the button to check for.
        * @return {boolean} True if a button is currently down.
        */
        isDown(buttonCode: number): boolean;

        /**
        * Returns the "just pressed" state of a button from ANY gamepad connected. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
        * @method Phaser.Gamepad#justPressed
        * @param {number} buttonCode - The buttonCode of the button to check for.
        * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.
        * @return {boolean} True if the button is just pressed otherwise false.
        */
        justPressed(buttonCode: number, duration?: number): boolean;

        justReleased(buttonCode: number, duration?: number): boolean;

        /**
        * Reset all buttons/axes of all gamepads
        * @method Phaser.Gamepad#reset
        */
        reset(): void;

        /**
        * Sets the deadZone variable for all four gamepads
        * @method Phaser.Gamepad#setDeadZones
        */
        setDeadZones(value: any): void;

        /**
        * Starts the Gamepad event handling.
        * This MUST be called manually before Phaser will start polling the Gamepad API.
        *
        * @method Phaser.Gamepad#start
        */
        start(): void;

        /**
        * Stops the Gamepad event handling.
        *
        * @method Phaser.Gamepad#stop
        */
        stop(): void;

        /**
        * Main gamepad update loop. Should not be called manually.
        * @method Phaser.Gamepad#update
        * @protected
        */
        update(): void;

    }
    /**
    * If you need more fine-grained control over the handling of specific buttons you can create and use Phaser.GamepadButton objects.
    * 
    * @class Phaser.GamepadButton
    * @constructor
    * @param {Phaser.SinglePad} pad - A reference to the gamepad that owns this button.
    * @param {number} buttonCode - The button code this GamepadButton is responsible for.
    */
    class GamepadButton {

        constructor(pad: Phaser.SinglePad, buttonCode: number);

        /**
        * @property {number} buttonCode - The buttoncode of this button.
        */
        buttonCode: number;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
        * @default
        */
        isDown: boolean;

        /**
        * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
        * @default
        */
        isUp: boolean;

        /**
        * @property {Phaser.Signal} onDown - A Signal that is dispatched each time a pointer is pressed down.
        */
        onDown: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onFloat - This Signal is dispatched every time this GamepadButton changes floating value (between (but not exactly) 0 and 1)
        */
        onFloat: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onUp - A Signal that is dispatched each time a pointer is released.
        */
        onUp: Phaser.Signal;

        /**
        * @property {Phaser.SinglePad} pad - A reference to the gamepad that owns this button.
        */
        pad: Phaser.Gamepad;

        /**
        * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
        * @default
        */
        repeats: number;

        /**
        * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
        */
        timeDown: number;

        /**
        * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
        * @default
        */
        timeUp: number;

        /**
        * @property {number} value - Button value. Mainly useful for checking analog buttons (like shoulder triggers)
        * @default
        */
        value: number;

        /**
        * Destroys this GamepadButton, this disposes of the onDown, onUp and onFloat signals and clears the pad and game references.
        * 
        * @method Phaser.GamepadButton#destroy
        */
        destroy(): void;

        /**
        * Returns the "just pressed" state of this button. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
        * 
        * @method Phaser.GamepadButton#justPressed
        * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.
        * @return {boolean} True if the button is just pressed otherwise false.
        */
        justPressed(duration?: number): boolean;

        justReleased(duration?: number): boolean;

        /**
        * Called automatically by Phaser.SinglePad.
        * 
        * @method Phaser.GamepadButton#processButtonDown
        * @protected
        * @param {number} value - Button value
        */
        processButtonDown(value: number): void;

        /**
        * Called automatically by Phaser.SinglePad.
        * 
        * @method Phaser.GamepadButton#processButtonFloat
        * @protected
        * @param {number} value - Button value
        */
        processButtonFloat(value: number): void;

        /**
        * Called automatically by Phaser.SinglePad.
        * 
        * @method Phaser.GamepadButton#processButtonUp
        * @protected
        * @param {number} value - Button value
        */
        processButtonUp(value: number): void;

        /**
        * Resets this GamepadButton, changing it to an isUp state and resetting the duration and repeats counters.
        * 
        * @method Phaser.GamepadButton#reset
        */
        reset(): void;

    }
    /**
    * Creates a new `Graphics` object.
    *
    * @class Phaser.Graphics
    * @constructor
    * @extends PIXI.Graphics
    * @param {Phaser.Game} game Current game instance.
    * @param {number} x - X position of the new graphics object.
    * @param {number} y - Y position of the new graphics object.
    */
    class Graphics extends PIXI.Graphics {

        constructor(game: Phaser.Game, x: number, y: number);

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        destroy(): void;

        drawTriangle(points: Phaser.Point[], cull?: boolean): void;

        drawTriangles(vertices: any[], indices?: number[], cull?: boolean): void;

        postUpdate(): void;

        preUpdate(): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        *
        * @method Phaser.Graphics#update
        * @memberof Phaser.Graphics
        */
        update(): void;

    }
    /**
    * A Group is a container for {@link DisplayObject display objects} including {@link Phaser.Sprite Sprites} and {@link Phaser.Image Images}.
    *
    * Groups form the logical tree structure of the display/scene graph where local transformations are applied to children.
    * For instance, all children are also moved/rotated/scaled when the group is moved/rotated/scaled.
    *
    * In addition, Groups provides support for fast pooling and object recycling.
    *
    * Groups are also display objects and can be nested as children within other Groups.
    * 
    * @class Phaser.Group
    * @extends PIXI.DisplayObjectContainer
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {DisplayObject|null} [parent=(game world)] - The parent Group (or other {@link DisplayObject}) that this group will be added to.
    *     If undefined/unspecified the Group will be added to the {@link Phaser.Game#world Game World}; if null the Group will not be added to any parent.
    * @param {string} [name='group'] - A name for this group. Not used internally but useful for debugging.
    * @param {boolean} [addToStage=false] - If true this group will be added directly to the Game.Stage instead of Game.World.
    * @param {boolean} [enableBody=false] - If true all Sprites created with {@link #create} or {@link #createMulitple} will have a physics body created on them. Change the body type with {@link #physicsBodyType}.
    * @param {integer} [physicsBodyType=0] - The physics body type to use when physics bodies are automatically added. See {@link #physicsBodyType} for values.
    */
    class Group extends PIXI.DisplayObjectContainer {

        constructor(game: Phaser.Game, parent?: any, name?: string, addToStage?: boolean, enableBody?: boolean, physicsBodyType?: number);

        static RETURN_CHILD: number;

        static RETURN_NONE: number;

        static RETURN_TOTAL: number;

        static SORT_ASCENDING: number;

        static SORT_DESCENDING: number;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {boolean} alive - A useful boolean to control if the Sprite is alive or dead (in terms of your gameplay, it doesn't effect rendering). Also linked to Sprite.health and Sprite.damage.
        * @default
        */
        alive: boolean;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        classType: any;

        cursor: any;

        enableBody: boolean;

        enableBodyDebug: boolean;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        ignoreDestroy: boolean;

        /**
        * @name Phaser.Line#length
        * @property {number} length - Gets the length of the line segment.
        * @readonly
        */
        length: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Signal} onDestroy - This signal is dispatched when the parent is destoyed.
        */
        onDestroy: Phaser.Signal;

        physicsBodyType: number;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * @name Phaser.FrameData#total
        * @property {number} total - The total number of frames in this FrameData set.
        * @readonly
        */
        total: number;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * Adds an existing object as the top child in this group.
        *
        * The child is automatically added to the top of the group and is displayed on top of every previous child.
        *
        * Use {@link #addAt} to control where a child is added. Use {@link #create} to create and add a new child.
        *
        * @method Phaser.Group#add
        * @param {DisplayObject} child - The display object to add as a child.
        * @param {boolean} [silent=false] - If true the child will not dispatch the `onAddedToGroup` event.
        * @return {DisplayObject} The child that was added to the group.
        */
        add(child: any, silent?: boolean): any;

        /**
        * Adds the amount to the given property on all children in this group.
        *
        * `Group.addAll('x', 10)` will add 10 to the child.x value for each child.
        *
        * @method Phaser.Group#addAll
        * @param {string} property - The property to increment, for example 'body.velocity.x' or 'angle'.
        * @param {number} amount - The amount to increment the property by. If child.x = 10 then addAll('x', 40) would make child.x = 50.
        * @param {boolean} checkAlive - If true the property will only be changed if the child is alive.
        * @param {boolean} checkVisible - If true the property will only be changed if the child is visible.
        */
        addAll(property: string, amount: number, checkAlive: boolean, checkVisible: boolean): void;

        /**
        * Adds an existing object to this group.
        *
        * The child is added to the group at the location specified by the index value, this allows you to control child ordering.
        *
        * @method Phaser.Group#addAt
        * @param {DisplayObject} child - The display object to add as a child.
        * @param {integer} [index=0] - The index within the group to insert the child to.
        * @param {boolean} [silent=false] - If true the child will not dispatch the `onAddedToGroup` event.
        * @return {DisplayObject} The child that was added to the group.
        */
        addAt(child: any, index: number, silent?: boolean): any;

        /**
        * Adds an array of existing display objects to this group.
        *
        * The children are automatically added to the top of the group, so render on-top of everything else within the group.
        *
        * TODO: Add ability to pass the children as parameters rather than having to be an array.
        *
        * @method Phaser.Group#addMultiple
        * @param {DisplayObject[]} children - An array of display objects to add as children.
        * @param {boolean} [silent=false] - If true the children will not dispatch the `onAddedToGroup` event.
        * @return {DisplayObject[]} The array of children that were added to the group.
        */
        addMultiple(children: any[], silent?: boolean): any[];

        /**
        * Brings the given child to the top of this group so it renders above all other children.
        *
        * @method Phaser.Group#bringToTop
        * @param {any} child - The child to bring to the top of this group.
        * @return {any} The child that was moved.
        */
        bringToTop(child: any): any;

        /**
        * Calls a function, specified by name, on all children in the group who exist (or do not exist).
        *
        * After the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.
        *
        * @method Phaser.Group#callAllExists
        * @param {string} callback - Name of the function on the children to call.
        * @param {boolean} existsValue - Only children with exists=existsValue will be called.
        * @param {...any} parameter - Additional parameters that will be passed to the callback.
        */
        callAll(method: string, context: any, ...parameters: any[]): void;

        /**
        * Calls a function, specified by name, on all children in the group who exist (or do not exist).
        *
        * After the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.
        *
        * @method Phaser.Group#callAllExists
        * @param {string} callback - Name of the function on the children to call.
        * @param {boolean} existsValue - Only children with exists=existsValue will be called.
        * @param {...any} parameter - Additional parameters that will be passed to the callback.
        */
        callAllExists(callback: Function, existsValue: boolean, ...parameters: any[]): void;

        /**
        * Returns a reference to a function that exists on a child of the group based on the given callback array.
        *
        * @method Phaser.Group#callbackFromArray
        * @param {object} child - The object to inspect.
        * @param {array} callback - The array of function names.
        * @param {integer} length - The size of the array (pre-calculated in callAll).
        * @protected
        */
        callbackFromArray(child: any, callback: Function, length: number): void;

        /**
        * Quickly check that the same property across all children of this group is equal to the given value.
        *
        * This call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.
        *
        * @method Phaser.Group#checkAll
        * @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'
        * @param {any} value - The value that will be checked.
        * @param {boolean} [checkAlive=false] - If set then only children with alive=true will be checked. This includes any Groups that are children.
        * @param {boolean} [checkVisible=false] - If set then only children with visible=true will be checked. This includes any Groups that are children.
        * @param {boolean} [force=false] - If `force` is true then the property will be checked on the child regardless if it already exists or not. If true and the property doesn't exist, false will be returned.
        */
        checkAll(key: string[], value: any, checkAlive?: boolean, checkVisible?: boolean, force?: boolean): boolean;

        /**
        * Checks a property for the given value on the child.
        *
        * @method Phaser.Group#checkProperty
        * @param {any} child - The child to check the property value on.
        * @param {array} key - An array of strings that make up the property that will be set.
        * @param {any} value - The value that will be checked.
        * @param {boolean} [force=false] - If `force` is true then the property will be checked on the child regardless if it already exists or not. If true and the property doesn't exist, false will be returned.
        * @return {boolean} True if the property was was equal to value, false if not.
        */
        checkProperty(child: any, key: string[], value: any, force?: boolean): boolean;

        /**
        * Get the number of dead children in this group.
        *
        * @method Phaser.Group#countDead
        * @return {integer} The number of children flagged as dead.
        */
        countDead(): number;

        /**
        * Get the number of living children in this group.
        *
        * @method Phaser.Group#countLiving
        * @return {integer} The number of children flagged as alive.
        */
        countLiving(): number;

        /**
        * Creates a new Phaser.Sprite object and adds it to the top of this group.
        *
        * Use {@link #classType} to change the type of object creaded.
        *
        * @method Phaser.Group#create
        * @param {number} x - The x coordinate to display the newly created Sprite at. The value is in relation to the group.x point.
        * @param {number} y - The y coordinate to display the newly created Sprite at. The value is in relation to the group.y point.
        * @param {string} key - The Game.cache key of the image that this Sprite will use.
        * @param {integer|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.
        * @param {boolean} [exists=true] - The default exists state of the Sprite.
        * @return {DisplayObject} The child that was created: will be a {@link Phaser.Sprite} unless {@link #classType} has been changed.
        */
        create(x: number, y: number, key: string, frame?: any, exists?: boolean): any;

        /**
        * Creates multiple Phaser.Sprite objects and adds them to the top of this group.
        *
        * Useful if you need to quickly generate a pool of identical sprites, such as bullets.
        *
        * By default the sprites will be set to not exist and will be positioned at 0, 0 (relative to the group.x/y).
        * Use {@link #classType} to change the type of object creaded.
        *
        * @method Phaser.Group#createMultiple
        * @param {integer} quantity - The number of Sprites to create.
        * @param {string} key - The Game.cache key of the image that this Sprite will use.
        * @param {integer|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.
        * @param {boolean} [exists=false] - The default exists state of the Sprite.
        */
        createMultiple(quantity: number, key: string, frame?: any, exists?: boolean): void;

        /**
        * Sort the children in the group according to custom sort function.
        *
        * The `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).
        * It should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.
        *
        * @method Phaser.Group#customSort
        * @param {function} sortHandler - The custom sort function.
        * @param {object} [context=undefined] - The context in which the sortHandler is called.
        */
        customSort(sortHandler: Function, context?: any): void;

        /**
        * Destroys this group.
        *
        * Removes all children, then removes this group from its parent and nulls references.
        *
        * @method Phaser.Group#destroy
        * @param {boolean} [destroyChildren=true] - If true `destroy` will be invoked on each removed child.
        * @param {boolean} [soft=false] - A 'soft destroy' (set to true) doesn't remove this group from its parent or null the game reference. Set to false and it does.
        */
        destroy(destroyChildren?: boolean, soft?: boolean): void;

        /**
        * Divides the given property by the amount on all children in this group.
        *
        * `Group.divideAll('x', 2)` will half the child.x value for each child.
        *
        * @method Phaser.Group#divideAll
        * @param {string} property - The property to divide, for example 'body.velocity.x' or 'angle'.
        * @param {number} amount - The amount to divide the property by. If child.x = 100 then divideAll('x', 2) would make child.x = 50.
        * @param {boolean} checkAlive - If true the property will only be changed if the child is alive.
        * @param {boolean} checkVisible - If true the property will only be changed if the child is visible.
        */
        divideAll(property: string, amount: number, checkAlive?: boolean, checkVisible?: boolean): void;

        /**
        * Call a function on each child in this group.
        *
        * Additional arguments for the callback can be specified after the `checkExists` parameter. For example,
        *
        *     Group.forEach(awardBonusGold, this, true, 100, 500)
        *
        * would invoke thee `awardBonusGolds` with the parameters `(child, 100, 500)`.
        *
        * Note: Currently this will skip any children which are Groups themselves.
        *
        * @method Phaser.Group#forEach
        * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.
        * @param {object} callbackContext - The context in which the function should be called (usually 'this').
        * @param {boolean} [checkExists=false] - If set only children matching for which `exists` is true will be passed to the callback, otherwise all children will be passed.
        * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.
        */
        forEach(callback: Function, callbackContext: any, checkExists?: boolean, ...args: any[]): void;

        /**
        * Call a function on each alive child in this group.
        *
        * See {@link Phaser.Group#forEach forEach} for details.
        *
        * @method Phaser.Group#forEachAlive
        * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.
        * @param {object} callbackContext - The context in which the function should be called (usually 'this').
        * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.
        */
        forEachAlive(callback: Function, callbackContext: any, ...args: any[]): void;

        /**
        * Call a function on each dead child in this group.
        *
        * See {@link Phaser.Group#forEach forEach} for details.
        *
        * @method Phaser.Group#forEachDead
        * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.
        * @param {object} callbackContext - The context in which the function should be called (usually 'this').
        * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.
        */
        forEachDead(callback: Function, callbackContext: any, ...args:any[]): void;

        /**
        * Call a function on each existing child in this group.
        *
        * See {@link Phaser.Group#forEach forEach} for details.
        *
        * @method Phaser.Group#forEachExists
        * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.
        * @param {object} callbackContext - The context in which the function should be called (usually 'this').
        * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.
        */
        forEachExists(callback: Function, callbackContext: any): void;

        /**
        * Find children matching a certain predicate.
        *
        * For example:
        *
        *     var healthyList = Group.filter(function(child, index, children) {
        *         return child.health > 10 ? true : false;
        *     }, true);
        *     healthyList.callAll('attack');
        *
        * Note: Currently this will skip any children which are Groups themselves.
        *
        * @method Phaser.Group#filter
        * @param {function} predicate - The function that each child will be evaluated against. Each child of the group will be passed to it as its first parameter, the index as the second, and the entire child array as the third
        * @param {boolean} [checkExists=false] - If true, only existing can be selected; otherwise all children can be selected and will be passed to the predicate.
        * @return {Phaser.ArraySet} Returns an array list containing all the children that the predicate returned true for
        */
        filter(predicate: Function, checkExists?: boolean): ArraySet;

        /**
        * Returns the child found at the given index within this group.
        *
        * @method Phaser.Group#getAt
        * @param {integer} index - The index to return the child from.
        * @return {DisplayObject} The child that was found at the given index, or -1 for an invalid index.
        */
        getAt(index: number): any;

        /**
        * Returns the child at the bottom of this group.
        *
        * The bottom child the child being displayed (rendered) below every other child.
        *
        * @method Phaser.Group#getBottom
        * @return {any} The child at the bottom of the Group.
        */
        getBottom(): any;

        /**
        * Get the first child that is alive (`child.alive === true`).
        *
        * This is handy for checking if everything has been wiped out, or choosing a squad leader, etc.
        *
        * @method Phaser.Group#getFirstAlive
        * @return {any} The first alive child, or null if none found.
        */
        getFirstAlive(): any;

        /**
        * Get the first child that is dead (`child.alive === false`).
        *
        * This is handy for checking if everything has been wiped out, or choosing a squad leader, etc.
        *
        * @method Phaser.Group#getFirstDead
        * @return {any} The first dead child, or null if none found.
        */
        getFirstDead(): any;

        /**
        * Get the first display object that exists, or doesn't exist.
        *
        * @method Phaser.Group#getFirstExists
        * @param {boolean} [exists=true] - If true, find the first existing child; otherwise find the first non-existing child.
        * @return {any} The first child, or null if none found.
        */
        getFirstExists(exists: boolean): any;

        /**
        * Get the index position of the given child in this group, which should match the child's `z` property.
        *
        * @method Phaser.Group#getIndex
        * @param {any} child - The child to get the index for.
        * @return {integer} The index of the child or -1 if it's not a member of this group.
        */
        getIndex(child: any): number;

        /**
        * Returns a random child from the group.
        *
        * @method Phaser.Group#getRandom
        * @param {integer} [startIndex=0] - Offset from the front of the front of the group (lowest child).
        * @param {integer} [length=(to top)] - Restriction on the number of values you want to randomly select from.
        * @return {any} A random child of this Group.
        */
        getRandom(startIndex?: number, length?: number): any;

        /**
        * Return the child at the top of this group.
        *
        * The top child is the child displayed (rendered) above every other child.
        *
        * @method Phaser.Group#getTop
        * @return {any} The child at the top of the Group.
        */
        getTop(): any;

        /**
        * Checks if the child has the given property.
        *
        * Will scan up to 4 levels deep only.
        *
        * @method Phaser.Group#hasProperty
        * @param {any} child - The child to check for the existance of the property on.
        * @param {string[]} key - An array of strings that make up the property.
        * @return {boolean} True if the child has the property, otherwise false.
        */
        hasProperty(child: any, key: string[]): boolean;

        /**
        * Iterates over the children of the group performing one of several actions for matched children.
        *
        * A child is considered a match when it has a property, named `key`, whose value is equal to `value`
        * according to a strict equality comparison.
        *
        * The result depends on the `returnType`:
        *
        * - {@link Phaser.Group.RETURN_TOTAL RETURN_TOTAL}:
        *     The callback, if any, is applied to all matching children. The number of matched children is returned.
        * - {@link Phaser.Group.RETURN_NONE RETURN_NONE}:
        *     The callback, if any, is applied to all matching children. No value is returned.
        * - {@link Phaser.Group.RETURN_CHILD RETURN_CHILD}:
        *     The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.
        *     If there is no matching child then null is returned.
        *
        * If `args` is specified it must be an array. The matched child will be assigned to the first
        * element and the entire array will be applied to the callback function.
        *
        * @method Phaser.Group#iterate
        * @param {string} key - The child property to check, i.e. 'exists', 'alive', 'health'
        * @param {any} value - A child matches if `child[key] === value` is true.
        * @param {integer} returnType - How to iterate the childen and what to return.
        * @param {function} [callback=null] - Optional function that will be called on each matching child. The matched child is supplied as the first argument.
        * @param {object} [callbackContext] - The context in which the function should be called (usually 'this').
        * @param {any[]} [args=(none)] - The arguments supplied to to the callback; the first array index (argument) will be replaced with the matched child.
        * @return {any} Returns either an integer (for RETURN_TOTAL), the first matched child (for RETURN_CHILD), or null.
        */
        iterate(key: string, value: any, returnType: number, callback?: Function, callbackContext?: any, ...args: any[]): any;

        /**
        * Moves the given child down one place in this group unless it's already at the bottom.
        *
        * @method Phaser.Group#moveDown
        * @param {any} child - The child to move down in the group.
        * @return {any} The child that was moved.
        */
        moveDown(child: any): any;

        /**
        * Moves the given child up one place in this group unless it's already at the top.
        *
        * @method Phaser.Group#moveUp
        * @param {any} child - The child to move up in the group.
        * @return {any} The child that was moved.
        */
        moveUp(child: any): any;

        /**
        * Multiplies the given property by the amount on all children in this group.
        *
        * `Group.multiplyAll('x', 2)` will x2 the child.x value for each child.
        *
        * @method Phaser.Group#multiplyAll
        * @param {string} property - The property to multiply, for example 'body.velocity.x' or 'angle'.
        * @param {number} amount - The amount to multiply the property by. If child.x = 10 then multiplyAll('x', 2) would make child.x = 20.
        * @param {boolean} checkAlive - If true the property will only be changed if the child is alive.
        * @param {boolean} checkVisible - If true the property will only be changed if the child is visible.
        */
        multiplyAll(property: string, amount: number, checkAlive: boolean, checkVisible: boolean): void;

        /**
        * Advances the group cursor to the next (higher) object in the group.
        *
        * If the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).
        *
        * @method Phaser.Group#next
        * @return {any} The child the cursor now points to.
        */
        next(): void;

        /**
        * The core postUpdate - as called by World.
        * @method Phaser.Group#postUpdate
        * @protected
        */
        postUpdate(): void;

        /**
        * The core preUpdate - as called by World.
        * @method Phaser.Group#preUpdate
        * @protected
        */
        preUpdate(): void;

        /**
        * Moves the group cursor to the previous (lower) child in the group.
        *
        * If the cursor is at the start of the group (bottom child) it is moved to the end (top child).
        *
        * @method Phaser.Group#previous
        * @return {any} The child the cursor now points to.
        */
        previous(): void;

        /**
        * Removes the given child from this group.
        *
        * This will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.
        *
        * If the group cursor was referring to the removed child it is updated to refer to the next child.
        *
        * @method Phaser.Group#remove
        * @param {any} child - The child to remove.
        * @param {boolean} [destroy=false] - If true `destroy` will be invoked on the removed child.
        * @param {boolean} [silent=false] - If true the the child will not dispatch the `onRemovedFromGroup` event.
        * @return {boolean} true if the child was removed from this group, otherwise false.
        */
        remove(child: any, destroy?: boolean, silent?: boolean): boolean;

        /**
        * Removes all children from this group, but does not remove the group from its parent.
        *
        * @method Phaser.Group#removeAll
        * @param {boolean} [destroy=false] - If true `destroy` will be invoked on each removed child.
        * @param {boolean} [silent=false] - If true the children will not dispatch their `onRemovedFromGroup` events.
        */
        removeAll(destroy?: boolean, silent?: boolean): void;

        /**
        * Removes all children from this group whose index falls beteen the given startIndex and endIndex values.
        *
        * @method Phaser.Group#removeBetween
        * @param {integer} startIndex - The index to start removing children from.
        * @param {integer} [endIndex] - The index to stop removing children at. Must be higher than startIndex. If undefined this method will remove all children between startIndex and the end of the group.
        * @param {boolean} [destroy=false] - If true `destroy` will be invoked on each removed child.
        * @param {boolean} [silent=false] - If true the children will not dispatch their `onRemovedFromGroup` events.
        */
        removeBetween(startIndex: number, endIndex?: number, destroy?: boolean, silent?: boolean): void;

        /**
        * Replaces a child of this group with the given newChild. The newChild cannot be a member of this group.
        *
        * @method Phaser.Group#replace
        * @param {any} oldChild - The child in this group that will be replaced.
        * @param {any} newChild - The child to be inserted into this group.
        * @return {any} Returns the oldChild that was replaced within this group.
        */
        replace(oldChild: any, newChild: any): any;

        /**
        * Sets the group cursor to the first child in the group.
        *
        * If the optional index parameter is given it sets the cursor to the object at that index instead.
        *
        * @method Phaser.Group#resetCursor
        * @param {integer} [index=0] - Set the cursor to point to a specific index.
        * @return {any} The child the cursor now points to.
        */
        resetCursor(index?: number): any;

        /**
        * Reverses all children in this group.
        *
        * This operaation applies only to immediate children and does not propagate to subgroups.
        *
        * @method Phaser.Group#reverse
        */
        reverse(): void;

        /**
        * Sends the given child to the bottom of this group so it renders below all other children.
        *
        * @method Phaser.Group#sendToBack
        * @param {any} child - The child to send to the bottom of this group.
        * @return {any} The child that was moved.
        */
        sendToBack(child: any): any;

        /**
        * Sets a property to the given value on the child. The operation parameter controls how the value is set.
        *
        * The operations are:
        * - 0: set the existing value to the given value; if force is `true` a new property will be created if needed
        * - 1: will add the given value to the value already present.
        * - 2: will subtract the given value from the value already present.
        * - 3: will multiply the value already present by the given value.
        * - 4: will divide the value already present by the given value.
        *
        * @method Phaser.Group#setProperty
        * @param {any} child - The child to set the property value on.
        * @param {array} key - An array of strings that make up the property that will be set.
        * @param {any} value - The value that will be set.
        * @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.
        * @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.
        * @return {boolean} True if the property was set, false if not.
        */
        set(child: any, key: string[], value: any, operation?: number, force?: boolean): boolean;

        /**
        * Quickly set the same property across all children of this group to a new value.
        *
        * This call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.
        * If you need that ability please see `Group.setAllChildren`.
        *
        * The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.
        *
        * @method Phaser.Group#setAll
        * @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'
        * @param {any} value - The value that will be set.
        * @param {boolean} [checkAlive=false] - If set then only children with alive=true will be updated. This includes any Groups that are children.
        * @param {boolean} [checkVisible=false] - If set then only children with visible=true will be updated. This includes any Groups that are children.
        * @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.
        * @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.
        */
        setAll(key: string, value: any, checkAlive?: boolean, checkVisible?: boolean, operation?: number, force?: boolean): boolean;

        /**
        * Sets a property to the given value on the child. The operation parameter controls how the value is set.
        *
        * The operations are:
        * - 0: set the existing value to the given value; if force is `true` a new property will be created if needed
        * - 1: will add the given value to the value already present.
        * - 2: will subtract the given value from the value already present.
        * - 3: will multiply the value already present by the given value.
        * - 4: will divide the value already present by the given value.
        *
        * @method Phaser.Group#setProperty
        * @param {any} child - The child to set the property value on.
        * @param {array} key - An array of strings that make up the property that will be set.
        * @param {any} value - The value that will be set.
        * @param {integer} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.
        * @param {boolean} [force=false] - If `force` is true then the property will be set on the child regardless if it already exists or not. If false and the property doesn't exist, nothing will be set.
        * @return {boolean} True if the property was set, false if not.
        */
        setProperty(child: any, key: string[], value: any, operation?: number, force?: boolean): boolean;

        /**
        * Sort the children in the group according to a particular key and ordering.
        *
        * Call this function to sort the group according to a particular key value and order.
        * For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.
        *
        * @method Phaser.Group#sort
        * @param {string} [key='z'] - The name of the property to sort on. Defaults to the objects z-depth value.
        * @param {integer} [order=Phaser.Group.SORT_ASCENDING] - Order ascending ({@link Phaser.Group.SORT_ASCENDING SORT_ASCENDING}) or descending ({@link Phaser.Group.SORT_DESCENDING SORT_DESCENDING}).
        */
        sort(key?: string, order?: number): void;

        /**
        * Subtracts the amount from the given property on all children in this group.
        *
        * `Group.subAll('x', 10)` will minus 10 from the child.x value for each child.
        *
        * @method Phaser.Group#subAll
        * @param {string} property - The property to decrement, for example 'body.velocity.x' or 'angle'.
        * @param {number} amount - The amount to subtract from the property. If child.x = 50 then subAll('x', 40) would make child.x = 10.
        * @param {boolean} checkAlive - If true the property will only be changed if the child is alive.
        * @param {boolean} checkVisible - If true the property will only be changed if the child is visible.
        */
        subAll(property: string, amount: number, checkAlive: boolean, checkVisible: boolean): void;

        /**
        * Swaps the position of two children in this group.
        *
        * Both children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.
        *
        * @method Phaser.Group#swap
        * @param {any} child1 - The first child to swap.
        * @param {any} child2 - The second child to swap.
        */
        swap(child1: any, child2: any): boolean;

        /**
        * Internal method that re-applies all of the childrens Z values.
        *
        * This must be called whenever children ordering is altered so that their `z` indices are correctly updated.
        *
        * @method Phaser.Group#updateZ
        * @protected
        */
        update(): void;

        /**
        * Internal method that re-applies all of the childrens Z values.
        *
        * This must be called whenever children ordering is altered so that their `z` indices are correctly updated.
        *
        * @method Phaser.Group#updateZ
        * @protected
        */
        updateZ(): void;

        /**
        * Positions the child found at the given index within this group to the given x and y coordinates.
        *
        * @method Phaser.Group#xy
        * @param {integer} index - The index of the child in the group to set the position of.
        * @param {number} x - The new x position of the child.
        * @param {number} y - The new y position of the child.
        */
        xy(index: number, x: number, y: number): void;

    }
    /**
    * An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
    * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
    *
    * @class Phaser.Image
    * @extends PIXI.Sprite
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {number} y - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
    * @param {string|number} frame - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    */
    class Image extends PIXI.Sprite {

        constructor(game: Phaser.Game, x: number, y: number, key: any, frame: any);

        /**
        * @property {boolean} alive - A useful boolean to control if the Sprite is alive or dead (in terms of your gameplay, it doesn't effect rendering). Also linked to Sprite.health and Sprite.damage.
        * @default
        */
        alive: boolean;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        anchor: Phaser.Point;

        /**
        * Should this Sprite be automatically culled if out of range of the camera?
        * A culled sprite has its renderable property set to 'false'.
        * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.
        *
        * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.
        * @default
        */
        autoCull: boolean;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        /**
        * @property {Phaser.Rectangle} cropRect - The Rectangle used to crop the texture. Set this via Sprite.crop. Any time you modify this property directly you must call Sprite.updateCrop.
        * @default
        */
        cropRect: Phaser.Rectangle;

        /**
        * Returns the delta x value. The difference between world.x now and in the previous step.
        *
        * @name Phaser.Sprite#deltaX
        * @property {number} deltaX - The delta value. Positive if the motion was to the right, negative if to the left.
        * @readonly
        */
        deltaX: number;

        /**
        * Returns the delta y value. The difference between world.y now and in the previous step.
        *
        * @name Phaser.Sprite#deltaY
        * @property {number} deltaY - The delta value. Positive if the motion was downwards, negative if upwards.
        * @readonly
        */
        deltaY: number;

        /**
        * Returns the delta z value. The difference between rotation now and in the previous step.
        *
        * @name Phaser.Sprite#deltaZ
        * @property {number} deltaZ - The delta value.
        * @readonly
        */
        deltaZ: number;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: any;

        /**
        * @name Phaser.Sprite#frameName
        * @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.
        */
        frameName: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * Checks if the Sprite bounds are within the game camera, otherwise false if fully outside of it.
        *
        * @name Phaser.Sprite#inCamera
        * @property {boolean} inCamera - True if the Sprite bounds is within the game camera, even if only partially. Otherwise false if fully outside of it.
        * @readonly
        */
        inCamera: boolean;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * Checks if the Sprite bounds are within the game world, otherwise false if fully outside of it.
        *
        * @name Phaser.Sprite#inWorld
        * @property {boolean} inWorld - True if the Sprite bounds is within the game world, even if only partially. Otherwise false if fully outside of it.
        * @readonly
        */
        inWorld: boolean;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: any;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @name Phaser.Sprite#renderOrderID
        * @property {number} renderOrderID - The render order ID, reset every frame.
        * @readonly
        */
        renderOrderID: number;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.
        *
        * @name Phaser.Stage#smoothed
        * @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
        */
        smoothed: boolean;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * Brings the Image to the top of the display list it is a child of. Images that are members of a Phaser.Group are only
        * bought to the top of that Group, not the entire display list.
        *
        * @method Phaser.Image#bringToTop
        * @memberof Phaser.Image
        * @return {Phaser.Image} This instance.
        */
        bringToTop(): Phaser.Image;

        /**
        * Crop allows you to crop the texture used to display this Image.
        * Cropping takes place from the top-left of the Image and can be modified in real-time by providing an updated rectangle object.
        * The rectangle object given to this method can be either a Phaser.Rectangle or any object so long as it has public x, y, width and height properties.
        * Please note that the rectangle object given is not duplicated by this method, but rather the Image uses a reference to the rectangle.
        * Keep this in mind if assigning a rectangle in a for-loop, or when cleaning up for garbage collection.
        *
        * @method Phaser.Image#crop
        * @memberof Phaser.Image
        * @param {Phaser.Rectangle} rect - The Rectangle used during cropping. Pass null or no parameters to clear a previously set crop rectangle.
        * @param {boolean} [copy=false] - If false Sprite.cropRect will be a reference to the given rect. If true it will copy the rect values into a local Sprite.cropRect object.
        */
        crop(rect: Phaser.Rectangle, copy?: boolean): void;

        /**
        * Destroys the Image. This removes it from its parent group, destroys the input, event and animation handlers if present
        * and nulls its reference to game, freeing it up for garbage collection.
        *
        * @method Phaser.Image#destroy
        * @memberof Phaser.Image
        * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?
        */
        destroy(destroyChildren?: boolean): void;

        /**
        * Kills a Image. A killed Image has its alive, exists and visible properties all set to false.
        * It will dispatch the onKilled event, you can listen to Image.events.onKilled for the signal.
        * Note that killing a Image is a way for you to quickly recycle it in a Image pool, it doesn't free it up from memory.
        * If you don't need this Image any more you should call Image.destroy instead.
        *
        * @method Phaser.Image#kill
        * @memberof Phaser.Image
        * @return {Phaser.Image} This instance.
        */
        kill(): Phaser.Image;

        /**
        * Changes the Texture the Image is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.
        * This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.
        *
        * @method Phaser.Image#loadTexture
        * @memberof Phaser.Image
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
        * @param {string|number} frame - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        */
        loadTexture(key: any, frame: any): void;

        /**
        * Internal function called by the World postUpdate cycle.
        *
        * @method Phaser.Image#postUpdate
        * @memberof Phaser.Image
        */
        postUpdate(): void;

        /**
        * Automatically called by World.preUpdate.
        *
        * @method Phaser.Image#preUpdate
        * @memberof Phaser.Image
        */
        preUpdate(): void;

        /**
        * Resets the Texture frame dimensions that the Image uses for rendering.
        *
        * @method Phaser.Image#resetFrame
        * @memberof Phaser.Image
        */
        reset(x: number, y: number): Phaser.Image;

        /**
        * Resets the Texture frame dimensions that the Image uses for rendering.
        *
        * @method Phaser.Image#resetFrame
        * @memberof Phaser.Image
        */
        resetFrame(): void;

        /**
        * Brings a 'dead' Image back to life, optionally giving it the health value specified.
        * A resurrected Image has its alive, exists and visible properties all set to true.
        * It will dispatch the onRevived event, you can listen to Image.events.onRevived for the signal.
        *
        * @method Phaser.Image#revive
        * @memberof Phaser.Image
        * @return {Phaser.Image} This instance.
        */
        revive(): Phaser.Image;

        /**
        * Sets the Texture frame the Image uses for rendering.
        * This is primarily an internal method used by Image.loadTexture, although you may call it directly.
        *
        * @method Phaser.Image#setFrame
        * @memberof Phaser.Image
        * @param {Phaser.Frame} frame - The Frame to be used by the Image texture.
        */
        setFrame(frame: Phaser.Frame): void;

        /**
        * Sets the scaleMin and scaleMax values in one call.
        * These values are used to limit how far this Image will scale (either up or down) based on its parent.
        * For example if this Image has a minScale value of 1 and its parent has a scale value of 0.5, the 0.5 will be ignored and the scale value of 1 will be used.
        * By using these values you can carefully control how Images deal with responsive scaling.
        * 
        * If only one parameter is given then that value will be used for both scaleMin and scaleMax:
        * setScaleMinMax(1) = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1
        *
        * If only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:
        * setScaleMinMax(0.5, 2) = scaleMin.x and y = 0.5 and scaleMax.x and y = 2
        *
        * If you wish to set scaleMin with different values for x and y then either modify Image.scaleMin directly, or pass `null` for the maxX and maxY parameters.
        * 
        * Call setScaleMinMax(null) to clear both the scaleMin and scaleMax values.
        *
        * @method Phaser.Image#setScaleMinMax
        * @memberof Phaser.Image
        * @param {number|null} minX - The minimum horizontal scale value this Image can scale down to.
        * @param {number|null} minY - The minimum vertical scale value this Image can scale down to.
        * @param {number|null} maxX - The maximum horizontal scale value this Image can scale up to.
        * @param {number|null} maxY - The maximum vertical scale value this Image can scale up to.
        */
        setScaleMinMax(minX?: number, minY?: number, maxX?: number, maxY?: number): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        *
        * @method Phaser.Image#update
        * @memberof Phaser.Image
        */
        update(): void;

        /**
        * If you have set a crop rectangle on this Image via Image.crop and since modified the Image.cropRect property (or the rectangle it references)
        * then you need to update the crop frame by calling this method.
        *
        * @method Phaser.Image#updateCrop
        * @memberof Phaser.Image
        */
        updateCrop(): void;

    }
    /**
    * Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.
    * The Input manager is updated automatically by the core game loop.
    *
    * @class Phaser.Input
    * @constructor
    * @param {Phaser.Game} game - Current game instance.
    */
    class Input {

        constructor(game: Phaser.Game);

        static MAX_POINTERS: number;

        static MOUSE_OVERRIDES_TOUCH: number;

        static MOUSE_TOUCH_COMBINE: number;

        static TOUCH_OVERRIDES_MOUSE: number;

        activePointer: Phaser.Pointer;

        circle: Phaser.Circle;

        /**
        * @property {number} currentPointers - The current number of active Pointers.
        * @deprecated This is only updated when `maxPointers >= 0` and will generally be innacurate. Use `totalActivePointers` instead.
        */
        currentPointers: number;

        disabled: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {number} doubleTapRate - The number of milliseconds between taps of the same Pointer for it to be considered a double tap / click.
        * @default
        */
        doubleTapRate: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Gamepad} gamepad - The Gamepad Input manager.
        */
        gamepad: Phaser.Gamepad;

        /**
        * @property {HTMLCanvasElement} hitCanvas - The canvas to which single pixels are drawn in order to perform pixel-perfect hit detection.
        * @default
        */
        hitCanvas: HTMLCanvasElement;

        /**
        * @property {CanvasRenderingContext2D} hitContext - The context of the pixel perfect hit canvas.
        * @default
        */
        hitContext: CanvasRenderingContext2D;

        /**
        * @property {number} holdRate - The number of milliseconds that the Pointer has to be pressed down for it to fire a onHold event.
        * @default
        */
        holdRate: number;

        interactiveItems: Phaser.ArraySet;

        /**
        * @property {number} justPressedRate - The number of milliseconds below which the Pointer is considered justPressed.
        * @default
        */
        justPressedRate: number;

        /**
        * @property {number} justReleasedRate - The number of milliseconds below which the Pointer is considered justReleased .
        * @default
        */
        justReleasedRate: number;

        /**
        * @property {Phaser.Keyboard} keyboard - The Keyboard Input manager.
        */
        keyboard: Phaser.Keyboard;

        /**
        * @property {integer} maxPointers - The maximum number of Pointers allowed to be active at any one time. A value of -1 is only limited by the total number of pointers. For lots of games it's useful to set this to 1.
        * @default -1 (Limited by total pointers.)
        */
        maxPointers: number;

        /**
        * @property {number} minPriorityID - You can tell all Pointers to ignore any object with a priorityID lower than the minPriorityID. Useful when stacking UI layers. Set to zero to disable.
        * @default
        */
        minPriorityID: number;

        /**
        * @property {Phaser.Mouse} mouse - The Mouse Input manager.
        */
        mouse: Phaser.Mouse;

        /**
        * @property {Pointer} mousePointer - The mouse has its own unique Phaser.Pointer object which you can use if making a desktop specific game.
        */
        mousePointer: Phaser.Pointer;

        moveCallbacks: (pointer: Phaser.Pointer, x: number, y: number) => void[];

        /**
        * @property {object} moveCallbackContext - The context in which the moveCallback will be sent. Defaults to Phaser.Input but can be set to any valid JS object.
        */
        moveCallbackContext: any;

        /**
        * @property {Phaser.MSPointer} mspointer - The MSPointer Input manager.
        */
        mspointer: Phaser.MSPointer;

        /**
        * @property {number} multiInputOverride - Controls the expected behaviour when using a mouse and touch together on a multi-input device.
        * @default
        */
        multiInputOverride: number;

        /**
        * @property {Phaser.Signal} onDown - A Signal that is dispatched each time a pointer is pressed down.
        */
        onDown: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onHold - A Signal that is dispatched each time a pointer is held down.
        */
        onHold: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onTap - A Signal that is dispatched each time a pointer is tapped.
        */
        onTap: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onUp - A Signal that is dispatched each time a pointer is released.
        */
        onUp: Phaser.Signal;

        /**
        * @property {Phaser.Pointer} pointer1 - A Pointer object.
        */
        pointer1: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer2 - A Pointer object.
        */
        pointer2: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer3 - A Pointer object.
        */
        pointer3: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer4 - A Pointer object.
        */
        pointer4: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer5 - A Pointer object.
        */
        pointer5: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer6 - A Pointer object.
        */
        pointer6: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer7 - A Pointer object.
        */
        pointer7: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer8 - A Pointer object.
        */
        pointer8: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer9 - A Pointer object.
        */
        pointer9: Phaser.Pointer;

        /**
        * @property {Phaser.Pointer} pointer10 - A Pointer object.
        */
        pointer10: Phaser.Pointer;

        pollLocked: boolean;

        /**
        * @property {number} pollRate - How often should the input pointers be checked for updates? A value of 0 means every single frame (60fps); a value of 1 means every other frame (30fps) and so on.
        * @default
        */
        pollRate: number;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        pointer: Phaser.Pointer[];

        recordLimit: number;

        recordPointerHistory: boolean;

        /**
        * @property {number} recordRate - The rate in milliseconds at which the Pointer objects should update their tracking history.
        * @default
        */
        recordRate: number;

        /**
        * @property {boolean} resetLocked - If the Input Manager has been reset locked then all calls made to InputManager.reset, such as from a State change, are ignored.
        * @default
        */
        resetLocked: boolean;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
        */
        speed: Phaser.Point;

        /**
        * @property {number} tapRate - The number of milliseconds that the Pointer has to be pressed down and then released to be considered a tap or click.
        * @default
        */
        tapRate: number;

        totalActivePointers: number;

        totalInactivePointers: number;

        /**
        * @property {Phaser.Touch} touch - the Touch Input manager.
        */
        touch: Phaser.Touch;

        /**
        * The world X coordinate of the most recently active pointer.
        * @name Phaser.Input#worldX
        * @property {number} worldX - The world X coordinate of the most recently active pointer.
        * @readonly
        */
        worldX: number;

        /**
        * The world Y coordinate of the most recently active pointer.
        * @name Phaser.Input#worldY
        * @property {number} worldY - The world Y coordinate of the most recently active pointer.
        * @readonly
        */
        worldY: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Add a new Pointer object to the Input Manager.
        * By default Input creates 3 pointer objects: `mousePointer` (not include in part of general pointer pool), `pointer1` and `pointer2`.
        * This method adds an additional pointer, up to a maximum of Phaser.Input.MAX_POINTERS (default of 10).
        *
        * @method Phaser.Input#addPointer
        * @return {Phaser.Pointer|null} The new Pointer object that was created; null if a new pointer could not be added.
        */
        addPointer(): Phaser.Pointer;

        /**
        * Adds a callback that is fired every time the activePointer receives a DOM move event such as a mousemove or touchmove.
        *
        * The callback will be sent 4 parameters: The Pointer that moved, the x position of the pointer, the y position and the down state.
                * It will be called every time the activePointer moves, which in a multi-touch game can be a lot of times, so this is best
        * to only use if you've limited input to a single pointer (i.e. mouse or touch).
        * The callback is added to the Phaser.Input.moveCallbacks array and should be removed with Phaser.Input.deleteMoveCallback.
        * 
        * @method Phaser.Input#addMoveCallback
        * @param {function} callback - The callback that will be called each time the activePointer receives a DOM move event.
        * @param {object} context - The context in which the callback will be called.
        * @return {number} The index of the callback entry. Use this index when calling Input.deleteMoveCallback.
        */
        addMoveCallback(callback: Function, context: any): number;

        /**
        * Starts the Input Manager running.
        *
        * @method Phaser.Input#boot
        * @protected
        */
        boot(): void;

        countActivePointers(limit?: number): number;

        /**
        * Removes the callback at the defined index from the Phaser.Input.moveCallbacks array
        * 
        * @method Phaser.Input#deleteMoveCallback
        * @param {number} index - The index of the callback to remove.
        */
        deleteMoveCallback(index: number): void;

        /**
        * Stops all of the Input Managers from running.
        *
        * @method Phaser.Input#destroy
        */
        destroy(): void;

        /**
        * This will return the local coordinates of the specified displayObject based on the given Pointer.
        *
        * @method Phaser.Input#getLocalPosition
        * @param {Phaser.Sprite|Phaser.Image} displayObject - The DisplayObject to get the local coordinates for.
        * @param {Phaser.Pointer} pointer - The Pointer to use in the check against the displayObject.
        * @return {Phaser.Point} A point containing the coordinates of the Pointer position relative to the DisplayObject.
        */
        getLocalPosition(displayObject: any, pointer: Phaser.Pointer): Phaser.Point;

        /**
        * Get the first Pointer with the given active state.
        *
        * @method Phaser.Input#getPointer
        * @param {boolean} [isActive=false] - The state the Pointer should be in - active or innactive?
        * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested state.
        */
        getPointer(isActive?: boolean): Phaser.Pointer;

        /**
        * Get the Pointer object whos `identifier` property matches the given identifier value.
        *
        * The identifier property is not set until the Pointer has been used at least once, as its populated by the DOM event.
        * Also it can change every time you press the pointer down, and is not fixed once set.
        * Note: Not all browsers set the identifier property and it's not part of the W3C spec, so you may need getPointerFromId instead.
        *
        * @method Phaser.Input#getPointerFromIdentifier
        * @param {number} identifier - The Pointer.identifier value to search for.
        * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested identifier.
        */
        getPointerFromId(pointerID: number): Phaser.Pointer;

        /**
        * Get the Pointer object whos `identifier` property matches the given identifier value.
        *
        * The identifier property is not set until the Pointer has been used at least once, as its populated by the DOM event.
        * Also it can change every time you press the pointer down, and is not fixed once set.
        * Note: Not all browsers set the identifier property and it's not part of the W3C spec, so you may need getPointerFromId instead.
        *
        * @method Phaser.Input#getPointerFromIdentifier
        * @param {number} identifier - The Pointer.identifier value to search for.
        * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested identifier.
        */
        getPointerFromIdentifier(identifier: number): Phaser.Pointer;

        /**
        * Tests if the pointer hits the given object.
        *
        * @method Phaser.Input#hitTest
        * @param {DisplayObject} displayObject - The displayObject to test for a hit.
        * @param {Phaser.Pointer} pointer - The pointer to use for the test.
        * @param {Phaser.Point} localPoint - The local translated point.
        */
        hitTest(displayObject: any, pointer: Phaser.Pointer, localPoint: Phaser.Point): void;

        /**
        * Reset all of the Pointers and Input states.
        *
        * The optional `hard` parameter will reset any events or callbacks that may be bound.
        * Input.reset is called automatically during a State change or if a game loses focus / visibility.
        * To control control the reset manually set {@link Phaser.InputManager.resetLocked} to `true`.
        *
        * @method Phaser.Input#reset
        * @public
        * @param {boolean} [hard=false] - A soft reset won't reset any events or callbacks that are bound. A hard reset will.
        */
        reset(hard?: boolean): void;

        /**
        * Resets the speed and old position properties.
        *
        * @method Phaser.Input#resetSpeed
        * @param {number} x - Sets the oldPosition.x value.
        * @param {number} y - Sets the oldPosition.y value.
        */
        resetSpeed(x: number, y: number): void;

        /**
        * Find the first free Pointer object and start it, passing in the event data.
        * This is called automatically by Phaser.Touch and Phaser.MSPointer.
        *
        * @method Phaser.Input#startPointer
        * @protected
        * @param {any} event - The event data from the Touch event.
        * @return {Phaser.Pointer} The Pointer object that was started or null if no Pointer object is available.
        */
        startPointer(event: any): Phaser.Pointer;

        /**
        * Stops the matching Pointer object, passing in the event data.
        *
        * @method Phaser.Input#stopPointer
        * @protected
        * @param {any} event - The event data from the Touch event.
        * @return {Phaser.Pointer} The Pointer object that was stopped or null if no Pointer object is available.
        */
        stopPointer(event: any): Phaser.Pointer;

        /**
        * Updates the Input Manager. Called by the core Game loop.
        * 
        * @method Phaser.Input#update
        * @protected
        */
        update(): void;

        /**
        * Updates the matching Pointer object, passing in the event data.
        * This is called automatically and should not normally need to be invoked.
        *
        * @method Phaser.Input#updatePointer
        * @protected
        * @param {any} event - The event data from the Touch event.
        * @return {Phaser.Pointer} The Pointer object that was updated; null if no pointer was updated.
        */
        updatePointer(event: any): Phaser.Pointer;

    }
    /**
    * The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.
    *
    * @class Phaser.InputHandler
    * @constructor
    * @param {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
    */
    class InputHandler {

        constructor(sprite: Phaser.Sprite);

        /**
        * @property {boolean} allowHorizontalDrag - Controls if the Sprite is allowed to be dragged horizontally.
        * @default
        */
        allowHorizontalDrag: boolean;

        /**
        * @property {boolean} allowVerticalDrag - Controls if the Sprite is allowed to be dragged vertically.
        * @default
        */
        allowVerticalDrag: boolean;

        /**
        * @property {Phaser.Rectangle} boundsRect - A region of the game world within which the sprite is restricted during drag.
        * @default
        */
        boundsRect: Phaser.Rectangle;

        /**
        * @property {Phaser.Sprite} boundsSprite - A Sprite the bounds of which this sprite is restricted during drag.
        * @default
        */
        boundsSprite: Phaser.Sprite;

        /**
        * @property {boolean} bringToTop - If true when this Sprite is clicked or dragged it will automatically be bought to the top of the Group it is within.
        * @default
        */
        bringToTop: boolean;

        consumePointerEvent: boolean;

        /**
        * @property {boolean} draggable - Is this sprite allowed to be dragged by the mouse? true = yes, false = no
        * @default
        */
        draggable: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * Warning: EXPERIMENTAL
        * @method Phaser.InputHandler#globalToLocalX
        * @param {number} x
        */
        globalToLocalX(x: number): number;

        /**
        * Warning: EXPERIMENTAL
        * @method Phaser.InputHandler#globalToLocalY
        * @param {number} y
        */
        globalToLocalY(y: number): number;

        /**
        * @property {boolean} isDragged - true if the Sprite is being currently dragged.
        * @default
        */
        isDragged: boolean;

        /**
        * @property {number} pixelPerfectAlpha - The alpha tolerance threshold. If the alpha value of the pixel matches or is above this value, it's considered a hit.
        * @default
        */
        pixelPerfectAlpha: number;

        /**
        * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite when it's clicked or touched.
        * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.
        * Warning: This is expensive so only enable if you really need it.
        * @property {number} pixelPerfectClick - Use a pixel perfect check when testing for clicks or touches on the Sprite.
        * @default
        */
        pixelPerfectClick: boolean;

        /**
        * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite.
        * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.
        * Warning: This is expensive, especially on mobile (where it's not even needed!) so only enable if required. Also see the less-expensive InputHandler.pixelPerfectClick.
        * @property {number} pixelPerfectOver - Use a pixel perfect check when testing for pointer over.
        * @default
        */
        pixelPerfectOver: boolean;

        priorityID: number;

        /**
        * @property {boolean} scaleLayer - EXPERIMENTAL: Please do not use this property unless you know what it does. Likely to change in the future.
        */
        scaleLayer: boolean;

        /**
        * @property {Phaser.Point} snapOffset - A Point object that contains by how far the Sprite snap is offset.
        * @default
        */
        snapOffset: Phaser.Point;

        /**
        * @property {number} snapOffsetX - This defines the top-left X coordinate of the snap grid.
        * @default
        */
        snapOffsetX: number;

        /**
        * @property {number} snapOffsetY - This defines the top-left Y coordinate of the snap grid..
        * @default
        */
        snapOffsetY: number;

        /**
        * @property {boolean} snapOnDrag - When the Sprite is dragged this controls if the center of the Sprite will snap to the pointer on drag or not.
        * @default
        */
        snapOnDrag: boolean;

        /**
        * @property {boolean} snapOnRelease - When the Sprite is dragged this controls if the Sprite will be snapped on release.
        * @default
        */
        snapOnRelease: boolean;

        /**
        * @property {number} snapX - When a Sprite has snapping enabled this holds the width of the snap grid.
        * @default
        */
        snapX: number;

        /**
        * @property {number} snapY - When a Sprite has snapping enabled this holds the height of the snap grid.
        * @default
        */
        snapY: number;

        /**
        * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
        */
        sprite: Phaser.Sprite;

        /**
        * @property {boolean} useHandCursor - On a desktop browser you can set the 'hand' cursor to appear when moving over the Sprite.
        * @default
        */
        useHandCursor: boolean;

        /**
        * Bounds Rect check for the sprite drag
        * @method Phaser.InputHandler#checkBoundsRect
        */
        checkBoundsRect(): void;

        /**
        * Parent Sprite Bounds check for the sprite drag.
        * @method Phaser.InputHandler#checkBoundsSprite
        */
        checkBoundsSprite(): void;

        /**
        * Runs a pixel perfect check against the given x/y coordinates of the Sprite this InputHandler is bound to.
        * It compares the alpha value of the pixel and if >= InputHandler.pixelPerfectAlpha it returns true.
        * @method Phaser.InputHandler#checkPixel
        * @param {number} x - The x coordinate to check.
        * @param {number} y - The y coordinate to check.
        * @param {Phaser.Pointer} [pointer] - The pointer to get the x/y coordinate from if not passed as the first two parameters.
        * @return {boolean} true if there is the alpha of the pixel is >= InputHandler.pixelPerfectAlpha
        */
        checkPixel(x: number, y: number, pointer?: Phaser.Pointer): boolean;

        /**
        * Checks if the given pointer is both down and over the Sprite this InputHandler belongs to.
        * Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.
        *
        * @method Phaser.InputHandler#checkPointerDown
        * @param {Phaser.Pointer} pointer
        * @param {boolean} [fastTest=false] - Force a simple hit area check even if `pixelPerfectOver` is true for this object?
        * @return {boolean} True if the pointer is down, otherwise false.
        */
        checkPointerDown(pointer: Phaser.Pointer, fastTest?: boolean): boolean;

        /**
        * Checks if the given pointer is over the Sprite this InputHandler belongs to.
        * Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.
        *
        * @method Phaser.InputHandler#checkPointerOver
        * @param {Phaser.Pointer} pointer
        * @param {boolean} [fastTest=false] - Force a simple hit area check even if `pixelPerfectOver` is true for this object?
        * @return {boolean}
        */
        checkPointerOver(pointer: Phaser.Pointer, fastTest?: boolean): boolean;

        /**
        * Clean up memory.
        * @method Phaser.InputHandler#destroy
        */
        destroy(): void;

        /**
        * Stops this sprite from being able to be dragged. If it is currently the target of an active drag it will be stopped immediately. Also disables any set callbacks.
        * @method Phaser.InputHandler#disableDrag
        */
        disableDrag(): void;

        /**
        * Stops the sprite from snapping to a grid during drag or release.
        * @method Phaser.InputHandler#disableSnap
        */
        disableSnap(): void;

        /**
        * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.
        * @method Phaser.InputHandler#downDuration
        * @param {Phaser.Pointer} pointer
        * @return {number} The number of milliseconds the pointer has been pressed down on the Sprite, or -1 if not over.
        */
        downDuration(pointer: Phaser.Pointer): number;

        /**
        * Make this Sprite draggable by the mouse. You can also optionally set mouseStartDragCallback and mouseStopDragCallback
        * @method Phaser.InputHandler#enableDrag
        * @param {boolean} [lockCenter=false] - If false the Sprite will drag from where you click it minus the dragOffset. If true it will center itself to the tip of the mouse pointer.
        * @param {boolean} [bringToTop=false] - If true the Sprite will be bought to the top of the rendering list in its current Group.
        * @param {boolean} [pixelPerfect=false] - If true it will use a pixel perfect test to see if you clicked the Sprite. False uses the bounding box.
        * @param {boolean} [alphaThreshold=255] - If using pixel perfect collision this specifies the alpha level from 0 to 255 above which a collision is processed.
        * @param {Phaser.Rectangle} [boundsRect=null] - If you want to restrict the drag of this sprite to a specific Rectangle, pass the Phaser.Rectangle here, otherwise it's free to drag anywhere.
        * @param {Phaser.Sprite} [boundsSprite=null] - If you want to restrict the drag of this sprite to within the bounding box of another sprite, pass it here.
        */
        enableDrag(lockCenter?: boolean, bringToTop?: boolean, pixelPerfect?: boolean, alphaThreshold?: number, boundsRect?: Phaser.Rectangle, boundsSprite?: Phaser.Rectangle): void;

        /**
        * Make this Sprite snap to the given grid either during drag or when it's released.
        * For example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.
        * @method Phaser.InputHandler#enableSnap
        * @param {number} snapX - The width of the grid cell to snap to.
        * @param {number} snapY - The height of the grid cell to snap to.
        * @param {boolean} [onDrag=true] - If true the sprite will snap to the grid while being dragged.
        * @param {boolean} [onRelease=false] - If true the sprite will snap to the grid when released.
        * @param {number} [snapOffsetX=0] - Used to offset the top-left starting point of the snap grid.
        * @param {number} [snapOffsetX=0] - Used to offset the top-left starting point of the snap grid.
        */
        enableSnap(snapX: number, snapY: number, onDrag?: boolean, onRelease?: boolean, snapOffsetX?: number, snapOffsetY?: number): void;

        /**
        * Is this object using pixel perfect checking?
        *
        * @method Phaser.InputHandler#isPixelPerfect
        * @return {boolean} True if the this InputHandler has either `pixelPerfectClick` or `pixelPerfectOver` set to `true`.
        */
        isPixelPerfect(): boolean;

        /**
        * Returns true if the pointer has left the Sprite within the specified delay time (defaults to 500ms, half a second)
        * @method Phaser.InputHandler#justOut
        * @param {Phaser.Pointer} pointer
        * @param {number} delay - The time below which the pointer is considered as just out.
        * @return {boolean}
        */
        justOut(pointer: number, delay: number): boolean;

        /**
        * Returns true if the pointer has entered the Sprite within the specified delay time (defaults to 500ms, half a second)
        * @method Phaser.InputHandler#justOver
        * @param {Phaser.Pointer} pointer
        * @param {number} delay - The time below which the pointer is considered as just over.
        * @return {boolean}
        */
        justOver(pointer: number, delay: number): boolean;

        /**
        * Returns true if the pointer has touched or clicked on the Sprite within the specified delay time (defaults to 500ms, half a second)
        * @method Phaser.InputHandler#justPressed
        * @param {Phaser.Pointer} pointer
        * @param {number} delay - The time below which the pointer is considered as just over.
        * @return {boolean}
        */
        justPressed(pointer: number, delay: number): boolean;

        /**
        * Returns true if the pointer was touching this Sprite, but has been released within the specified delay time (defaults to 500ms, half a second)
        * @method Phaser.InputHandler#justReleased
        * @param {Phaser.Pointer} pointer
        * @param {number} delay - The time below which the pointer is considered as just out.
        * @return {boolean}
        */
        justReleased(pointer: number, delay: number): boolean;

        /**
        * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.
        * @method Phaser.InputHandler#overDuration
        * @param {Phaser.Pointer} pointer
        * @return {number} The number of milliseconds the pointer has been over the Sprite, or -1 if not over.
        */
        overDuration(pointer: Phaser.Pointer): number;

        /**
        * If the Pointer is down this returns true. Please note that it only checks if the Pointer is down, not if it's down over any specific Sprite.
        *
        * @method Phaser.InputHandler#pointerDown
        * @param {number} pointer - The index of the pointer to check. You can get this from Phaser.Pointer.id.
        * @return {boolean} - True if the given pointer is down, otherwise false.
        */
        pointerDown(pointer: number): boolean;

        /**
        * Is this sprite being dragged by the mouse or not?
        * @method Phaser.InputHandler#pointerDragged
        * @param {Phaser.Pointer} pointer
        * @return {boolean} True if the pointer is dragging an object, otherwise false.
        */
        pointerDragged(pointer: Phaser.Pointer): boolean;

        /**
        * Is the Pointer outside of this Sprite?
        * @method Phaser.InputHandler#pointerOut
        * @param {number} [index] - The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.
        * @return {boolean} True if the given pointer (if a index was given, or any pointer if not) is out of this object.
        */
        pointerOut(index: number): boolean;

        /**
        * Is the Pointer over this Sprite?
        *
        * @method Phaser.InputHandler#pointerOver
        * @param {number} [index] - The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.
        * @return {boolean} - True if the given pointer (if a index was given, or any pointer if not) is over this object.
        */
        pointerOver(index: number): boolean;

        /**
        * A timestamp representing when the Pointer first touched the touchscreen.
        *
        * @method Phaser.InputHandler#pointerTimeDown
        * @param {number} pointer - The index of the pointer to check. You can get this from Phaser.Pointer.id.
        * @return {number}
        */
        pointerTimeDown(pointer: Phaser.Pointer): number;

        /**
        * A timestamp representing when the Pointer left the touchscreen.
        * @method Phaser.InputHandler#pointerTimeOut
        * @param {Phaser.Pointer} pointer
        * @return {number}
        */
        pointerTimeOut(pointer: Phaser.Pointer): number;

        /**
        * A timestamp representing when the Pointer first touched the touchscreen.
        * @method Phaser.InputHandler#pointerTimeOver
        * @param {Phaser.Pointer} pointer
        * @return {number}
        */
        pointerTimeOver(pointer: number): number;

        /**
        * A timestamp representing when the Pointer left the touchscreen.
        * @method Phaser.InputHandler#pointerTimeUp
        * @param {Phaser.Pointer} pointer
        * @return {number}
        */
        pointerTimeUp(pointer: number): number;

        /**
        * If the Pointer is up this returns true. Please note that it only checks if the Pointer is up, not if it's up over any specific Sprite.
        *
        * @method Phaser.InputHandler#pointerUp
        * @param {number} pointer - The index of the pointer to check. You can get this from Phaser.Pointer.id.
        * @return {boolean} - True if the given pointer is up, otherwise false.
        */
        pointerUp(pointer: number): boolean;

        /**
        * The x coordinate of the Input pointer, relative to the top-left of the parent Sprite.
        * This value is only set when the pointer is over this Sprite.
        *
        * @method Phaser.InputHandler#pointerX
        * @param {number} pointer - The index of the pointer to check. You can get this from Phaser.Pointer.id.
        * @return {number} The x coordinate of the Input pointer.
        */
        pointerX(pointer: number): number;

        /**
        * The y coordinate of the Input pointer, relative to the top-left of the parent Sprite
        * This value is only set when the pointer is over this Sprite.
        *
        * @method Phaser.InputHandler#pointerY
        * @param {number} pointer - The index of the pointer to check. You can get this from Phaser.Pointer.id.
        * @return {number} The y coordinate of the Input pointer.
        */
        pointerY(pointer: number): number;

        /**
        * Resets the Input Handler and disables it.
        * @method Phaser.InputHandler#reset
        */
        reset(): void;

        /**
        * Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!
        * @method Phaser.InputHandler#setDragLock
        * @param {boolean} [allowHorizontal=true] - To enable the sprite to be dragged horizontally set to true, otherwise false.
        * @param {boolean} [allowVertical=true] - To enable the sprite to be dragged vertically set to true, otherwise false.
        */
        setDragLock(allowHorizontal?: boolean, allowVertical?: boolean): void;

        /**
        * Starts the Input Handler running. This is called automatically when you enable input on a Sprite, or can be called directly if you need to set a specific priority.
        * @method Phaser.InputHandler#start
        * @param {number} priority - Higher priority sprites take click priority over low-priority sprites when they are stacked on-top of each other.
        * @param {boolean} useHandCursor - If true the Sprite will show the hand cursor on mouse-over (doesn't apply to mobile browsers)
        * @return {Phaser.Sprite} The Sprite object to which the Input Handler is bound.
        */
        start(priority: number, useHandCursor: boolean): Phaser.Sprite;

        /**
        * Called by Pointer when drag starts on this Sprite. Should not usually be called directly.
        * @method Phaser.InputHandler#startDrag
        * @param {Phaser.Pointer} pointer
        */
        startDrag(pointer: Phaser.Pointer): void;

        /**
        * Stops the Input Handler from running.
        * @method Phaser.InputHandler#stop
        */
        stop(): void;

        /**
        * Called by Pointer when drag is stopped on this Sprite. Should not usually be called directly.
        * @method Phaser.InputHandler#stopDrag
        * @param {Phaser.Pointer} pointer
        */
        stopDrag(pointer: Phaser.Pointer): void;

        /**
        * Update.
        * 
        * @method Phaser.InputHandler#update
        * @protected
        * @param {Phaser.Pointer} pointer
        */
        update(pointer: Phaser.Pointer): void;

        /**
        * Updates the Pointer drag on this Sprite.
        * @method Phaser.InputHandler#updateDrag
        * @param {Phaser.Pointer} pointer
        * @return {boolean}
        */
        updateDrag(pointer: Phaser.Pointer): boolean;

        /**
        * Checks if the object this InputHandler is bound to is valid for consideration in the Pointer move event.
        * This is called by Phaser.Pointer and shouldn't typically be called directly.
        *
        * @method Phaser.InputHandler#validForInput
        * @protected
        * @param {number} highestID - The highest ID currently processed by the Pointer.
        * @param {number} highestRenderID - The highest Render Order ID currently processed by the Pointer.
        * @param {boolean} [includePixelPerfect=true] - If this object has `pixelPerfectClick` or `pixelPerfectOver` set should it be considered as valid?
        * @return {boolean} True if the object this InputHandler is bound to should be considered as valid for input detection.
        */
        validForInput(highestID: number, highestRenderID: number, includePixelPerfect?: boolean): boolean;

    }
    /**
    * If you need more fine-grained control over the handling of specific keys you can create and use Phaser.Key objects.
    * 
    * @class Phaser.Key
    * @constructor
    * @param {Phaser.Game} game - Current game instance.
    * @param {number} keycode - The key code this Key is responsible for.
    */
    class Key {

        constructor(game: Phaser.Game, keycode: number);

        /**
        * @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.
        * @default
        */
        altKey: boolean;

        /**
        * @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.
        * @default
        */
        ctrlKey: boolean;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {object} event - Stores the most recent DOM event.
        * @readonly
        */
        event: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
        * @default
        */
        isDown: boolean;

        /**
        * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
        * @default
        */
        isUp: boolean;

        /**
        * @property {boolean} _justDown - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
        * @private
        */
        _justDown: boolean;

        justDown: boolean;

        /**
        * @property {boolean} _justUp - True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
        * @private
        */
        _justUp: boolean;

        justUp: boolean;

        /**
        * @property {number} keyCode - The keycode of this key.
        */
        keyCode: number;

        /**
        * @property {Phaser.Signal} onDown - A Signal that is dispatched each time a pointer is pressed down.
        */
        onDown: Phaser.Signal;

        /**
        * @property {function} onHoldCallback - A callback that is called while this Key is held down. Warning: Depending on refresh rate that could be 60+ times per second.
        */
        onHoldCallback: Function;

        /**
        * @property {object} onHoldContext - The context under which the onHoldCallback will be called.
        */
        onHoldContext: any;

        /**
        * @property {Phaser.Signal} onUp - A Signal that is dispatched each time a pointer is released.
        */
        onUp: Phaser.Signal;

        /**
        * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.
        * @default
        */
        repeats: number;

        /**
        * @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.
        * @default
        */
        shiftKey: boolean;

        /**
        * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
        */
        timeDown: number;

        /**
        * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
        * @default
        */
        timeUp: number;

        /**
        * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
        * or was pressed down longer ago than then given duration.
        * 
        * @method Phaser.Key#downDuration
        * @param {number} [duration=50] - The duration within which the key is considered as being just pressed. Given in ms.
        * @return {boolean} True if the key was pressed down within the given duration.
        */
        downDuration(duration?: number): boolean;

        /**
        * Called automatically by Phaser.Keyboard.
        * 
        * @method Phaser.Key#processKeyDown
        * @param {KeyboardEvent} event - The DOM event that triggered this.
        * @protected
        */
        processKeyDown(event: KeyboardEvent): void;

        /**
        * Called automatically by Phaser.Keyboard.
        * 
        * @method Phaser.Key#processKeyUp
        * @param {KeyboardEvent} event - The DOM event that triggered this.
        * @protected
        */
        processKeyUp(event: KeyboardEvent): void;

        /**
        * Resets the state of this Key.
        *
        * This sets isDown to false, isUp to true, resets the time to be the current time, and _enables_ the key.
        * In addition, if it is a "hard reset", it clears clears any callbacks associated with the onDown and onUp events and removes the onHoldCallback.
        *
        * @method Phaser.Key#reset
        * @param {boolean} [hard=true] - A soft reset won't reset any events or callbacks; a hard reset will.
        */
        reset(hard?: boolean): void;

        /**
        * Called automatically by Phaser.Keyboard.
        * 
        * @method Phaser.Key#update
        * @protected
        */
        update(): void;

        /**
        * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
        * or was pressed down longer ago than then given duration.
        * 
        * @method Phaser.Key#upDuration
        * @param {number} [duration=50] - The duration within which the key is considered as being just released. Given in ms.
        * @return {boolean} True if the key was released within the given duration.
        */
        upDuration(duration?: number): boolean;

    }
    /**
    * The Keyboard class monitors keyboard input and dispatches keyboard events.
    *
    * _Be aware_ that many keyboards are unable to process certain combinations of keys due to hardware
    * limitations known as ghosting. Full details here: http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/
    *
    * @class Phaser.Keyboard
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Keyboard {

        constructor(game: Phaser.Game);

        static A: number;

        static B: number;

        static C: number;

        static D: number;

        static E: number;

        static F: number;

        static G: number;

        static H: number;

        static I: number;

        static J: number;

        static K: number;

        static L: number;

        static M: number;

        static N: number;

        static O: number;

        static P: number;

        static Q: number;

        static R: number;

        static S: number;

        static T: number;

        static U: number;

        static V: number;

        static W: number;

        static X: number;

        static Y: number;

        static Z: number;

        static ZERO: number;

        static ONE: number;

        static TWO: number;

        static THREE: number;

        static FOUR: number;

        static FIVE: number;

        static SIX: number;

        static SEVEN: number;

        static EIGHT: number;

        static NINE: number;

        static NUMPAD_0: number;

        static NUMPAD_1: number;

        static NUMPAD_2: number;

        static NUMPAD_3: number;

        static NUMPAD_4: number;

        static NUMPAD_5: number;

        static NUMPAD_6: number;

        static NUMPAD_7: number;

        static NUMPAD_8: number;

        static NUMPAD_9: number;

        static NUMPAD_MULTIPLY: number;

        static NUMPAD_ADD: number;

        static NUMPAD_ENTER: number;

        static NUMPAD_SUBTRACT: number;

        static NUMPAD_DECIMAL: number;

        static NUMPAD_DIVIDE: number;

        static F1: number;

        static F2: number;

        static F3: number;

        static F4: number;

        static F5: number;

        static F6: number;

        static F7: number;

        static F8: number;

        static F9: number;

        static F10: number;

        static F11: number;

        static F12: number;

        static F13: number;

        static F14: number;

        static F15: number;

        static COLON: number;

        static EQUALS: number;

        static UNDERSCORE: number;

        static QUESTION_MARK: number;

        static TILDE: number;

        static OPEN_BRACKET: number;

        static BACKWARD_SLASH: number;

        static CLOSED_BRACKET: number;

        static QUOTES: number;

        static BACKSPACE: number;

        static TAB: number;

        static CLEAR: number;

        static ENTER: number;

        static SHIFT: number;

        static CONTROL: number;

        static ALT: number;

        static CAPS_LOCK: number;

        static ESC: number;

        static SPACEBAR: number;

        static PAGE_UP: number;

        static PAGE_DOWN: number;

        static END: number;

        static HOME: number;

        static LEFT: number;

        static UP: number;

        static RIGHT: number;

        static DOWN: number;

        static INSERT: number;

        static DELETE: number;

        static HELP: number;

        static NUM_LOCK: number;

        static PLUS: number;

        static MINUS: number;

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        disabled: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {object} event - Stores the most recent DOM event.
        * @readonly
        */
        event: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * Returns the string value of the most recently pressed key.
        * @name Phaser.Keyboard#lastChar
        * @property {string} lastChar - The string value of the most recently pressed key.
        * @readonly
        */
        lastChar: string;

        /**
        * Returns the most recently pressed Key. This is a Phaser.Key object and it changes every time a key is pressed.
        * @name Phaser.Keyboard#lastKey
        * @property {Phaser.Key} lastKey - The most recently pressed Key.
        * @readonly
        */
        lastKey: Phaser.Key;

        /**
        * @property {function} onDownCallback - This callback is invoked every time a key is pressed down, including key repeats when a key is held down.
        */
        onDownCallback: Function;

        /**
        * @property {function} onPressCallback - This callback is invoked every time a DOM onkeypress event is raised, which is only for printable keys.
        */
        onPressCallback: Function;

        /**
        * @property {function} onUpCallback - This callback is invoked every time a key is released.
        */
        onUpCallback: Function;

        /**
        * @property {object} pressEvent - The most recent DOM event from keypress.
        */
        pressEvent: any;

        /**
        * Add callbacks to the Keyboard handler so that each time a key is pressed down or released the callbacks are activated.
        *
        * @method Phaser.Keyboard#addCallbacks
        * @param {object} context - The context under which the callbacks are run.
        * @param {function} [onDown=null] - This callback is invoked every time a key is pressed down.
        * @param {function} [onUp=null] - This callback is invoked every time a key is released.
        * @param {function} [onPress=null] - This callback is invoked every time the onkeypress event is raised.
        */
        addCallbacks(context: any, onDown?: Function, onUp?: Function, onPress?: Function): void;

        /**
        * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
        * The Key object can then be polled, have events attached to it, etc.
        *
        * @method Phaser.Keyboard#addKey
        * @param {number} keycode - The keycode of the key, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR
        * @return {Phaser.Key} The Key object which you can store locally and reference directly.
        */
        addKey(keycode: number): Phaser.Key;

        /**
        * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
        * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
        * You can use addKeyCapture to consume the keyboard event for specific keys so it doesn't bubble up to the the browser.
        * Pass in either a single keycode or an array/hash of keycodes.
        *
        * @method Phaser.Keyboard#addKeyCapture
        * @param {number|array|object} keycode - Either a single numeric keycode or an array/hash of keycodes: [65, 67, 68].
        */
        addKeyCapture(keycode: any): void;

        /**
        * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.
        *
        * @method Phaser.Keyboard#createCursorKeys
        * @return {object} An object containing properties: up, down, left and right. Which can be polled like any other Phaser.Key object.
        */
        createCursorKeys(): Phaser.CursorKeys;

        /**
        * Clear all set key captures.
        *
        * @method Phaser.Keyboard#clearCaptures
        */
        clearCaptures(): void;

        /**
        * Stops the Keyboard event listeners from running (keydown and keyup). They are removed from the window.
        * Also clears all key captures and currently created Key objects.
        *
        * @method Phaser.Keyboard#destroy
        */
        destroy(): void;

        /**
        * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
        * or was pressed down longer ago than then given duration.
        * 
        * @method Phaser.Keyboard#downDuration
        * @param {number} keycode - The keycode of the key to check, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR
        * @param {number} [duration=50] - The duration within which the key is considered as being just pressed. Given in ms.
        * @return {boolean} True if the key was pressed down within the given duration, false if not or null if the Key wasn't found.
        */
        downDuration(keycode: number, duration?: number): boolean;

        /**
        * Returns true of the key is currently pressed down. Note that it can only detect key presses on the web browser.
        *
        * @method Phaser.Keyboard#isDown
        * @param {number} keycode - The keycode of the key to check, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR
        * @return {boolean} True if the key is currently down, false if not or null if the Key wasn't found.
        */
        isDown(keycode: number): boolean;

        /**
        * Process the keydown event.
        *
        * @method Phaser.Keyboard#processKeyDown
        * @param {KeyboardEvent} event
        * @protected
        */
        processKeyDown(event: KeyboardEvent): void;

        /**
        * Process the keypress event.
        *
        * @method Phaser.Keyboard#processKeyPress
        * @param {KeyboardEvent} event
        * @protected
        */
        processKeyPress(event: KeyboardEvent): void;

        /**
        * Process the keyup event.
        *
        * @method Phaser.Keyboard#processKeyUp
        * @param {KeyboardEvent} event
        * @protected
        */
        processKeyUp(event: KeyboardEvent): void;

        /**
        * Removes a Key object from the Keyboard manager.
        *
        * @method Phaser.Keyboard#removeKey
        * @param {number} keycode - The keycode of the key to remove, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR
        */
        removeKey(keycode: number): void;

        /**
        * Removes an existing key capture.
        *
        * @method Phaser.Keyboard#removeKeyCapture
        * @param {number} keycode
        */
        removeKeyCapture(keycode: number): void;

        /**
        * Resets all Keys.
        *
        * @method Phaser.Keyboard#reset
        * @param {boolean} [hard=true] - A soft reset won't reset any events or callbacks that are bound to the Keys. A hard reset will.
        */
        reset(hard?: boolean): void;

        /**
        * Starts the Keyboard event listeners running (keydown and keyup). They are attached to the window.
        * This is called automatically by Phaser.Input and should not normally be invoked directly.
        *
        * @method Phaser.Keyboard#start
        */
        start(): void;

        /**
        * Stops the Keyboard event listeners from running (keydown, keyup and keypress). They are removed from the window.
        *
        * @method Phaser.Keyboard#stop
        */
        stop(): void;

        /**
        * Updates all currently defined keys.
        *
        * @method Phaser.Keyboard#update
        */
        update(): void;

        /**
        * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
        * or was pressed down longer ago than then given duration.
        * 
        * @method Phaser.Keyboard#upDuration
        * @param {number} keycode - The keycode of the key to check, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR
        * @param {number} [duration=50] - The duration within which the key is considered as being just released. Given in ms.
        * @return {boolean} True if the key was released within the given duration, false if not or null if the Key wasn't found.
        */
        upDuration(keycode: number, duration?: number): boolean;

    }
    /**
    * Creates a new Line object with a start and an end point.
    * 
    * @class Phaser.Line
    * @constructor
    * @param {number} [x1=0] - The x coordinate of the start of the line.
    * @param {number} [y1=0] - The y coordinate of the start of the line.
    * @param {number} [x2=0] - The x coordinate of the end of the line.
    * @param {number} [y2=0] - The y coordinate of the end of the line.
    */
    class Line {

        constructor(x1?: number, y1?: number, x2?: number, y2?: number);

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.Point} end - The end point of the line.
        */
        end: Phaser.Point;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
        * @name Phaser.Rectangle#left
        * @property {number} left - The x coordinate of the left of the Rectangle.
        */
        left: number;

        /**
        * @name Phaser.Line#length
        * @property {number} length - Gets the length of the line segment.
        * @readonly
        */
        length: number;

        /**
        * @name Phaser.Line#perpSlope
        * @property {number} perpSlope - Gets the perpendicular slope of the line (x/y).
        * @readonly
        */
        perpSlope: number;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * @name Phaser.Line#slope
        * @property {number} slope - Gets the slope of the line (y/x).
        * @readonly
        */
        slope: number;

        /**
        * @property {Phaser.Point} start - The start point of the line.
        */
        start: Phaser.Point;

        /**
        * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#top
        * @property {number} top - Gets or sets the top of the circle.
        */
        top: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Checks for intersection between two lines as defined by the given start and end points.
        * If asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.
        * Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
        * Adapted from code by Keith Hair
        *
        * @method Phaser.Line.intersectsPoints
        * @param {Phaser.Point} a - The start of the first Line to be checked.
        * @param {Phaser.Point} b - The end of the first line to be checked.
        * @param {Phaser.Point} e - The start of the second Line to be checked.
        * @param {Phaser.Point} f - The end of the second line to be checked.
        * @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.
        * @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.
        * @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.
        */
        static intersectsPoints(a: Phaser.Point, b: Phaser.Point, e: Phaser.Point, f: Phaser.Point, asSegment?: boolean, result?: Phaser.Point): Phaser.Point;

        /**
        * Checks for intersection between two lines as defined by the given start and end points.
        * If asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.
        * Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
        * Adapted from code by Keith Hair
        *
        * @method Phaser.Line.intersectsPoints
        * @param {Phaser.Point} a - The start of the first Line to be checked.
        * @param {Phaser.Point} b - The end of the first line to be checked.
        * @param {Phaser.Point} e - The start of the second Line to be checked.
        * @param {Phaser.Point} f - The end of the second line to be checked.
        * @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.
        * @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.
        * @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.
        */
        static intersects(a: Phaser.Line, b: Phaser.Line, asSegment?: boolean, result?: Phaser.Point): Phaser.Point;

        /**
        * Returns a new Line object with the same values for the start and end properties as this Line object.
        * @method Phaser.Line#clone
        * @param {Phaser.Line} output - Optional Line object. If given the values will be set into the object, otherwise a brand new Line object will be created and returned.
        * @return {Phaser.Line} The cloned Line object.
        */
        clone(output: Phaser.Line): Phaser.Line;

        /**
        * Using Bresenham's line algorithm this will return an array of all coordinates on this line.
        * The start and end points are rounded before this runs as the algorithm works on integers.
        *
        * @method Phaser.Line#coordinatesOnLine
        * @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.
        * @param {array} [results] - The array to store the results in. If not provided a new one will be generated.
        * @return {array} An array of coordinates.
        */
        coordinatesOnLine(stepRate: number, results: any[]): any[];

        /**
        * Sets the line to match the x/y coordinates of the two given sprites.
        * Can optionally be calculated from their center coordinates.
        * @method Phaser.Line#fromSprite
        * @param {Phaser.Sprite} startSprite - The coordinates of this Sprite will be set to the Line.start point.
        * @param {Phaser.Sprite} endSprite - The coordinates of this Sprite will be set to the Line.start point.
        * @param {boolean} [useCenter=false] - If true it will use startSprite.center.x, if false startSprite.x. Note that Sprites don't have a center property by default, so only enable if you've over-ridden your Sprite with a custom class.
        * @return {Phaser.Line} This line object
        */
        fromSprite(startSprite: Phaser.Sprite, endSprite: Phaser.Sprite, useCenter?: boolean): Phaser.Line;

        /**
        * Checks for intersection between this line and another Line.
        * If asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.
        * Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
        *
        * @method Phaser.Line#intersects
        * @param {Phaser.Line} line - The line to check against this one.
        * @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.
        * @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.
        * @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.
        */
        intersects(line: Phaser.Line, asSegment?: boolean, result?: Phaser.Point): Phaser.Point;

        /**
        * Tests if the given coordinates fall on this line. See pointOnSegment to test against just the line segment.
        * @method Phaser.Line#pointOnLine
        * @param {number} x - The line to check against this one.
        * @param {number} y - The line to check against this one.
        * @return {boolean} True if the point is on the line, false if not.
        */
        pointOnLine(x: number, y: number): boolean;

        /**
        * Tests if the given coordinates fall on this line and within the segment. See pointOnLine to test against just the line.
        * @method Phaser.Line#pointOnSegment
        * @param {number} x - The line to check against this one.
        * @param {number} y - The line to check against this one.
        * @return {boolean} True if the point is on the line and segment, false if not.
        */
        pointOnSegment(x: number, y: number): boolean;

        /**
        * Sets the components of the Line to the specified values.
        * @method Phaser.Line#setTo
        * @param {number} [x1=0] - The x coordinate of the start of the line.
        * @param {number} [y1=0] - The y coordinate of the start of the line.
        * @param {number} [x2=0] - The x coordinate of the end of the line.
        * @param {number} [y2=0] - The y coordinate of the end of the line.
        * @return {Phaser.Line} This line object
        */
        setTo(x1?: number, y1?: number, x2?: number, y2?: number): Phaser.Line;

    }
    /**
    * A basic Linked List data structure.
    *
    * This implementation _modifies_ the `prev` and `next` properties of each item added:
    * - The `prev` and `next` properties must be writable and should not be used for any other purpose.
    * - Items _cannot_ be added to multiple LinkedLists at the same time.
    * - Only objects can be added.
    *
    * @class Phaser.LinkedList
    * @constructor
    */
    class LinkedList {

        first: any;

        last: any;

        /**
        * @name Phaser.Timer#next
        * @property {number} next - The time at which the next event will occur.
        * @readonly
        */
        next: any;

        /**
        * @property {Phaser.Point} prev - The previous position of the physics body.
        * @readonly
        */
        prev: any;

        /**
        * @name Phaser.FrameData#total
        * @property {number} total - The total number of frames in this FrameData set.
        * @readonly
        */
        total: number;

        /**
        * Adds a new element to this linked list.
        *
        * @method Phaser.LinkedList#add
        * @param {object} item - The element to add to this list. Can be a Phaser.Sprite or any other object you need to quickly iterate through.
        * @return {object} The item that was added.
        */
        add(item: any): any;

        /**
        * Calls a function on all members of this list, using the member as the context for the callback.
        * The function must exist on the member.
        *
        * @method Phaser.LinkedList#callAll
        * @param {function} callback - The function to call.
        */
        callAll(callback: Function): void;

        /**
        * Removes the given element from this linked list if it exists.
        *
        * @method Phaser.LinkedList#remove
        * @param {object} item - The item to be removed from the list.
        */
        remove(item: any): void;

        /**
        * Resets the first, last, next and previous node pointers in this list.
        *
        * @method Phaser.LinkedList#reset
        */
        reset(): void;

    }
    /**
    * The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.
    * It uses a combination of Image() loading and xhr and provides progress and completion callbacks.
    *
    * @class Phaser.Loader
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Loader {

        constructor(game: Phaser.Game);

        static PHYSICS_LIME_CORONA_JSON: number;

        static PHYSICS_PHASER_JSON: number;

        static TEXTURE_ATLAS_JSON_ARRAY: number;

        static TEXTURE_ATLAS_JSON_HASH: number;

        static TEXTURE_ATLAS_XML_STARLING: number;

        baseURL: string;

        /**
        * @property {boolean|string} crossOrigin - The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.
        * @default
        */
        crossOrigin: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} hasLoaded - True if all assets in the queue have finished loading.
        * @default
        */
        hasLoaded: boolean;

        /**
        * @property {boolean} isLoading - True if the Loader is in the process of loading the queue.
        * @default
        */
        isLoading: boolean;

        /**
        * @property {Phaser.Signal} onFileStart - This event is dispatched immediately before a file starts loading. It's possible the file may still error (404, etc) after this event is sent.
        */
        onFileStart: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onFileComplete - This event is dispatched when a file completes loading successfully.
        */
        onFileComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onFileError - This event is dispatched when a file errors as a result of the load request.
        */
        onFileError: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onLoadComplete - This event is dispatched when the final file in the load queue has either loaded or failed.
        */
        onLoadComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onLoadStart - This event is dispatched when the loading process starts, before the first file has been requested.
        */
        onLoadStart: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onPackComplete - This event is dispatched when an asset pack has either loaded or failed.
        */
        onPackComplete: Phaser.Signal;

        preloadSprite: any;

        /**
        * @property {number} progress - The rounded load progress percentage value (from 0 to 100)
        * @default
        */
        progress: number;

        /**
        * @property {number} progressFloat - The non-rounded load progress value (from 0.0 to 100.0)
        * @default
        */
        progressFloat: number;

        /**
        * @property {boolean} useXDomainRequest - If true and if the browser supports XDomainRequest, it will be used in preference for xhr when loading json files. This is only relevant for IE9 when you know your server/CDN requires it.
        */
        useXDomainRequest: boolean;

        /**
        * Internal function that adds a new entry to the file list. Do not call directly.
        *
        * @method Phaser.Loader#addToFileList
        * @protected
        * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).
        * @param {string} key - The unique Cache ID key of this resource.
        * @param {string} url - The URL the asset will be loaded from.
        * @param {object} properties - Any additional properties needed to load the file.
        */
        addToFileList(type: string, key: string, url: string, properties: any): void;

        /**
        * Add a new texture atlas to the loader. This atlas uses the JSON Array data format.
        *
        * @method Phaser.Loader#atlasJSONArray
        * @param {string} key - Unique asset key of the texture atlas file.
        * @param {string} textureURL - The url of the texture atlas image file.
        * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.
        * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.
        * @return {Phaser.Loader} This Loader instance.
        */
        atlas(key: string, textureURL: string, atlasURL?: string, atlasData?: any, format?: number): Phaser.Loader;

        /**
        * Add a new texture atlas to the loader. This atlas uses the JSON Array data format.
        *
        * @method Phaser.Loader#atlasJSONArray
        * @param {string} key - Unique asset key of the texture atlas file.
        * @param {string} textureURL - The url of the texture atlas image file.
        * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.
        * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.
        * @return {Phaser.Loader} This Loader instance.
        */
        atlasJSONArray(key: string, textureURL: string, atlasURL?: string, atlasData?: any): Phaser.Loader;

        /**
        * Add a new texture atlas to the loader. This atlas uses the JSON Hash data format.
        *
        * @method Phaser.Loader#atlasJSONHash
        * @param {string} key - Unique asset key of the texture atlas file.
        * @param {string} textureURL - The url of the texture atlas image file.
        * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.
        * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.
        * @return {Phaser.Loader} This Loader instance.
        */
        atlasJSONHash(key: string, textureURL: string, atlasURL?: string, atlasData?: any): Phaser.Loader;

        /**
        * Add a new texture atlas to the loader. This atlas uses the Starling XML data format.
        *
        * @method Phaser.Loader#atlasXML
        * @param {string} key - Unique asset key of the texture atlas file.
        * @param {string} textureURL - The url of the texture atlas image file.
        * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.
        * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.
        * @return {Phaser.Loader} This Loader instance.
        */
        atlasXML(key: string, textureURL: string, atlasURL?: string, atlasData?: any): Phaser.Loader;

        /**
        * Add a new audio file to the loader.
        *
        * @method Phaser.Loader#audio
        * @param {string} key - Unique asset key of the audio file.
        * @param {Array|string} urls - An array containing the URLs of the audio files, i.e.: [ 'jump.mp3', 'jump.ogg', 'jump.m4a' ] or a single string containing just one URL.
        * @param {boolean} autoDecode - When using Web Audio the audio files can either be decoded at load time or run-time. They can't be played until they are decoded, but this let's you control when that happens. Decoding is a non-blocking async process.
        * @return {Phaser.Loader} This Loader instance.
        */
        audio(key: string, urls: any, autoDecode?: boolean): Phaser.Loader;

        /**
        * Add a new audiosprite file to the loader. Audio Sprites are a combination of audio files and a JSON configuration.
        * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
        *
        * @method Phaser.Loader#audiosprite
        * @param {string} key - Unique asset key of the audio file.
        * @param {Array|string} urls - An array containing the URLs of the audio files, i.e.: [ 'audiosprite.mp3', 'audiosprite.ogg', 'audiosprite.m4a' ] or a single string containing just one URL.
        * @param {string} atlasURL - The URL of the audiosprite configuration json.
        * @return {Phaser.Loader} This Loader instance.
        */
        audiosprite(key: string, urls: any, atlasurl: string): Phaser.Loader;

        /**
        * Add a binary file to the Loader. It will be loaded via xhr with a responseType of "arraybuffer". You can specify an optional callback to process the file after load.
        * When the callback is called it will be passed 2 parameters: the key of the file and the file data.
        * WARNING: If you specify a callback, the file data will be set to whatever your callback returns. So always return the data object, even if you didn't modify it.
        *
        * @method Phaser.Loader#binary
        * @param {string} key - Unique asset key of the binary file.
        * @param {string} url - URL of the binary file.
        * @param {function} [callback] - Optional callback that will be passed the file after loading, so you can perform additional processing on it.
        * @param {function} [callbackContext] - The context under which the callback will be applied. If not specified it will use the callback itself as the context.
        * @return {Phaser.Loader} This Loader instance.
        */
        binary(key: string, url: string, callback?: Function, callbackContext?: Function): Phaser.Loader;

        /**
        * Add a new bitmap font loading request.
        *
        * @method Phaser.Loader#bitmapFont
        * @param {string} key - Unique asset key of the bitmap font.
        * @param {string} textureURL - The url of the font image file.
        * @param {string} [xmlURL] - The url of the font data file (xml/fnt)
        * @param {object} [xmlData] - An optional XML data object.
        * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.
        * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.
        * @return {Phaser.Loader} This Loader instance.
        */
        bitmapFont(key: string, textureURL: string, xmlURL?: string, xmlData?: any, xSpacing?: number, ySpacing?: number): Phaser.Loader;

        /**
        * Check whether asset exists with a specific key.
        * Use Phaser.Cache to access loaded assets, e.g. Phaser.Cache#checkImageKey
        *
        * @method Phaser.Loader#checkKeyExists
        * @param {string} type - The type asset you want to check.
        * @param {string} key - Key of the asset you want to check.
        * @return {boolean} Return true if exists, otherwise return false.
        */
        checkKeyExists(type: string, key: string): boolean;

        /**
        * Successfully loaded a CSV file.
        *
        * @method Phaser.Loader#csvLoadComplete
        * @param {number} index - The index of the file in the file queue that loaded.
        */
        csvLoadComplete(index: number): void;

        /**
        * Error occured when load a JSON.
        *
        * @method Phaser.Loader#dataLoadError
        * @param {number} index - The index of the file in the file queue that errored.
        */
        dataLoadError(index: number): void;

        /**
        * Called when a file is successfully loaded.
        *
        * @method Phaser.Loader#fileComplete
        * @param {number} index - The index of the file in the file queue that loaded.
        */
        fileComplete(index: number): void;

        /**
        * Error occured when loading a file.
        *
        * @method Phaser.Loader#fileError
        * @param {number} index - The index of the file in the file queue that errored.
        */
        fileError(index: number): void;

        /**
        * Gets the fileList index for the given key.
        *
        * @method Phaser.Loader#getAssetIndex
        * @param {string} type - The type asset you want to check.
        * @param {string} key - Key of the asset you want to check.
        * @return {number} The index of this key in the filelist, or -1 if not found.
        */
        getAsset(type: string, key: string): any;

        /**
        * Gets the fileList index for the given key.
        *
        * @method Phaser.Loader#getAssetIndex
        * @param {string} type - The type asset you want to check.
        * @param {string} key - Key of the asset you want to check.
        * @return {number} The index of this key in the filelist, or -1 if not found.
        */
        getAssetIndex(type: string, key: string): number;

        /**
        * Add an image to the Loader.
        *
        * @method Phaser.Loader#image
        * @param {string} key - Unique asset key of this image file.
        * @param {string} url - URL of image file.
        * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.
        * @return {Phaser.Loader} This Loader instance.
        */
        image(key: string, url: string, overwrite?: boolean): Phaser.Loader;

        /**
        * Add a json file to the Loader.
        *
        * @method Phaser.Loader#json
        * @param {string} key - Unique asset key of the json file.
        * @param {string} url - URL of the json file.
        * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.
        * @return {Phaser.Loader} This Loader instance.
        */
        json(key: string, url: string, overwrite?: boolean): Phaser.Loader;

        /**
        * Successfully loaded a JSON file.
        *
        * @method Phaser.Loader#jsonLoadComplete
        * @param {number} index - The index of the file in the file queue that loaded.
        */
        jsonLoadComplete(index: number): void;

        /**
        * Add an image to the Loader.
        *
        * @method Phaser.Loader#pack
        * @param {string} key - Unique asset key of this image file.
        * @param {string} [url] - URL of the Asset Pack JSON file. If you wish to pass a json object instead set this to null and pass the object as the data parameter.
        * @param {object} [data] - The Asset Pack JSON data. Use this to pass in a json data object rather than loading it from a URL. TODO
        * @param {object} [callbackContext] - Some Loader operations, like Binary and Script require a context for their callbacks. Pass the context here.
        * @return {Phaser.Loader} This Loader instance.
        */
        pack(key: string, url?: string, data?: any, callbackContext?: any): Phaser.Loader;

        /**
        * Add a new physics data object loading request.
        * The data must be in Lime + Corona JSON format. Physics Editor by code'n'web exports in this format natively.
        *
        * @method Phaser.Loader#physics
        * @param {string} key - Unique asset key of the physics json data.
        * @param {string} [url] - The url of the map data file (csv/json)
        * @param {object} [data] - An optional JSON data object. If given then the url is ignored and this JSON object is used for physics data instead.
        * @param {string} [format=Phaser.Physics.LIME_CORONA_JSON] - The format of the physics data.
        * @return {Phaser.Loader} This Loader instance.
        */
        physics(key: string, url?: string, data?: any, format?: string): Phaser.Loader;

        /**
        * Remove all file loading requests.
        *
        * @method Phaser.Loader#removeAll
        */
        removeAll(): void;

        /**
        * Remove loading request of a file.
        *
        * @method Phaser.Loader#removeFile
        * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).
        * @param {string} key - Key of the file you want to remove.
        */
        removeFile(key: string, type: string): void;

        /**
        * Internal function that replaces an existing entry in the file list with a new one. Do not call directly.
        *
        * @method Phaser.Loader#replaceInFileList
        * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).
        * @param {string} key - The unique Cache ID key of this resource.
        * @param {string} url - The URL the asset will be loaded from.
        * @param {object} properties - Any additional properties needed to load the file.
        * @protected
        */
        replaceInFileList(type: string, key: string, url: string, properties: any): void;

        /**
        * Reset loader, this will remove the load queue.
        *
        * @method Phaser.Loader#reset
        */
        reset(): void;

        /**
        * Called automatically by ScaleManager when the game resizes in RESIZE scalemode.
        * We use this to adjust the height of the preloading sprite, if set.
        *
        * @method Phaser.Loader#resize
        * @param {number} width - The new width of the game in pixels.
        * @param {number} height - The new height of the game in pixels.
        */
        resize(): void;

        /**
        * Add a JavaScript file to the Loader. Once loaded the JavaScript file will be automatically turned into a script tag (and executed), so be careful what you load!
        * You can also specify a callback. This will be executed as soon as the script tag has been created.
        *
        * @method Phaser.Loader#script
        * @param {string} key - Unique asset key of the script file.
        * @param {string} url - URL of the JavaScript file.
        * @param {function} [callback] - Optional callback that will be called after the script tag has loaded, so you can perform additional processing.
        * @param {function} [callbackContext] - The context under which the callback will be applied. If not specified it will use the callback itself as the context.
        * @return {Phaser.Loader} This Loader instance.
        */
        script(key: string, url: String, callback?: Function, callbackContext?: any): Phaser.Loader;

        /**
        * You can set a Sprite to be a "preload" sprite by passing it to this method.
        * A "preload" sprite will have its width or height crop adjusted based on the percentage of the loader in real-time.
        * This allows you to easily make loading bars for games. Note that Sprite.visible = true will be set when calling this.
        *
        * @method Phaser.Loader#setPreloadSprite
        * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite or image that will be cropped during the load.
        * @param {number} [direction=0] - A value of zero means the sprite will be cropped horizontally, a value of 1 means its will be cropped vertically.
        */
        setPreloadSprite(sprite: Phaser.Sprite, direction?: number): void;

        /**
        * Add a new sprite sheet to the loader.
        *
        * @method Phaser.Loader#spritesheet
        * @param {string} key - Unique asset key of the sheet file.
        * @param {string} url - URL of the sheet file.
        * @param {number} frameWidth - Width of each single frame.
        * @param {number} frameHeight - Height of each single frame.
        * @param {number} [frameMax=-1] - How many frames in this sprite sheet. If not specified it will divide the whole image into frames.
        * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.
        * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.
        * @return {Phaser.Loader} This Loader instance.
        */
        spritesheet(key: string, url: string, frameWidth: number, frameHeight: number, frameMax?: number, margin?: number, spacing?: number): Phaser.Loader;

        /**
        * Start loading the assets. Normally you don't need to call this yourself as the StateManager will do so.
        *
        * @method Phaser.Loader#start
        */
        start(): void;

        /**
        * Add a text file to the Loader.
        *
        * @method Phaser.Loader#text
        * @param {string} key - Unique asset key of the text file.
        * @param {string} url - URL of the text file.
        * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.
        * @return {Phaser.Loader} This Loader instance.
        */
        text(key: string, url: string, overwrite?: boolean): Phaser.Loader;

        /**
        * Add a new tilemap loading request.
        *
        * @method Phaser.Loader#tilemap
        * @param {string} key - Unique asset key of the tilemap data.
        * @param {string} [url] - The url of the map data file (csv/json)
        * @param {object} [data] - An optional JSON data object. If given then the url is ignored and this JSON object is used for map data instead.
        * @param {number} [format=Phaser.Tilemap.CSV] - The format of the map data. Either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.
        * @return {Phaser.Loader} This Loader instance.
        */
        tilemap(key: string, url?: string, data?: any, format?: number): Phaser.Loader;

        /**
        * Returns the number of files that have already been loaded, even if they errored.
        *
        * @method Phaser.Loader#totalLoadedFiles
        * @return {number} The number of files that have already been loaded (even if they errored)
        */
        totalLoadedFiles(): number;

        /**
        * Returns the number of asset packs that have already been loaded, even if they errored.
        *
        * @method Phaser.Loader#totalLoadedPacks
        * @return {number} The number of asset packs that have already been loaded (even if they errored)
        */
        totalLoadedPacks(): number;

        /**
        * Returns the number of files still waiting to be processed in the load queue. This value decreases as each file in the queue is loaded.
        *
        * @method Phaser.Loader#totalQueuedFiles
        * @return {number} The number of files that still remain in the load queue.
        */
        totalQueuedFiles(): number;

        /**
        * Returns the number of asset packs still waiting to be processed in the load queue. This value decreases as each pack in the queue is loaded.
        *
        * @method Phaser.Loader#totalQueuedPacks
        * @return {number} The number of asset packs that still remain in the load queue.
        */
        totalQueuedPacks(): number;

        /**
        * Add an XML file to the Loader.
        *
        * @method Phaser.Loader#xml
        * @param {string} key - Unique asset key of the xml file.
        * @param {string} url - URL of the xml file.
        * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.
        * @return {Phaser.Loader} This Loader instance.
        */
        xml(key: string, url: string, overwrite?: boolean): Phaser.Loader;

        /**
        * Successfully loaded an XML file.
        *
        * @method Phaser.Loader#xmlLoadComplete
        * @param {number} index - The index of the file in the file queue that loaded.
        */
        xmlLoadComplete(index: number): void;

    }
    /**
    * Phaser.LoaderParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into the Cache.
    *
    * @class Phaser.LoaderParser
    */
    class LoaderParser {

        /**
        * Parse a Bitmap Font from an XML file.
        * 
        * @method Phaser.LoaderParser.bitmapFont
        * @param {Phaser.Game} game - A reference to the current game.
        * @param {object} xml - XML data you want to parse.
        * @param {string} cacheKey - The key of the texture this font uses in the cache.
        * @param {number} [xSpacing=0] - Additional horizontal spacing between the characters.
        * @param {number} [ySpacing=0] - Additional vertical spacing between the characters.
        */
        static bitmapFont(game: Phaser.Game, xml: any, cacheKey: string, xSpacing: number, ySpacing: number): Phaser.FrameData;

    }
    /**
    * A collection of useful mathematical functions.
    *
    * These are normally accessed through `game.math`.
    *
    * @class Phaser.Math
    * @static
    * @see {@link Phaser.Utils}
    * @see {@link Phaser.ArrayUtils}
    */
    class Math {

        static angleBetween(x1: number, y1: number, x2: number, y2: number): number;

        static angleBetweenPoints(point1: Phaser.Point, point2: Phaser.Point): number;

        static angleBetweenY(x1: number, y1: number, x2: number, y2: number): number;

        static angleBetweenPointsY(point1: Phaser.Point, point2: Phaser.Point): number;

        static angleLimit(angle: number, min: number, max: number): number;

        static average(...numbers: number[]): number;

        static bernstein(n: number, i: number): number;

        static bezierInterpolation(v: number[], k: number): number;

        static catmullRom(p0: number, p1: number, p2: number, p3: number, t: number): number;

        static catmullRomInterpolation(v: number[], k: number): number;

        static ceil(value: number): number;

        static ceilTo(value: number, place?: number, base?: number): number;

        static chanceRoll(chance: number): boolean;

        static clamp(x: number, a: number, b: number): number;

        static clampBottom(x: number, a: number): number;

        static degToRad(degrees: number): number;

        static difference(a: number, b: number): number;

        static distance(x1: number, y1: number, x2: number, y2: number): number;

        static distancePow(xy: number, y1: number, x2: number, y2: number, pow?: number): number;

        static distanceRounded(x1: number, y1: number, x2: number, y2: number): number;

        static factorial(value: number): number;

        static floor(value: number): number;

        static floorTo(value: number, place: number, base: number): number;

        static fuzzyCeil(val: number, epsilon?: number): boolean;

        static fuzzyEqual(a: number, b: number, epsilon?: number): boolean;

        static fuzzyLessThan(a: Number, b: number, epsilon?: number): boolean;

        static fuzzyFloor(val: number, epsilon?: number): boolean;

        static fuzzyGreaterThan(a: number, b: number, epsilon?: number): boolean;

        static fuzzyLessThan(a: number, b: number, epsilon?: number): boolean;

        static getRandom<T>(objects: T[], startIndex?: number, length?: number): T;

        static interpolateFloat(a: number, b: number, weight: number): number;

        static isEven(n: number): boolean;

        static isOdd(n: number): boolean;

        static linear(p0: number, p1: number, t: number): number;

        static linearInterpolation(v: number[], k: number): number;

        static limitValue(value: number, min: number, max: number): number;

        static mapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number;

        static max(...numbers: number[]): number;

        static maxAdd(value: number, amount: number, max: number): number;

        static maxProperty(...numbers: number[]): number;

        static min(...numbers: number[]): number;

        static minProperty(...numbers: number[]): number;

        static minSub(value: number, amount: number, min: number): number;

        static normalizeAngle(angle: number, radians?: boolean): number;

        static normalizeLatitude(lat: number): number;

        static normalizeLongitude(lng: number): number;

        static numberArray(start: number, end: number): number[];

        static numberArrayStep(start: number, end: number, step?: number): number[];

        static percent(a: number, b: number, base?: number): number;

        static p2px(v: number): number;

        static PI2: number;

        static radToDeg(radians: number): number;

        static randomSign(): number;

        static reverseAngle(angleRed: number): number;

        static removeRandom<T>(objects: T[], startIndex?: number, length?: number): T;

        static roundTo(value: number, place?: number, base?: number): number;

        static shear(n: number): number;

        static shift(stack: any[]): any;

        static shuffleArray(array: any[]): any[];

        static sign(x: number): number;

        static sinCosGenerator(length: number, sinAmplitude?: number, cosAmplitude?: number, frequency?: number): { sin: number[]; cos: number[]; };

        static smootherstep(x: number, min: number, max: number): number;

        static smoothstep(x: number, min: number, max: number): number;

        static snapTo(input: number, gap: number, start?: number): number;

        static snapToCeil(input: number, gap: number, start?: number): number;

        static snapToFloor(input: number, gap: number, start?: number): number;

        static snapToInArray(input: number, arr: number[], sort?: boolean): number;

        static truncate(n: number): number;

        static within(a: number, b: number, tolerance: number): boolean;

        static wrap(value: number, min: number, max: number): number;

        static wrapAngle(angle: number, radians?: boolean): number;

        static wrapValue(value: number, amount: number, max: number): number;

    }
    interface WheelEventProxy {
        bindEvent(event: any): WheelEventProxy;
        type: string;
        deltaMode: number;
        deltaX: number;
        deltaY: number;
        deltaZ: number;
    }
    /**
    * The Mouse class is responsible for handling all aspects of mouse interaction with the browser.
    *
    * It captures and processes mouse events that happen on the game canvas object. It also adds a single `mouseup` listener to `window` which
    * is used to capture the mouse being released when not over the game.
    *
    * @class Phaser.Mouse
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Mouse {

        constructor(game: Phaser.Game);

        static LEFT_BUTTON: number;

        static MIDDLE_BUTTON: number;

        static NO_BUTTON: number;

        static RIGHT_BUTTON: number;

        static WHEEL_DOWN: number;

        static WHEEL_UP: number;

        /**
        * @property {any} button - The button property of the Pointer as set by the DOM event when this Pointer is started.
        * @default
        */
        button: number;

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        /**
        * @property {boolean} capture - If true the DOM mouse events will have event.preventDefault applied to them, if false they will propogate fully.
        */
        capture: boolean;

        disabled: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {object} event - Stores the most recent DOM event.
        * @readonly
        */
        event: MouseEvent;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} locked - If the mouse has been Pointer Locked successfully this will be set to true.
        * @default
        */
        locked: boolean;

        mouseDownCallback: (event: MouseEvent) => void;

        mouseMoveCallback: (event: MouseEvent) => void;

        mouseOutCallback: (event: MouseEvent) => void;

        mouseOverCallback: (event: MouseEvent) => void;

        mouseUpCallback: (event: MouseEvent) => void;

        mouseWheelCallback: (event: MouseEvent) => void;

        _onMouseDown: (event: MouseEvent) => void;

        _onMouseMove: (event: MouseEvent) => void;

        _onMouseUp: (event: MouseEvent) => void;

        _onMouseOut: (event: MouseEvent) => void;

        _onMouseOver: (event: MouseEvent) => void;

        _onMouseWheel: (event: MouseEvent) => void;

        _wheelEvent: WheelEventProxy;

        /**
        * @property {Phaser.Signal} pointerLock - This event is dispatched when the browser enters or leaves pointer lock state.
        * @default
        */
        pointerLock: Phaser.Signal;

        /**
        * @property {boolean} stopOnGameOut - If true Pointer.stop will be called if the mouse leaves the game canvas.
        * @default
        */
        stopOnGameOut: boolean;

        /**
        * @property {number} wheelDelta - The direction of the _last_ mousewheel usage 1 for up -1 for down
        */
        wheelDelta: WheelEventProxy;

        /**
        * The internal method that handles the mouse down event from the browser.
        * @method Phaser.Mouse#onMouseDown
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseDown(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse move event from the browser.
        * @method Phaser.Mouse#onMouseMove
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseMove(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse out event from the browser.
        *
        * @method Phaser.Mouse#onMouseOut
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseOut(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse over event from the browser.
        *
        * @method Phaser.Mouse#onMouseOver
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseOver(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse up event from the browser.
        * @method Phaser.Mouse#onMouseUp
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseUp(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse up event from the window.
        * 
        * @method Phaser.Mouse#onMouseUpGlobal
        * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.
        */
        onMouseUpGlobal(event: MouseEvent): void;

        /**
        * The internal method that handles the mouse wheel event from the browser.
        *
        * @method Phaser.Mouse#onMouseWheel
        * @param {MouseEvent} event - The native event from the browser.
        */
        onMouseWheel(event: MouseEvent): void;

        /**
        * Internal pointerLockChange handler.
        * 
        * @method Phaser.Mouse#pointerLockChange
        * @param {Event} event - The native event from the browser. This gets stored in Mouse.event.
        */
        pointerLockChange(event: MouseEvent): void;

        /**
        * Internal release pointer lock handler.
        * @method Phaser.Mouse#releasePointerLock
        */
        releasePointerLock(): void;

        /**
        * If the browser supports it you can request that the pointer be locked to the browser window.
        * This is classically known as 'FPS controls', where the pointer can't leave the browser until the user presses an exit key.
        * If the browser successfully enters a locked state the event Phaser.Mouse.pointerLock will be dispatched and the first parameter will be 'true'.
        * @method Phaser.Mouse#requestPointerLock
        */
        requestPointerLock(): void;

        /**
        * Starts the event listeners running.
        * @method Phaser.Mouse#start
        */
        start(): void;

        /**
        * Stop the event listeners.
        * @method Phaser.Mouse#stop
        */
        stop(): void;

    }
    /**
    * The MSPointer class handles Microsoft touch interactions with the game and the resulting Pointer objects.
    *
    * It will work only in Internet Explorer 10 and Windows Store or Windows Phone 8 apps using JavaScript.
    * http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx
    *
    * @class Phaser.MSPointer
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class MSPointer {

        constructor(game: Phaser.Game);

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        disabled: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * The function that handles the PointerDown event.
        * 
        * @method Phaser.MSPointer#onPointerDown
        * @param {PointerEvent} event - The native DOM event.
        */
        onPointerDown(event: MSPointerEvent): void;

        /**
        * The function that handles the PointerMove event.
        * @method Phaser.MSPointer#onPointerMove
        * @param {PointerEvent} event - The native DOM event.
        */
        onPointerMove(event: MSPointerEvent): void;

        /**
        * The function that handles the PointerUp event.
        * @method Phaser.MSPointer#onPointerUp
        * @param {PointerEvent} event - The native DOM event.
        */
        onPointerUp(event: MSPointerEvent): void;

        mouseDownCallback(event: MSPointerEvent): void;

        mouseMoveCallback(event: MSPointerEvent): void;

        mouseUpCallback(event: MSPointerEvent): void;

        /**
        * Starts the event listeners running.
        * @method Phaser.MSPointer#start
        */
        start(): void;

        /**
        * Stop the event listeners.
        * @method Phaser.MSPointer#stop
        */
        stop(): void;

    }
    /**
    * Phaser.Net handles browser URL related tasks such as checking host names, domain names and query string manipulation.
    *
    * @class Phaser.Net
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Net {

        constructor(game: Phaser.Game);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * Compares the given domain name against the hostname of the browser containing the game.
        * If the domain name is found it returns true.
        * You can specify a part of a domain, for example 'google' would match 'google.com', 'google.co.uk', etc.
        * Do not include 'http://' at the start.
        *
        * @method Phaser.Net#checkDomainName
        * @param {string} domain
        * @return {boolean} true if the given domain fragment can be found in the window.location.hostname
        */
        checkDomainName(domain: string): boolean;

        /**
        * Returns the Query String as an object.
        * If you specify a parameter it will return just the value of that parameter, should it exist.
        *
        * @method Phaser.Net#decodeURI
        * @param {string} value - The URI component to be decoded.
        * @return {string} The decoded value.
        */
        decodeURI(value: string): string;

        /**
        * Returns the hostname given by the browser.
        *
        * @method Phaser.Net#getHostName
        * @return {string}
        */
        getHostName(): string;

        /**
        * Returns the Query String as an object.
        * If you specify a parameter it will return just the value of that parameter, should it exist.
        *
        * @method Phaser.Net#getQueryString
        * @param {string} [parameter=''] - If specified this will return just the value for that key.
        * @return {string|object} An object containing the key value pairs found in the query string or just the value if a parameter was given.
        */
        getQueryString(parameter?: string): string;

        /**
        * Updates a value on the Query String and returns it in full.
        * If the value doesn't already exist it is set.
        * If the value exists it is replaced with the new value given. If you don't provide a new value it is removed from the query string.
        * Optionally you can redirect to the new url, or just return it as a string.
        *
        * @method Phaser.Net#updateQueryString
        * @param {string} key - The querystring key to update.
        * @param {string} value - The new value to be set. If it already exists it will be replaced.
        * @param {boolean} redirect - If true the browser will issue a redirect to the url with the new querystring.
        * @param {string} url - The URL to modify. If none is given it uses window.location.href.
        * @return {string} If redirect is false then the modified url and query string is returned.
        */
        updateQueryString(key: string, value: any, redirect?: boolean, url?: string): string;

    }
    /**
    * Create a new `Particle` object. Particles are extended Sprites that are emitted by a particle emitter such as Phaser.Particles.Arcade.Emitter.
    * 
    * @class Phaser.Particle
    * @constructor
    * @extends Phaser.Sprite
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate (in world space) to position the Particle at.
    * @param {number} y - The y coordinate (in world space) to position the Particle at.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Particle during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
    * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    */
    class Particle extends Phaser.Sprite {

        constructor(game: Phaser.Game, x: number, y: number, key?: any, frame?: any);

        /**
        * Called by the Emitter when this particle is emitted. Left empty for you to over-ride as required.
        *
        * @method Phaser.Particle#onEmit
        * @memberof Phaser.Particle
        */
        onEmit(): void;

        /**
        * Resets the Particle. This places the Particle at the given x/y world coordinates and then
        * sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state and health values.
        * If the Particle has a physics body that too is reset.
        *
        * @method Phaser.Particle#reset
        * @memberof Phaser.Particle
        * @param {number} x - The x coordinate (in world space) to position the Particle at.
        * @param {number} y - The y coordinate (in world space) to position the Particle at.
        * @param {number} [health=1] - The health to give the Particle.
        * @return (Phaser.Particle) This instance.
        */
        reset(x: number, y: number, health?: number): Phaser.Particle;

        /**
        * Called by the Emitter if autoAlpha has been enabled. Passes over the alpha ease data and resets the alpha counter.
        *
        * @method Phaser.Particle#setAlphaData
        * @memberof Phaser.Particle
        */
        setAlphaData(data: any[]): void;

        /**
        * Called by the Emitter if autoScale has been enabled. Passes over the scale ease data and resets the scale counter.
        *
        * @method Phaser.Particle#setScaleData
        * @memberof Phaser.Particle
        */
        setScaleData(data: any[]): void;

        /**
        * Updates the Particle scale or alpha if autoScale and autoAlpha are set.
        *
        * @method Phaser.Particle#update
        * @memberof Phaser.Particle
        */
        update(): void;

    }
    /**
    * Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.
    *
    * @class Phaser.Particles
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Particles {

        constructor(game: Phaser.Game);

        /**
        * @property {object} emitters - Internal emitters store.
        */
        emitters: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} ID -
        * @default
        */
        ID: number;

        /**
        * Adds a new Particle Emitter to the Particle Manager.
        * @method Phaser.Particles#add
        * @param {Phaser.Emitter} emitter - The emitter to be added to the particle manager.
        * @return {Phaser.Emitter} The emitter that was added.
        */
        add(emitter: Phaser.Particles.Arcade.Emitter): Phaser.Particles.Arcade.Emitter;

        /**
        * Removes an existing Particle Emitter from the Particle Manager.
        * @method Phaser.Particles#remove
        * @param {Phaser.Emitter} emitter - The emitter to remove.
        */
        remove(emitter: Phaser.Particles.Arcade.Emitter): void;

        /**
        * Called by the core game loop. Updates all Emitters who have their exists value set to true.
        * @method Phaser.Particles#update
        * @protected
        */
        update(): void;

    }
    module Particles {

        module Arcade {

            /**
            * Emitter is a lightweight particle emitter that uses Arcade Physics.
            * It can be used for one-time explosions or for continuous effects like rain and fire.
            * All it really does is launch Particle objects out at set intervals, and fixes their positions and velocities accordingly.
            * 
            * @class Phaser.Particles.Arcade.Emitter
            * @constructor
            * @extends Phaser.Group
            * @param {Phaser.Game} game - Current game instance.
            * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.
            * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.
            * @param {number} [maxParticles=50] - The total number of particles in this emitter.
            */
            class Emitter extends Phaser.Group {

                constructor(game: Phaser.Game, x?: number, y?: number, maxParticles?: number);

                /**
                * @property {array} alphaData - A reference to the alphaData array owned by the Emitter that emitted this Particle.
                * @protected
                */
                alphaData: any[];

                /**
                * @property {boolean} autoAlpha - If this Particle automatically changes alpha this is set to true by Particle.setAlphaData.
                * @protected
                */
                autoAlpha: boolean;

                /**
                * @property {boolean} autoScale - If this Particle automatically scales this is set to true by Particle.setScaleData.
                * @protected
                */
                autoScale: boolean;

                /**
                * @name Phaser.Line#angle
                * @property {number} angle - Gets the angle of the line.
                * @readonly
                */
                angle: number;

                /**
                * @property {number} angularDrag - The angular drag applied to the rotation of the Body.
                * @default
                */
                angularDrag: number;

                /**
                * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @name Phaser.Circle#bottom
                * @property {number} bottom - Gets or sets the bottom of the circle.
                */
                bottom: number;

                /**
                * @property {Phaser.Point} bounce - The elasticitiy of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.
                */
                bounce: Phaser.Point;

                emitX: number;

                emitY: number;

                /**
                * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
                * @default
                */
                exists: boolean;

                /**
                * @property {boolean} frequency - How often a particle is emitted in ms (if emitter is started with Explode === false).
                * @default
                */
                frequency: number;

                /**
                * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
                */
                gravity: number;

                group: Phaser.Group;

                /**
                * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
                */
                height: number;

                /**
                * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
                * @name Phaser.Rectangle#left
                * @property {number} left - The x coordinate of the left of the Rectangle.
                */
                left: number;

                /**
                * @property {number} lifespan - How long each particle lives once it is emitted in ms. Default is 2 seconds. Set lifespan to 'zero' for particles to live forever.
                * @default
                */
                lifespan: number;

                /**
                * @property {number} maxParticles - The total number of particles in this emitter.
                * @default
                */
                maxParticles: number;

                /**
                * @property {number} maxParticleScale - The maximum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see maxParticleScaleX.
                * @default
                */
                maxParticleScale: number;

                /**
                * @property {Phaser.Point} maxParticleSpeed - The maximum possible velocity of a particle.
                * @default
                */
                maxParticleSpeed: Phaser.Point;

                /**
                * @property {number} maxRotation - The maximum possible angular velocity of a particle.
                * @default
                */
                maxRotation: number;

                /**
                * @property {number} minParticleScale - The minimum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see minParticleScaleX.
                * @default
                */
                minParticleScale: number;

                /**
                * @property {Phaser.Point} minParticleSpeed - The minimum possible velocity of a particle.
                * @default
                */
                minParticleSpeed: Phaser.Point;

                /**
                * @property {number} minRotation - The minimum possible angular velocity of a particle.
                * @default
                */
                minRotation: number;

                /**
                * @property {string} name - The name of this object.
                * @default
                */
                name: string;

                /**
                * @property {boolean} on - Determines whether the emitter is currently emitting particles. It is totally safe to directly toggle this.
                * @default
                */
                on: boolean;

                /**
                * @property {boolean} particleBringToTop - If this is `true` then when the Particle is emitted it will be bought to the top of the Emitters display list.
                * @default
                */
                particleBringToTop: boolean;

                /**
                * @property {boolean} particleSendToBack - If this is `true` then when the Particle is emitted it will be sent to the back of the Emitters display list.
                * @default
                */
                particleSendToBack: boolean;

                /**
                * @property {any} particleClass - For emitting your own particle class types. They must extend Phaser.Particle.
                * @default
                */
                particleClass: Phaser.Sprite;

                /**
                * @property {Phaser.Point} particleDrag - The X and Y drag component of particles launched from the emitter.
                */
                particleDrag: Phaser.Point;

                /**
                * @property {Phaser.Point} position - Current position of the camera in world.
                * @private
                * @default
                */
                position: Phaser.Point;

                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @name Phaser.Circle#right
                * @property {number} right - Gets or sets the value of the rightmost point of the circle.
                */
                right: number;

                /**
                * @property {array} scaleData - A reference to the scaleData array owned by the Emitter that emitted this Particle.
                * @protected
                */
                scaleData: any[];

                /**
                * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @name Phaser.Circle#top
                * @property {number} top - Gets or sets the top of the circle.
                */
                top: number;

                /**
                * @property {number} type - The base object type.
                */
                type: number;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                /**
                * Change the emitters center to match the center of any object with a `center` property, such as a Sprite.
                * If the object doesn't have a center property it will be set to object.x + object.width / 2
                *
                * @method Phaser.Particles.Arcade.Emitter#at
                * @param {object|Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Text|PIXI.DisplayObject} object - The object that you wish to match the center with.
                */
                at(object: any): void;

                /**
                * This function can be used both internally and externally to emit the next particle in the queue.
                *
                * @method Phaser.Particles.Arcade.Emitter#emitParticle
                */
                emitParticle(): void;

                /**
                * Call this function to emit the given quantity of particles at all once (an explosion)
                * 
                * @method Phaser.Particles.Arcade.Emitter#explode
                * @param {number} [lifespan=0] - How long each particle lives once emitted in ms. 0 = forever.
                * @param {number} [quantity=0] - How many particles to launch.
                */
                explode(lifespan?: number, quantity?: number): void;

                /**
                * Call this function to start emitting a flow of particles at the given frequency.
                * 
                * @method Phaser.Particles.Arcade.Emitter#flow
                * @param {number} [lifespan=0] - How long each particle lives once emitted in ms. 0 = forever.
                * @param {number} [frequency=250] - Frequency is how often to emit a particle, given in ms.
                * @param {number} [quantity=0] - How many particles to launch.
                */
                flow(lifespan?: number, frequency?: number, quantity?: number): void;

                /**
                * Call this function to turn off all the particles and the emitter.
                *
                * @method Phaser.Particles.Arcade.Emitter#kill
                */
                kill(): void;

                /**
                * This function generates a new set of particles for use by this emitter.
                * The particles are stored internally waiting to be emitted via Emitter.start.
                *
                * @method Phaser.Particles.Arcade.Emitter#makeParticles
                * @param {array|string} keys - A string or an array of strings that the particle sprites will use as their texture. If an array one is picked at random.
                * @param {array|number} [frames=0] - A frame number, or array of frames that the sprite will use. If an array one is picked at random.
                * @param {number} [quantity] - The number of particles to generate. If not given it will use the value of Emitter.maxParticles.
                * @param {boolean} [collide=false] - If you want the particles to be able to collide with other Arcade Physics bodies then set this to true.
                * @param {boolean} [collideWorldBounds=false] - A particle can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.
                * @return {Phaser.Particles.Arcade.Emitter} This Emitter instance.
                */
                makeParticles(keys: any, frames?: any, quantity?: number, collide?: boolean, collideWorldBounds?: boolean): Phaser.Particles.Arcade.Emitter;

                reset(x: number, y: number, health?: number): Phaser.Particles;

                /**
                * A more compact way of setting the alpha constraints of the particles.
                * The rate parameter, if set to a value above zero, lets you set the speed at which the Particle change in alpha from min to max.
                * If rate is zero, which is the default, the particle won't change alpha - instead it will pick a random alpha between min and max on emit.
                *
                * @method Phaser.Particles.Arcade.Emitter#setAlpha
                * @param {number} [min=1] - The minimum value for this range.
                * @param {number} [max=1] - The maximum value for this range.
                * @param {number} [rate=0] - The rate (in ms) at which the particles will change in alpha from min to max, or set to zero to pick a random alpha between the two.
                * @param {number} [ease=Phaser.Easing.Linear.None] - If you've set a rate > 0 this is the easing formula applied between the min and max values.
                * @param {boolean} [yoyo=false] - If you've set a rate > 0 you can set if the ease will yoyo or not (i.e. ease back to its original values)
                */
                setAlpha(min?: number, max?: number, rate?: number, ease?: number, yoyo?: boolean): void;

                /**
                * A more compact way of setting the angular velocity constraints of the particles.
                *
                * @method Phaser.Particles.Arcade.Emitter#setRotation
                * @param {number} [min=0] - The minimum value for this range.
                * @param {number} [max=0] - The maximum value for this range.
                */
                setRotation(min?: number, max?: number): void;

                /**
                * A more compact way of setting the scale constraints of the particles.
                * The rate parameter, if set to a value above zero, lets you set the speed and ease which the Particle uses to change in scale from min to max across both axis.
                * If rate is zero, which is the default, the particle won't change scale during update, instead it will pick a random scale between min and max on emit.
                *
                * @method Phaser.Particles.Arcade.Emitter#setScale
                * @param {number} [minX=1] - The minimum value of Particle.scale.x.
                * @param {number} [maxX=1] - The maximum value of Particle.scale.x.
                * @param {number} [minY=1] - The minimum value of Particle.scale.y.
                * @param {number} [maxY=1] - The maximum value of Particle.scale.y.
                * @param {number} [rate=0] - The rate (in ms) at which the particles will change in scale from min to max, or set to zero to pick a random size between the two.
                * @param {number} [ease=Phaser.Easing.Linear.None] - If you've set a rate > 0 this is the easing formula applied between the min and max values.
                * @param {boolean} [yoyo=false] - If you've set a rate > 0 you can set if the ease will yoyo or not (i.e. ease back to its original values)
                */
                setScale(minX?: number, maxX?: number, minY?: number, maxY?: number, rate?: number, ease?: (k: number) => number, yoyo?: boolean): void;

                /**
                * A more compact way of setting the width and height of the emitter.
                * 
                * @method Phaser.Particles.Arcade.Emitter#setSize
                * @param {number} width - The desired width of the emitter (particles are spawned randomly within these dimensions).
                * @param {number} height - The desired height of the emitter.
                */
                setSize(width: number, height: number): void;

                /**
                * A more compact way of setting the X velocity range of the emitter.
                * @method Phaser.Particles.Arcade.Emitter#setXSpeed
                * @param {number} [min=0] - The minimum value for this range.
                * @param {number} [max=0] - The maximum value for this range.
                */
                setXSpeed(min: number, max: number): void;

                /**
                * A more compact way of setting the Y velocity range of the emitter.
                * @method Phaser.Particles.Arcade.Emitter#setYSpeed
                * @param {number} [min=0] - The minimum value for this range.
                * @param {number} [max=0] - The maximum value for this range.
                */
                setYSpeed(min: number, max: number): void;

                /**
                * Call this function to start emitting particles.
                * 
                * @method Phaser.Particles.Arcade.Emitter#start
                * @param {boolean} [explode=true] - Whether the particles should all burst out at once (true) or at the frequency given (false).
                * @param {number} [lifespan=0] - How long each particle lives once emitted in ms. 0 = forever.
                * @param {number} [frequency=250] - Ignored if Explode is set to true. Frequency is how often to emit 1 particle. Value given in ms.
                * @param {number} [quantity=0] - How many particles to launch. 0 = "all of the particles".
                * @param {number} [forceQuantity=false] - If true and creating a particle flow, the quantity emitted will be forced to the be quantity given in this call.
                */
                start(explode?: boolean, lifespan?: number, frequency?: number, quantity?: number, forceQuantity?: boolean): void;

                /**
                * Called automatically by the game loop, decides when to launch particles and when to "die".
                * @method Phaser.Particles.Arcade.Emitter#update
                */
                update(): void;

                /**
                * Handy for bringing game objects "back to life". Just sets alive and exists back to true.
                *
                * @method Phaser.Particles.Arcade.Emitter#revive
                */
                revive(): void;

            }
        }
    }
    /**
    * The Physics Manager is responsible for looking after all of the running physics systems.
    * Phaser supports 4 physics systems: Arcade Physics, P2, Ninja Physics and Box2D via a commercial plugin.
    * 
    * Game Objects (such as Sprites) can only belong to 1 physics system, but you can have multiple systems active in a single game.
    *
    * For example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the
    * faster (due to being much simpler) Arcade Physics system.
    *
    * @class Phaser.Physics
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.
    */
    class Physics {

        constructor(game: Phaser.Game, config?: any);

        static ARCADE: number;

        static P2JS: number;

        static NINJA: number;

        static BOX2D: number;

        static CHIPMUNK: number;

        /**
        * @property {Phaser.Physics.Arcade} arcade - The Arcade Physics system.
        */
        arcade: Phaser.Physics.Arcade;

        /**
        * @property {object} config - The Phaser.Game configuration object.
        */
        config: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Physics.Ninja} ninja - The N+ Ninja Physics system.
        */
        ninja: Phaser.Physics.Ninja;

        /**
        * @property {Phaser.Physics.P2} p2 - The P2.JS Physics system.
        */
        p2: Phaser.Physics.P2;

        /**
        * Clears down all active physics systems. This doesn't destroy them, it just clears them of objects and is called when the State changes.
        *
        * @method Phaser.Physics#clear
        * @protected
        */
        clear(): void;

        /**
        * Destroys all active physics systems. Usually only called on a Game Shutdown, not on a State swap.
        *
        * @method Phaser.Physics#destroy
        */
        destroy(): void;

        /**
        * This will create a default physics body on the given game object or array of objects.
        * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
        * It can be for any of the physics systems that have been started:
        *
        * Phaser.Physics.Arcade - A light weight AABB based collision system with basic separation.
        * Phaser.Physics.P2JS - A full-body advanced physics system supporting multiple object shapes, polygon loading, contact materials, springs and constraints.
        * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system. Advanced AABB and Circle vs. Tile collision.
        * Phaser.Physics.BOX2D - A port of https://code.google.com/p/box2d-html5
        * Phaser.Physics.CHIPMUNK is still in development.
        *
        * If you require more control over what type of body is created, for example to create a Ninja Physics Circle instead of the default AABB, then see the
        * individual physics systems `enable` methods instead of using this generic one.
        *
        * @method Phaser.Physics#enable
        * @param {object|array} object - The game object to create the physics body on. Can also be an array of objects, a body will be created on every object in the array.
        * @param {number} [system=Phaser.Physics.ARCADE] - The physics system that will be used to create the body. Defaults to Arcade Physics.
        * @param {boolean} [debug=false] - Enable the debug drawing for this body. Defaults to false.
        */
        enable(object: any, system?: number, debug?: boolean): void;

        /**
        * Parses the Physics Configuration object passed to the Game constructor and starts any physics systems specified within.
        *
        * @method Phaser.Physics#parseConfig
        */
        parseConfig(): void;

        /**
        * preUpdate checks.
        *
        * @method Phaser.Physics#preUpdate
        * @protected
        */
        preUpdate(): void;

        /**
        * Updates the physics bounds to match the world dimensions.
        *
        * @method Phaser.Physics#setBoundsToWorld
        * @protected
        */
        setBoundsToWorld(): void;

        /**
        * This will create an instance of the requested physics simulation.
        * Phaser.Physics.Arcade is running by default, but all others need activating directly.
        * 
        * You can start the following physics systems:
        * 
        * Phaser.Physics.P2JS - A full-body advanced physics system by Stefan Hedman.
        * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system.
        * Phaser.Physics.BOX2D - A commercial Phaser Plugin (see http://phaser.io)
        *
        * Both Ninja Physics and Box2D require their respective plugins to be loaded before you can start them.
        * They are not bundled into the core Phaser library.
        *
        * If the physics world has already been created (i.e. in another state in your game) then 
        * calling startSystem will reset the physics world, not re-create it. If you need to start them again from their constructors 
        * then set Phaser.Physics.p2 (or whichever system you want to recreate) to `null` before calling `startSystem`.
        *
        * @method Phaser.Physics#startSystem
        * @param {number} system - The physics system to start: Phaser.Physics.ARCADE, Phaser.Physics.P2JS, Phaser.Physics.NINJA or Phaser.Physics.BOX2D.
        */
        startSystem(system: number): void;

        /**
        * Updates all running physics systems.
        *
        * @method Phaser.Physics#update
        * @protected
        */
        update(): void;

    }
    module Physics {

        /**
        * The Arcade Physics world. Contains Arcade Physics related collision, overlap and motion methods.
        *
        * @class Phaser.Physics.Arcade
        * @constructor
        * @param {Phaser.Game} game - reference to the current game instance.
        */
        class Arcade {

            /**
            * @property {number} OVERLAP_BIAS - A value added to the delta values during collision checks.
            */
            static OVERLAP_BIAS: number;

            /**
            * @property {number} TILE_BIAS - A value added to the delta values during collision with tiles. Adjust this if you get tunnelling.
            */
            static TILE_BIAS: number;

            constructor(game: Phaser.Game);

            /**
            * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
            * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
            * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
            * 
            * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
            */
            bounds: Phaser.Rectangle;

            /**
            * Set the checkCollision properties to control for which bounds collision is processed.
            * For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.
            * @property {object} checkCollision - An object containing allowed collision flags.
            */
            checkCollision: { up?: boolean; down?: boolean; left?: boolean; right?: boolean; };

            /**
            * @property {boolean} forceX - If true World.separate will always separate on the X axis before Y. Otherwise it will check gravity totals first.
            */
            forceX: boolean;

            /**
            * @property {Phaser.Game} game - A reference to the currently running Game.
            */
            game: Phaser.Game;

            /**
            * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
            */
            gravity: Phaser.Point;

            /**
            * @property {Phaser.QuadTree} quadTree - The world QuadTree.
            */
            quadTree: Phaser.QuadTree;

            /**
            * @property {number} maxObjects - The maximum number of objects per node.
            * @default
            */
            maxObjects: number;

            /**
            * @property {number} maxLevels - The maximum number of levels to break down to.
            * @default
            */
            maxLevels: number;

            /**
            * @property {boolean} skipQuadTree - If true the QuadTree will not be used for any collision. QuadTrees are great if objects are well spread out in your game, otherwise they are a performance hit. If you enable this you can disable on a per body basis via `Body.skipQuadTree`.
            */
            skipQuadTree: boolean;

            /**
            * Given the rotation (in radians) and speed calculate the acceleration and return it as a Point object, or set it to the given point object.
            * One way to use this is: accelerationFromRotation(rotation, 200, sprite.acceleration) which will set the values directly to the sprites acceleration and not create a new Point object.
            *
            * @method Phaser.Physics.Arcade#accelerationFromRotation
            * @param {number} rotation - The angle in radians.
            * @param {number} [speed=60] - The speed it will move, in pixels per second sq.
            * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated acceleration.
            * @return {Phaser.Point} - A Point where point.x contains the acceleration x value and point.y contains the acceleration y value.
            */
            accelerationFromRotation(rotation: number, speed?: number, point?: Phaser.Point): Phaser.Point;

            /**
            * Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)
            * You must give a maximum speed value, beyond which the display object won't go any faster.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            *
            * @method Phaser.Physics.Arcade#accelerateToObject
            * @param {any} displayObject - The display object to move.
            * @param {any} destination - The display object to move towards. Can be any object but must have visible x/y properties.
            * @param {number} [speed=60] - The speed it will accelerate in pixels per second.
            * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.
            * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.
            */
            accelerateToObject(displayObject: any, destination: any, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

            /**
            * Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)
            * You must give a maximum speed value, beyond which the display object won't go any faster.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            *
            * @method Phaser.Physics.Arcade#accelerateToPointer
            * @param {any} displayObject - The display object to move.
            * @param {Phaser.Pointer} [pointer] - The pointer to move towards. Defaults to Phaser.Input.activePointer.
            * @param {number} [speed=60] - The speed it will accelerate in pixels per second.
            * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.
            * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.
            */
            accelerateToPointer(displayObject: any, pointer?: Phaser.Pointer, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

            /**
            * Sets the acceleration.x/y property on the display object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)
            * You must give a maximum speed value, beyond which the display object won't go any faster.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            *
            * @method Phaser.Physics.Arcade#accelerateToXY
            * @param {any} displayObject - The display object to move.
            * @param {number} x - The x coordinate to accelerate towards.
            * @param {number} y - The y coordinate to accelerate towards.
            * @param {number} [speed=60] - The speed it will accelerate in pixels per second.
            * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.
            * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.
            */
            accelerateToXY(displayObject: any, x: number, y: number, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

            /**
            * Find the angle in radians between two display objects (like Sprites).
            *
            * @method Phaser.Physics.Arcade#angleBetween
            * @param {any} source - The Display Object to test from.
            * @param {any} target - The Display Object to test to.
            * @return {number} The angle in radians between the source and target display objects.
            */
            angleBetween(source: any, target: any): number;

            /**
            * Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x/y and center into account.
            *
            * @method Phaser.Physics.Arcade#angleToPointer
            * @param {any} displayObject - The Display Object to test from.
            * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.
            * @return {number} The angle in radians between displayObject.x/y to Pointer.x/y
            */
            angleToPointer(displayObject: any, pointer?: Phaser.Pointer): number;

            /**
            * Find the angle in radians between a display object (like a Sprite) and the given x/y coordinate.
            *
            * @method Phaser.Physics.Arcade#angleToXY
            * @param {any} displayObject - The Display Object to test from.
            * @param {number} x - The x coordinate to get the angle to.
            * @param {number} y - The y coordinate to get the angle to.
            * @return {number} The angle in radians between displayObject.x/y to Pointer.x/y
            */
            angleToXY(displayObject: any, x: number, y: number): number;

            /**
            * Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.
            * Both the first and second parameter can be arrays of objects, of differing types.
            * If two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.
            * The objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.
            * An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,
            * giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.
            * The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.
            * NOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups or Tilemaps within other Groups).
            *
            * @method Phaser.Physics.Arcade#collide
            * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.TilemapLayer|array} object1 - The first object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.TilemapLayer.
            * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.TilemapLayer|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.TilemapLayer.
            * @param {function} [collideCallback=null] - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are colliding Group vs. Sprite, in which case Sprite will always be the first parameter.
            * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.
            * @param {object} [callbackContext] - The context in which to run the callbacks.
            * @return {boolean} True if a collision occured otherwise false.
            */
            collide(object1: any, object2: any, collideCallback?: Function, processCallback?: Function, callbackContext?: any): boolean;

            /**
            * A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
            * Based on a function in Flixel by @ADAMATOMIC
            *
            * @method Phaser.Physics.Arcade#computeVelocity
            * @param {number} axis - 0 for nothing, 1 for horizontal, 2 for vertical.
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to be updated.
            * @param {number} velocity - Any component of velocity (e.g. 20).
            * @param {number} acceleration - Rate at which the velocity is changing.
            * @param {number} drag - Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
            * @param {number} [max=10000] - An absolute value cap for the velocity.
            * @return {number} The altered Velocity value.
            */
            computeVelocity(axis: number, body: Phaser.Physics.Arcade.Body, velocity: number, acceleration: number, drag: number, max?: number): number;

            /**
            * Find the distance between two display objects (like Sprites).
            *
            * @method Phaser.Physics.Arcade#distanceBetween
            * @param {any} source - The Display Object to test from.
            * @param {any} target - The Display Object to test to.
            * @return {number} The distance between the source and target objects.
            */
            distanceBetween(source: any, target: any): number;

            /**
            * Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.
            * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.
            * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()
            *
            * @method Phaser.Physics.Arcade#distanceToPointer
            * @param {any} displayObject - The Display Object to test from.
            * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.
            * @return {number} The distance between the object and the Pointer.
            */
            distanceToPointer(displayObject: any, pointer?: Phaser.Pointer): number;

            /**
            * Find the distance between a display object (like a Sprite) and the given x/y coordinates.
            * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.
            * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()
            *
            * @method Phaser.Physics.Arcade#distanceToXY
            * @param {any} displayObject - The Display Object to test from.
            * @param {number} x - The x coordinate to move towards.
            * @param {number} y - The y coordinate to move towards.
            * @return {number} The distance between the object and the x/y coordinates.
            */
            distanceToXY(displayObject: any, x: number, y: number): number;

            /**
            * This will create an Arcade Physics body on the given game object or array of game objects.
            * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
            *
            * @method Phaser.Physics.Arcade#enable
            * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.
            * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.
            */
            enable(object: any, children?: Boolean): void;

            /**
            * Creates an Arcade Physics body on the given game object.
            * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
            *
            * @method Phaser.Physics.Arcade#enableBody
            * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.
            */
            enableBody(object: any): void;

            /**
            * Given a Group and a location this will check to see which Group children overlap with the coordinates.
            * Each child will be sent to the given callback for further processing.
            * Note that the children are not checked for depth order, but simply if they overlap the coordinate or not.
            *
            * @method Phaser.Physics.Arcade#getObjectsAtLocation
            * @param {Phaser.Pointer} pointer - The Pointer to check.
            * @param {Phaser.Group} group - The Group to check.
            * @param {function} [callback] - A callback function that is called if the object overlaps the coordinates. The callback will be sent two parameters: the callbackArg and the Object that overlapped the location.
            * @param {object} [callbackContext] - The context in which to run the callback.
            * @param {object} [callbackArg] - An argument to pass to the callback.
            * @return {PIXI.DisplayObject[]} An array of the Sprites from the Group that overlapped the coordinates.
            */
            getObjectsAtLocation(x: number, y: number, group: Phaser.Group, callback?: (callbackArg: any, object: any) => void, callbackContext?: any, callbackArg?: any): Sprite[];

            /**
            * Check for intersection against two bodies.
            *
            * @method Phaser.Physics.Arcade#intersects
            * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to check.
            * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to check.
            * @return {boolean} True if they intersect, otherwise false.
            */
            intersects(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body): boolean;

            /**
            * Move the given display object towards the destination object at a steady velocity.
            * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.
            * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
            *
            * @method Phaser.Physics.Arcade#moveToObject
            * @param {any} displayObject - The display object to move.
            * @param {any} destination - The display object to move towards. Can be any object but must have visible x/y properties.
            * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)
            * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
            */
            moveToObject(displayObject: any, destination: any, speed?: number, maxTime?: number): number;

            /**
            * Move the given display object towards the pointer at a steady velocity. If no pointer is given it will use Phaser.Input.activePointer.
            * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
            * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            *
            * @method Phaser.Physics.Arcade#moveToPointer
            * @param {any} displayObject - The display object to move.
            * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)
            * @param {Phaser.Pointer} [pointer] - The pointer to move towards. Defaults to Phaser.Input.activePointer.
            * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
            */
            moveToPointer(displayObject: any, speed?: number, pointer?: Phaser.Pointer, maxTime?: number): number;

            /**
            * Move the given display object towards the x/y coordinates at a steady velocity.
            * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
            * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
            * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
            * Note: The display object doesn't stop moving once it reaches the destination coordinates.
            * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
            *
            * @method Phaser.Physics.Arcade#moveToXY
            * @param {any} displayObject - The display object to move.
            * @param {number} x - The x coordinate to move towards.
            * @param {number} y - The y coordinate to move towards.
            * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)
            * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.
            * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.
            */
            moveToXY(displayObject: any, x: number, y: number, speed?: number, maxTime?: number): number;

            /**
            * Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.
            * You can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.
            * Unlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.
            * Both the first and second parameter can be arrays of objects, of differing types.
            * If two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.
            * NOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups within Groups).
            *
            * @method Phaser.Physics.Arcade#overlap
            * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|array} object1 - The first object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.
            * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.
            * @param {function} [overlapCallback=null] - An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them.
            * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then overlapCallback will only be called if processCallback returns true.
            * @param {object} [callbackContext] - The context in which to run the callbacks.
            * @return {boolean} True if an overlap occurred otherwise false.
            */
            overlap(object1: any, object2: any, overlapCallback?: Function, processCallback?: Function, callbackContext?: any): boolean;

            /**
            * Internal function to process the separation of a physics body from a tile.
            *
            * @private
            * @method Phaser.Physics.Arcade#processTileSeparationX
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.
            * @param {number} x - The x separation amount.
            * @return {boolean} Returns true as a pass-thru to the separateTile method.
            */
            processTileSeparationX(body: Phaser.Physics.Arcade.Body, x: number): boolean;

            /**
            * Internal function to process the separation of a physics body from a tile.
            *
            * @private
            * @method Phaser.Physics.Arcade#processTileSeparationY
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.
            * @param {number} y - The y separation amount.
            */
            processTileSeparationY(body: Phaser.Physics.Arcade.Body, y: number): void;

            /**
            * Updates the size of this physics world.
            *
            * @method Phaser.Physics.Arcade#setBounds
            * @param {number} x - Top left most corner of the world.
            * @param {number} y - Top left most corner of the world.
            * @param {number} width - New width of the world. Can never be smaller than the Game.width.
            * @param {number} height - New height of the world. Can never be smaller than the Game.height.
            */
            setBounds(x: number, y: number, width: number, height: number): void;

            /**
            * Updates the size of this physics world to match the size of the game world.
            *
            * @method Phaser.Physics.Arcade#setBoundsToWorld
            */
            setBoundsToWorld(): void;

            /**
            * The core separation function to separate two physics bodies.
            *
            * @private
            * @method Phaser.Physics.Arcade#separate
            * @param {Phaser.Physics.Arcade.Body} body1 - The first Body object to separate.
            * @param {Phaser.Physics.Arcade.Body} body2 - The second Body object to separate.
            * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this function is set then the sprites will only be collided if it returns true.
            * @param {object} [callbackContext] - The context in which to run the process callback.
            * @param {boolean} overlapOnly - Just run an overlap or a full collision.
            * @return {boolean} Returns true if the bodies collided, otherwise false.
            */
            separate(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, processCallback?: Function, callbackContext?: any, overlapOnly?: boolean): boolean;

            /**
            * The core separation function to separate two physics bodies on the x axis.
            *
            * @private
            * @method Phaser.Physics.Arcade#separateX
            * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to separate.
            * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to separate.
            * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.
            * @return {boolean} Returns true if the bodies were separated, otherwise false.
            */
            separateX(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean): boolean;

            /**
            * The core separation function to separate two physics bodies on the y axis.
            *
            * @private
            * @method Phaser.Physics.Arcade#separateY
            * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to separate.
            * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to separate.
            * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.
            * @return {boolean} Returns true if the bodies were separated, otherwise false.
            */
            separateY(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean): boolean;

            /**
            * The core separation function to separate a physics body and a tile.
            *
            * @private
            * @method Phaser.Physics.Arcade#separateTile
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.
            * @param {Phaser.Tile} tile - The tile to collide against.
            * @return {boolean} Returns true if the body was separated, otherwise false.
            */
            separateTile(i: number, body: Phaser.Physics.Arcade.Body, tile: Phaser.Tile): boolean;

            /**
            * Check the body against the given tile on the X axis.
            *
            * @private
            * @method Phaser.Physics.Arcade#tileCheckX
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.
            * @param {Phaser.Tile} tile - The tile to check.
            * @return {number} The amount of separation that occured.
            */
            tileCheckX(body: Phaser.Physics.Arcade.Body, tile: Phaser.Tile): number;

            /**
            * Check the body against the given tile on the Y axis.
            *
            * @private
            * @method Phaser.Physics.Arcade#tileCheckY
            * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.
            * @param {Phaser.Tile} tile - The tile to check.
            * @return {number} The amount of separation that occured.
            */
            tileCheckY(body: Phaser.Physics.Arcade.Body, tile: Phaser.Tile): number;

            /**
            * Called automatically by a Physics body, it updates all motion related values on the Body.
            *
            * @method Phaser.Physics.Arcade#updateMotion
            * @param {Phaser.Physics.Arcade.Body} The Body object to be updated.
            */
            updateMotion(body: Phaser.Physics.Arcade.Body): void;

            /**
            * Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
            * One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
            *
            * @method Phaser.Physics.Arcade#velocityFromAngle
            * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
            * @param {number} [speed=60] - The speed it will move, in pixels per second sq.
            * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated velocity.
            * @return {Phaser.Point} - A Point where point.x contains the velocity x value and point.y contains the velocity y value.
            */
            velocityFromAngle(angle: number, speed?: number, point?: Phaser.Point): Phaser.Point;

            /**
            * Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
            * One way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
            *
            * @method Phaser.Physics.Arcade#velocityFromRotation
            * @param {number} rotation - The angle in radians.
            * @param {number} [speed=60] - The speed it will move, in pixels per second sq.
            * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated velocity.
            * @return {Phaser.Point} - A Point where point.x contains the velocity x value and point.y contains the velocity y value.
            */
            velocityFromRotation(rotation: number, speed?: number, point?: Phaser.Point): Phaser.Point;

        }
        module Arcade {

            /**
            * The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than
            * the Sprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.
            *
            * @class Phaser.Physics.Arcade.Body
            * @constructor
            * @param {Phaser.Sprite} sprite - The Sprite object this physics body belongs to.
            */
            class Body {

                constructor(sprite: Phaser.Sprite);

                /**
                * @property {Phaser.Point} acceleration - The velocity in pixels per second sq. of the Body.
                */
                acceleration: Phaser.Point;

                /**
                * @property {boolean} allowGravity - Allow this Body to be influenced by gravity? Either world or local.
                * @default
                */
                allowGravity: boolean;

                /**
                * @property {boolean} allowRotation - Allow this Body to be rotated? (via angularVelocity, etc)
                * @default
                */
                allowRotation: boolean;

                /**
                * @name Phaser.Line#angle
                * @property {number} angle - Gets the angle of the line.
                * @readonly
                */
                angle: number;

                /**
                * @property {number} angularAcceleration - The angular acceleration in pixels per second sq. of the Body.
                * @default
                */
                angularAcceleration: number;

                /**
                * @property {number} angularDrag - The angular drag applied to the rotation of the Body.
                * @default
                */
                angularDrag: number;

                /**
                * @property {number} angularVelocity - The angular velocity in pixels per second sq. of the Body.
                * @default
                */
                angularVelocity: number;

                /**
                * This object is populated with boolean values when the Body collides with the World bounds or a Tile.
                * For example if blocked.up is true then the Body cannot move up.
                * @property {object} blocked - An object containing on which faces this Body is blocked from moving, if any.
                */
                blocked: FaceChoices;

                /**
                * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @name Phaser.Circle#bottom
                * @property {number} bottom - Gets or sets the bottom of the circle.
                */
                bottom: number;

                /**
                * @property {Phaser.Point} bounce - The elasticitiy of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.
                */
                bounce: Phaser.Point;

                /**
                * @property {Phaser.Point} center - The center coordinate of the Physics Body.
                */
                center: Phaser.Point;

                /**
                * Set the checkCollision properties to control for which bounds collision is processed.
                * For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.
                * @property {object} checkCollision - An object containing allowed collision flags.
                */
                checkCollision: FaceChoices;

                /**
                * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.
                * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?
                */
                collideWorldBounds: boolean;

                /**
                * This flag allows you to disable the custom x separation that takes place by Physics.Arcade.separate.
                * Used in combination with your own collision processHandler you can create whatever type of collision response you need.
                * @property {boolean} customSeparateX - Use a custom separation system or the built-in one?
                * @default
                */
                customSeparateX: boolean;

                /**
                * This flag allows you to disable the custom y separation that takes place by Physics.Arcade.separate.
                * Used in combination with your own collision processHandler you can create whatever type of collision response you need.
                * @property {boolean} customSeparateY - Use a custom separation system or the built-in one?
                * @default
                */
                customSeparateY: boolean;

                /**
                * @property {Phaser.Point} deltaMax - The Sprite position is updated based on the delta x/y values. You can set a cap on those (both +-) using deltaMax.
                */
                deltaMax: Phaser.Point;

                /**
                * @property {Phaser.Point} drag - The drag applied to the motion of the Body.
                */
                drag: Phaser.Point;

                /**
                * If a body is overlapping with another body, but neither of them are moving (maybe they spawned on-top of each other?) this is set to true.
                * @property {boolean} embedded - Body embed value.
                */
                embedded: boolean;

                /**
                * @property {boolean} enable - A disabled body won't be checked for any form of collision or overlap or have its pre/post updates run.
                * @default
                */
                enable: boolean;

                /**
                * @property {number} facing - A const reference to the direction the Body is traveling or facing.
                * @default
                */
                facing: number;

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
                */
                gravity: Phaser.Point;

                /**
                * @name Phaser.Rectangle#halfWidth
                * @property {number} halfWidth - Half of the width of the Rectangle.
                * @readonly
                */
                halfWidth: number;

                /**
                * @name Phaser.Rectangle#halfHeight
                * @property {number} halfHeight - Half of the height of the Rectangle.
                * @readonly
                */
                halfHeight: number;

                /**
                * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies.
                * @default
                */
                immovable: boolean;

                /**
                * @property {number} mass - The mass of the Body.
                * @default
                */
                mass: number;

                /**
                * @property {number} maxAngular - The maximum angular velocity in pixels per second sq. that the Body can reach.
                * @default
                */
                maxAngular: number;

                /**
                * @property {Phaser.Point} maxVelocity - The maximum velocity in pixels per second sq. that the Body can reach.
                * @default
                */
                maxVelocity: Phaser.Point;

                /**
                * If you have a Body that is being moved around the world via a tween or a Group motion, but its local x/y position never
                * actually changes, then you should set Body.moves = false. Otherwise it will most likely fly off the screen.
                * If you want the physics system to move the body around, then set moves to true.
                * @property {boolean} moves - Set to true to allow the Physics system to move this Body, other false to move it manually.
                * @default
                */
                moves: boolean;

                /**
                * @property {Phaser.Point} newVelocity - New velocity.
                * @readonly
                */
                newVelocity: Phaser.Point;

                /**
                * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.
                */
                offset: Phaser.Point;

                /**
                * When this body collides with another, the amount of overlap is stored here.
                * @property {number} overlapX - The amount of horizontal overlap during the collision.
                */
                overlapX: number;

                /**
                * When this body collides with another, the amount of overlap is stored here.
                * @property {number} overlapY - The amount of vertical overlap during the collision.
                */
                overlapY: number;

                phase: number;

                /**
                * @property {Phaser.Point} position - Current position of the camera in world.
                * @private
                * @default
                */
                position: Phaser.Point;

                /**
                * @property {number} preRotation - The previous rotation of the physics body.
                * @readonly
                */
                preRotation: number;

                /**
                * @property {Phaser.Point} prev - The previous position of the physics body.
                * @readonly
                */
                prev: Phaser.Point;

                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @name Phaser.Circle#right
                * @property {number} right - Gets or sets the value of the rightmost point of the circle.
                */
                right: number;

                /**
                * @property {number} rotation - The amount the Body is rotated.
                */
                rotation: number;

                /**
                * @property {boolean} skipQuadTree - If true the QuadTree will not be used for any collision. QuadTrees are great if objects are well spread out in your game, otherwise they are a performance hit. If you enable this you can disable on a per body basis via `Body.skipQuadTree`.
                */
                skipQuadTree: boolean;

                /**
                * @property {number} sourceWidth - The un-scaled original size.
                * @readonly
                */
                sourceWidth: number;

                /**
                * @property {number} sourceHeight - The un-scaled original size.
                * @readonly
                */
                sourceHeight: number;

                /**
                * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
                */
                speed: number;

                /**
                * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
                */
                sprite: Phaser.Sprite;

                /**
                * If this is an especially small or fast moving object then it can sometimes skip over tilemap collisions if it moves through a tile in a step.
                * Set this padding value to add extra padding to its bounds. tilePadding.x applied to its width, y to its height.
                * @property {Phaser.Point} tilePadding - Extra padding to be added to this sprites dimensions when checking for tile collision.
                */
                tilePadding: Phaser.Point;

                /**
                * This object is populated with boolean values when the Body collides with another.
                * touching.up = true means the collision happened to the top of this Body for example.
                * @property {object} touching - An object containing touching results.
                */
                touching: FaceChoices;

                /**
                * @property {number} type - The base object type.
                */
                type: number;

                /**
                * This object is populated with previous touching values from the bodies previous collision.
                * @property {object} wasTouching - An object containing previous touching results.
                */
                wasTouching: FaceChoices;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Point;

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                /**
                * Internal method.
                *
                * @method Phaser.Physics.Arcade.Body#checkWorldBounds
                * @protected
                */
                checkWorldBounds(): void;

                /**
                * Returns the delta x value. The difference between Body.x now and in the previous step.
                *
                * @method Phaser.Physics.Arcade.Body#deltaX
                * @return {number} The delta value. Positive if the motion was to the right, negative if to the left.
                */
                deltaX(): number;

                /**
                * Returns the delta y value. The difference between Body.y now and in the previous step.
                *
                * @method Phaser.Physics.Arcade.Body#deltaY
                * @return {number} The delta value. Positive if the motion was downwards, negative if upwards.
                */
                deltaY(): number;

                /**
                * Returns the delta z value. The difference between Body.rotation now and in the previous step.
                *
                * @method Phaser.Physics.Arcade.Body#deltaZ
                * @return {number} The delta value. Positive if the motion was clockwise, negative if anti-clockwise.
                */
                deltaZ(): number;

                /**
                * Returns the absolute delta x value.
                *
                * @method Phaser.Physics.Arcade.Body#deltaAbsX
                * @return {number} The absolute delta value.
                */
                deltaAbsX(): void;

                /**
                * Returns the absolute delta y value.
                *
                * @method Phaser.Physics.Arcade.Body#deltaAbsY
                * @return {number} The absolute delta value.
                */
                deltaAbsY(): void;

                /**
                * Removes this bodies reference to its parent sprite, freeing it up for gc.
                *
                * @method Phaser.Physics.Arcade.Body#destroy
                */
                destroy(): void;

                /**
                * Tests if a world point lies within this Body.
                *
                * @method Phaser.Physics.Arcade.Body#hitTest
                * @param {number} x - The world x coordinate to test.
                * @param {number} y - The world y coordinate to test.
                * @return {boolean} True if the given coordinates are inside this Body, otherwise false.
                */
                hitTest(x: number, y: number): boolean;

                /**
                * Returns true if the bottom of this Body is in contact with either the world bounds or a tile.
                *
                * @method Phaser.Physics.Arcade.Body#onFloor
                * @return {boolean} True if in contact with either the world bounds or a tile.
                */
                onFloor(): void;

                /**
                * Returns true if either side of this Body is in contact with either the world bounds or a tile.
                *
                * @method Phaser.Physics.Arcade.Body#onWall
                * @return {boolean} True if in contact with either the world bounds or a tile.
                */
                onWall(): void;

                /**
                * Internal method.
                *
                * @method Phaser.Physics.Arcade.Body#preUpdate
                * @protected
                */
                preUpdate(): void;

                /**
                * Internal method.
                *
                * @method Phaser.Physics.Arcade.Body#postUpdate
                * @protected
                */
                postUpdate(): void;

                /**
                * Render Sprite Body.
                *
                * @method Phaser.Physics.Arcade.Body#render
                * @param {object} context - The context to render to.
                * @param {Phaser.Physics.Arcade.Body} body - The Body to render the info of.
                * @param {string} [color='rgba(0,255,0,0.4)'] - color of the debug info to be rendered. (format is css color string).
                * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)
                */
                render(context: any, body: Phaser.Physics.Arcade.Body, color?: string, filled?: boolean): void;

                /**
                * Render Sprite Body Physics Data as text.
                *
                * @method Phaser.Physics.Arcade.Body#renderBodyInfo
                * @param {Phaser.Physics.Arcade.Body} body - The Body to render the info of.
                * @param {number} x - X position of the debug info to be rendered.
                * @param {number} y - Y position of the debug info to be rendered.
                * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
                */
                renderBodyInfo(debug: Phaser.Utils.Debug, body: Phaser.Physics.Arcade.Body): void;

                /**
                * Resets all Body values (velocity, acceleration, rotation, etc)
                *
                * @method Phaser.Physics.Arcade.Body#reset
                * @param {number} x - The new x position of the Body.
                * @param {number} y - The new y position of the Body.
                */
                reset(x: number, y: number): void;

                /**
                * You can modify the size of the physics Body to be any dimension you need.
                * So it could be smaller or larger than the parent Sprite. You can also control the x and y offset, which
                * is the position of the Body relative to the top-left of the Sprite.
                *
                * @method Phaser.Physics.Arcade.Body#setSize
                * @param {number} width - The width of the Body.
                * @param {number} height - The height of the Body.
                * @param {number} [offsetX] - The X offset of the Body from the Sprite position.
                * @param {number} [offsetY] - The Y offset of the Body from the Sprite position.
                */
                setSize(width: number, height: number, offsetX?: number, offsetY?: number): void;

                /**
                * Internal method.
                *
                * @method Phaser.Physics.Arcade.Body#updateBounds
                * @protected
                */
                updateBounds(): boolean;

            }
            class FaceChoices {

                none: boolean;

                any: boolean;

                up: boolean;

                down: boolean;

                /**
                * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
                * @name Phaser.Rectangle#left
                * @property {number} left - The x coordinate of the left of the Rectangle.
                */
                left: boolean;

                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @name Phaser.Circle#right
                * @property {number} right - Gets or sets the value of the rightmost point of the circle.
                */
                right: boolean;

            }
        }
        class Ninja {

            constructor(game: Phaser.Game);

            /**
            * @property {Phaser.Game} game - A reference to the currently running Game.
            */
            game: Phaser.Game

            /**
            * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
            */
            gravity: number;

            /**
            * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
            * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
            * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
            * 
            * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
            */
            bounds: Phaser.Rectangle;

            /**
            * @property {number} maxObjects - The maximum number of objects per node.
            * @default
            */
            maxObjects: number;

            /**
            * @property {number} maxLevels - The maximum number of levels to break down to.
            * @default
            */
            maxLevels: number;

            /**
            * @property {Phaser.QuadTree} quadTree - The world QuadTree.
            */
            quadTree: Phaser.QuadTree;

            /**
            * @property {Phaser.Time} time - A reference to the game clock and timed events system.
            */
            time: Phaser.Time;

            clearTilemapLayerBodies(map: Phaser.Tilemap, layer: any): void;

            collide(object1: any, object2: any, collideCallback?: Function, processCallback?: Function, callbackContext?: any): boolean;

            convertTilemap(map: Phaser.Tilemap, layer?: any, slopeMap?: any): Phaser.Physics.Ninja.Tile[];

            enableAABB(object: any, children?: boolean): void;

            enableCircle(object: any, radius: number, children?: boolean): void;

            enableTile(object: any, id: number, children?: boolean): void;

            enable(object: any, type?: number, id?: number, radius?: number, children?: boolean): void;

            enableBody(object: any, type?: number, id?: number, radius?: number): void;

            overlap(object1: any, object2: any, overlapCallback?: Function, processCallback?: Function, callbackContext?: any): boolean;

            separate(body1: Phaser.Physics.Ninja.Body, body2: Phaser.Physics.Ninja.Body, processCallback?: Function, callbackContext?: any, overlapOnly?: boolean): boolean;

            setBounds(x: number, y: number, width: number, height: number): void;

            setBoundsToWorld(): void;

        }
        module Ninja {

            class Body {

                constructor(system: Phaser.Physics.Ninja, sprite: Phaser.Sprite, type?: number, id?: number, radius?: number, x?: number, y?: number, width?: number, height?: number);

                aabb: Phaser.Physics.Ninja.AABB;

                /**
                * @name Phaser.Line#angle
                * @property {number} angle - Gets the angle of the line.
                * @readonly
                */
                angle: number;

                /**
                * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @name Phaser.Circle#bottom
                * @property {number} bottom - Gets or sets the bottom of the circle.
                */
                bottom: number;

                /**
                * @property {Phaser.Point} bounce - The elasticitiy of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.
                */
                bounce: number;

                /**
                * Set the checkCollision properties to control for which bounds collision is processed.
                * For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.
                * @property {object} checkCollision - An object containing allowed collision flags.
                */
                checkCollision: Phaser.Physics.Arcade.FaceChoices;

                circle: Phaser.Physics.Ninja.Circle;

                /**
                * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.
                * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?
                */
                collideWorldBounds: boolean;

                /**
                * @property {Phaser.Point} drag - The drag applied to the motion of the Body.
                */
                drag: number;

                /**
                * @property {number} facing - A const reference to the direction the Body is traveling or facing.
                * @default
                */
                facing: number;

                /**
                * @name Phaser.Physics.P2#friction
                * @property {number} friction - Friction between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.
                */
                friction: number;

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                gravityScale: number;

                /**
                * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
                */
                height: number;

                /**
                * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies.
                * @default
                */
                immovable: boolean;

                maxSpeed: number;

                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @name Phaser.Circle#right
                * @property {number} right - Gets or sets the value of the rightmost point of the circle.
                */
                right: number;

                /**
                * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
                */
                sprite: Phaser.Sprite;

                system: Phaser.Physics.Ninja;

                tile: Phaser.Physics.Ninja.Tile;

                /**
                * This object is populated with boolean values when the Body collides with another.
                * touching.up = true means the collision happened to the top of this Body for example.
                * @property {object} touching - An object containing touching results.
                */
                touching: Phaser.Physics.Arcade.FaceChoices;

                /**
                * @property {number} type - The base object type.
                */
                type: number;

                shape: any;

                /**
                * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
                */
                speed: number;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Point;

                /**
                * This object is populated with previous touching values from the bodies previous collision.
                * @property {object} wasTouching - An object containing previous touching results.
                */
                wasTouching: Phaser.Physics.Arcade.FaceChoices;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                deltaAbsX(): number;

                deltaAbsY(): number;

                deltaX(): number;

                deltaY(): number;

                destroy(): void;

                setZeroVelocity(): void;

                moveTo(speed: number, angle: number): void;

                moveFrom(speed: number, angle: number): void;

                moveLeft(speed: number): void;

                moveRight(speed: number): void;

                moveUp(speed: number): void;

                moveDown(speed: number): void;

                poseUpdate(): void;

                preUpdate(): void;

                render(context: any, body: Phaser.Physics.Ninja.Body, color?: string, filled?: boolean): void;

                reset(): void;

            }
            class AABB {

                constructor(body: Phaser.Physics.Ninja.Body, x: number, y: number, width: number, height: number);

                static COL_NONE: number;

                static COL_AXIS: number;

                static COL_OTHER: number;

                aabbTileProjections: any;

                /**
                * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
                */
                body: Phaser.Physics.Ninja.Body;

                /**
                * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
                */
                height: number;

                oldPos: Phaser.Point;

                pos: Phaser.Point;

                system: Phaser.Physics.Ninja;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Point;

                xw: number;

                yw: number;

                collideWorldBounds(): void;

                collideAABBVsAABB(aabb: Phaser.Physics.Ninja.AABB): boolean;

                collideAABBVsTile(tile: Phaser.Physics.Ninja.Tile): boolean;

                destroy(): void;

                integrate(): void;

                render(context: any, xOffset: number, yOffset: number, color: string, filled: boolean): void;

                reportCollisionVsWorld(px: number, py: number, dx: number, dy: number, obj: any): void;

                reportCollisionVsBody(px: number, py: number, dx: number, dy: number, obj: any): void;

                resolveTile(x: number, y: number, body: Phaser.Physics.Ninja.AABB, tile: Phaser.Physics.Ninja.Tile): boolean;

                reverse(): void;

            }
            class Circle {

                constructor(body: Phaser.Physics.Ninja.Body, x: number, y: number, radius: number);

                COL_NONE: number;

                COL_AXIS: number;

                COL_OTHER: number;

                /**
                * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
                */
                body: Phaser.Physics.Ninja.Body;

                circleTileProjections: any;

                oldPos: Phaser.Point;

                /**
                * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
                */
                height: number;

                pos: Phaser.Point;

                /**
                * The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter.
                * @name Phaser.Circle#radius
                * @property {number} radius - Gets or sets the radius of the circle.
                */
                radius: number;

                system: Phaser.Physics.Ninja;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Point;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                xw: number;

                yw: number;

                collideCircleVsTile(tile: Phaser.Physics.Ninja.Tile): boolean;

                collideWorldBounds(): void;

                destroy(): void;

                distance(dest: number, round?: boolean): number;

                integrate(): void;

                render(context: any, xOffset: number, yOffset: number, color: string, filled: boolean): void;

                reportCollisionVsWorld(px: number, py: number, dx: number, dy: number, obj: any): void;

                reportCollisionVsBody(px: number, py: number, dx: number, dy: number, obj: any): void;

                resolveCircleTile(x: number, y: number, oH: number, oV: number, obj: Phaser.Physics.Ninja.Circle, t: Phaser.Physics.Ninja.Tile): boolean;

            }
            class Tile {

                constructor(body: Phaser.Physics.Ninja.Body, x: number, y: number, width: number, height: number, type?: number);

                /**
                * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
                */
                body: Phaser.Physics.Ninja.Body;

                /**
                * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @name Phaser.Circle#bottom
                * @property {number} bottom - Gets or sets the bottom of the circle.
                */
                bottom: number;

                /**
                * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
                */
                height: number;

                /**
                * @property {number} id - Reserved for future multiple camera set-ups.
                * @default
                */
                id: number;

                oldpos: Phaser.Point;

                pos: Phaser.Point;

                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @name Phaser.Circle#right
                * @property {number} right - Gets or sets the value of the rightmost point of the circle.
                */
                right: number;

                system: Phaser.Physics.Ninja;

                /**
                * @property {number} type - The base object type.
                */
                type: number;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Point;

                /**
                * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
                */
                width: number;

                xw: number;

                yw: number;

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                clear(): void;

                collideWorldBounds(): void;

                destroy(): void;

                integrate(): void;

                reportCollisionVsWorld(px: number, py: number, dx: number, dy: number, obj: any): void;

                setType(id: number): number;

            }
        }
        /**
        * This is your main access to the P2 Physics World.
        * From here you can create materials, listen for events and add bodies into the physics simulation.
        * 
        * @class Phaser.Physics.P2
        * @constructor
        * @param {Phaser.Game} game - Reference to the current game instance.
        * @param {object} [config] - Physics configuration object passed in from the game constructor.
        */
        class P2 {

            constructor(game: Phaser.Game, config?: any);

            /**
            * @name Phaser.Physics.P2#applyDamping
            * @property {boolean} applyDamping - Enable to automatically apply body damping each step.
            */
            applyDamping: boolean;

            /**
            * @name Phaser.Physics.P2#applyGravity
            * @property {boolean} applyGravity - Enable to automatically apply gravity each step.
            */
            applyGravity: boolean;

            /**
            * @name Phaser.Physics.P2#applySpringForces
            * @property {boolean} applySpringForces - Enable to automatically apply spring forces each step.
            */
            applySpringForces: boolean;

            /**
            * @property {array} boundsCollidesWith - An array of the bodies the world bounds collides with.
            */
            boundsCollidesWith: Phaser.Physics.P2.Body[];

            /**
            * @property {Phaser.Physics.P2.CollisionGroup} boundsCollisionGroup - A default collision group.
            */
            boundsCollisionGroup: Phaser.Physics.P2.CollisionGroup;

            /**
            * @property {object} config - The Phaser.Game configuration object.
            */
            config: any;

            /**
            * @property {object} callbackContext - The context under which the callbacks are run.
            */
            callbackContext: any;

            /**
            * @property {array} collisionGroups - An array containing the collision groups that have been defined in the World.
            */
            collisionGroups: Phaser.Physics.P2.CollisionGroup[];

            /**
            * @name Phaser.Physics.P2#contactMaterial
            * @property {p2.ContactMaterial} contactMaterial - The default Contact Material being used by the World.
            */
            contactMaterial: Phaser.Physics.P2.ContactMaterial;

            /**
            * @name Phaser.Physics.P2#emitImpactEvent
            * @property {boolean} emitImpactEvent - Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
            */
            emitImpactEvent: boolean;

            /**
            * @property {Phaser.Physics.P2.CollisionGroup} everythingCollisionGroup - A default collision group.
            */
            everythingCollisionGroup: Phaser.Physics.P2.CollisionGroup;

            /**
            * @property {number} frameRate - The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.
            * @default
            */
            frameRate: number;

            /**
            * @name Phaser.Physics.P2#friction
            * @property {number} friction - Friction between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.
            */
            friction: number;

            /**
            * @property {Phaser.Game} game - A reference to the currently running Game.
            */
            game: Phaser.Game;

            /**
            * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
            */
            gravity: Phaser.Physics.P2.InversePointProxy;

            /**
            * @property {array<Phaser.Physics.P2.Material>} materials - A local array of all created Materials.
            * @protected
            */
            materials: Phaser.Physics.P2.Material[];

            /**
            * @property {Phaser.Physics.P2.CollisionGroup} nothingCollisionGroup - A default collision group.
            */
            nothingCollisionGroup: Phaser.Physics.P2.CollisionGroup;

            /**
            * @property {Phaser.Signal} onBodyAdded - Dispatched when a new Body is added to the World.
            */
            onBodyAdded: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onBodyRemoved - Dispatched when a Body is removed from the World.
            */
            onBodyRemoved: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onBeginContact - Dispatched when a first contact is created between two bodies. This event is fired before the step has been done.
            */
            onBeginContact: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onConstraintAdded - Dispatched when a new Constraint is added to the World.
            */
            onConstraintAdded: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onConstraintRemoved - Dispatched when a Constraint is removed from the World.
            */
            onConstraintRemoved: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onContactMaterialAdded - Dispatched when a new ContactMaterial is added to the World.
            */
            onContactMaterialAdded: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onContactMaterialRemoved - Dispatched when a ContactMaterial is removed from the World.
            */
            onContactMaterialRemoved: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onEndContact - Dispatched when final contact occurs between two bodies. This event is fired before the step has been done.
            */
            onEndContact: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onSpringAdded - Dispatched when a new Spring is added to the World.
            */
            onSpringAdded: Phaser.Signal;

            /**
            * @property {Phaser.Signal} onSpringRemoved - Dispatched when a Spring is removed from the World.
            */
            onSpringRemoved: Phaser.Signal;

            /**
            * The paused state of the Game. A paused game doesn't update any of its subsystems.
            * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
            * @name Phaser.Game#paused
            * @property {boolean} paused - Gets and sets the paused state of the Game.
            */
            paused: boolean;

            postBroaddphaseCallback: Function;

            /**
            * @name Phaser.Physics.P2#restitution
            * @property {number} restitution - Default coefficient of restitution between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.
            */
            restitution: number;

            /**
            * @name Phaser.Physics.P2#solveConstraints
            * @property {boolean} solveConstraints - Enable/disable constraint solving in each step.
            */
            solveConstraints: boolean;

            /**
            * @property {Phaser.Time} time - A reference to the game clock and timed events system.
            */
            time: any;

            /**
            * @name Phaser.FrameData#total
            * @property {number} total - The total number of frames in this FrameData set.
            * @readonly
            */
            total: number;

            /**
            * @property {boolean} useElapsedTime - If true the frameRate value will be ignored and instead p2 will step with the value of Game.Time.physicsElapsed, which is a delta time value.
            * @default
            */
            useElapsedTime: boolean;

            /**
            * @property {object} walls - An object containing the 4 wall bodies that bound the physics world.
            */
            walls: {

                left?: Phaser.Physics.P2.Body;
                right?: Phaser.Physics.P2.Body;
                top?: Phaser.Physics.P2.Body;
                bottom?: Phaser.Physics.P2.Body;
            };
            /**
            * @property {Phaser.World} world - A reference to the game world.
            */
            world: p2.World;

            /**
            * Add a body to the world.
            *
            * @method Phaser.Physics.P2#addBody
            * @param {Phaser.Physics.P2.Body} body - The Body to add to the World.
            * @return {boolean} True if the Body was added successfully, otherwise false.
            */
            addBody(body: Phaser.Physics.P2.Body): boolean;

            /**
            * Adds a Contact Material to the world.
            *
            * @method Phaser.Physics.P2#addContactMaterial
            * @param {Phaser.Physics.P2.ContactMaterial} material - The Contact Material to be added to the World.
            * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was added.
            */
            addContactMaterial(material: Phaser.Physics.P2.ContactMaterial): Phaser.Physics.P2.ContactMaterial;

            addConstraint<T>(constraint: T): T;

            /**
            * Adds a Spring to the world.
            *
            * @method Phaser.Physics.P2#addSpring
            * @param {Phaser.Physics.P2.Spring|p2.LinearSpring|p2.RotationalSpring} spring - The Spring to add to the World.
            * @return {Phaser.Physics.P2.Spring} The Spring that was added.
            */
            addSpring(spring: Phaser.Physics.P2.Spring): Phaser.Physics.P2.Spring;

            /**
            * Handles a p2 begin contact event.
            *
            * @method Phaser.Physics.P2#beginContactHandler
            * @param {object} event - The event data.
            */
            beginContactHandler(event: any): void;

            /**
            * Clears all bodies from the simulation, resets callbacks and resets the collision bitmask.
            * 
            * The P2 world is also cleared:
            * 
            * * Removes all solver equations
            * * Removes all constraints
            * * Removes all bodies
            * * Removes all springs
            * * Removes all contact materials
            * 
            * This is called automatically when you switch state.
            *
            * @method Phaser.Physics.P2#clear
            */
            clear(): void;

            /**
            * Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.
            *
            * @method Phaser.Physics.P2#clearTilemapLayerBodies
            * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.
            * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.
            */
            clearTilemapLayerBodies(map: Phaser.Tilemap, layer?: any): void;

            /**
            * Converts all of the polylines objects inside a Tiled ObjectGroup into physics bodies that are added to the world.
            * Note that the polylines must be created in such a way that they can withstand polygon decomposition.
            *
            * @method Phaser.Physics.P2#convertCollisionObjects
            * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.
            * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.
            * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world.
            * @return {array} An array of the Phaser.Physics.Body objects that have been created.
            */
            convertCollisionObjects(map: Phaser.Tilemap, layer?: any, addToWorld?: boolean): Phaser.Physics.P2.Body[];

            /**
            * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.
            * Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.
            * Every time you call this method it will destroy any previously created bodies and remove them from the world.
            * Therefore understand it's a very expensive operation and not to be done in a core game update loop.
            *
            * @method Phaser.Physics.P2#convertTilemap
            * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.
            * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.
            * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world, otherwise it's up to you to do so.
            * @param {boolean} [optimize=true] - If true adjacent colliding tiles will be combined into a single body to save processing. However it means you cannot perform specific Tile to Body collision responses.
            * @return {array} An array of the Phaser.Physics.P2.Body objects that were created.
            */
            convertTilemap(map: Phaser.Tilemap, layer?: any, addToWorld?: Boolean, optimize?: boolean): Phaser.Physics.P2.Body[];

            /**
            * Creates a new Body and adds it to the World.
            *
            * @method Phaser.Physics.P2#createBody
            * @param {number} x - The x coordinate of Body.
            * @param {number} y - The y coordinate of Body.
            * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.
            * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).
            * @param {object} options - An object containing the build options:
            * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
            * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.
            * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
            * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.
            *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
            *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
            * @return {Phaser.Physics.P2.Body} The body
            */
            createBody(x: number, y: number, mass: number, addToWorld?: boolean, options?: p2.BodyOptions, data?: number[][]): Phaser.Physics.P2.Body;

            /**
            * Creates a new Body and adds it to the World.
            *
            * @method Phaser.Physics.P2#createBody
            * @param {number} x - The x coordinate of Body.
            * @param {number} y - The y coordinate of Body.
            * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.
            * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).
            * @param {object} options - An object containing the build options:
            * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
            * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.
            * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
            * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.
            *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
            *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
            * @return {Phaser.Physics.P2.Body} The body
            */
            createBody(x: number, y: number, mass: number, addToWorld?: boolean, options?: p2.BodyOptions, data?: number[]): Phaser.Physics.P2.Body;

            /**
            * Creates a new Collision Group and optionally applies it to the given object.
            * Collision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.
            *
            * @method Phaser.Physics.P2#createCollisionGroup
            * @param {Phaser.Group|Phaser.Sprite} [object] - An optional Sprite or Group to apply the Collision Group to. If a Group is given it will be applied to all top-level children.
            */
            createCollisionGroup(group?: Phaser.Group): Phaser.Physics.P2.CollisionGroup;

            /**
            * Creates a new Collision Group and optionally applies it to the given object.
            * Collision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.
            *
            * @method Phaser.Physics.P2#createCollisionGroup
            * @param {Phaser.Group|Phaser.Sprite} [object] - An optional Sprite or Group to apply the Collision Group to. If a Group is given it will be applied to all top-level children.
            */
            createCollisionGroup(group?: Phaser.Sprite): Phaser.Physics.P2.CollisionGroup;

            /**
            * Creates a Contact Material from the two given Materials. You can then edit the properties of the Contact Material directly.
            *
            * @method Phaser.Physics.P2#createContactMaterial
            * @param {Phaser.Physics.P2.Material} [materialA] - The first Material to create the ContactMaterial from. If undefined it will create a new Material object first.
            * @param {Phaser.Physics.P2.Material} [materialB] - The second Material to create the ContactMaterial from. If undefined it will create a new Material object first.
            * @param {object} [options] - Material options object.
            * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was created.
            */
            createContactMaterial(materialA: Phaser.Physics.P2.Material, materialB: Phaser.Physics.P2.Material, options?: p2.ContactMaterialOptions): Phaser.Physics.P2.ContactMaterial;

            /**
            * Creates a constraint that tries to keep the distance between two bodies constant.
            *
            * @method Phaser.Physics.P2#createDistanceConstraint
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {number} distance - The distance to keep between the bodies.
            * @param {Array} [localAnchorA] - The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
            * @param {Array} [localAnchorB] - The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
            * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.
            * @return {Phaser.Physics.P2.DistanceConstraint} The constraint
            */
            createDistanceConstraint(bodyA: any, bodyB: any, distance: number, localAnchorA?: number[], localAnchorB?: number[], maxForce?: number): Phaser.Physics.P2.DistanceConstraint;

            /**
            * Creates a constraint that tries to keep the distance between two bodies constant.
            *
            * @method Phaser.Physics.P2#createGearConstraint
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {number} [angle=0] - The relative angle
            * @param {number} [ratio=1] - The gear ratio.
            * @return {Phaser.Physics.P2.GearConstraint} The constraint
            */
            createGearConstraint(bodyA: any, bodyB: any, angle?: number, ratio?: number): Phaser.Physics.P2.GearConstraint;

            /**
            * Locks the relative position between two bodies.
            *
            * @method Phaser.Physics.P2#createLockConstraint
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {Array} [offset] - The offset of bodyB in bodyA's frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {number} [angle=0] - The angle of bodyB in bodyA's frame.
            * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.
            * @return {Phaser.Physics.P2.LockConstraint} The constraint
            */
            createLockConstraint(bodyA: any, bodyB: any, offset?: number[], angle?: number, maxForce?: number): Phaser.Physics.P2.LockConstraint;

            /**
            * Creates a Material. Materials are applied to Shapes owned by a Body and can be set with Body.setMaterial().
            * Materials are a way to control what happens when Shapes collide. Combine unique Materials together to create Contact Materials.
            * Contact Materials have properties such as friction and restitution that allow for fine-grained collision control between different Materials.
            *
            * @method Phaser.Physics.P2#createMaterial
            * @param {string} [name] - Optional name of the Material. Each Material has a unique ID but string names are handy for debugging.
            * @param {Phaser.Physics.P2.Body} [body] - Optional Body. If given it will assign the newly created Material to the Body shapes.
            * @return {Phaser.Physics.P2.Material} The Material that was created. This is also stored in Phaser.Physics.P2.materials.
            */
            createMaterial(name?: string, body?: Phaser.Physics.P2.Body): Phaser.Physics.P2.Material;

            /**
            * Creates a new Particle and adds it to the World.
            *
            * @method Phaser.Physics.P2#createParticle
            * @param {number} x - The x coordinate of Body.
            * @param {number} y - The y coordinate of Body.
            * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.
            * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).
            * @param {object} options - An object containing the build options:
            * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
            * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.
            * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
            * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.
            *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
            *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
            */
            createParticle(x: number, y: number, mass: number, addToWorld?: boolean, options?: p2.BodyOptions, data?: number[][]): Phaser.Physics.P2.Body;

            /**
            * Creates a new Particle and adds it to the World.
            *
            * @method Phaser.Physics.P2#createParticle
            * @param {number} x - The x coordinate of Body.
            * @param {number} y - The y coordinate of Body.
            * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.
            * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).
            * @param {object} options - An object containing the build options:
            * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
            * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.
            * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
            * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.
            *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
            *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
            */
            createParticle(x: number, y: number, mass: number, addToWorld?: boolean, options?: p2.BodyOptions, data?: number[]): Phaser.Physics.P2.Body;

            /**
            * Constraint that only allows bodies to move along a line, relative to each other.
            * See http://www.iforce2d.net/b2dtut/joints-prismatic
            *
            * @method Phaser.Physics.P2#createPrismaticConstraint
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {boolean} [lockRotation=true] - If set to false, bodyB will be free to rotate around its anchor point.
            * @param {Array} [anchorA] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [anchorB] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [axis] - An axis, defined in body A frame, that body B's anchor point may slide along. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.
            * @return {Phaser.Physics.P2.PrismaticConstraint} The constraint
            */
            createPrismaticConstraint(body: any, bodyB: any, lockRotation?: boolean, anchorA?: number[], anchorB?: number[], axis?: Float32Array, maxForce?: number): Phaser.Physics.P2.PrismaticConstraint;

            /**
            * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
            * The pivot points are given in world (pixel) coordinates.
            *
            * @method Phaser.Physics.P2#createRevoluteConstraint
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Array} pivotA - The point relative to the center of mass of bodyA which bodyA is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {Array} pivotB - The point relative to the center of mass of bodyB which bodyB is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {number} [maxForce=0] - The maximum force that should be applied to constrain the bodies.
            * @param {Float32Array} [worldPivot=null] - A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
            * @return {Phaser.Physics.P2.RevoluteConstraint} The constraint
            */
            createRevoluteConstraint(bodyA: any, pivotA: number[], bodyB: any, pivotB: number[], maxForce?: number, worldPivot?: number[]): Phaser.Physics.P2.RevoluteContraint;

            /**
            * Creates a rotational spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
            *
            * @method Phaser.Physics.P2#createRotationalSpring
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {number} [restAngle] - The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
            * @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.
            * @param {number} [damping=1] - Damping of the spring. A number >= 0.
            * @return {Phaser.Physics.P2.RotationalSpring} The spring
            */
            createRotationalSpring(bodyA: any, bodyB: any, restAngle?: number, stiffness?: number, damping?: number): p2.RotationalSpring;

            /**
            * Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
            *
            * @method Phaser.Physics.P2#createSpring
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.
            * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.
            * @param {number} [restLength=1] - Rest length of the spring. A number > 0.
            * @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.
            * @param {number} [damping=1] - Damping of the spring. A number >= 0.
            * @param {Array} [worldA] - Where to hook the spring to body A in world coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].
            * @param {Array} [worldB] - Where to hook the spring to body B in world coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].
            * @param {Array} [localA] - Where to hook the spring to body A in local body coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].
            * @param {Array} [localB] - Where to hook the spring to body B in local body coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].
            * @return {Phaser.Physics.P2.Spring} The spring
            */
            createSpring(bodyA: any, bodyB: any, restLength?: number, stiffness?: number, damping?: number, worldA?: number[], worldB?: number[], localA?: number[], localB?: number[]): Phaser.Physics.P2.Spring;

            /**
            * Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.
            *
            * @method Phaser.Physics.P2#destroy
            */
            destroy(): void;

            /**
            * This will create a P2 Physics body on the given game object or array of game objects.
            * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
            * Note: When the game object is enabled for P2 physics it has its anchor x/y set to 0.5 so it becomes centered.
            *
            * @method Phaser.Physics.P2#enable
            * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.
            * @param {boolean} [debug=false] - Create a debug object to go with this body?
            * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.
            */
            enable(object: any, debug?: boolean, children?: boolean): void;

            /**
            * Creates a P2 Physics body on the given game object.
            * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
            *
            * @method Phaser.Physics.P2#enableBody
            * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.
            * @param {boolean} debug - Create a debug object to go with this body?
            */
            enableBody(object: any, debug: boolean): void;

            /**
            * Handles a p2 end contact event.
            *
            * @method Phaser.Physics.P2#endContactHandler
            * @param {object} event - The event data.
            */
            endContactHandler(event: any): void;

            /**
            * Populates and returns an array with references to of all current Bodies in the world.
            *
            * @method Phaser.Physics.P2#getBodies
            * @return {array<Phaser.Physics.P2.Body>} An array containing all current Bodies in the world.
            */
            getBodies(): Phaser.Physics.P2.Body[];

            /**
            * Checks the given object to see if it has a p2.Body and if so returns it.
            *
            * @method Phaser.Physics.P2#getBody
            * @param {object} object - The object to check for a p2.Body on.
            * @return {p2.Body} The p2.Body, or null if not found.
            */
            getBody(object: any): Phaser.Physics.P2.Body;

            /**
            * Populates and returns an array of all current Constraints in the world.
            *
            * @method Phaser.Physics.P2#getConstraints
            * @return {array<Phaser.Physics.P2.Constraint>} An array containing all current Constraints in the world.
            */
            getConstraints(): p2.Constraint[];

            /**
            * Populates and returns an array of all current Springs in the world.
            *
            * @method Phaser.Physics.P2#getSprings
            * @return {array<Phaser.Physics.P2.Spring>} An array containing all current Springs in the world.
            */
            getSprings(): Phaser.Physics.P2.Spring[];

            /**
            * Gets a Contact Material based on the two given Materials.
            *
            * @method Phaser.Physics.P2#getContactMaterial
            * @param {Phaser.Physics.P2.Material} materialA - The first Material to search for.
            * @param {Phaser.Physics.P2.Material} materialB - The second Material to search for.
            * @return {Phaser.Physics.P2.ContactMaterial|boolean} The Contact Material or false if none was found matching the Materials given.
            */
            getContactMaterial(materialA: Phaser.Physics.P2.Material, materialB: Phaser.Physics.P2.Material): Phaser.Physics.P2.ContactMaterial;

            /**
            * Test if a world point overlaps bodies. You will get an array of actual P2 bodies back. You can find out which Sprite a Body belongs to
            * (if any) by checking the Body.parent.sprite property. Body.parent is a Phaser.Physics.P2.Body property.
            *
            * @method Phaser.Physics.P2#hitTest
            * @param {Phaser.Point} worldPoint - Point to use for intersection tests. The points values must be in world (pixel) coordinates.
            * @param {Array<Phaser.Physics.P2.Body|Phaser.Sprite|p2.Body>} [bodies] - A list of objects to check for intersection. If not given it will check Phaser.Physics.P2.world.bodies (i.e. all world bodies)
            * @param {number} [precision=5] - Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
            * @param {boolean} [filterStatic=false] - If true all Static objects will be removed from the results array.
            * @return {Array} Array of bodies that overlap the point.
            */
            hitTest(worldPoint: Phaser.Point, bodies?: any[], precision?: number, filterStatic?: boolean): Phaser.Physics.P2.Body[];

            /**
            * Convert p2 physics value (meters) to pixel scale.
            * By default Phaser uses a scale of 20px per meter.
            * If you need to modify this you can over-ride these functions via the Physics Configuration object.
            *
            * @method Phaser.Physics.P2#mpx
            * @param {number} v - The value to convert.
            * @return {number} The scaled value.
            */
            mpx(v: number): number;

            /**
            * Convert p2 physics value (meters) to pixel scale and inverses it.
            * By default Phaser uses a scale of 20px per meter.
            * If you need to modify this you can over-ride these functions via the Physics Configuration object.
            *
            * @method Phaser.Physics.P2#mpxi
            * @param {number} v - The value to convert.
            * @return {number} The scaled value.
            */
            mpxi(v: number): number;

            /**
            * Pauses the P2 World independent of the game pause state.
            *
            * @method Phaser.Physics.P2#pause
            */
            pause(): void;

            /**
            * Called at the start of the core update loop. Purges flagged bodies from the world.
            *
            * @method Phaser.Physics.P2#preUpdate
            */
            preUpdate(): void;

            /**
            * Convert pixel value to p2 physics scale (meters).
            * By default Phaser uses a scale of 20px per meter.
            * If you need to modify this you can over-ride these functions via the Physics Configuration object.
            *
            * @method Phaser.Physics.P2#pxm
            * @param {number} v - The value to convert.
            * @return {number} The scaled value.
            */
            pxm(v: number): number;

            /**
            * Convert pixel value to p2 physics scale (meters) and inverses it.
            * By default Phaser uses a scale of 20px per meter.
            * If you need to modify this you can over-ride these functions via the Physics Configuration object.
            *
            * @method Phaser.Physics.P2#pxmi
            * @param {number} v - The value to convert.
            * @return {number} The scaled value.
            */
            pxmi(v: number): number;

            /**
            * This will add a P2 Physics body into the removal list for the next step.
            *
            * @method Phaser.Physics.P2#removeBodyNextStep
            * @param {Phaser.Physics.P2.Body} body - The body to remove at the start of the next step.
            */
            removeBody(body: Phaser.Physics.P2.Body): Phaser.Physics.P2.Body;

            /**
            * This will add a P2 Physics body into the removal list for the next step.
            *
            * @method Phaser.Physics.P2#removeBodyNextStep
            * @param {Phaser.Physics.P2.Body} body - The body to remove at the start of the next step.
            */
            removeBodyNextStep(body: Phaser.Physics.P2.Body): void;

            removeConstraint<T>(constraint: T): T;

            /**
            * Removes a Contact Material from the world.
            *
            * @method Phaser.Physics.P2#removeContactMaterial
            * @param {Phaser.Physics.P2.ContactMaterial} material - The Contact Material to be removed from the World.
            * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was removed.
            */
            removeContactMaterial(material: Phaser.Physics.P2.ContactMaterial): Phaser.Physics.P2.ContactMaterial;

            /**
            * Removes a Spring from the world.
            *
            * @method Phaser.Physics.P2#removeSpring
            * @param {Phaser.Physics.P2.Spring} spring - The Spring to remove from the World.
            * @return {Phaser.Physics.P2.Spring} The Spring that was removed.
            */
            removeSpring(spring: Phaser.Physics.P2.Spring): Phaser.Physics.P2.Spring;

            /**
            * Called by Phaser.Physics when a State swap occurs.
            * Starts the begin and end Contact listeners again.
            *
            * @method Phaser.Physics.P2#reset
            */
            reset(): void;

            /**
            * Resumes a paused P2 World.
            *
            * @method Phaser.Physics.P2#resume
            */
            resume(): void;

            /**
            * Sets the bounds of the Physics world to match the given world pixel dimensions.
            * You can optionally set which 'walls' to create: left, right, top or bottom.
            *
            * @method Phaser.Physics.P2#setBounds
            * @param {number} x - The x coordinate of the top-left corner of the bounds.
            * @param {number} y - The y coordinate of the top-left corner of the bounds.
            * @param {number} width - The width of the bounds.
            * @param {number} height - The height of the bounds.
            * @param {boolean} [left=true] - If true will create the left bounds wall.
            * @param {boolean} [right=true] - If true will create the right bounds wall.
            * @param {boolean} [top=true] - If true will create the top bounds wall.
            * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.
            * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.
            */
            setBounds(x: number, y: number, width: number, height: number, left?: Boolean, right?: boolean, top?: boolean, bottom?: boolean, setCollisionGroup?: boolean): void;

            setBoundsToWorld(left?: boolean, right?: boolean, top?: boolean, bottom?: boolean, setCollisionGroup?: boolean): void;

            setCollisionGroup(object: any, group: Phaser.Physics.P2.CollisionGroup): void;

            /**
            * Impact event handling is disabled by default. Enable it before any impact events will be dispatched.
            * In a busy world hundreds of impact events can be generated every step, so only enable this if you cannot do what you need via beginContact or collision masks.
            *
            * @method Phaser.Physics.P2#setImpactEvents
            * @param {boolean} state - Set to true to enable impact events, or false to disable.
            */
            setImpactEvents(state: boolean): void;

            /**
            * Sets the given Material against all Shapes owned by all the Bodies in the given array.
            *
            * @method Phaser.Physics.P2#setMaterial
            * @param {Phaser.Physics.P2.Material} material - The Material to be applied to the given Bodies.
            * @param {array<Phaser.Physics.P2.Body>} bodies - An Array of Body objects that the given Material will be set on.
            */
            setMaterial(material: Phaser.Physics.P2.Material, bodies?: Phaser.Physics.P2.Body[]): void;

            /**
            * Sets a callback to be fired after the Broadphase has collected collision pairs in the world.
            * Just because a pair exists it doesn't mean they *will* collide, just that they potentially could do.
            * If your calback returns `false` the pair will be removed from the narrowphase. This will stop them testing for collision this step.
            * Returning `true` from the callback will ensure they are checked in the narrowphase.
            *
            * @method Phaser.Physics.P2#setPostBroadphaseCallback
            * @param {function} callback - The callback that will receive the postBroadphase event data. It must return a boolean. Set to null to disable an existing callback.
            * @param {object} context - The context under which the callback will be fired.
            */
            setPostBroadphaseCallback(callback: Function, context: any): void;

            setWorldMaterial(material: Phaser.Physics.P2.Material, left?: boolean, right?: boolean, top?: boolean, bottom?: boolean): void;

            /**
            * Converts the current world into a JSON object.
            *
            * @method Phaser.Physics.P2#toJSON
            * @return {object} A JSON representation of the world.
            */
            toJSON(): any;

            /**
            * By default the World will be set to collide everything with everything. The bounds of the world is a Body with 4 shapes, one for each face.
            * If you start to use your own collision groups then your objects will no longer collide with the bounds.
            * To fix this you need to adjust the bounds to use its own collision group first BEFORE changing your Sprites collision group.
            *
            * @method Phaser.Physics.P2#updateBoundsCollisionGroup
            * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.
            */
            update(): void;

            /**
            * By default the World will be set to collide everything with everything. The bounds of the world is a Body with 4 shapes, one for each face.
            * If you start to use your own collision groups then your objects will no longer collide with the bounds.
            * To fix this you need to adjust the bounds to use its own collision group first BEFORE changing your Sprites collision group.
            *
            * @method Phaser.Physics.P2#updateBoundsCollisionGroup
            * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.
            */
            updateBoundsCollisionGroup(setCollisionGroup?: boolean): void;

        }
        module P2 {

            /**
            * The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.
            * These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.
            * In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.
            * By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearShapes to add extra shapes around the Body.
            * Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.
            * Note: When a game object is given a P2 body it has its anchor x/y set to 0.5, so it becomes centered.
            *
            * @class Phaser.Physics.P2.Body
            * @constructor
            * @param {Phaser.Game} game - Game reference to the currently running game.
            * @param {Phaser.Sprite} [sprite] - The Sprite object this physics body belongs to.
            * @param {number} [x=0] - The x coordinate of this Body.
            * @param {number} [y=0] - The y coordinate of this Body.
            * @param {number} [mass=1] - The default mass of this Body (0 = static).
            */
            class Body {

                static DYNAMIC: number;

                static STATIC: number;

                static KINEMATIC: number;

                constructor(game: Phaser.Game, sprite?: Phaser.Sprite, x?: number, y?: number, mass?: number);

                /**
                * @name Phaser.Physics.P2.Body#allowSleep
                * @property {boolean} allowSleep -
                */
                allowSleep: boolean;

                /**
                * @name Phaser.Line#angle
                * @property {number} angle - Gets the angle of the line.
                * @readonly
                */
                angle: number;

                /**
                * Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second.
                * @name Phaser.Physics.P2.Body#angularDamping
                * @property {number} angularDamping - The angular damping acting acting on the body.
                */
                angularDamping: number;

                /**
                * @name Phaser.Physics.P2.Body#angularForce
                * @property {number} angularForce - The angular force acting on the body.
                */
                angularForce: number;

                /**
                * @property {number} angularVelocity - The angular velocity in pixels per second sq. of the Body.
                * @default
                */
                angularVelocity: number;

                /**
                * @property {array} collidesWith - Array of CollisionGroups that this Bodies shapes collide with.
                */
                collidesWith: Phaser.Physics.P2.CollisionGroup[];

                /**
                * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.
                * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?
                */
                collideWorldBounds: boolean;

                /**
                * Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second.
                * @name Phaser.Physics.P2.Body#damping
                * @property {number} damping - The linear damping acting on the body in the velocity direction.
                */
                damping: number;

                /**
                * @property {Uint8ClampedArray} data - A Uint8ClampedArray view into BitmapData.buffer.
                */
                data: p2.Body;

                /**
                * @property {Phaser.Utils.Debug} debug - A set of useful debug utilitie.
                */
                debug: boolean;

                /**
                * @property {Phaser.Physics.P2.BodyDebug} debugBody - Reference to the debug body.
                */
                debugBody: Phaser.Physics.P2.BodyDebug;

                /**
                * @name Phaser.Physics.P2.Body#dynamic
                * @property {boolean} dynamic - Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.
                */
                dynamic: boolean;

                /**
                * @name Phaser.Physics.P2.Body#fixedRotation
                * @property {boolean} fixedRotation -
                */
                fixedRotation: boolean;

                /**
                * @property {Phaser.Physics.P2.InversePointProxy} force - The force applied to the body.
                */
                force: Phaser.Physics.P2.InversePointProxy;

                /**
                * @name Phaser.Physics.P2.Body#kinematic
                * @property {boolean} kinematic - Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.
                */
                kinematic: boolean;

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
                */
                gravity: Phaser.Point;

                /**
                * @property {number} id - Reserved for future multiple camera set-ups.
                * @default
                */
                id: number;

                /**
                * @name Phaser.Physics.P2.Body#inertia
                * @property {number} inertia - The inertia of the body around the Z axis..
                */
                inertia: number;

                /**
                * @property {number} mass - The mass of the Body.
                * @default
                */
                mass: number;

                /**
                * @name Phaser.Physics.P2.Body#motionState
                * @property {number} motionState - The type of motion this body has. Should be one of: Body.STATIC (the body does not move), Body.DYNAMIC (body can move and respond to collisions) and Body.KINEMATIC (only moves according to its .velocity).
                */
                motionState: number;

                /**
                * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.
                */
                offset: Phaser.Point;

                /**
                * @property {Phaser.Signal} onBeginContact - Dispatched when a first contact is created between two bodies. This event is fired before the step has been done.
                */
                onBeginContact: Phaser.Signal;

                /**
                * @property {Phaser.Signal} onEndContact - Dispatched when final contact occurs between two bodies. This event is fired before the step has been done.
                */
                onEndContact: Phaser.Signal;

                /**
                * @property {number} rotation - The amount the Body is rotated.
                */
                rotation: number;

                /**
                * @property {boolean} removeNextStep - To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.
                */
                removeNextStep: boolean;

                /**
                * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
                */
                sprite: Phaser.Sprite;

                /**
                * @name Phaser.Physics.P2.Body#sleepSpeedLimit
                * @property {number} sleepSpeedLimit - .
                */
                sleepSpeedLimit: number;

                /**
                * @name Phaser.Physics.P2.Body#static
                * @property {boolean} static - Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.
                */
                static: boolean;

                /**
                * @property {number} type - The base object type.
                */
                type: number;

                /**
                * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.
                */
                velocity: Phaser.Physics.P2.InversePointProxy;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                /**
                * Adds this physics body to the world.
                *
                * @method Phaser.Physics.P2.Body#addToWorld
                */
                addToWorld(): void;

                /**
                * Adds a Capsule shape to this Body.
                * You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addCapsule
                * @param {number} length - The distance between the end points in pixels.
                * @param {number} radius - Radius of the capsule in pixels.
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Capsule} The Capsule shape that was added to the Body.
                */
                addCapsule(length: number, radius: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Capsule;

                /**
                * Adds a Circle shape to this Body. You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addCircle
                * @param {number} radius - The radius of this circle (in pixels)
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Circle} The Circle shape that was added to the Body.
                */
                addCircle(radius: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Circle;

                /**
                * Add a polygon fixture. This is used during #loadPolygon.
                *
                * @method Phaser.Physics.P2.Body#addFixture
                * @param {string} fixtureData - The data for the fixture. It contains: isSensor, filter (collision) and the actual polygon shapes.
                * @return {array} An array containing the generated shapes for the given polygon.
                */
                addFixture(fixtureData: string): p2.Shape[];

                /**
                * Adds a Line shape to this Body.
                * The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
                * You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addLine
                * @param {number} length - The length of this line (in pixels)
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Line} The Line shape that was added to the Body.
                */
                addLine(length: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Line;

                /**
                * Adds a Particle shape to this Body. You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addParticle
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Particle} The Particle shape that was added to the Body.
                */
                addParticle(offsetX?: number, offsetY?: number, rotation?: number): p2.Particle;

                /**
                * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points. The shape must be simple and without holes.
                * This function expects the x.y values to be given in pixels. If you want to provide them at p2 world scales then call Body.data.fromPolygon directly.
                *
                * @method Phaser.Physics.P2.Body#addPolygon
                * @param {object} options - An object containing the build options:
                * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
                * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.
                * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
                * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.
                *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
                *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
                * @return {boolean} True on success, else false.
                */
                addPolygon(options: { optimalDecomp?: boolean; skipSimpleCheck?: boolean; removeCollinearPoints?: boolean; }, points: number[][]): boolean;

                /**
                * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.
                * The shape data format is based on the custom phaser export in.
                *
                * @method Phaser.Physics.P2.Body#addPhaserPolygon
                * @param {string} key - The key of the Physics Data file as stored in Game.Cache.
                * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.
                */
                addPhaserPolygon(key: string, object: string): Phaser.Physics.P2.FixtureList;

                /**
                * Adds a Plane shape to this Body. The plane is facing in the Y direction. You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addPlane
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Plane} The Plane shape that was added to the Body.
                */
                addPlane(offsetX?: number, offsetY?: number, rotation?: number): p2.Plane;

                /**
                * Adds a Rectangle shape to this Body. You can control the offset from the center of the body and the rotation.
                *
                * @method Phaser.Physics.P2.Body#addRectangle
                * @param {number} width - The width of the rectangle in pixels.
                * @param {number} height - The height of the rectangle in pixels.
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Rectangle} The Rectangle shape that was added to the Body.
                */
                addRectangle(width: number, height: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Rectangle;

                /**
                * Add a shape to the body. You can pass a local transform when adding a shape, so that the shape gets an offset and an angle relative to the body center of mass.
                * Will automatically update the mass properties and bounding radius.
                *
                * @method Phaser.Physics.P2.Body#addShape
                * @param {p2.Shape} shape - The shape to add to the body.
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Shape} The shape that was added to the body.
                */
                addShape(shape: p2.Shape, offsetX?: number, offsetY?: number, rotation?: number): p2.Shape;

                /**
                * Moves the shape offsets so their center of mass becomes the body center of mass.
                *
                * @method Phaser.Physics.P2.Body#adjustCenterOfMass
                */
                adjustCenterOfMass(): void;

                /**
                * Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details.
                *
                * @method Phaser.Physics.P2.Body#applyDamping
                * @param {number} dt - Current time step.
                */
                applyDamping(dt: number): void;

                /**
                * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
                *
                * @method Phaser.Physics.P2.Body#applyForce
                * @param {Float32Array|Array} force - The force vector to add.
                * @param {number} worldX - The world x point to apply the force on.
                * @param {number} worldY - The world y point to apply the force on.
                */
                applyForce(force: number[], worldX: number, worldY: number): void;

                /**
                * Clears the collision data from the shapes in this Body. Optionally clears Group and/or Mask.
                *
                * @method Phaser.Physics.P2.Body#clearCollision
                * @param {boolean} [clearGroup=true] - Clear the collisionGroup value from the shape/s?
                * @param {boolean} [clearMask=true] - Clear the collisionMask value from the shape/s?
                * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision data will be cleared from all Shapes in this Body.
                */
                clearCollision(clearGroup?: boolean, cleanMask?: boolean, shape?: p2.Shape): void;

                /**
                * Removes all Shapes from this Body.
                *
                * @method Phaser.Physics.P2.Body#clearShapes
                */
                clearShapes(): void;

                /**
                * Adds the given CollisionGroup, or array of CollisionGroups, to the list of groups that this body will collide with and updates the collision masks.
                *
                * @method Phaser.Physics.P2.Body#collides
                * @param {Phaser.Physics.CollisionGroup|array} group - The Collision Group or Array of Collision Groups that this Bodies shapes will collide with.
                * @param {function} [callback] - Optional callback that will be triggered when this Body impacts with the given Group.
                * @param {object} [callbackContext] - The context under which the callback will be called.
                * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision mask will be added to all Shapes in this Body.
                */
                collides(group: any, callback?: Function, callbackContext?: any, shape?: p2.Shape): void;

                /**
                * Sets a callback to be fired any time a shape in this Body impacts with a shape in the given Body. The impact test is performed against body.id values.
                * The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.
                * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
                * It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.
                *
                * @method Phaser.Physics.P2.Body#createBodyCallback
                * @param {Phaser.Sprite|Phaser.TileSprite|Phaser.Physics.P2.Body|p2.Body} object - The object to send impact events for.
                * @param {function} callback - The callback to fire on impact. Set to null to clear a previously set callback.
                * @param {object} callbackContext - The context under which the callback will fire.
                */
                createBodyCallback(object: any, callback: Function, callbackContext: any): void;

                /**
                * Sets a callback to be fired any time this Body impacts with the given Group. The impact test is performed against shape.collisionGroup values.
                * The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.
                * This callback will only fire if this Body has been assigned a collision group.
                * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
                * It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.
                *
                * @method Phaser.Physics.P2.Body#createGroupCallback
                * @param {Phaser.Physics.CollisionGroup} group - The Group to send impact events for.
                * @param {function} callback - The callback to fire on impact. Set to null to clear a previously set callback.
                * @param {object} callbackContext - The context under which the callback will fire.
                */
                createGroupCallback(group: Phaser.Physics.P2.CollisionGroup, callback: Function, callbackContext: any): void;

                /**
                * Destroys this Body and all references it holds to other objects.
                *
                * @method Phaser.Physics.P2.Body#destroy
                */
                destroy(): void;

                /**
                * Gets the collision bitmask from the groups this body collides with.
                *
                * @method Phaser.Physics.P2.Body#getCollisionMask
                * @return {number} The bitmask.
                */
                getCollisionMask(): number;

                /**
                * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.
                *
                * @method Phaser.Physics.P2.Body#loadPolygon
                * @param {string} key - The key of the Physics Data file as stored in Game.Cache.
                * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.
                * @return {boolean} True on success, else false.
                */
                loadPolygon(key: string, object: string): boolean;

                /**
                * Moves the Body backwards based on its current angle and the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveBackward
                * @param {number} speed - The speed at which it should move backwards.
                */
                moveBackward(speed: number): void;

                /**
                * If this Body is dynamic then this will move it down by setting its y velocity to the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveDown
                * @param {number} speed - The speed at which it should move down, in pixels per second.
                */
                moveDown(speed: number): void;

                /**
                * Moves the Body forwards based on its current angle and the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveForward
                * @param {number} speed - The speed at which it should move forwards.
                */
                moveForward(speed: number): void;

                /**
                * If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveLeft
                * @param {number} speed - The speed at which it should move to the left, in pixels per second.
                */
                moveLeft(speed: number): void;

                /**
                * If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveRight
                * @param {number} speed - The speed at which it should move to the right, in pixels per second.
                */
                moveRight(speed: number): void;

                /**
                * If this Body is dynamic then this will move it up by setting its y velocity to the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#moveUp
                * @param {number} speed - The speed at which it should move up, in pixels per second.
                */
                moveUp(speed: number): void;

                /**
                * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
                *
                * @method Phaser.Physics.P2.Body#preUpdate
                * @protected
                */
                preUpdate(): void;

                /**
                * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
                *
                * @method Phaser.Physics.P2.Body#postUpdate
                * @protected
                */
                postUpdate(): void;

                /**
                * Removes this physics body from the world.
                *
                * @method Phaser.Physics.P2.Body#removeFromWorld
                */
                removeFromWorld(): void;

                /**
                * Remove a shape from the body. Will automatically update the mass properties and bounding radius.
                *
                * @method Phaser.Physics.P2.Body#removeShape
                * @param {p2.Circle|p2.Rectangle|p2.Plane|p2.Line|p2.Particle} shape - The shape to remove from the body.
                * @return {boolean} True if the shape was found and removed, else false.
                */
                removeShape(shape: p2.Shape): boolean;

                /**
                * Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#reverse
                * @param {number} speed - The speed at which it should reverse.
                */
                reverse(speed: number): void;

                /**
                * This will rotate the Body by the given speed to the left (counter-clockwise).
                *
                * @method Phaser.Physics.P2.Body#rotateLeft
                * @param {number} speed - The speed at which it should rotate.
                */
                rotateLeft(speed: number): void;

                /**
                * This will rotate the Body by the given speed to the left (clockwise).
                *
                * @method Phaser.Physics.P2.Body#rotateRight
                * @param {number} speed - The speed at which it should rotate.
                */
                rotateRight(speed: number): void;

                /**
                * Resets the Body force, velocity (linear and angular) and rotation. Optionally resets damping and mass.
                *
                * @method Phaser.Physics.P2.Body#reset
                * @param {number} x - The new x position of the Body.
                * @param {number} y - The new x position of the Body.
                * @param {boolean} [resetDamping=false] - Resets the linear and angular damping.
                * @param {boolean} [resetMass=false] - Sets the Body mass back to 1.
                */
                reset(x: number, y: number, resetDamping?: boolean, resetMass?: boolean): void;

                /**
                * Updates the debug draw if any body shapes change.
                *
                * @method Phaser.Physics.P2.Body#shapeChanged
                */
                shapeChanged(): void;

                /**
                * Clears any previously set shapes. Then creates a new Circle shape and adds it to this Body.
                *
                * @method Phaser.Physics.P2.Body#setCircle
                * @param {number} radius - The radius of this circle (in pixels)
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                */
                setCircle(radius: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Circle;

                /**
                * Sets the given CollisionGroup to be the collision group for all shapes in this Body, unless a shape is specified.
                * This also resets the collisionMask.
                *
                * @method Phaser.Physics.P2.Body#setCollisionGroup
                * @param {Phaser.Physics.CollisionGroup} group - The Collision Group that this Bodies shapes will use.
                * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision group will be added to all Shapes in this Body.
                */
                setCollisionGroup(group: Phaser.Physics.P2.CollisionGroup, shape?: p2.Shape): void;

                /**
                * Clears any previously set shapes. The creates a new Rectangle shape at the given size and offset, and adds it to this Body.
                * If you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.
                *
                * @method Phaser.Physics.P2.Body#setRectangle
                * @param {number} [width=16] - The width of the rectangle in pixels.
                * @param {number} [height=16] - The height of the rectangle in pixels.
                * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.
                * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.
                * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.
                * @return {p2.Rectangle} The Rectangle shape that was added to the Body.
                */
                setRectangle(width?: number, height?: number, offsetX?: number, offsetY?: number, rotation?: number): p2.Rectangle;

                /**
                * Clears any previously set shapes.
                * Then creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.
                * If no Sprite is given it defaults to using the parent of this Body.
                *
                * @method Phaser.Physics.P2.Body#setRectangleFromSprite
                * @param {Phaser.Sprite|Phaser.Image} [sprite] - The Sprite on which the Rectangle will get its dimensions.
                * @return {p2.Rectangle} The Rectangle shape that was added to the Body.
                */
                setRectangleFromSprite(sprite: any): p2.Rectangle;

                /**
                * Adds the given Material to all Shapes that belong to this Body.
                * If you only wish to apply it to a specific Shape in this Body then provide that as the 2nd parameter.
                *
                * @method Phaser.Physics.P2.Body#setMaterial
                * @param {Phaser.Physics.P2.Material} material - The Material that will be applied.
                * @param {p2.Shape} [shape] - An optional Shape. If not provided the Material will be added to all Shapes in this Body.
                */
                setMaterial(material: Phaser.Physics.P2.Material, shape?: p2.Shape): void;

                /**
                * Sets the Body damping and angularDamping to zero.
                *
                * @method Phaser.Physics.P2.Body#setZeroDamping
                */
                setZeroDamping(): void;

                /**
                * Sets the force on the body to zero.
                *
                * @method Phaser.Physics.P2.Body#setZeroForce
                */
                setZeroForce(): void;

                /**
                * If this Body is dynamic then this will zero its angular velocity.
                *
                * @method Phaser.Physics.P2.Body#setZeroRotation
                */
                setZeroRotation(): void;

                /**
                * If this Body is dynamic then this will zero its velocity on both axis.
                *
                * @method Phaser.Physics.P2.Body#setZeroVelocity
                */
                setZeroVelocity(): void;

                /**
                * Transform a world point to local body frame.
                *
                * @method Phaser.Physics.P2.Body#toLocalFrame
                * @param {Float32Array|Array} out - The vector to store the result in.
                * @param {Float32Array|Array} worldPoint - The input world vector.
                */
                toLocalFrame(out: number[], worldPoint: number[]): void;

                /**
                * Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.
                * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
                *
                * @method Phaser.Physics.P2.Body#thrust
                * @param {number} speed - The speed at which it should thrust.
                */
                thrust(speed: number): void;

                /**
                * Transform a local point to world frame.
                *
                * @method Phaser.Physics.P2.Body#toWorldFrame
                * @param {Array} out - The vector to store the result in.
                * @param {Array} localPoint - The input local vector.
                */
                toWorldFrame(out: number[], localPoint: number[]): void;

                /**
                * Updates the collisionMask.
                *
                * @method Phaser.Physics.P2.Body#updateCollisionMask
                * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision group will be added to all Shapes in this Body.
                */
                updateCollisionMask(shape?: p2.Shape): void;

            }
            /**
            * Draws a P2 Body to a Graphics instance for visual debugging.
            * Needless to say, for every body you enable debug drawing on, you are adding processor and graphical overhead.
            * So use sparingly and rarely (if ever) in production code.
            *
            * @class Phaser.Physics.P2.BodyDebug
            * @constructor
            * @extends Phaser.Group
            * @param {Phaser.Game} game - Game reference to the currently running game.
            * @param {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
            * @param {object} settings - Settings object.
            */
            class BodyDebug extends Phaser.Group {

                constructor(game: Phaser.Game, body: Phaser.Physics.P2.Body, settings: { pixelsPerLengthUnit?: number; debugPolygons?: boolean; lineWidth?: number; alpha?: number; });

                /**
                * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
                */
                body: Phaser.Physics.P2.Body;

                /**
                * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
                */
                canvas: Phaser.Graphics;

                /**
                * @property {number} ppu - Pixels per Length Unit.
                */
                ppu: number;

                /**
                * Core update.
                *
                * @method Phaser.Physics.P2.BodyDebug#updateSpriteTransform
                */
                updateSpriteTransform(): void;

                /**
                * Draws the P2 shapes to the Graphics object.
                *
                * @method Phaser.Physics.P2.BodyDebug#draw
                */
                draw(): void;

            }
            /**
            * Collision Group
            *
            * @class Phaser.Physics.P2.CollisionGroup
            * @constructor
            * @param {number} bitmask - The CollisionGroup bitmask.
            */
            class CollisionGroup {

                constructor(bitmask: number);

                /**
                * @property {number} mask - The CollisionGroup bitmask.
                */
                mask: number;

            }
            /**
            * Defines a physics material
            *
            * @class Phaser.Physics.P2.ContactMaterial
            * @constructor
            * @param {Phaser.Physics.P2.Material} materialA - First material participating in the contact material.
            * @param {Phaser.Physics.P2.Material} materialB - Second material participating in the contact material.
            * @param {object} [options] - Additional configuration options.
            */
            class ContactMaterial extends p2.ContactMaterial {

            }
            /**
            * A constraint that tries to keep the distance between two bodies constant.
            *
            * @class Phaser.Physics.P2.DistanceConstraint
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {p2.Body} bodyA - First connected body.
            * @param {p2.Body} bodyB - Second connected body.
            * @param {number} distance - The distance to keep between the bodies.
            * @param {Array} [localAnchorA] - The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
            * @param {Array} [localAnchorB] - The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
            * @param {object} [maxForce=Number.MAX_VALUE] - Maximum force to apply.
            */
            class DistanceConstraint extends p2.DistanceConstraint {

                constructor(world: Phaser.Physics.P2, bodyA: Phaser.Physics.P2.Body, bodyB: Phaser.Physics.P2.Body, distance: number, maxForce: number);

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
            /**
            * Allow to access a list of created fixture (coming from Body#addPhaserPolygon)
            * which itself parse the input from PhysicsEditor with the custom phaser exporter.
            * You can access fixtures of a Body by a group index or even by providing a fixture Key.
                        * You can set the fixture key and also the group index for a fixture in PhysicsEditor.
            * This gives you the power to create a complex body built of many fixtures and modify them
            * during runtime (to remove parts, set masks, categories & sensor properties)
            *
            * @class Phaser.Physics.P2.FixtureList
            * @constructor
            * @param {Array} list - A list of fixtures (from Phaser.Physics.P2.Body#addPhaserPolygon)
            */
            class FixtureList {

                constructor(list: any[]);

                /**
                * A helper to flatten arrays. This is very useful as the fixtures are nested from time to time due to the way P2 creates and splits polygons.
                * 
                * @method Phaser.Physics.P2.FixtureList#flatten
                * @param {array} array - The array to flatten. Notice: This will happen recursive not shallow.
                */
                flatten(array: any[]): any[];

                /**
                * Accessor to get either a list of specified fixtures by key or the whole fixture list
                * 
                * @method Phaser.Physics.P2.FixtureList#getFixtures
                * @param {array} keys - A list of fixture keys
                */
                getFixtures(keys: string): any[];

                /**
                * Accessor to get either a single fixture by its key.
                * 
                * @method Phaser.Physics.P2.FixtureList#getFixtureByKey
                * @param {string} key - The key of the fixture.
                */
                getFixtureByKey(key: string): any[];

                /**
                * Accessor to get a group of fixtures by its group index.
                * 
                * @method Phaser.Physics.P2.FixtureList#getGroup
                * @param {number} groupID - The group index.
                */
                getGroup(groupID: number): any[];

                /**
                * @method Phaser.Physics.P2.FixtureList#init
                */
                init(): void;

                /**
                * Parser for the output of Phaser.Physics.P2.Body#addPhaserPolygon
                * 
                * @method Phaser.Physics.P2.FixtureList#parse
                */
                parse(): void;

                /**
                * @method Phaser.Physics.P2.FixtureList#setCategory
                * @param {number} bit - The bit to set as the collision group.
                * @param {string} fixtureKey - Only apply to the fixture with the given key.
                */
                setCategory(bit: number, fictureKey: string): void;

                /**
                * @method Phaser.Physics.P2.FixtureList#setMask
                * @param {number} bit - The bit to set as the collision mask
                * @param {string} fixtureKey - Only apply to the fixture with the given key
                */
                setMask(bit: number, fixtureKey: string): void;

                /**
                * @method Phaser.Physics.P2.FixtureList#setMaterial
                * @param {Object} material - The contact material for a fixture
                * @param {string} fixtureKey - Only apply to the fixture with the given key
                */
                setMaterial(material: any, fixtureKey: string): void;

                /**
                * @method Phaser.Physics.P2.FixtureList#setSensor
                * @param {boolean} value - sensor true or false
                * @param {string} fixtureKey - Only apply to the fixture with the given key
                */
                setSensor(value: boolean, fixtureKey: string): void;

            }
            /**
            * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
            *
            * @class Phaser.Physics.P2.GearConstraint
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {p2.Body} bodyA - First connected body.
            * @param {p2.Body} bodyB - Second connected body.
            * @param {number} [angle=0] - The relative angle
            * @param {number} [ratio=1] - The gear ratio.
            */
            class GearConstraint extends p2.GearConstraint {

                constructor(world: Phaser.Physics.P2, bodyA: Phaser.Physics.P2.Body, bodyB: Phaser.Physics.P2.Body, angle?: number, ratio?: number);

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
            /**
            * A InversePointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays but inverses the values on set.
            *
            * @class Phaser.Physics.P2.InversePointProxy
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {any} destination - The object to bind to.
            */
            class InversePointProxy {

                constructor(world: Phaser.Physics.P2, destination: any);

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                /**
                * @name Phaser.Physics.P2.PointProxy#mx
                * @property {number} mx - The x property of this PointProxy get and set in meters.
                */
                mx: number;

                /**
                * @name Phaser.Physics.P2.PointProxy#my
                * @property {number} my - The x property of this PointProxy get and set in meters.
                */
                my: number;

            }
            /**
            * Locks the relative position between two bodies.
            *
            * @class Phaser.Physics.P2.LockConstraint
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {p2.Body} bodyA - First connected body.
            * @param {p2.Body} bodyB - Second connected body.
            * @param {Array} [offset] - The offset of bodyB in bodyA's frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {number} [angle=0] - The angle of bodyB in bodyA's frame.
            * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.
            */
            class LockConstraint extends p2.LockConstraint {

                constructor(world: Phaser.Physics.P2, bodyA: Phaser.Physics.P2.Body, bodyB: Phaser.Physics.P2.Body, offset?: number[], angle?: number, maxForce?: number);

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
            /**
            * A P2 Material.
            * 
            * \o/ ~ "Because I'm a Material girl"
            *
            * @class Phaser.Physics.P2.Material
            * @constructor
            * @param {string} name - The user defined name given to this Material.
            */
            class Material extends p2.Material {

                constructor(name: string);

                /**
                * @property {string} name - The name of this object.
                * @default
                */
                name: string;

            }
            /**
            * A PointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays.
            *
            * @class Phaser.Physics.P2.PointProxy
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {any} destination - The object to bind to.
            */
            class PointProxy {

                constructor(world: Phaser.Physics.P2, destination: any);

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                /**
                * @name Phaser.Physics.P2.PointProxy#mx
                * @property {number} mx - The x property of this PointProxy get and set in meters.
                */
                mx: number;

                /**
                * @name Phaser.Physics.P2.PointProxy#my
                * @property {number} my - The x property of this PointProxy get and set in meters.
                */
                my: number;

            }
            /**
            * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
            *
            * @class Phaser.Physics.P2.PrismaticConstraint
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {p2.Body} bodyA - First connected body.
            * @param {p2.Body} bodyB - Second connected body.
            * @param {boolean} [lockRotation=true] - If set to false, bodyB will be free to rotate around its anchor point.
            * @param {Array} [anchorA] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [anchorB] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [axis] - An axis, defined in body A frame, that body B's anchor point may slide along. The value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.
            */
            class PrismaticConstraint extends p2.PrismaticConstraint {

                constructor(world: Phaser.Physics.P2, bodyA?: Phaser.Physics.P2.Body, bodyB?: Phaser.Physics.P2.Body, lockRotation?: boolean, anchorA?: number[], anchorB?: number[], axis?: number[], maxForce?: number);

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
            class RevoluteContraint extends p2.RevoluteConstraint {

                constructor(world: Phaser.Physics.P2, bodyA: Phaser.Physics.P2.Body, pivotA: number[], bodyB: Phaser.Physics.P2.Body, pivotB: number[], maxForce?: number);

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
            /**
            * Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
            *
            * @class Phaser.Physics.P2.Spring
            * @constructor
            * @param {Phaser.Physics.P2} world - A reference to the P2 World.
            * @param {p2.Body} bodyA - First connected body.
            * @param {p2.Body} bodyB - Second connected body.
            * @param {number} [restLength=1] - Rest length of the spring. A number > 0.
            * @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.
            * @param {number} [damping=1] - Damping of the spring. A number >= 0.
            * @param {Array} [worldA] - Where to hook the spring to body A in world coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [worldB] - Where to hook the spring to body B in world coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [localA] - Where to hook the spring to body A in local body coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].
            * @param {Array} [localB] - Where to hook the spring to body B in local body coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].
            */
            class Spring {

                constructor(world: Phaser.Physics.P2, bodyA: Phaser.Physics.P2.Body, bodyB: Phaser.Physics.P2.Body, restLength?: number, stiffness?: number, damping?: number, worldA?: number[], worldB?: number[], localA?: number[], localB?: number[]);

                /**
                * @property {Uint8ClampedArray} data - A Uint8ClampedArray view into BitmapData.buffer.
                */
                data: p2.LinearSpring;

                /**
                * @property {Phaser.Game} game - A reference to the currently running Game.
                */
                game: Phaser.Game;

                /**
                * @property {Phaser.World} world - A reference to the game world.
                */
                world: Phaser.Physics.P2;

            }
        }
    }
    /**
    * This is a base Plugin template to use for any Phaser plugin development.
    *
    * @class Phaser.Plugin
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {any} parent - The object that owns this plugin, usually Phaser.PluginManager.
    */
    class Plugin extends StateCycle {

        constructor(game: Phaser.Game, parent: any);

        /**
        * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
        * @default
        */
        active: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} hasPostRender - A flag to indicate if this plugin has a postRender method.
        * @default
        */
        hasPostRender: boolean;

        /**
        * @property {boolean} hasPostUpdate - A flag to indicate if this plugin has a postUpdate method.
        * @default
        */
        hasPostUpdate: boolean;

        /**
        * @property {boolean} hasPreUpdate - A flag to indicate if this plugin has a preUpdate method.
        * @default
        */
        hasPreUpdate: boolean;

        /**
        * @property {boolean} hasRender - A flag to indicate if this plugin has a render method.
        * @default
        */
        hasRender: boolean;

        /**
        * @property {boolean} hasUpdate - A flag to indicate if this plugin has an update method.
        * @default
        */
        hasUpdate: boolean;

        /**
        * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
        */
        parent: any;

        /**
        * @property {boolean} visible - Whether this camera is visible or not.
        * @default
        */
        visible: boolean;

        /**
        * Clear down this Plugin and null out references
        * @method Phaser.Plugin#destroy
        */
        destroy(): void;

        /**
        * Post-render is called after the Game Renderer and State.render have run.
        * It is only called if visible is set to true.
        * @method Phaser.Plugin#postRender
        */
        postRender(): void;

        /**
        * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).
        * It is only called if active is set to true.
        * @method Phaser.Plugin#preUpdate
        */
        preUpdate(): void;

        /**
        * Render is called right after the Game Renderer completes, but before the State.render.
        * It is only called if visible is set to true.
        * @method Phaser.Plugin#render
        */
        render(): void;

        /**
        * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.
        * It is only called if active is set to true.
        * @method Phaser.Plugin#update
        */
        update(): void;

    }
    module Plugin {

        class AStar extends Phaser.Plugin {

            static VERSION: string;

            static COST_ORTHAGONAL: number;

            static COST_DIAGAONAL: number;

            static DISTANCE_MANHATTEN: string;

            static DISTANCE_EUCLIDIAN: string;

            constructor(parent: any);

            /**
            * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
            */
            parent: any;

            /**
            * @property {number} version - The version of the map data (as specified in Tiled, usually 1).
            */
            version: string;

            findPath(startPoint: Phaser.Point, goalPoint: Phaser.Point): Phaser.Plugin.AStar.AStarPath;

            isWalkable(x: number, y: number): boolean;

            setAStarMap(map: Phaser.Tilemap, layerName: string, tilesetName: string): Phaser.Plugin.AStar;

        }
        module AStar {

            class AStarNode {

                constructor(x: number, y: number, isWalkable: boolean);

                /**
                * @property {number} x - The x coordinate of the center of the circle.
                */
                x: number;

                /**
                * @property {number} y - The y coordinate of the center of the circle.
                */
                y: number;

                g: number;

                h: number;

                f: number;

                /**
                * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
                */
                parent: Phaser.Plugin.AStar.AStarNode;

                travelCost: number;

                walkable: boolean;

            }
            class AStarPath {

                constructor(nodes: Phaser.Plugin.AStar.AStarNode[], start: Phaser.Plugin.AStar.AStarNode, goal: Phaser.Plugin.AStar.AStarNode);

                /**
                * @property {array} nodes - Array of associated child nodes.
                */
                nodes: Phaser.Plugin.AStar.AStarNode[];

                /**
                * @property {Phaser.Point} start - The start point of the line.
                */
                start: Phaser.Plugin.AStar.AStarNode;

                goal: Phaser.Plugin.AStar.AStarNode;

                visited: Phaser.Plugin.AStar.AStarNode[];

            }
        }
        class ColorHarmony extends Phaser.Plugin {

            getAnalogousHarmony(color: number, threshold?: number): any;

            getComplementHarmony(color: number): number;

            getSplitComplementHarmony(color: number, threshold: number): any;

            getTriadicHarmony(color: number): any;

        }
        class CSS3Filters extends Phaser.Plugin {

            constructor(parent: any);

            blur: number;

            brightness: number;

            contrast: number;

            grayscale: number;

            hueRotate: number;

            invert: number;

            opacity: number;

            saturate: number;

            sepia: number;

        }
        class TilemapWalker extends Phaser.Plugin {

            constructor(game: Phaser.Game, map: Phaser.Tilemap, layer?: any, x?: number, y?: number);

            /**
            * @name Phaser.Tile#collides
            * @property {boolean} collides - True if this tile can collide on any of its faces.
            * @readonly
            */
            collides: boolean;

            /**
            * @property {Phaser.Game} game - A reference to the currently running Game.
            */
            game: Phaser.Game;

            history: boolean;

            /**
            * @property {number} facing - A const reference to the direction the Body is traveling or facing.
            * @default
            */
            facing: number;

            map: Phaser.Tilemap;

            location: Phaser.Point;

            locationLayer: number;

            checkTile(x: number, y: number): boolean;

            getTileFromLocation(x: number, y: number): Phaser.Tile;

            getTiles(width: number, height: number, center?: boolean): any[];

            getTileBehind(distance?: number): Phaser.Tile;

            getTileBehindLeft(distance?: number): Phaser.Tile;

            getTileBehindRight(distance?: number): Phaser.Tile;

            getTileAhead(distance?: number): Phaser.Tile;

            getTileAheadLeft(distance?: number): Phaser.Tile;

            getTileAheadRight(distance?: number): Phaser.Tile;

            getTileLeft(distance: number): Phaser.Tile;

            getTileRight(distance: number): Phaser.Tile;

            moveForward(): boolean;

            moveBackward(): boolean;

            moveLeft(): boolean;

            moveRight(): boolean;

            putTile(index: number): void;

            setLocation(x: number, y: number, layer?: any): boolean;

            turnLeft(): void;

            turnRight(): void;

            updateLocation(x: number, y: number): boolean;

        }
        class SamplePlugin extends Phaser.Plugin {

            constructor(game: Phaser.Game, parent: any);

            addSprite(sprite: Phaser.Sprite): void;

            update(): void;

        }
        class VirtualJoystick extends Phaser.Plugin {

            constructor(game: Phaser.Game, parent: any);

            /**
            * @name Phaser.Line#angle
            * @property {number} angle - Gets the angle of the line.
            * @readonly
            */
            angle: number;

            base: Phaser.Sprite;

            baseBMD: Phaser.BitmapData;

            baseCircle: Phaser.Circle;

            /**
            * Returns the delta x value. The difference between world.x now and in the previous step.
            *
            * @name Phaser.Sprite#deltaX
            * @property {number} deltaX - The delta value. Positive if the motion was to the right, negative if to the left.
            * @readonly
            */
            deltaX: number;

            /**
            * Returns the delta y value. The difference between world.y now and in the previous step.
            *
            * @name Phaser.Sprite#deltaY
            * @property {number} deltaY - The delta value. Positive if the motion was downwards, negative if upwards.
            * @readonly
            */
            deltaY: number;

            /**
            * @property {number} distance - The distance from the top left to the bottom-right of this Frame.
            */
            distance: number;

            /**
            * @property {Phaser.Physics.P2.InversePointProxy} force - The force applied to the body.
            */
            force: number;

            isDragging: boolean;

            limit: number;

            limitPoint: Phaser.Point;

            location: Phaser.Point;

            nub: Phaser.Sprite;

            nubBMD: Phaser.BitmapData;

            /**
            * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
            */
            speed: number;

            /**
            * @property {number} x - The x coordinate of the center of the circle.
            */
            x: number;

            /**
            * @property {number} y - The y coordinate of the center of the circle.
            */
            y: number;

            init(x: number, y: number, diameter?: number, limit?: number): void;

            move(pointer: Phaser.Pointer, x: number, y: number): void;

            render(): void;

            setVelocity(sprite: Phaser.Sprite, minSpeed?: number, maxSpeed?: number): Phaser.Sprite;

            startDrag(): void;

            stopDrag(nub: Phaser.Sprite, pointer: Phaser.Pointer): void;

            update(): void;

        }
        class Webcam extends Phaser.Plugin {

            constructor(game: Phaser.Game, parent: any);

            /**
            * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
            * @default
            */
            active: boolean;

            /**
            * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
            */
            context: any;

            stream: any;

            video: HTMLVideoElement;

            connectCallback: (stream: any) => void;

            errorCallback: (e: any) => void;

            grab: (context: any, x: number, y: number) => void;

            start(width: number, height: number, context: any): void;

            stop(): void;

            update(): void;

        }
    }
    /**
    * The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.
    *
    * @class Phaser.PluginManager
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class PluginManager extends StateCycle {

        constructor(game: Phaser.Game, parent: any);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Plugin[]} plugins - An array of all the plugins being managed by this PluginManager.
        */
        plugins: Phaser.Plugin[];

        /**
        * Add a new Plugin into the PluginManager.
        * The Plugin must have 2 properties: game and parent. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.
        *
        * @method Phaser.PluginManager#add
        * @param {object|Phaser.Plugin} plugin - The Plugin to add into the PluginManager. This can be a function or an existing object.
        * @param {...*} parameter - Additional parameters that will be passed to the Plugin.init method.
        * @return {Phaser.Plugin} The Plugin that was added to the manager.
        */
        add(plugin: Phaser.Plugin, ...parameter: any[]): Phaser.Plugin;

        /**
        * Clear down this PluginManager, calls destroy on every plugin and nulls out references.
        *
        * @method Phaser.PluginManager#destroy
        */
        destroy(): void;

        /**
        * Post-render is called after the Game Renderer and State.render have run.
        * It only calls plugins who have visible=true.
        *
        * @method Phaser.PluginManager#postRender
        */
        postRender(): void;

        /**
        * PostUpdate is the last thing to be called before the world render.
        * In particular, it is called after the world postUpdate, which means the camera has been adjusted.
        * It only calls plugins who have active=true.
        *
        * @method Phaser.PluginManager#postUpdate
        */
        postUpdate(): void;

        /**
        * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).
        * It only calls plugins who have active=true.
        *
        * @method Phaser.PluginManager#preUpdate
        */
        preUpdate(): void;

        /**
        * Remove a Plugin from the PluginManager. It calls Plugin.destroy on the plugin before removing it from the manager.
        *
        * @method Phaser.PluginManager#remove
        * @param {Phaser.Plugin} plugin - The plugin to be removed.
        */
        remove(plugin: Phaser.Plugin): void;

        /**
        * Remove all Plugins from the PluginManager. It calls Plugin.destroy on every plugin before removing it from the manager.
        *
        * @method Phaser.PluginManager#removeAll
        */
        removeAll(): void;

        /**
        * Render is called right after the Game Renderer completes, but before the State.render.
        * It only calls plugins who have visible=true.
        *
        * @method Phaser.PluginManager#render
        */
        render(): void;

        /**
        * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.
        * It only calls plugins who have active=true.
        *
        * @method Phaser.PluginManager#update
        */
        update(): void;

    }
    /**
    * A Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
    * The following code creates a point at (0,0):
    * `var myPoint = new Phaser.Point();`
    * You can also use them as 2D Vectors and you'll find different vector related methods in this class.
    * 
    * @class Phaser.Point
    * @constructor
    * @param {number} [x=0] - The horizontal position of this Point.
    * @param {number} [y=0] - The vertical position of this Point.
    */
    class Point extends PIXI.Point {

        constructor(x?: number, y?: number);

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Adds the coordinates of two points together to create a new point.
        *
        * @method Phaser.Point.add
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static add(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Subtracts the coordinates of two points to create a new point.
        *
        * @method Phaser.Point.subtract
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static subtract(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Multiplies the coordinates of two points to create a new point.
        *
        * @method Phaser.Point.multiply
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static multiply(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Divides the coordinates of two points to create a new point.
        *
        * @method Phaser.Point.divide
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static divide(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Determines whether the two given Point objects are equal. They are considered equal if they have the same x and y values.
        *
        * @method Phaser.Point.equals
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @return {boolean} A value of true if the Points are equal, otherwise false.
        */
        static equals(a: Phaser.Point, b: Phaser.Point): boolean;

        /**
        * Returns the angle between two Point objects.
        *
        * @method Phaser.Point.angle
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @return {number} The angle between the two Points.
        */
        static angle(a: Phaser.Point, b: Phaser.Point): number;

        /**
        * Returns the angle squared between two Point objects.
        *
        * @method Phaser.Point.angleSq
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @return {number} The angle squared between the two Points.
        */
        static angleSq(a: Phaser.Point, b: Phaser.Point): number;

        /**
        * Creates a negative Point.
        *
        * @method Phaser.Point.negative
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static negative(a: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Adds two 2D Points together and multiplies the result by the given scalar.
        * 
        * @method Phaser.Point.multiplyAdd
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {number} s - The scaling value.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static multiplyAdd(a: Phaser.Point, b: Phaser.Point, scale: number, out?: Phaser.Point): Phaser.Point;

        /**
        * Interpolates the two given Points, based on the `f` value (between 0 and 1) and returns a new Point.
        * 
        * @method Phaser.Point.interpolate
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {number} f - The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static interpolate(a: Phaser.Point, b: Phaser.Point, alpha: number, out?: Phaser.Point): Phaser.Point;

        /**
        * Parses an object for x and/or y properties and returns a new Phaser.Point with matching values.
        * If the object doesn't contain those properties a Point with x/y of zero will be returned.
        *
        * @method Phaser.Point.parse
        * @static
        * @param {object} obj - The object to parse.
        * @param {string} [xProp='x'] - The property used to set the Point.x value.
        * @param {string} [yProp='y'] - The property used to set the Point.y value.
        * @return {Phaser.Point} The new Point object.
        */
        static parse(obj: any, xProp?: string, yProp?: string): Phaser.Point;

        /**
        * Return a perpendicular vector (90 degrees rotation)
        *
        * @method Phaser.Point.perp
        * @param {Phaser.Point} a - The Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static perp(a: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Return a perpendicular vector (-90 degrees rotation)
        *
        * @method Phaser.Point.rperp
        * @param {Phaser.Point} a - The Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static rperp(a: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties).
        *
        * @method Phaser.Point.distance
        * @param {object} a - The target object. Must have visible x and y properties that represent the center of the object.
        * @param {object} b - The target object. Must have visible x and y properties that represent the center of the object.
        * @param {boolean} [round=false] - Round the distance to the nearest integer.
        * @return {number} The distance between this Point object and the destination Point object.
        */
        static distance(a: any, b: any, round?: boolean): number;

        /**
        * Project two Points onto another Point.
        * 
        * @method Phaser.Point.project
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static project(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Project two Points onto a Point of unit length.
        * 
        * @method Phaser.Point.projectUnit
        * @param {Phaser.Point} a - The first Point object.
        * @param {Phaser.Point} b - The second Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static projectUnit(a: Phaser.Point, b: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Right-hand normalize (make unit length) a Point.
        *
        * @method Phaser.Point.normalRightHand
        * @param {Phaser.Point} a - The Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static normalRightHand(a: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Normalize (make unit length) a Point.
        *
        * @method Phaser.Point.normalize
        * @param {Phaser.Point} a - The Point object.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static normalize(a: Phaser.Point, out?: Phaser.Point): Phaser.Point;

        /**
        * Rotates a Point around the x/y coordinates given to the desired angle.
        *
        * @method Phaser.Point.rotate
        * @param {Phaser.Point} a - The Point object to rotate.
        * @param {number} x - The x coordinate of the anchor point
        * @param {number} y - The y coordinate of the anchor point
        * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point to.
        * @param {boolean} [asDegrees=false] - Is the given rotation in radians (false) or degrees (true)?
        * @param {number} [distance] - An optional distance constraint between the Point and the anchor.
        * @return {Phaser.Point} The modified point object.
        */
        static rotate(a: Phaser.Point, x: number, y: number, angle: number, asDegrees?: boolean, distance?: number): Phaser.Point;

        /**
        * Calculates centroid (or midpoint) from an array of points. If only one point is provided, that point is returned.
        *
        * @method Phaser.Point.centroid
        * @param {Phaser.Point[]} points - The array of one or more points.
        * @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.
        * @return {Phaser.Point} The new Point object.
        */
        static centroid(points: Phaser.Point[], out?: Phaser.Point): Phaser.Point;

        /**
        * Adds the given x and y values to this Point.
        *
        * @method Phaser.Point#add
        * @param {number} x - The value to add to Point.x.
        * @param {number} y - The value to add to Point.y.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        add(x: number, y: number): Phaser.Point;

        /**
        * Returns the angle between this Point object and another object with public x and y properties.
        *
        * @method Phaser.Point#angle
        * @param {Phaser.Point|any} a - The object to get the angle from this Point to.
        * @param {boolean} [asDegrees=false] - Is the given angle in radians (false) or degrees (true)?
        * @return {number} The angle between the two objects.
        */
        angle(a: Phaser.Point, asDegrees?: boolean): number;

        /**
        * Returns the angle squared between this Point object and another object with public x and y properties.
        *
        * @method Phaser.Point#angleSq
        * @param {Phaser.Point|any} a - The object to get the angleSq from this Point to.
        * @return {number} The angleSq between the two objects.
        */
        angleSq(a: Phaser.Point): number;

        /**
        * Clamps the x value of this Point to be between the given min and max.
        *
        * @method Phaser.Point#clampX
        * @param {number} min - The minimum value to clamp this Point to.
        * @param {number} max - The maximum value to clamp this Point to.
        * @return {Phaser.Point} This Point object.
        */
        clamp(min: number, max: number): Phaser.Point;

        /**
        * Clamps the x value of this Point to be between the given min and max.
        *
        * @method Phaser.Point#clampX
        * @param {number} min - The minimum value to clamp this Point to.
        * @param {number} max - The maximum value to clamp this Point to.
        * @return {Phaser.Point} This Point object.
        */
        clampX(min: number, max: number): Phaser.Point;

        /**
        * Clamps the y value of this Point to be between the given min and max
        *
        * @method Phaser.Point#clampY
        * @param {number} min - The minimum value to clamp this Point to.
        * @param {number} max - The maximum value to clamp this Point to.
        * @return {Phaser.Point} This Point object.
        */
        clampY(min: number, max: number): Phaser.Point;

        /**
        * Creates a copy of the given Point.
        *
        * @method Phaser.Point#clone
        * @param {Phaser.Point} [output] Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.
        * @return {Phaser.Point} The new Point object.
        */
        clone(output?: Phaser.Point): Phaser.Point;

        /**
        * Copies the x and y properties from any given object to this Point.
        *
        * @method Phaser.Point#copyFrom
        * @param {any} source - The object to copy from.
        * @return {Phaser.Point} This Point object.
        */
        copyFrom(source: Phaser.Point): Phaser.Point;

        copyTo<T>(dest: T): T;

        /**
        * Math.ceil() both the x and y properties of this Point.
        *
        * @method Phaser.Point#ceil
        * @return {Phaser.Point} This Point object.
        */
        ceil(): Phaser.Point;

        /**
        * The cross product of this and another Point object.
        * 
        * @method Phaser.Point#cross
        * @param {Phaser.Point} a - The Point object to get the cross product combined with this Point.
        * @return {number} The result.
        */
        cross(a: Phaser.Point): number;

        /**
        * Divides Point.x and Point.y by the given x and y values.
        *
        * @method Phaser.Point#divide
        * @param {number} x - The value to divide Point.x by.
        * @param {number} y - The value to divide Point.x by.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        divide(x: number, y: number): Phaser.Point;

        /**
        * Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties)
        *
        * @method Phaser.Point#distance
        * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.
        * @param {boolean} [round] - Round the distance to the nearest integer (default false).
        * @return {number} The distance between this Point object and the destination Point object.
        */
        distance(dest: Phaser.Point, round?: boolean): number;

        /**
        * The dot product of this and another Point object.
        * 
        * @method Phaser.Point#dot
        * @param {Phaser.Point} a - The Point object to get the dot product combined with this Point.
        * @return {number} The result.
        */
        dot(a: Phaser.Point): number;

        /**
        * Determines whether the given objects x/y values are equal to this Point object.
        *
        * @method Phaser.Point#equals
        * @param {Phaser.Point|any} a - The object to compare with this Point.
        * @return {boolean} A value of true if the x and y points are equal, otherwise false.
        */
        equals(a: Phaser.Point): boolean;

        /**
        * Math.floor() both the x and y properties of this Point.
        *
        * @method Phaser.Point#floor
        * @return {Phaser.Point} This Point object.
        */
        floor(): Phaser.Point;

        /**
        * Calculates the length of the Point object.
        *
        * @method Phaser.Point#getMagnitude
        * @return {number} The length of the Point.
        */
        getMagnitude(): number;

        /**
        * Calculates the length squared of the Point object.
        *
        * @method Phaser.Point#getMagnitudeSq
        * @return {number} The length ^ 2 of the Point.
        */
        getMagnitudeSq(): number;

        /**
        * Inverts the x and y values of this Point
        *
        * @method Phaser.Point#invert
        * @return {Phaser.Point} This Point object.
        */
        invert(): Phaser.Point;

        /**
        * Determine if this point is at 0,0.
        *
        * @method Phaser.Point#isZero
        * @return {boolean} True if this Point is 0,0, otherwise false.
        */
        isZero(): boolean;

        /**
        * Multiplies Point.x and Point.y by the given x and y values. Sometimes known as `Scale`.
        *
        * @method Phaser.Point#multiply
        * @param {number} x - The value to multiply Point.x by.
        * @param {number} y - The value to multiply Point.x by.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        multiply(x: number, y: number): Phaser.Point;

        /**
        * Alters the Point object so that its length is 1, but it retains the same direction.
        *
        * @method Phaser.Point#normalize
        * @return {Phaser.Point} This Point object.
        */
        normalize(): Phaser.Point;

        /**
        * Right-hand normalize (make unit length) this Point.
        *
        * @method Phaser.Point#normalRightHand
        * @return {Phaser.Point} This Point object.
        */
        normalRightHand(): Phaser.Point;

        /**
        * Make this Point perpendicular (90 degrees rotation)
        * 
        * @method Phaser.Point#perp
        * @return {Phaser.Point} This Point object.
        */
        perp(): Phaser.Point;

        /**
        * Make this Point perpendicular (-90 degrees rotation)
        * 
        * @method Phaser.Point#rperp
        * @return {Phaser.Point} This Point object.
        */
        rperp(): Phaser.Point;

        /**
        * Rotates this Point around the x/y coordinates given to the desired angle.
        *
        * @method Phaser.Point#rotate
        * @param {number} x - The x coordinate of the anchor point.
        * @param {number} y - The y coordinate of the anchor point.
        * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point to.
        * @param {boolean} asDegrees - Is the given rotation in radians (false) or degrees (true)?
        * @param {number} [distance] - An optional distance constraint between the Point and the anchor.
        * @return {Phaser.Point} The modified point object.
        */
        rotate(x: number, y: number, angle: number, asDegrees?: boolean, distance?: number): Phaser.Point;

        /**
        * Sets the `x` and `y` values of this Point object to the given values.
        * If you omit the `y` value then the `x` value will be applied to both, for example:
        * `Point.setTo(2)` is the same as `Point.setTo(2, 2)`
        *
        * @method Phaser.Point#setTo
        * @param {number} x - The horizontal value of this point.
        * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        set(x: number, y?: number): Phaser.Point;

        /**
        * Alters the length of the Point without changing the direction.
        *
        * @method Phaser.Point#setMagnitude
        * @param {number} magnitude - The desired magnitude of the resulting Point.
        * @return {Phaser.Point} This Point object.
        */
        setMagnitude(magnitude: number): Phaser.Point;

        /**
        * Sets the `x` and `y` values of this Point object to the given values.
        * If you omit the `y` value then the `x` value will be applied to both, for example:
        * `Point.setTo(2)` is the same as `Point.setTo(2, 2)`
        *
        * @method Phaser.Point#setTo
        * @param {number} x - The horizontal value of this point.
        * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        setTo(x: number, y?: number): Phaser.Point;

        /**
        * Subtracts the given x and y values from this Point.
        *
        * @method Phaser.Point#subtract
        * @param {number} x - The value to subtract from Point.x.
        * @param {number} y - The value to subtract from Point.y.
        * @return {Phaser.Point} This Point object. Useful for chaining method calls.
        */
        subtract(x: number, y: number): Phaser.Point;

        /**
        * Returns a string representation of this object.
        *
        * @method Phaser.Point#toString
        * @return {string} A string representation of the instance.
        */
        toString(): string;

    }
    /**
    * A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.
    *
    * @class Phaser.Pointer
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} id - The ID of the Pointer object within the game. Each game can have up to 10 active pointers.
    */
    class Pointer {

        constructor(game: Phaser.Game, id: number);

        /**
        * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
        * @default
        */
        active: boolean;

        /**
        * @property {any} button - The button property of the Pointer as set by the DOM event when this Pointer is started.
        * @default
        */
        button: any;

        circle: Phaser.Circle;

        /**
        * @property {number} clientX - The horizontal coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).
        */
        clientX: number;

        /**
        * @property {number} clientY - The vertical coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).
        */
        clientY: number;

        /**
        * @property {boolean} dirty - Internal PIXI var.
        * @default
        */
        dirty: boolean;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} id - Reserved for future multiple camera set-ups.
        * @default
        */
        id: number;

        /**
        * @property {number} identifier - The identifier property of the Pointer as set by the DOM event when this Pointer is started.
        * @default
        */
        identifier: number;

        /**
        * @property {boolean} isDown - The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
        * @default
        */
        isDown: boolean;

        /**
        * @property {boolean} isMouse - If the Pointer is a mouse this is true, otherwise false.
        * @default
        */
        isMouse: boolean;

        /**
        * @property {boolean} isUp - The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
        * @default
        */
        isUp: boolean;

        /**
        * @property {number} movementX - The horizontal processed relative movement of the Pointer in pixels since last event.
        * @default
        */
        movementX: number;

        /**
        * @property {number} movementY - The vertical processed relative movement of the Pointer in pixels since last event.
        * @default
        */
        movementY: number;

        /**
        * @property {number} msSinceLastClick - The number of milliseconds since the last click or touch event.
        * @default
        */
        msSinceLastClick: number;

        /**
        * @property {number} pageX - The horizontal coordinate of the Pointer relative to whole document.
        */
        pageX: number;

        /**
        * @property {number} pageY - The vertical coordinate of the Pointer relative to whole document.
        */
        pageY: number;

        /**
        * @property {number} pointerId - The pointerId property of the Pointer as set by the DOM event when this Pointer is started. The browser can and will recycle this value.
        * @default
        */
        pointerId: number;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {Phaser.Point} positionDown - A Phaser.Point object containing the x/y values of the pointer when it was last in a down state on the display.
        */
        positionDown: Phaser.Point;

        /**
        * @property {Phaser.Point} positionUp - A Phaser.Point object containing the x/y values of the pointer when it was last released.
        */
        positionUp: Phaser.Point;

        /**
        * @property {number} previousTapTime - A timestamp representing when the Pointer was last tapped or clicked.
        * @default
        */
        previousTapTime: number;

        /**
        * @property {number} rawMovementX - The horizontal raw relative movement of the Pointer in pixels since last event.
        * @default
        */
        rawMovementX: number;

        /**
        * @property {number} rawMovementY - The vertical raw relative movement of the Pointer in pixels since last event.
        * @default
        */
        rawMovementY: number;

        /**
        * @property {number} screenX - The horizontal coordinate of the Pointer relative to the screen.
        */
        screenX: number;

        /**
        * @property {number} screenY - The vertical coordinate of the Pointer relative to the screen.
        */
        screenY: number;

        /**
        * @property {Phaser.Sprite} target - If the camera is tracking a Sprite, this is a reference to it, otherwise null.
        * @default
        */
        target: any;

        /**
        * @property {any} targetObject - The Game Object this Pointer is currently over / touching / dragging.
        * @default
        */
        targetObject: any;

        /**
        * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.
        */
        timeDown: number;

        /**
        * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.
        * @default
        */
        timeUp: number;

        /**
        * @property {number} totalTouches - The total number of times this Pointer has been touched to the touchscreen.
        * @default
        */
        totalTouches: number;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {boolean} withinGame - true if the Pointer is over the game canvas, otherwise false.
        */
        withinGame: boolean;

        /**
        * The world X coordinate of the most recently active pointer.
        * @name Phaser.Input#worldX
        * @property {number} worldX - The world X coordinate of the most recently active pointer.
        * @readonly
        */
        worldX: number;

        /**
        * The world Y coordinate of the most recently active pointer.
        * @name Phaser.Input#worldY
        * @property {number} worldY - The world Y coordinate of the most recently active pointer.
        * @readonly
        */
        worldY: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Add a click trampoline to this pointer.
        *
        * A click trampoline is a callback that is run on the DOM 'click' event; this is primarily
        * needed with certain browsers (ie. IE11) which restrict some actions like requestFullscreen
        * to the DOM 'click' event and reject it for 'pointer*' and 'mouse*' events.
        *
        * This is used internally by the ScaleManager; click trampoline usage is uncommon.
        * Click trampolines can only be added to pointers that are currently down.
        *
        * @method Phaser.Pointer#addClickTrampoline
        * @protected
        * @param {string} name - The name of the trampoline; must be unique among active trampolines in this pointer.
        * @param {function} callback - Callback to run/trampoline.
        * @param {object} callbackContext - Context of the callback.
        * @param {object[]|null} callbackArgs - Additional callback args, if any. Supplied as an array.
        */
        addClickTrampoline(name: string, callback: Function, callbackContext: any, ...callbackArgs: any[]): void;

        /**
        * The Pointer is considered justPressed if the time it was pressed onto the touchscreen or clicked is less than justPressedRate.
        * Note that calling justPressed doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.
        * If you wish to check if the Pointer was pressed down just once then see the Sprite.events.onInputDown event.
        * @method Phaser.Pointer#justPressed
        * @param {number} [duration] - The time to check against. If none given it will use InputManager.justPressedRate.
        * @return {boolean} true if the Pointer was pressed down within the duration given.
        */
        justPressed(duration?: number): boolean;

        /**
        * The Pointer is considered justReleased if the time it left the touchscreen is less than justReleasedRate.
        * Note that calling justReleased doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.
        * If you wish to check if the Pointer was released just once then see the Sprite.events.onInputUp event.
        * @method Phaser.Pointer#justReleased
        * @param {number} [duration] - The time to check against. If none given it will use InputManager.justReleasedRate.
        * @return {boolean} true if the Pointer was released within the duration given.
        */
        justReleased(duration?: number): boolean;

        /**
        * Called when the Pointer leaves the target area.
        *
        * @method Phaser.Pointer#leave
        * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.
        */
        leave(event: any): void;

        /**
        * Called when the Pointer is moved.
        * 
        * @method Phaser.Pointer#move
        * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.
        * @param {boolean} [fromClick=false] - Was this called from the click event?
        */
        move(event: any, fromClick?: boolean): void;

        /**
        * Resets the Pointer properties. Called by InputManager.reset when you perform a State change.
        * @method Phaser.Pointer#reset
        */
        reset(): void;

        /**
        * Resets the movementX and movementY properties. Use in your update handler after retrieving the values.
        * @method Phaser.Pointer#resetMovement
        */
        resetMovement(): void;

        /**
        * Called when the Pointer is pressed onto the touchscreen.
        * @method Phaser.Pointer#start
        * @param {any} event - The DOM event from the browser.
        */
        start(event: any): void;

        /**
        * Called when the Pointer leaves the touchscreen.
        *
        * @method Phaser.Pointer#stop
        * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.
        */
        stop(event: any): void;

        /**
        * Called by the Input Manager.
        * @method Phaser.Pointer#update
        */
        update(): void;

    }
    /**
    * Creates a new Polygon.
    * 
    * The points can be set from a variety of formats:
    *
    * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
    * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
    * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
    * - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
    * - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
    * - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
    *
    * @class Phaser.Polygon
    * @constructor
    * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
    */
    class Polygon {

        constructor(points: any[]);

        /**
        * The area of this Circle.
        * @name Phaser.Circle#area
        * @property {number} area - The area of this circle.
        * @readonly
        */
        area: number;

        /**
        * Sets and modifies the points of this polygon.
        *
        * See {@link Phaser.Polygon#setTo setTo} for the different kinds of arrays formats that can be assigned.
        *
        * @name Phaser.Polygon#points
        * @property {Phaser.Point[]} points - The array of vertex points.
        * @deprecated Use `setTo`.
        */
        points: any[]; //number : point

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * Creates a copy of the given Polygon.
        * This is a deep clone, the resulting copy contains new Phaser.Point objects
        *
        * @method Phaser.Polygon#clone
        * @param {Phaser.Polygon} [output=(new Polygon)] - The polygon to update. If not specified a new polygon will be created.
        * @return {Phaser.Polygon} The cloned (`output`) polygon object.
        */
        clone(output: Phaser.Polygon): Phaser.Polygon;

        /**
        * Checks whether the x and y coordinates are contained within this polygon.
        *
        * @method Phaser.Polygon#contains
        * @param {number} x - The X value of the coordinate to test.
        * @param {number} y - The Y value of the coordinate to test.
        * @return {boolean} True if the coordinates are within this polygon, otherwise false.
        */
        contains(x: number, y: number): boolean;

        /**
        * Sets this Polygon to the given points.
        *
        * The points can be set from a variety of formats:
        *
        * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
        * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
        * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
        * - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
        * - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
        * - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
        *
        * `setTo` may also be called without any arguments to remove all points.
        *
        * @method Phaser.Polygon#setTo
        * @param {Phaser.Point[]|number[]|...Phaser.Point|...number} points - The points to set.
        * @return {Phaser.Polygon} This Polygon object
        */
        setTo(points: any[]): void;

    }
    /**
    * A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.
    * However I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.
    * Original version at https://github.com/timohausmann/quadtree-js/
    *
    * @class Phaser.QuadTree
    * @constructor
    * @param {number} x - The top left coordinate of the quadtree.
    * @param {number} y - The top left coordinate of the quadtree.
    * @param {number} width - The width of the quadtree in pixels.
    * @param {number} height - The height of the quadtree in pixels.
    * @param {number} [maxObjects=10] - The maximum number of objects per node.
    * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.
    * @param {number} [level=0] - Which level is this?
    */
    class QuadTree {

        constructor(x: number, y: number, width: number, height: number, maxObject?: number, maxLevels?: number, level?: number);

        /**
        * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
        * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
        * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
        * 
        * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
        */
        bounds: {

            x: number;
            y: number;
            width: number;
            height: number;
            subWidth: number;
            subHeight: number;
            right: number;
            bottom: number;
        };
        /**
        * @property {number} level - The current level.
        */
        level: number;

        /**
        * @property {number} maxObjects - The maximum number of objects per node.
        * @default
        */
        maxObjects: number;

        /**
        * @property {number} maxLevels - The maximum number of levels to break down to.
        * @default
        */
        maxLevels: number;

        /**
        * @property {array} objects - Array of quadtree children.
        */
        objects: any[];

        /**
        * @property {array} nodes - Array of associated child nodes.
        */
        nodes: any[];

        /**
        * Clear the quadtree.
        * @method Phaser.QuadTree#clear
        */
        clear(): void;

        /**
        * Determine which node the object belongs to.
        *
        * @method Phaser.QuadTree#getIndex
        * @param {Phaser.Rectangle|object} rect - The bounds in which to check.
        * @return {number} index - Index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node.
        */
        getIndex(rect: any): number;

        /**
        * Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.
        *
        * @method Phaser.QuadTree#insert
        * @param {Phaser.Physics.Arcade.Body|object} body - The Body object to insert into the quadtree. Can be any object so long as it exposes x, y, right and bottom properties.
        */
        insert(body: any): void;

        /**
        * Populates this quadtree with the children of the given Group. In order to be added the child must exist and have a body property.
        *
        * @method Phaser.QuadTree#populate
        * @param {Phaser.Group} group - The Group to add to the quadtree.
        */
        populate(group: Phaser.Group): void;

        /**
        * Handler for the populate method.
        *
        * @method Phaser.QuadTree#populateHandler
        * @param {Phaser.Sprite|object} sprite - The Sprite to check.
        */
        populateHandler(sprite: Phaser.Sprite): void;

        /**
        * Resets the QuadTree.
        *
        * @method Phaser.QuadTree#reset
        * @param {number} x - The top left coordinate of the quadtree.
        * @param {number} y - The top left coordinate of the quadtree.
        * @param {number} width - The width of the quadtree in pixels.
        * @param {number} height - The height of the quadtree in pixels.
        * @param {number} [maxObjects=10] - The maximum number of objects per node.
        * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.
        * @param {number} [level=0] - Which level is this?
        */
        reset(x: number, y: number, width: number, height: number, maxObject?: number, maxLevels?: number, level?: number): void;

        /**
        * Return all objects that could collide with the given Sprite or Rectangle.
        *
        * @method Phaser.QuadTree#retrieve
        * @param {Phaser.Sprite|Phaser.Rectangle} source - The source object to check the QuadTree against. Either a Sprite or Rectangle.
        * @return {array} - Array with all detected objects.
        */
        retrieve(source: any): any[];

        /**
        * Split the node into 4 subnodes
        *
        * @method Phaser.QuadTree#split
        */
        split(): void;

    }
    /**
    * An extremely useful repeatable random data generator.
    * Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.
    * Random number generator from http://baagoe.org/en/wiki/Better_random_numbers_for_javascript
    *
    * @class Phaser.RandomDataGenerator
    * @constructor
    * @param {any[]} [seeds] - An array of values to use as the seed.
    */
    class RandomDataGenerator {

        constructor(seeds: number[]);

        /**
        * Returns a random angle between -180 and 180.
        *
        * @method Phaser.RandomDataGenerator#angle
        * @return {number} A random number between -180 and 180.
        */
        angle(): number;

        /**
        * Returns a random integer between and including min and max.
        * This method is an alias for RandomDataGenerator.integerInRange.
        *
        * @method Phaser.RandomDataGenerator#between
        * @param {number} min - The minimum value in the range.
        * @param {number} max - The maximum value in the range.
        * @return {number} A random number between min and max.
        */
        between(min: number, max: number): number;

        /**
        * Returns a random real number between 0 and 1.
        *
        * @method Phaser.RandomDataGenerator#frac
        * @return {number} A random real number between 0 and 1.
        */
        frac(): number;

        /**
        * Returns a random integer between 0 and 2^32.
        *
        * @method Phaser.RandomDataGenerator#integer
        * @return {number} A random integer between 0 and 2^32.
        */
        integer(): number;

        /**
        * Returns a random integer between and including min and max.
        *
        * @method Phaser.RandomDataGenerator#integerInRange
        * @param {number} min - The minimum value in the range.
        * @param {number} max - The maximum value in the range.
        * @return {number} A random number between min and max.
        */
        integerInRange(min: number, max: number): number;

        /**
        * Returns a random real number between -1 and 1.
        *
        * @method Phaser.RandomDataGenerator#normal
        * @return {number} A random real number between -1 and 1.
        */
        normal(): number;

        pick<T>(ary: T[]): T;

        /**
        * Returns a random real number between 0 and 2^32.
        *
        * @method Phaser.RandomDataGenerator#real
        * @return {number} A random real number between 0 and 2^32.
        */
        real(): number;

        /**
        * Returns a random real number between min and max.
        *
        * @method Phaser.RandomDataGenerator#realInRange
        * @param {number} min - The minimum value in the range.
        * @param {number} max - The maximum value in the range.
        * @return {number} A random number between min and max.
        */
        realInRange(min: number, max: number): number;

        /**
        * Reset the seed of the random data generator.
        *
        * @method Phaser.RandomDataGenerator#sow
        * @param {any[]} seeds
        */
        sow(seeds: number[]): void;

        /**
        * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
        *
        * @method Phaser.RandomDataGenerator#timestamp
        * @param {number} min - The minimum value in the range.
        * @param {number} max - The maximum value in the range.
        * @return {number} A random timestamp between min and max.
        */
        timestamp(min: number, max: number): number;

        /**
        * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
        *
        * @method Phaser.RandomDataGenerator#uuid
        * @return {string} A valid RFC4122 version4 ID hex string
        */
        uuid(): number;

        weightedPick<T>(ary: T[]): T;

    }
    /**
    * Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters.
    * If you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.
    *
    * @class Phaser.Rectangle
    * @constructor
    * @param {number} x - The x coordinate of the top-left corner of the Rectangle.
    * @param {number} y - The y coordinate of the top-left corner of the Rectangle.
    * @param {number} width - The width of the Rectangle. Should always be either zero or a positive value.
    * @param {number} height - The height of the Rectangle. Should always be either zero or a positive value.
    */
    class Rectangle {

        constructor(x: number, y: number, width: number, height: number);

        /**
        * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#bottom
        * @property {number} bottom - Gets or sets the bottom of the circle.
        */
        bottom: number;

        /**
        * The location of the Rectangles bottom right corner as a Point object.
        * @name Phaser.Rectangle#bottom
        * @property {Phaser.Point} bottomRight - Gets or sets the location of the Rectangles bottom right corner as a Point object.
        */
        bottomRight: Phaser.Point;

        /**
        * The x coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerX
        * @property {number} centerX - The x coordinate of the center of the Rectangle.
        */
        centerX: number;

        /**
        * The y coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerY
        * @property {number} centerY - The y coordinate of the center of the Rectangle.
        */
        centerY: number;

        /**
        * Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
        * If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0.
        * @name Phaser.Circle#empty
        * @property {boolean} empty - Gets or sets the empty state of the circle.
        */
        empty: boolean;

        /**
        * @name Phaser.Rectangle#halfHeight
        * @property {number} halfHeight - Half of the height of the Rectangle.
        * @readonly
        */
        halfHeight: number;

        /**
        * @name Phaser.Rectangle#halfWidth
        * @property {number} halfWidth - Half of the width of the Rectangle.
        * @readonly
        */
        halfWidth: number;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
        * @name Phaser.Rectangle#left
        * @property {number} left - The x coordinate of the left of the Rectangle.
        */
        left: number;

        /**
        * The perimeter size of the Rectangle. This is the sum of all 4 sides.
        * @name Phaser.Rectangle#perimeter
        * @property {number} perimeter - The perimeter size of the Rectangle. This is the sum of all 4 sides.
        * @readonly
        */
        perimeter: number;

        /**
        * A random value between the left and right values (inclusive) of the Rectangle.
        *
        * @name Phaser.Rectangle#randomX
        * @property {number} randomX - A random value between the left and right values (inclusive) of the Rectangle.
        */
        randomX: number;

        /**
        * A random value between the top and bottom values (inclusive) of the Rectangle.
        *
        * @name Phaser.Rectangle#randomY
        * @property {number} randomY - A random value between the top and bottom values (inclusive) of the Rectangle.
        */
        randomY: number;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#top
        * @property {number} top - Gets or sets the top of the circle.
        */
        top: number;

        /**
        * The location of the Rectangles top left corner as a Point object.
        * @name Phaser.Rectangle#topLeft
        * @property {Phaser.Point} topLeft - The location of the Rectangles top left corner as a Point object.
        */
        topLeft: Phaser.Point;

        /**
        * The location of the Rectangles top right corner as a Point object.
        * @name Phaser.Rectangle#topRight
        * @property {Phaser.Point} topRight - The location of the Rectangles top left corner as a Point object.
        */
        topRight: Phaser.Point;

        /**
        * The volume of the Rectangle derived from width * height.
        * @name Phaser.Rectangle#volume
        * @property {number} volume - The volume of the Rectangle derived from width * height.
        * @readonly
        */
        volume: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        static aabb(points: Phaser.Point[], out?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
        * @method Phaser.Rectangle.clone
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle}
        */
        static clone(a: Phaser.Rectangle, output?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.
        * @method Phaser.Rectangle.contains
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {number} x - The x coordinate of the point to test.
        * @param {number} y - The y coordinate of the point to test.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        static contains(a: Phaser.Rectangle, x: number, y: number): boolean;

        /**
        * Determines whether the specified point is contained within the rectangular region defined by this Rectangle object. This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.
        * @method Phaser.Rectangle.containsPoint
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {Phaser.Point} point - The point object being checked. Can be Point or any object with .x and .y values.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        static containsPoint(a: Phaser.Rectangle, point: Phaser.Point): boolean;

        /**
        * Determines whether the specified coordinates are contained within the region defined by the given raw values.
        * @method Phaser.Rectangle.containsRaw
        * @param {number} rx - The x coordinate of the top left of the area.
        * @param {number} ry - The y coordinate of the top left of the area.
        * @param {number} rw - The width of the area.
        * @param {number} rh - The height of the area.
        * @param {number} x - The x coordinate of the point to test.
        * @param {number} y - The y coordinate of the point to test.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        static containsRaw(rx: number, ry: number, rw: number, rh: number, x: number, y: number): boolean;

        /**
        * Determines whether the first Rectangle object is fully contained within the second Rectangle object.
        * A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.
        * @method Phaser.Rectangle.containsRect
        * @param {Phaser.Rectangle} a - The first Rectangle object.
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        static containsRect(a: Phaser.Rectangle, b: Phaser.Rectangle): boolean;

        /**
        * Determines whether the two Rectangles are equal.
        * This method compares the x, y, width and height properties of each Rectangle.
        * @method Phaser.Rectangle.equals
        * @param {Phaser.Rectangle} a - The first Rectangle object.
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.
        */
        static equals(a: Phaser.Rectangle, b: Phaser.Rectangle): boolean;

        /**
        * Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.
        * @method Phaser.Rectangle.inflate
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {number} dx - The amount to be added to the left side of the Rectangle.
        * @param {number} dy - The amount to be added to the bottom side of the Rectangle.
        * @return {Phaser.Rectangle} This Rectangle object.
        */
        static inflate(a: Phaser.Rectangle, dx: number, dy: number): Phaser.Rectangle;

        /**
        * Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.
        * @method Phaser.Rectangle.inflatePoint
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {Phaser.Point} point - The x property of this Point object is used to increase the horizontal dimension of the Rectangle object. The y property is used to increase the vertical dimension of the Rectangle object.
        * @return {Phaser.Rectangle} The Rectangle object.
        */
        static inflatePoint(a: Phaser.Rectangle, point: Phaser.Point): Phaser.Rectangle;

        /**
        * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.
        * @method Phaser.Rectangle.intersection
        * @param {Phaser.Rectangle} a - The first Rectangle object.
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.
        */
        static intersection(a: Phaser.Rectangle, b: Phaser.Rectangle, out?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Determines whether the two Rectangles intersect with each other.
        * This method checks the x, y, width, and height properties of the Rectangles.
        * @method Phaser.Rectangle.intersects
        * @param {Phaser.Rectangle} a - The first Rectangle object.
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.
        */
        static intersects(a: Phaser.Rectangle, b: Phaser.Rectangle): boolean;

        /**
        * Determines whether the object specified intersects (overlaps) with the given values.
        * @method Phaser.Rectangle.intersectsRaw
        * @param {number} left - The x coordinate of the left of the area.
        * @param {number} right - The right coordinate of the area.
        * @param {number} top - The y coordinate of the area.
        * @param {number} bottom - The bottom coordinate of the area.
        * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0
        * @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.
        */
        static intersectsRaw(left: number, right: number, top: number, bottom: number, tolerance: number): boolean;

        /**
        * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.
        * @method Phaser.Rectangle.size
        * @param {Phaser.Rectangle} a - The Rectangle object.
        * @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.
        * @return {Phaser.Point} The size of the Rectangle object
        */
        static size(a: Phaser.Rectangle, output?: Phaser.Point): Phaser.Point;

        /**
        * Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.
        * @method Phaser.Rectangle.union
        * @param {Phaser.Rectangle} a - The first Rectangle object.
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.
        */
        static union(a: Phaser.Rectangle, b: Phaser.Rectangle, out?: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Centers this Rectangle so that the center coordinates match the given x and y values.
        *
        * @method Phaser.Rectangle#centerOn
        * @param {number} x - The x coordinate to place the center of the Rectangle at.
        * @param {number} y - The y coordinate to place the center of the Rectangle at.
        * @return {Phaser.Rectangle} This Rectangle object
        */
        centerOn(x: number, y: number): Phaser.Rectangle;

        /**
        * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
        * @method Phaser.Rectangle#clone
        * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle}
        */
        clone(output: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.
        * @method Phaser.Rectangle#contains
        * @param {number} x - The x coordinate of the point to test.
        * @param {number} y - The y coordinate of the point to test.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        contains(x: number, y: number): boolean;

        /**
        * Determines whether the first Rectangle object is fully contained within the second Rectangle object.
        * A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.
        * @method Phaser.Rectangle#containsRect
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
        */
        containsRect(b: Phaser.Rectangle): boolean;

        /**
        * Copies the x, y, width and height properties from any given object to this Rectangle.
        * @method Phaser.Rectangle#copyFrom
        * @param {any} source - The object to copy from.
        * @return {Phaser.Rectangle} This Rectangle object.
        */
        copyFrom(source: any): Phaser.Rectangle;

        /**
        * Copies the x, y, width and height properties from this Rectangle to any given object.
        * @method Phaser.Rectangle#copyTo
        * @param {any} source - The object to copy to.
        * @return {object} This object.
        */
        copyTo(dest: any): any;

        /**
        * Determines whether the two Rectangles are equal.
        * This method compares the x, y, width and height properties of each Rectangle.
        * @method Phaser.Rectangle#equals
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.
        */
        equals(b: Phaser.Rectangle): boolean;

        /**
        * Runs Math.floor() on both the x and y values of this Rectangle.
        * @method Phaser.Rectangle#floor
        */
        floor(): void;

        /**
        * Runs Math.floor() on the x, y, width and height values of this Rectangle.
        * @method Phaser.Rectangle#floorAll
        */
        floorAll(): void;

        /**
        * Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.
        * @method Phaser.Rectangle#inflate
        * @param {number} dx - The amount to be added to the left side of the Rectangle.
        * @param {number} dy - The amount to be added to the bottom side of the Rectangle.
        * @return {Phaser.Rectangle} This Rectangle object.
        */
        inflate(dx: number, dy: number): Phaser.Rectangle;

        /**
        * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.
        * @method Phaser.Rectangle#intersection
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @param {Phaser.Rectangle} out - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.
        */
        intersection(b: Phaser.Rectangle, out: Phaser.Rectangle): Phaser.Rectangle;

        /**
        * Determines whether the two Rectangles intersect with each other.
        * This method checks the x, y, width, and height properties of the Rectangles.
        * @method Phaser.Rectangle#intersects
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0.
        * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.
        */
        intersects(b: Phaser.Rectangle, tolerance: number): boolean;

        /**
        * Determines whether the coordinates given intersects (overlaps) with this Rectangle.
        *
        * @method Phaser.Rectangle#intersectsRaw
        * @param {number} left - The x coordinate of the left of the area.
        * @param {number} right - The right coordinate of the area.
        * @param {number} top - The y coordinate of the area.
        * @param {number} bottom - The bottom coordinate of the area.
        * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0
        * @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.
        */
        intersectsRaw(left: number, right: number, top: number, bottom: number, tolerance: number): boolean;

        /**
        * Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.
        * @method Phaser.Rectangle#offset
        * @param {number} dx - Moves the x value of the Rectangle object by this amount.
        * @param {number} dy - Moves the y value of the Rectangle object by this amount.
        * @return {Phaser.Rectangle} This Rectangle object.
        */
        offset(dx: number, dy: number): Phaser.Rectangle;

        /**
        * Adjusts the location of the Rectangle object using a Point object as a parameter. This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.
        * @method Phaser.Rectangle#offsetPoint
        * @param {Phaser.Point} point - A Point object to use to offset this Rectangle object.
        * @return {Phaser.Rectangle} This Rectangle object.
        */
        offsetPoint(point: Phaser.Point): Phaser.Rectangle;

        /**
        * Sets the members of Rectangle to the specified values.
        * @method Phaser.Rectangle#setTo
        * @param {number} x - The x coordinate of the top-left corner of the Rectangle.
        * @param {number} y - The y coordinate of the top-left corner of the Rectangle.
        * @param {number} width - The width of the Rectangle. Should always be either zero or a positive value.
        * @param {number} height - The height of the Rectangle. Should always be either zero or a positive value.
        * @return {Phaser.Rectangle} This Rectangle object
        */
        setTo(x: number, y: number, width: number, height: number): Phaser.Rectangle;

        /**
        * Scales the width and height of this Rectangle by the given amounts.
        * 
        * @method Phaser.Rectangle#scale
        * @param {number} x - The amount to scale the width of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the width, etc.
        * @param {number} [y] - The amount to scale the height of the Rectangle by. A value of 0.5 would reduce by half, a value of 2 would double the height, etc.
        * @return {Phaser.Rectangle} This Rectangle object
        */
        scale(x: number, y?: number): Phaser.Rectangle;

        /**
        * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.
        * @method Phaser.Rectangle#size
        * @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.
        * @return {Phaser.Point} The size of the Rectangle object.
        */
        size(output?: Phaser.Point): Phaser.Point;

        /**
        * Returns a string representation of this object.
        * @method Phaser.Rectangle#toString
        * @return {string} A string representation of the instance.
        */
        toString(): string;

        /**
        * Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.
        * @method Phaser.Rectangle#union
        * @param {Phaser.Rectangle} b - The second Rectangle object.
        * @param {Phaser.Rectangle} [out] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
        * @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.
        */
        union(b: Phaser.Rectangle, out?: Phaser.Rectangle): Phaser.Rectangle;

    }
    /**
    * A RenderTexture is a special texture that allows any displayObject to be rendered to it. It allows you to take many complex objects and
    * render them down into a single quad (on WebGL) which can then be used to texture other display objects with. A way of generating textures at run-time.
    * 
    * @class Phaser.RenderTexture
    * @constructor
    * @extends PIXI.RenderTexture
    * @param {Phaser.Game} game - Current game instance.
    * @param {string} key - Internal Phaser reference key for the render texture.
    * @param {number} [width=100] - The width of the render texture.
    * @param {number} [height=100] - The height of the render texture.
    * @param {string} [key=''] - The key of the RenderTexture in the Cache, if stored there.
    * @param {number} [scaleMode=Phaser.scaleModes.DEFAULT] - One of the Phaser.scaleModes consts.
    * @param {number} [resolution=1] - The resolution of the texture being generated.
    */
    class RenderTexture extends PIXI.RenderTexture {

        constructor(game: Phaser.Game, width?: number, height?: number, key?: string, scaleMode?: number, resolution?: number);

        crop: PIXI.Rectangle;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: string;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        render(displayObject: PIXI.DisplayObject, position: Phaser.Point, clear?: boolean): void;

        renderXY(displayObject: PIXI.DisplayObject, x: number, y: number, clear?: boolean): void;

    }
    /**
    * Abstracts away the use of RAF or setTimeOut for the core game update loop.
    *
    * @class Phaser.RequestAnimationFrame
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.
    */
    class RequestAnimationFrame {

        constructor(game: Phaser.Game, forceSetTimeOut?: boolean);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isRunning - Is game running or paused?
        * @readonly
        */
        isRunning: boolean;

        /**
        * Is the browser using requestAnimationFrame?
        * @method Phaser.RequestAnimationFrame#isRAF
        * @return {boolean}
        */
        isRAF(): boolean;

        /**
        * Is the browser using setTimeout?
        * @method Phaser.RequestAnimationFrame#isSetTimeOut
        * @return {boolean}
        */
        isSetTimeOut(): boolean;

        /**
        * Starts the requestAnimationFrame running or setTimeout if unavailable in browser
        * @method Phaser.RequestAnimationFrame#start
        */
        start(): boolean;

        /**
        * Stops the requestAnimationFrame from running.
        * @method Phaser.RequestAnimationFrame#stop
        */
        stop(): void;

        /**
        * The update method for the requestAnimationFrame
        * @method Phaser.RequestAnimationFrame#updateRAF
        * 
        */
        updateRAF(rafTime: number): void;

        /**
        * The update method for the setTimeout.
        * @method Phaser.RequestAnimationFrame#updateSetTimeout
        */
        updateSetTimeout(): void;

    }
    /**
    * A Retro Font is similar to a BitmapFont, in that it uses a texture to render the text. However unlike a BitmapFont every character in a RetroFont
    * is the same size. This makes it similar to a sprite sheet. You typically find font sheets like this from old 8/16-bit games and demos.
    * 
    * @class Phaser.RetroFont
    * @extends Phaser.RenderTexture
    * @constructor
    * @param {Phaser.Game} game - Current game instance.
    * @param {string} key - The font set graphic set as stored in the Game.Cache.
    * @param {number} characterWidth - The width of each character in the font set.
    * @param {number} characterHeight - The height of each character in the font set.
    * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
    * @param {number} [charsPerRow] - The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.
    * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.
    * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.
    * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
    * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
    */
    class RetroFont extends Phaser.RenderTexture {

        constructor(game: Phaser.Game, key: string, characterWidth: number, characterHeight: number, chars: string, charsPerRow?: number, xSpacing?: number, ySpacing?: number, xOffset?: number, yOffset?: number);

        static ALIGN_CENTER: string;

        static ALIGN_LEFT: string;

        static ALIGN_RIGHT: string;

        static TEXT_SET1: string;

        static TEXT_SET2: string;

        static TEXT_SET3: string;

        static TEXT_SET4: string;

        static TEXT_SET5: string;

        static TEXT_SET6: string;

        static TEXT_SET7: string;

        static TEXT_SET8: string;

        static TEXT_SET9: string;

        static TEXT_SET10: string;

        static TEXT_SET11: string;

        /**
        * @name Phaser.Text#align
        * @property {string} align - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.
        */
        align: string;

        /**
        * @property {boolean} autoUpperCase - Automatically convert any text to upper case. Lots of old bitmap fonts only contain upper-case characters, so the default is true.
        * @default
        */
        autoUpperCase: boolean;

        /**
        * @property {number} characterHeight - The height of each character in the font set.
        */
        characterHeight: number;

        /**
        * @property {number} characterPerRow - The number of characters per row in the font set.
        */
        characterPerRow: number;

        /**
        * @property {number} characterSpacingX - If the characters in the font set have horizontal spacing between them set the required amount here.
        */
        characterSpacingX: number;

        /**
        * @property {number} characterSpacingY - If the characters in the font set have vertical spacing between them set the required amount here.
        */
        characterSpacingY: number;

        /**
        * @property {number} characterWidth - The width of each character in the font set.
        */
        characterWidth: number;

        /**
        * @property {number} customSpacingX - Adds horizontal spacing between each character of the font, in pixels.
        * @default
        */
        customSpacingX: number;

        /**
        * @property {number} customSpacingY - Adds vertical spacing between each line of multi-line text, set in pixels.
        * @default
        */
        customSpacingY: number;

        fixedWidth: number;

        /**
        * @property {Image} fontSet - A reference to the image stored in the Game.Cache that contains the font.
        */
        fontSet: Image;

        /**
        * @property {Phaser.FrameData} frameData - The FrameData representing this Retro Font.
        */
        frameData: Phaser.FrameData;

        /**
        * @property {boolean} multiLine - If set to true all carriage-returns in text will form new lines (see align). If false the font will only contain one single line of text (the default)
        * @default
        */
        multiLine: boolean;

        /**
        * @property {number} offsetX - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
        * @readonly
        */
        offsetX: number;

        /**
        * @property {number} offsetY - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
        * @readonly
        */
        offsetY: number;

        /**
        * Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.
        *
        * @name Phaser.Stage#smoothed
        * @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
        */
        smoothed: string;

        /**
        * @property {Phaser.Image} stamp - The image that is stamped to the RenderTexture for each character in the font.
        * @readonly
        */
        stamp: Phaser.Image;

        /**
        * The text string to be displayed by this Text object, taking into account the style settings.
        * @name Phaser.Text#text
        * @property {string} text - The text string to be displayed by this Text object, taking into account the style settings.
        */
        text: string;

        /**
        * Updates the texture with the new text.
        *
        * @method Phaser.RetroFont#buildRetroFontText
        * @memberof Phaser.RetroFont
        */
        buildRetroFontText(): void;

        /**
        * Works out the longest line of text in _text and returns its length
        *
        * @method Phaser.RetroFont#getLongestLine
        * @memberof Phaser.RetroFont
        * @return {number} The length of the longest line of text.
        */
        getLongestLine(): number;

        /**
        * Internal function that takes a single line of text (2nd parameter) and pastes it into the BitmapData at the given coordinates.
        * Used by getLine and getMultiLine
        *
        * @method Phaser.RetroFont#pasteLine
        * @memberof Phaser.RetroFont
        * @param {string} line - The single line of text to paste.
        * @param {number} x - The x coordinate.
        * @param {number} y - The y coordinate.
        * @param {number} customSpacingX - Custom X spacing.
        */
        pasteLine(line: string, x: number, y: number, customSpacingX: number): void;

        /**
        * Internal helper function that removes all unsupported characters from the _text String, leaving only characters contained in the font set.
        *
        * @method Phaser.RetroFont#removeUnsupportedCharacters
        * @memberof Phaser.RetroFont
        * @protected
        * @param {boolean} [stripCR=true] - Should it strip carriage returns as well?
        * @return {string}  A clean version of the string.
        */
        removeUnsupportedCharacters(stripCR?: boolean): string;

        /**
        * If you need this RetroFont to have a fixed width and custom alignment you can set the width here.
        * If text is wider than the width specified it will be cropped off.
        *
        * @method Phaser.RetroFont#setFixedWidth
        * @memberof Phaser.RetroFont
        * @param {number} width - Width in pixels of this RetroFont. Set to zero to disable and re-enable automatic resizing.
        * @param {string} [lineAlignment='left'] - Align the text within this width. Set to RetroFont.ALIGN_LEFT (default), RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.
        */
        setFixedWidth(width: number, lineAlignment?: string): void;

        /**
        * A helper function that quickly sets lots of variables at once, and then updates the text.
        *
        * @method Phaser.RetroFont#setText
        * @memberof Phaser.RetroFont
        * @param {string} content - The text of this sprite.
        * @param {boolean} [multiLine=false] - Set to true if you want to support carriage-returns in the text and create a multi-line sprite instead of a single line.
        * @param {number} [characterSpacing=0] - To add horizontal spacing between each character specify the amount in pixels.
        * @param {number} [lineSpacing=0] - To add vertical spacing between each line of text, set the amount in pixels.
        * @param {string} [lineAlignment='left'] - Align each line of multi-line text. Set to RetroFont.ALIGN_LEFT, RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.
        * @param {boolean} [allowLowerCase=false] - Lots of bitmap font sets only include upper-case characters, if yours needs to support lower case then set this to true.
        */
        setText(content: string, multiLine?: boolean, characterSpacing?: number, lineSpacing?: number, lineAlignment?: string, allowLowerCase?: boolean): void;

        /**
        * Updates the x and/or y offset that the font is rendered from. This updates all of the texture frames, so be careful how often it is called.
        * Note that the values given for the x and y properties are either ADDED to or SUBTRACTED from (if negative) the existing offsetX/Y values of the characters.
        * So if the current offsetY is 8 and you want it to start rendering from y16 you would call updateOffset(0, 8) to add 8 to the current y offset.
        *
        * @method Phaser.RetroFont#updateOffset
        * @memberof Phaser.RetroFont
        * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
        * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
        */
        updateOffset(x?: number, y?: number): void;

    }
    /**
    * A Rope is a Sprite that has a repeating texture. The texture can be scrolled and scaled and will automatically wrap on the edges as it does so.
    * Please note that Ropes, as with normal Sprites, have no input handler or physics bodies by default. Both need enabling.
    * Example usage: https://github.com/codevinsky/phaser-rope-demo/blob/master/dist/demo.js
    *
    * @class Phaser.Rope
    * @constructor
    * @extends PIXI.Rope
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate (in world space) to position the Rope at.
    * @param {number} y - The y coordinate (in world space) to position the Rope at.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Rope during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
    * @param {string|number} frame - If this Rope is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    * @param {Array} points - An array of {Phaser.Point}.
    */
    class Rope extends PIXI.Rope {

        constructor(game: Phaser.Game, x: number, y: number, key: any, frame?: any, points?: Phaser.Point[]);

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.AnimationManager} animations - This manages animations of the sprite. You can modify animations through it (see Phaser.AnimationManager)
        */
        animations: AnimationManager;

        /**
        * Should this Sprite be automatically culled if out of range of the camera?
        * A culled sprite has its renderable property set to 'false'.
        * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.
        *
        * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.
        * @default
        */
        autoCull: boolean;

        /**
        * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
        */
        body: any;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        checkWorldBounds: boolean;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: number;

        /**
        * @name Phaser.Sprite#frameName
        * @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.
        */
        frameName: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: any;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * Sets and modifies the points of this polygon.
        *
        * See {@link Phaser.Polygon#setTo setTo} for the different kinds of arrays formats that can be assigned.
        *
        * @name Phaser.Polygon#points
        * @property {Phaser.Point[]} points - The array of vertex points.
        * @deprecated Use `setTo`.
        */
        points: Phaser.Point[];

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        segments: Phaser.Rectangle[];

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * Destroys the Rope. This removes it from its parent group, destroys the event and animation handlers if present
        * and nulls its reference to game, freeing it up for garbage collection.
        *
        * @method Phaser.Rope#destroy
        * @memberof Phaser.Rope
        * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?
        */
        destroy(destroyChildren?: boolean): void;

        /**
        * Changes the Texture the Rope is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.
        * This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.
        *
        * @method Phaser.Rope#loadTexture
        * @memberof Phaser.Rope
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Rope during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
        * @param {string|number} frame - If this Rope is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        */
        loadTexture(key: any, frame?: any): void;

        /**
        * Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()
        * If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.
        *
        * @method Phaser.Rope#play
        * @memberof Phaser.Rope
        * @param {string} name - The name of the animation to be played, e.g. "fire", "walk", "jump".
        * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.
        * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.
        * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.
        * @return {Phaser.Animation} A reference to playing Animation instance.
        */
        play(): void;

        /**
        * Automatically called by World.preUpdate.
        *
        * @method Phaser.Rope#preUpdate
        * @memberof Phaser.Rope
        */
        preUpdate(): void;

        /**
        * Internal function called by the World postUpdate cycle.
        *
        * @method Phaser.Rope#postUpdate
        * @memberof Phaser.Rope
        */
        postUpdate(): void;

        /**
        * Resets the Rope. This places the Rope at the given x/y world coordinates, resets the tilePosition and then
        * sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.
        * If the Rope has a physics body that too is reset.
        *
        * @method Phaser.Rope#reset
        * @memberof Phaser.Rope
        * @param {number} x - The x coordinate (in world space) to position the Sprite at.
        * @param {number} y - The y coordinate (in world space) to position the Sprite at.
        * @return (Phaser.Rope) This instance.
        */
        reset(x: number, y: number): void;

        /**
        * Sets the Texture frame the Rope uses for rendering.
        * This is primarily an internal method used by Rope.loadTexture, although you may call it directly.
        *
        * @method Phaser.Rope#setFrame
        * @memberof Phaser.Rope
        * @param {Phaser.Frame} frame - The Frame to be used by the Rope texture.
        */
        setFrame(frame: Phaser.Frame): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        *
        * @method Phaser.Rope#update
        * @memberof Phaser.Rope
        */
        update(): void;

        updateAnimation(): void;

    }
    /**
    * A Signal is an event dispatch mechansim than supports broadcasting to multiple listeners.
    *
    * Event listeners are uniquely identified by the listener/callback function and the context.
    * 
    * @class Phaser.Signal
    * @constructor
    */
    class Signal {

        /**
        * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
        * @default
        */
        active: boolean;

        boundDispatch: Function;

        memorize: boolean;

        /**
        * Add an event listener.
        *
        * @method Phaser.Signal#add
        * @param {function} listener - The function to call when this Signal is dispatched.
        * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).
        * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)
        * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.
        */
        add(listener: Function, listenerContext?: any, priority?: number): Phaser.SignalBinding;

        /**
        * Add a one-time listener - the listener is automatically removed after the first execution.
        *
        * If there is as {@link Phaser.Signal#memorize memorized} event then it will be dispatched and
        * the listener will be removed immediately.
        *
        * @method Phaser.Signal#addOnce
        * @param {function} listener - The function to call when this Signal is dispatched.
        * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).
        * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)
        * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.
        */
        addOnce(listener: Function, listenerContext?: any, priority?: number): Phaser.SignalBinding;

        /**
        * Dispatch / broadcast the event to all listeners.
        *
        * To create an instance-bound dispatch for this Signal, use {@link #boundDispatch}.
        *
        * @method Phaser.Signal#dispatch
        * @param {any} [params] - Parameters that should be passed to each handler.
        */
        dispatch(...params: any[]): void;

        /**
        * Dispose the signal - no more events can be dispatched.
        *
        * This removes all event listeners and clears references to external objects.
        * Calling methods on a disposed objects results in undefined behavior.
        *
        * @method Phaser.Signal#dispose
        */
        dispose(): void;

        /**
        * Forget the currently {@link Phaser.Signal#memorize memorized} event, if any.
        *
        * @method Phaser.Signal#forget
        */
        forget(): void;

        /**
        * Gets the total number of listeners attached to this Signal.
        *
        * @method Phaser.Signal#getNumListeners
        * @return {integer} Number of listeners attached to the Signal.
        */
        getNumListeners(): number;

        /**
        * Stop propagation of the event, blocking the dispatch to next listener on the queue.
        *
        * This should be called only during event dispatch as calling it before/after dispatch won't affect other broadcast.
        * See {@link #active} to enable/disable the signal entirely.
        *
        * @method Phaser.Signal#halt
        */
        halt(): void;

        /**
        * Check if a specific listener is attached.
        *
        * @method Phaser.Signal#has
        * @param {function} listener - Signal handler function.
        * @param {object} [context] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        * @return {boolean} If Signal has the specified listener.
        */
        has(listener: Function, context?: any): boolean;

        /**
        * Remove a single event listener.
        *
        * @method Phaser.Signal#remove
        * @param {function} listener - Handler function that should be removed.
        * @param {object} [context=null] - Execution context (since you can add the same handler multiple times if executing in a different context).
        * @return {function} Listener handler function.
        */
        remove(listener: Function, context?: any): Function;

        /**
        * Remove all event listeners.
        *
        * @method Phaser.Signal#removeAll
        * @param {object} [context=null] - If specified only listeners for the given context will be removed.
        */
        removeAll(context?: any): void;

        /**
        * A string representation of the object.
        *
        * @method Phaser.Signal#toString
        * @return {string} String representation of the object.
        */
        toString(): string;

        /**
        * @method Phaser.Signal#validateListener
        * @param {function} listener - Signal handler function.
        * @param {string} fnName - Function name.
        * @private
        */
        validateListener(listener: Function, fnName: string): void;

    }
    /**
    * Object that represents a binding between a Signal and a listener function.
    * This is an internal constructor and shouldn't be created directly.
    * Inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
    * 
    * @class Phaser.SignalBinding
    * @constructor
    * @param {Phaser.Signal} signal - Reference to Signal object that listener is currently bound to.
    * @param {function} listener - Handler function bound to the signal.
    * @param {boolean} isOnce - If binding should be executed just once.
    * @param {object} [listenerContext=null] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
    * @param {number} [priority] - The priority level of the event listener. (default = 0).
    */
    class SignalBinding {

        constructor(signal: Phaser.Signal, listener: Function, isOnce: boolean, listenerContext?: any, priority?: number);

        /**
        * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
        * @default
        */
        active: boolean;

        /**
        * @property {number} callCount - The number of times the handler function has been called.
        */
        callCount: number;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: any;

        params: any[];

        /**
        * Call listener passing arbitrary parameters.
        * If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.
        * @method Phaser.SignalBinding#execute
        * @param {any[]} [paramsArr] - Array of parameters that should be passed to the listener.
        * @return {any} Value returned by the listener.
        */
        execute(paramsArr?: any[]): void;

        /**
        * Detach binding from signal.
        * alias to: @see mySignal.remove(myBinding.getListener());
        * @method Phaser.SignalBinding#detach
        * @return {function|null} Handler function bound to the signal or `null` if binding was previously detached.
        */
        detach(): Function;

        /**
        * @method Phaser.SignalBinding#isBound
        * @return {boolean} True if binding is still bound to the signal and has a listener.
        */
        isBound(): boolean;

        /**
        * @method Phaser.SignalBinding#isOnce
        * @return {boolean} If SignalBinding will only be executed once.
        */
        isOnce(): boolean;

        /**
        * @method Phaser.SignalBinding#getListener
        * @return {function} Handler function bound to the signal.
        */
        getListener(): Function;

        /**
        * @method Phaser.SignalBinding#getSignal
        * @return {Phaser.Signal} Signal that listener is currently bound to.
        */
        getSignal(): Phaser.Signal;

        /**
        * @method Phaser.SignalBinding#toString
        * @return {string} String representation of the object.
        */
        toString(): string;

    }
    /**
    * A single Phaser Gamepad
    * 
    * @class Phaser.SinglePad
    * @constructor
    * @param {Phaser.Game} game - Current game instance.
    * @param {object} padParent - The parent Phaser.Gamepad object (all gamepads reside under this)
    */
    class SinglePad {

        constructor(game: Phaser.Game, padParent: any);

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        /**
        * @property {boolean} connected - Whether or not this particular gamepad is connected or not.
        * @readonly
        */
        connected: boolean;

        /**
        * @property {number} deadZone - Dead zone for axis feedback - within this value you won't trigger updates.
        */
        deadZone: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} index - The gamepad index as per browsers data
        * @readonly
        */
        index: number;

        /**
        * @property {function} onAxisCallback - This callback is invoked every time any gamepad axis is changed.
        */
        onAxisCallback: Function;

        /**
        * @property {function} onConnectCallback - This callback is invoked every time any gamepad is connected
        */
        onConnectCallback: Function;

        /**
        * @property {function} onDisconnectCallback - This callback is invoked every time any gamepad is disconnected
        */
        onDisconnectCallback: Function;

        /**
        * @property {function} onDownCallback - This callback is invoked every time a key is pressed down, including key repeats when a key is held down.
        */
        onDownCallback: Function;

        /**
        * @property {function} onFloatCallback - This callback is invoked every time any gamepad button is changed to a value where value > 0 and value < 1.
        */
        onFloatCallback: Function;

        /**
        * @property {function} onUpCallback - This callback is invoked every time a key is released.
        */
        onUpCallback: Function;

        /**
        * Returns value of requested axis.
        * 
        * @method Phaser.SinglePad#axis
        * @param {number} axisCode - The index of the axis to check
        * @return {number} Axis value if available otherwise false
        */
        axis(axisCode: number): number;

        /**
        * Add callbacks to this Gamepad to handle connect / disconnect / button down / button up / axis change / float value buttons.
        * 
        * @method Phaser.SinglePad#addCallbacks
        * @param {object} context - The context under which the callbacks are run.
        * @param {object} callbacks - Object that takes six different callbak methods:
        * onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback
        */
        addCallbacks(context: any, callbacks: any): void;

        /**
        * Returns the value of a gamepad button. Intended mainly for cases when you have floating button values, for example
        * analog trigger buttons on the XBOX 360 controller.
        * 
        * @method Phaser.SinglePad#buttonValue
        * @param {number} buttonCode - The buttonCode of the button to check.
        * @return {number} Button value if available otherwise null. Be careful as this can incorrectly evaluate to 0.
        */
        buttonValue(buttonCode: number): number;

        /**
        * Gamepad connect function, should be called by Phaser.Gamepad.
        * 
        * @method Phaser.SinglePad#connect
        * @param {object} rawPad - The raw gamepad object
        */
        connect(rawPad: any): void;

        /**
        * Destroys this object and associated callback references.
        *
        * @method Phaser.SinglePad#destroy
        */
        destroy(): void;

        /**
        * Gamepad disconnect function, should be called by Phaser.Gamepad.
        * 
        * @method Phaser.SinglePad#disconnect
        */
        disconnect(): void;

        /**
        * Gets a GamepadButton object from this controller to be stored and referenced locally.
        * The GamepadButton object can then be polled, have events attached to it, etc.
        *
        * @method Phaser.SinglePad#getButton
        * @param {number} buttonCode - The buttonCode of the button, i.e. Phaser.Gamepad.BUTTON_0, Phaser.Gamepad.XBOX360_A, etc.
        * @return {Phaser.GamepadButton} The GamepadButton object which you can store locally and reference directly.
        */
        getButton(buttonCode: number): Phaser.GamepadButton;

        /**
        * Returns true if the button is pressed down.
        * 
        * @method Phaser.SinglePad#isDown
        * @param {number} buttonCode - The buttonCode of the button to check.
        * @return {boolean} True if the button is pressed down.
        */
        isDown(buttonCode: number): boolean;

        /**
        * Returns true if the button is not currently pressed.
        * 
        * @method Phaser.SinglePad#isUp
        * @param {number} buttonCode - The buttonCode of the button to check.
        * @return {boolean} True if the button is not currently pressed down.
        */
        isUp(buttonCode: number): boolean;

        /**
        * Returns the "just pressed" state of a button from this gamepad. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
        * 
        * @method Phaser.SinglePad#justPressed
        * @param {number} buttonCode - The buttonCode of the button to check for.
        * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.
        * @return {boolean} True if the button is just pressed otherwise false.
        */
        justPressed(buttonCode: number, duration?: number): boolean;

        /**
        * Returns the "just released" state of a button from this gamepad. Just released is considered as being true if the button was released within the duration given (default 250ms).
        * 
        * @method Phaser.SinglePad#justReleased
        * @param {number} buttonCode - The buttonCode of the button to check for.
        * @param {number} [duration=250] - The duration below which the button is considered as being just released.
        * @return {boolean} True if the button is just released otherwise false.
        */
        justReleased(buttonCode: number, duration?: number): boolean;

        /**
        * Main update function called by Phaser.Gamepad.
        * 
        * @method Phaser.SinglePad#pollStatus
        */
        pollStatus(): void;

        /**
        * Handles changes in axis.
        * 
        * @method Phaser.SinglePad#processAxisChange
        * @param {object} axisState - State of the relevant axis
        */
        processAxisChange(axisState: any): void;

        /**
        * Handles button down press.
        * 
        * @method Phaser.SinglePad#processButtonDown
        * @param {number} buttonCode - Which buttonCode of this button
        * @param {object} value - Button value
        */
        processButtonDown(buttonCode: number, value: any): void;

        /**
        * Handles buttons with floating values (like analog buttons that acts almost like an axis but still registers like a button)
        * 
        * @method Phaser.SinglePad#processButtonFloat
        * @param {number} buttonCode - Which buttonCode of this button
        * @param {object} value - Button value (will range somewhere between 0 and 1, but not specifically 0 or 1.
        */
        processButtonFloat(buttonCode: number, value: any): void;

        /**
        * Handles button release.
        * 
        * @method Phaser.SinglePad#processButtonUp
        * @param {number} buttonCode - Which buttonCode of this button
        * @param {object} value - Button value
        */
        processButtonUp(buttonCode: number, value: any): void;

        /**
        * Reset all buttons/axes of this gamepad.
        * 
        * @method Phaser.SinglePad#reset
        */
        reset(): void;

    }
    /**
    * The Sound class constructor.
    *
    * @class Phaser.Sound
    * @constructor
    * @param {Phaser.Game} game - Reference to the current game instance.
    * @param {string} key - Asset key for the sound.
    * @param {number} [volume=1] - Default value for the volume, between 0 and 1.
    * @param {boolean} [loop=false] - Whether or not the sound will loop.
    */
    class Sound {

        constructor(game: Phaser.Game, key: string, volume?: number, loop?: boolean, connect?: boolean);

        /**
        * @property {boolean} autoplay - Boolean indicating whether the sound should start automatically.
        */
        autoplay: boolean;

        /**
        * @property {boolean} allowMultiple - This will allow you to have multiple instances of this Sound playing at once. This is only useful when running under Web Audio, and we recommend you implement a local pooling system to not flood the sound channels.
        * @default
        */
        allowMultiple: boolean;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: any;

        /**
        * @property {string} currentMarker - The string ID of the currently playing marker, if any.
        * @default
        */
        currentMarker: string;

        /**
        * @property {number} currentTime - The current time the sound is at.
        */
        currentTime: number;

        /**
        * Destroys this sound and all associated events and removes it from the SoundManager.
        *
        * @method Phaser.Sound#destroy
        * @param {boolean} [remove=true] - If true this Sound is automatically removed from the SoundManager.
        */
        destroy(remove?: boolean): void;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {number} durationMS - The duration of the current sound marker in ms.
        */
        durationMS: number;

        /**
        * @property {object} externalNode - If defined this Sound won't connect to the SoundManager master gain node, but will instead connect to externalNode.
        */
        externalNode: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {object} gainNode - The gain node in a Web Audio system.
        */
        gainNode: any;

        /**
        * @name Phaser.Sound#isDecoded
        * @property {boolean} isDecoded - Returns true if the sound file has decoded.
        * @readonly
        */
        isDecoded: boolean;

        /**
        * @name Phaser.Sound#isDecoding
        * @property {boolean} isDecoding - Returns true if the sound file is still decoding.
        * @readonly
        */
        isDecoding: boolean;

        /**
        * @property {boolean} isPlaying - The playing state of the Animation. Set to false once playback completes, true during playback.
        * @default
        */
        isPlaying: boolean;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: string;

        /**
        * @property {boolean} loop - True if this TimerEvent loops, otherwise false.
        */
        loop: boolean;

        /**
        * @property {object} markers - The sound markers.
        */
        markers: any;

        /**
        * @property {object} masterGainNode - The master gain node in a Web Audio system.
        */
        masterGainNode: any;

        /**
        * @name Phaser.Sound#mute
        * @property {boolean} mute - Gets or sets the muted state of this sound.
        */
        mute: boolean;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Signal} onDecoded - The onDecoded event is dispatched when the sound has finished decoding (typically for mp3 files)
        */
        onDecoded: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onFadeComplete - The onFadeComplete event is dispatched when this sound finishes fading either in or out.
        */
        onFadeComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onLoop - This event is dispatched when this Animation loops.
        */
        onLoop: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onMarkerComplete - The onMarkerComplete event is dispatched when a marker within this sound completes playback.
        */
        onMarkerComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onMute - The onMouse event is dispatched when this sound is muted.
        */
        onMute: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onPause - This event is fired when the game pauses.
        */
        onPause: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onPlay - The onPlay event is dispatched each time this sound is played.
        */
        onPlay: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onResume - This event is fired when the game resumes from a paused state.
        */
        onResume: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onStop - The onStop event is dispatched when this sound stops playback.
        */
        onStop: Phaser.Signal;

        /**
        * @property {boolean} override - if true when you play this sound it will always start from the beginning.
        * @default
        */
        override: boolean;

        /**
        * The paused state of the Game. A paused game doesn't update any of its subsystems.
        * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
        * @name Phaser.Game#paused
        * @property {boolean} paused - Gets and sets the paused state of the Game.
        */
        paused: boolean;

        /**
        * @property {number} pausedPosition - The position the sound had reached when it was paused.
        */
        pausedPosition: number;

        /**
        * @property {number} pausedTime - The game time at which the sound was paused.
        */
        pausedTime: number;

        /**
        * @property {boolean} pendingPlayback - true if the sound file is pending playback
        * @readonly
        */
        pendingPlayback: boolean;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: number;

        /**
        * @property {number} startTime - The time the Tween started or null if it hasn't yet started.
        */
        startTime: number;

        /**
        * @property {number} stopTime - The time the sound stopped.
        */
        stopTime: number;

        /**
        * @name Phaser.Tween#totalDuration
        * @property {Phaser.TweenData} totalDuration - Gets the total duration of this Tween, including all child tweens, in milliseconds.
        */
        totalDuration: number;

        /**
        * @property {boolean} usingAudioTag - true if the sound is being played via the Audio tag.
        */
        usingAudioTag: boolean;

        /**
        * @property {boolean} usingWebAudio - true if this sound is being played with Web Audio.
        * @readonly
        */
        usingWebAudio: boolean;

        /**
        * The volume of the Rectangle derived from width * height.
        * @name Phaser.Rectangle#volume
        * @property {number} volume - The volume of the Rectangle derived from width * height.
        * @readonly
        */
        volume: number;

        /**
        * Adds a marker into the current Sound. A marker is represented by a unique key and a start time and duration.
        * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.
        *
        * @method Phaser.Sound#addMarker
        * @param {string} name - A unique name for this marker, i.e. 'explosion', 'gunshot', etc.
        * @param {number} start - The start point of this marker in the audio file, given in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.
        * @param {number} duration - The duration of the marker in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.
        * @param {number} [volume=1] - The volume the sound will play back at, between 0 (silent) and 1 (full volume).
        * @param {boolean} [loop=false] - Sets if the sound will loop or not.
        */
        addMarker(name: string, start: number, duration: number, volume?: number, loop?: boolean): void;

        /**
        * Destroys this sound and all associated events and removes it from the SoundManager.
        *
        * @method Phaser.Sound#destroy
        * @param {boolean} [remove=true] - If true this Sound is automatically removed from the SoundManager.
        */
        destroy(): void;

        /**
        * Starts this sound playing (or restarts it if already doing so) and sets the volume to zero.
        * Then increases the volume from 0 to 1 over the duration specified.
        * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,
        * and the final volume (1) as the second parameter.
        *
        * @method Phaser.Sound#fadeIn
        * @param {number} [duration=1000] - The time in milliseconds over which the Sound should fade in.
        * @param {boolean} [loop=false] - Should the Sound be set to loop? Note that this doesn't cause the fade to repeat.
        */
        fadeIn(duration?: number, loop?: boolean): void;

        /**
        * Decreases the volume of this Sound from its current value to 0 over the duration specified.
        * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,
        * and the final volume (0) as the second parameter.
        *
        * @method Phaser.Sound#fadeOut
        * @param {number} [duration=1000] - The time in milliseconds over which the Sound should fade out.
        */
        fadeOut(duration?: number): void;

        /**
        * Fades the volume of this Sound from its current value to the given volume over the duration specified.
        * At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter, 
        * and the final volume (volume) as the second parameter.
        *
        * @method Phaser.Sound#fadeTo
        * @param {number} [duration=1000] - The time in milliseconds during which the Sound should fade out.
        * @param {number} [volume] - The volume which the Sound should fade to. This is a value between 0 and 1.
        */
        fadeTo(duration?: number, volume?: number): void;

        /**
        * Pauses the sound.
        *
        * @method Phaser.Sound#pause
        */
        pause(): void;

        /**
        * Play this sound, or a marked section of it.
        * @method Phaser.Sound#play
        * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.
        * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.
        * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).
        * @param {boolean} [loop=false] - Loop when it finished playing?
        * @param {boolean} [forceRestart=true] - If the sound is already playing you can set forceRestart to restart it from the beginning.
        * @return {Phaser.Sound} This sound instance.
        */
        play(marker?: string, position?: number, volume?: number, loop?: boolean, forceRestart?: boolean): Phaser.Sound;

        /**
        * Removes a marker from the sound.
        * @method Phaser.Sound#removeMarker
        * @param {string} name - The key of the marker to remove.
        */
        removeMarker(name: string): void;

        /**
        * Restart the sound, or a marked section of it.
        *
        * @method Phaser.Sound#restart
        * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.
        * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.
        * @param {number} [volume=1] - Volume of the sound you want to play.
        * @param {boolean} [loop=false] - Loop when it finished playing?
        */
        restart(marker: string, position: number, volume?: number, loop?: boolean): void;

        /**
        * Resumes the sound.
        *
        * @method Phaser.Sound#resume
        */
        resume(): void;

        /**
        * Called automatically when this sound is unlocked.
        * @method Phaser.Sound#soundHasUnlocked
        * @param {string} key - The Phaser.Cache key of the sound file to check for decoding.
        * @protected
        */
        soundHasUnlocked(key: string): void;

        /**
        * Stop playing this sound.
        *
        * @method Phaser.Sound#stop
        */
        stop(): void;

        /**
        * Called automatically by Phaser.SoundManager.
        * @method Phaser.Sound#update
        * @protected
        */
        update(): void;

    }
    /**
    * The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.
    * Note: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.
    * The audio file type and the encoding of those files are extremely important. Not all browsers can play all audio formats.
    * There is a good guide to what's supported here: http://hpr.dogphilosophy.net/test/
    *
    * If you are reloading a Phaser Game on a page that never properly refreshes (such as in an AngularJS project) then you will quickly run out
    * of AudioContext nodes. If this is the case create a global var called PhaserGlobal on the window object before creating the game. The active
    * AudioContext will then be saved to window.PhaserGlobal.audioContext when the Phaser game is destroyed, and re-used when it starts again.
    *
    * @class Phaser.SoundManager
    * @constructor
    * @param {Phaser.Game} game - Reference to the current game instance.
    */
    class SoundManager {

        constructor(game: Phaser.Game);

        /**
        * @property {number} channels - The number of audio channels to use in playback.
        * @default
        */
        channels: number;

        /**
        * @property {boolean} connectToMaster - Used in conjunction with Sound.externalNode this allows you to stop a Sound node being connected to the SoundManager master gain node.
        * @default
        */
        connectToMaster: boolean;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @name Phaser.Sound#mute
        * @property {boolean} mute - Gets or sets the muted state of this sound.
        */
        mute: boolean;

        /**
        * @property {boolean} noAudio - Has audio been disabled via the PhaserGlobal object? Useful if you need to use a 3rd party audio library instead.
        * @default
        */
        noAudio: boolean;

        /**
        * @property {Phaser.Signal} onSoundDecode - The event dispatched when a sound decodes (typically only for mp3 files)
        */
        onSoundDecode: Phaser.Signal;

        /**
        * @property {boolean} touchLocked - true if the audio system is currently locked awaiting a touch event.
        * @default
        */
        touchLocked: boolean;

        /**
        * @property {boolean} usingAudioTag - true if the sound is being played via the Audio tag.
        */
        usingAudioTag: boolean;

        /**
        * @property {boolean} usingWebAudio - true if this sound is being played with Web Audio.
        * @readonly
        */
        usingWebAudio: boolean;

        /**
        * The volume of the Rectangle derived from width * height.
        * @name Phaser.Rectangle#volume
        * @property {number} volume - The volume of the Rectangle derived from width * height.
        * @readonly
        */
        volume: number;

        /**
        * Adds a new Sound into the SoundManager.
        *
        * @method Phaser.SoundManager#add
        * @param {string} key - Asset key for the sound.
        * @param {number} [volume=1] - Default value for the volume.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.
        * @return {Phaser.Sound} The new sound instance.
        */
        add(key: string, volume?: number, loop?: boolean, connect?: boolean): Phaser.Sound;

        /**
        * Adds a new AudioSprite into the SoundManager.
        *
        * @method Phaser.SoundManager#addSprite
        * @param {string} key - Asset key for the sound.
        * @return {Phaser.AudioSprite} The new AudioSprite instance.
        */
        addSprite(key: string): Phaser.AudioSprite;

        /**
        * Initialises the sound manager.
        * @method Phaser.SoundManager#boot
        * @protected
        */
        boot(): void;

        /**
        * Decode a sound by its assets key.
        *
        * @method Phaser.SoundManager#decode
        * @param {string} key - Assets key of the sound to be decoded.
        * @param {Phaser.Sound} [sound] - Its buffer will be set to decoded data.
        */
        decode(key: string, sound?: Phaser.Sound): void;

        /**
        * Stops all the sounds in the game, then destroys them and finally clears up any callbacks.
        *
        * @method Phaser.SoundManager#destroy
        */
        destroy(): void;

        /**
        * Pauses all the sounds in the game.
        *
        * @method Phaser.SoundManager#pauseAll
        */
        pauseAll(): void;

        /**
        * Adds a new Sound into the SoundManager and starts it playing.
        *
        * @method Phaser.SoundManager#play
        * @param {string} key - Asset key for the sound.
        * @param {number} [volume=1] - Default value for the volume.
        * @param {boolean} [loop=false] - Whether or not the sound will loop.
        * @return {Phaser.Sound} The new sound instance.
        */
        play(key: string, volume?: number, loop?: boolean): Phaser.Sound;

        /**
        * Removes a Sound from the SoundManager. The removed Sound is destroyed before removal.
        *
        * @method Phaser.SoundManager#remove
        * @param {Phaser.Sound} sound - The sound object to remove.
        * @return {boolean} True if the sound was removed successfully, otherwise false.
        */
        remove(sound: Phaser.Sound): boolean;

        /**
        * Removes all Sounds from the SoundManager that have an asset key matching the given value.
        * The removed Sounds are destroyed before removal.
        *
        * @method Phaser.SoundManager#removeByKey
        * @param {string} key - The key to match when removing sound objects.
        * @return {number} The number of matching sound objects that were removed.
        */
        removeByKey(key: string): number;

        /**
        * Resumes every sound in the game.
        *
        * @method Phaser.SoundManager#resumeAll
        */
        resumeAll(): void;

        /**
        * Stops all the sounds in the game.
        *
        * @method Phaser.SoundManager#stopAll
        */
        stopAll(): void;

        /**
        * Enables the audio, usually after the first touch.
        * @method Phaser.SoundManager#unlock
        */
        unlock(): void;

        /**
        * Updates every sound in the game.
        *
        * @method Phaser.SoundManager#update
        */
        update(): void;

    }
    /**
    * Sprites are the lifeblood of your game, used for nearly everything visual.
    *
    * At its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.
    * They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
    * events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
    *
    * @class Phaser.Sprite
    * @constructor
    * @extends PIXI.Sprite
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate (in world space) to position the Sprite at.
    * @param {number} y - The y coordinate (in world space) to position the Sprite at.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
    * @param {string|number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    */
    class Sprite extends PIXI.Sprite {

        constructor(game: Phaser.Game, x: number, y: number, key?: any, frame?: any);

        /**
        * @property {boolean} alive - A useful boolean to control if the Sprite is alive or dead (in terms of your gameplay, it doesn't effect rendering). Also linked to Sprite.health and Sprite.damage.
        * @default
        */
        alive: boolean;

        anchor: Phaser.Point;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.AnimationManager} animations - This manages animations of the sprite. You can modify animations through it (see Phaser.AnimationManager)
        */
        animations: Phaser.AnimationManager;

        /**
        * Should this Sprite be automatically culled if out of range of the camera?
        * A culled sprite has its renderable property set to 'false'.
        * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.
        *
        * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.
        * @default
        */
        autoCull: boolean;

        /**
        * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
        */
        body: any;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        checkWorldBounds: boolean;

        /**
        * @property {Phaser.Rectangle} cropRect - The Rectangle used to crop the texture. Set this via Sprite.crop. Any time you modify this property directly you must call Sprite.updateCrop.
        * @default
        */
        cropRect: Phaser.Rectangle;

        /**
        * @property {Phaser.Utils.Debug} debug - A set of useful debug utilitie.
        */
        debug: boolean;

        /**
        * Returns the delta x value. The difference between world.x now and in the previous step.
        *
        * @name Phaser.Sprite#deltaX
        * @property {number} deltaX - The delta value. Positive if the motion was to the right, negative if to the left.
        * @readonly
        */
        deltaX: number;

        /**
        * Returns the delta y value. The difference between world.y now and in the previous step.
        *
        * @name Phaser.Sprite#deltaY
        * @property {number} deltaY - The delta value. Positive if the motion was downwards, negative if upwards.
        * @readonly
        */
        deltaY: number;

        /**
        * Returns the delta z value. The difference between rotation now and in the previous step.
        *
        * @name Phaser.Sprite#deltaZ
        * @property {number} deltaZ - The delta value.
        * @readonly
        */
        deltaZ: number;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: number;

        /**
        * @name Phaser.Sprite#frameName
        * @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.
        */
        frameName: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} health - Health value. Used in combination with damage() to allow for quick killing of Sprites.
        */
        health: number;

        /**
        * Checks if the Sprite bounds are within the game camera, otherwise false if fully outside of it.
        *
        * @name Phaser.Sprite#inCamera
        * @property {boolean} inCamera - True if the Sprite bounds is within the game camera, even if only partially. Otherwise false if fully outside of it.
        * @readonly
        */
        inCamera: boolean;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * Checks if the Sprite bounds are within the game world, otherwise false if fully outside of it.
        *
        * @name Phaser.Sprite#inWorld
        * @property {boolean} inWorld - True if the Sprite bounds is within the game world, even if only partially. Otherwise false if fully outside of it.
        * @readonly
        */
        inWorld: boolean;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: any;

        /**
        * @property {number} lifespan - How long each particle lives once it is emitted in ms. Default is 2 seconds. Set lifespan to 'zero' for particles to live forever.
        * @default
        */
        lifespan: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {boolean} outOfBoundsKill - If true Sprite.kill is called as soon as Sprite.inWorld returns false, as long as Sprite.checkWorldBounds is true.
        * @default
        */
        outOfBoundsKill: boolean;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        physicsEnabled: boolean;

        /**
        * @name Phaser.Sprite#renderOrderID
        * @property {number} renderOrderID - The render order ID, reset every frame.
        * @readonly
        */
        renderOrderID: number;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * @property {Phaser.Point} scaleMin - Set the minimum scale this Sprite will scale down to. Prevents a parent from scaling this Sprite lower than the given value. Set to `null` to remove.
        */
        scaleMin: Phaser.Point;

        /**
        * @property {Phaser.Point} scaleMax - Set the maximum scale this Sprite will scale up to. Prevents a parent from scaling this Sprite higher than the given value. Set to `null` to remove.
        */
        scaleMax: Phaser.Point;

        /**
        * Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.
        *
        * @name Phaser.Stage#smoothed
        * @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
        */
        smoothed: boolean;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * Brings the Sprite to the top of the display list it is a child of. Sprites that are members of a Phaser.Group are only
        * bought to the top of that Group, not the entire display list.
        *
        * @method Phaser.Sprite#bringToTop
        * @memberof Phaser.Sprite
        * @return (Phaser.Sprite) This instance.
        */
        bringToTop(): Phaser.Sprite;

        /**
        * Crop allows you to crop the texture used to display this Sprite.
        * This modifies the core Sprite texture frame, so the Sprite width/height properties will adjust accordingly.
        *
        * Cropping takes place from the top-left of the Sprite and can be modified in real-time by either providing an updated rectangle object to Sprite.crop,
        * or by modifying Sprite.cropRect (or a reference to it) and then calling Sprite.updateCrop.
        *
        * The rectangle object given to this method can be either a Phaser.Rectangle or any object so long as it has public x, y, width and height properties.
        * A reference to the rectangle is stored in Sprite.cropRect unless the `copy` parameter is `true` in which case the values are duplicated to a local object.
        *
        * @method Phaser.Sprite#crop
        * @memberof Phaser.Sprite
        * @param {Phaser.Rectangle} rect - The Rectangle used during cropping. Pass null or no parameters to clear a previously set crop rectangle.
        * @param {boolean} [copy=false] - If false Sprite.cropRect will be a reference to the given rect. If true it will copy the rect values into a local Sprite.cropRect object.
        */
        crop(rect: Phaser.Rectangle, copy: boolean): void;

        /**
        * Damages the Sprite, this removes the given amount from the Sprites health property.
        * If health is then taken below or is equal to zero `Sprite.kill` is called.
        *
        * @method Phaser.Sprite#damage
        * @memberof Phaser.Sprite
        * @param {number} amount - The amount to subtract from the Sprite.health value.
        * @return (Phaser.Sprite) This instance.
        */
        damage(amount: number): Phaser.Sprite;

        /**
        * Destroys the Sprite. This removes it from its parent group, destroys the input, event and animation handlers if present
        * and nulls its reference to game, freeing it up for garbage collection.
        *
        * @method Phaser.Sprite#destroy
        * @memberof Phaser.Sprite
        * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?
        */
        destroy(destroyChildren?: boolean): void;

        drawPolygon(): void;

        /**
        * Kills a Sprite. A killed Sprite has its alive, exists and visible properties all set to false.
        * It will dispatch the onKilled event, you can listen to Sprite.events.onKilled for the signal.
        * Note that killing a Sprite is a way for you to quickly recycle it in a Sprite pool, it doesn't free it up from memory.
        * If you don't need this Sprite any more you should call Sprite.destroy instead.
        *
        * @method Phaser.Sprite#kill
        * @memberof Phaser.Sprite
        * @return (Phaser.Sprite) This instance.
        */
        kill(): Phaser.Sprite;

        /**
        * Changes the Texture the Sprite is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.
        * This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.
        *
        * @method Phaser.Sprite#loadTexture
        * @memberof Phaser.Sprite
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
        * @param {string|number} [frame] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        * @param {boolean} [stopAnimation=true] - If an animation is already playing on this Sprite you can choose to stop it or let it carry on playing.
        */
        loadTexture(key: any, frame: any, stopAnimation?: boolean): void;

        /**
        * Checks to see if the bounds of this Sprite overlaps with the bounds of the given Display Object, which can be a Sprite, Image, TileSprite or anything that extends those such as a Button.
        * This check ignores the Sprites hitArea property and runs a Sprite.getBounds comparison on both objects to determine the result.
        * Therefore it's relatively expensive to use in large quantities (i.e. with lots of Sprites at a high frequency), but should be fine for low-volume testing where physics isn't required.
        *
        * @method Phaser.Sprite#overlap
        * @memberof Phaser.Sprite
        * @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Button|PIXI.DisplayObject} displayObject - The display object to check against.
        * @return {boolean} True if the bounds of this Sprite intersects at any point with the bounds of the given display object.
        */
        overlap(displayObject: any): boolean;

        /**
        * Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()
        * If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.
        *
        * @method Phaser.Sprite#play
        * @memberof Phaser.Sprite
        * @param {string} name - The name of the animation to be played, e.g. "fire", "walk", "jump".
        * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.
        * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.
        * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.
        * @return {Phaser.Animation} A reference to playing Animation instance.
        */
        play(name: string, frameRate?: number, loop?: boolean, killOnComplete?: boolean): Phaser.Animation;

        /**
        * Internal function called by the World postUpdate cycle.
        *
        * @method Phaser.Sprite#postUpdate
        * @memberof Phaser.Sprite
        */
        postUpdate(): void;

        /**
        * Automatically called by World.preUpdate.
        *
        * @method Phaser.Sprite#preUpdate
        * @memberof Phaser.Sprite
        * @return {boolean} True if the Sprite was rendered, otherwise false.
        */
        preUpdate(): void;

        /**
        * Resets the Texture frame dimensions that the Sprite uses for rendering.
        *
        * @method Phaser.Sprite#resetFrame
        * @memberof Phaser.Sprite
        */
        reset(x: number, y: number, health?: number): Phaser.Sprite;

        /**
        * Resets the Texture frame dimensions that the Sprite uses for rendering.
        *
        * @method Phaser.Sprite#resetFrame
        * @memberof Phaser.Sprite
        */
        resetFrame(): void;

        /**
        * Brings a 'dead' Sprite back to life, optionally giving it the health value specified.
        * A resurrected Sprite has its alive, exists and visible properties all set to true.
        * It will dispatch the onRevived event, you can listen to Sprite.events.onRevived for the signal.
        *
        * @method Phaser.Sprite#revive
        * @memberof Phaser.Sprite
        * @param {number} [health=1] - The health to give the Sprite.
        * @return (Phaser.Sprite) This instance.
        */
        revive(health?: number): Phaser.Sprite;

        /**
        * Sets the Texture frame the Sprite uses for rendering.
        * This is primarily an internal method used by Sprite.loadTexture, although you may call it directly.
        *
        * @method Phaser.Sprite#setFrame
        * @memberof Phaser.Sprite
        * @param {Phaser.Frame} frame - The Frame to be used by the Sprite texture.
        */
        setFrame(frame: Phaser.Frame): void;

        /**
        * Sets the scaleMin and scaleMax values. These values are used to limit how far this Sprite will scale based on its parent.
        * For example if this Sprite has a minScale value of 1 and its parent has a scale value of 0.5, the 0.5 will be ignored and the scale value of 1 will be used.
        * By using these values you can carefully control how Sprites deal with responsive scaling.
        * 
        * If only one parameter is given then that value will be used for both scaleMin and scaleMax:
        * setScaleMinMax(1) = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1
        *
        * If only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:
        * setScaleMinMax(0.5, 2) = scaleMin.x and y = 0.5 and scaleMax.x and y = 2
        *
        * If you wish to set scaleMin with different values for x and y then either modify Sprite.scaleMin directly, or pass `null` for the maxX and maxY parameters.
        * 
        * Call setScaleMinMax(null) to clear both the scaleMin and scaleMax values.
        *
        * @method Phaser.Sprite#setScaleMinMax
        * @memberof Phaser.Sprite
        * @param {number|null} minX - The minimum horizontal scale value this Sprite can scale down to.
        * @param {number|null} minY - The minimum vertical scale value this Sprite can scale down to.
        * @param {number|null} maxX - The maximum horizontal scale value this Sprite can scale up to.
        * @param {number|null} maxY - The maximum vertical scale value this Sprite can scale up to.
        */
        setScaleMinMax(minX?: number, minY?: number, maxX?: number, maxY?: number): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        * Remember if this Sprite has any children you should call update on them too.
        *
        * @method Phaser.Sprite#update
        * @memberof Phaser.Sprite
        */
        update(): void;

        /**
        * If you have set a crop rectangle on this Sprite via Sprite.crop and since modified the Sprite.cropRect property (or the rectangle it references)
        * then you need to update the crop frame by calling this method.
        *
        * @method Phaser.Sprite#updateCrop
        * @memberof Phaser.Sprite
        */
        updateCrop(): void;

    }
    /**
    * The SpriteBatch class is a really fast version of the DisplayObjectContainer built purely for speed, so use when you need a lot of sprites or particles.
    * It's worth mentioning that by default sprite batches are used through-out the renderer, so you only really need to use a SpriteBatch if you have over
    * 1000 sprites that all share the same texture (or texture atlas). It's also useful if running in Canvas mode and you have a lot of un-rotated or un-scaled
    * Sprites as it skips all of the Canvas setTransform calls, which helps performance, especially on mobile devices.
    *
    * @class Phaser.SpriteBatch
    * @extends Phaser.Group
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {Phaser.Group|Phaser.Sprite|null} parent - The parent Group, DisplayObject or DisplayObjectContainer that this Group will be added to. If `undefined` or `null` it will use game.world.
    * @param {string} [name=group] - A name for this Group. Not used internally but useful for debugging.
    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.
    */
    class SpriteBatch extends Phaser.Group {

        constructor(game: Phaser.Game, parent: any, name?: string, addedToStage?: boolean);

        /**
        * @property {number} type - The base object type.
        */
        type: number;

    }
    /**
    * The Stage controls root level display objects upon which everything is displayed.
    * It also handles browser visibility handling and the pausing due to loss of focus.
    *
    * @class Phaser.Stage
    * @extends PIXI.Stage
    * @constructor
    * @param {Phaser.Game} game - Game reference to the currently running game.
    */
    class Stage extends PIXI.Stage {

        constructor(game: Phaser.Game);

        /**
        * @name Phaser.Stage#backgroundColor
        * @property {number|string} backgroundColor - Gets and sets the background color of the stage. The color can be given as a number: 0xff0000 or a hex string: '#ff0000'
        */
        backgroundColor: any;

        /**
        * @property {number} currentRenderOrderID - Reset each frame, keeps a count of the total number of objects updated.
        */
        currentRenderOrderID: number;

        /**
        * @property {boolean} disableVisibilityChange - By default if the browser tab loses focus the game will pause. You can stop that behaviour by setting this property to true.
        * @default
        */
        disableVisibilityChange: boolean;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.
        *
        * @name Phaser.Stage#smoothed
        * @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
        */
        smoothed: boolean;

        /**
        * Initialises the stage and adds the event listeners.
        * @method Phaser.Stage#boot
        * @private
        */
        boot(): void;

        checkVisiblity(): void;

        destroy(): void;

        /**
        * Parses a Game configuration object.
        *
        * @method Phaser.Stage#parseConfig
        * @protected
        * @param {object} config -The configuration object to parse.
        */
        parseConfig(config: any): void;

        /**
        * This is called automatically before the renderer runs and after the plugins have updated.
        * In postUpdate this is where all the final physics calculatations and object positioning happens.
        * The objects are processed in the order of the display list.
        * The only exception to this is if the camera is following an object, in which case that is updated first.
        *
        * @method Phaser.Stage#postUpdate
        */
        postUpdate(): void;

        /**
        * This is called automatically after the plugins preUpdate and before the State.update.
        * Most objects have preUpdate methods and it's where initial movement and positioning is done.
        *
        * @method Phaser.Stage#preUpdate
        */
        preUpdate(): void;

        setBackgroundColor(backgroundColor: number): void;

        setBackgroundColor(backgroundColor: string): void;

        /**
        * This is called automatically after the State.update, but before particles or plugins update.
        *
        * @method Phaser.Stage#update
        */
        update(): void;

        /**
        * This method is called when the document visibility is changed.
        * 
        * @method Phaser.Stage#visibilityChange
        * @param {Event} event - Its type will be used to decide whether the game should be paused or not.
        */
        visibilityChange(event: any): void;

    }
    interface ResizeCallback {
        (width: number, height: number): any;
    }
    class ScaleManager {

        constructor(game: Phaser.Game, width: number, height: number);

        constructor(game: Phaser.Game, width: string, height: string);

        static EXACT_FIT: number;

        static NO_SCALE: number;

        static SHOW_ALL: number;

        static RESIZE: number;

        static USER_SCALE: number;

        aspectRatio: number;

        /**
        * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
        * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
        * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
        * 
        * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
        */
        bounds: Rectangle;

        boundingParent: HTMLElement;

        compatibility: {

            canExpandParent: boolean;
            forceMinimumDocumentHeight: boolean;
            noMargins: boolean;
            scrollTo: Point;
            supportsFullScreen: boolean;
        };
        currentScaleMode: number;

        dom: Phaser.DOM;

        enterIncorrectOrientation: Signal;

        enterFullScreen: Signal;

        enterLandscape: Signal;

        enterPortrait: Signal;

        /**
        * @property {object} event - Stores the most recent DOM event.
        * @readonly
        */
        event: any;

        forceLandscape: boolean;

        forcePortrait: boolean;

        fullScreenScaleMode: number;

        fullScreenFailed: Signal;

        fullScreenTarget: HTMLElement;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.FlexGrid} grid - A reference to the FlexGrid that owns this layer.
        */
        grid: Phaser.FlexGrid;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * True if the `forceLandscape` or `forcePortrait` are set and do not agree with the browser orientation.
        *
        * This value is not updated immediately.
        *
        * @property {boolean} incorrectOrientation    
        * @readonly
        * @protected
        */
        incorrectOrientation: boolean;

        isFullScreen: boolean;

        isPortrait: boolean;

        isLandscape: boolean;

        leaveFullScreen: Signal;

        leaveIncorrectOrientation: Signal;

        margin: { left: number; top: number; right: number; bottom: number; x: number; y: number; };

        /**
        * The maximum number of times a canvas will be resized (in a row) in order to fill the browser.
        * @property {number} maxIterations    
        * @protected
        * @see {@link Phaser.ScaleManger#refresh refresh}
        * @deprecated 2.2.0 - This is not used anymore as reflow iterations are "automatic".
        */
        maxIterations: number;

        maxHeight: number;

        maxWidth: number;

        minHeight: number;

        minWidth: number;

        /**
        * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.
        */
        offset: Point;

        onFullScreenInit: Phaser.Signal;

        onFullScreenChange: Phaser.Signal;

        onFullScreenError: Phaser.Signal;

        onOrientationChange: Phaser.Signal;

        onSizeChange: Signal;

        /**
        * @property {string} orientation - The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
        */
        orientation: number;

        pageAlignHorizontally: boolean;

        pageAlignVertically: boolean;

        parentNode: HTMLElement;

        parentIsWindow: boolean;

        parentScaleFactor: Point;

        /**
        * @property {Phaser.Point} scaleFactor - The scale factor based on the game dimensions vs. the scaled dimensions.
        * @readonly
        */
        scaleFactor: Point;

        scaleFactorInversed: Point;

        scaleMode: number;

        screenOrientation: string;

        sourceAspectRatio: number;

        trackParentInterval: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        windowConstraints: {

            bottom: boolean;
            right: boolean;
        };
        /**
        * Start the ScaleManager.
        * 
        * @method Phaser.ScaleManager#boot
        * @protected
        */
        boot(): void;

        checkOrientationState(): boolean;

        /**
        * Creates a fullscreen target. This is called automatically as as needed when entering
        * fullscreen mode and the resulting element is supplied to `onFullScreenInit`.
        *
        * Use {@link Phaser.ScaleManager#onFullScreenInit onFullScreenInit} to customize the created object.
        *
        * @method Phaser.ScaleManager#createFullScreenTarget
        * @protected
        */
        createFullScreenTarget(): HTMLDivElement;

        /**
        * Destroys the ScaleManager and removes any event listeners.
        * This should probably only be called when the game is destroyed.
        *
        * @method Phaser.ScaleManager#destroy
        * @protected
        */
        destroy(): void;

        /**
        * Force the game to run in only one orientation.
        *
        * This enables generation of incorrect orientation signals and affects resizing but does not otherwise rotate or lock the orientation.
        * 
        * @method Phaser.ScaleManager#forceOrientation
        * @public
        * @param {boolean} forceLandscape - true if the game should run in landscape mode only.
        * @param {boolean} [forcePortrait=false] - true if the game should run in portrait mode only.
        */
        forceOrientation(forceLandscape: boolean, forcePortrait?: boolean): void;

        /**
        * Returns the computed Parent size/bounds that the Display canvas is allowed/expected to fill.
        *
        * If in fullscreen mode or without parent (see {@link Phaser.ScaleManager#parentIsWindow parentIsWindow}),
        * this will be the bounds of the visual viewport itself.
        *
        * This function takes the `windowConstraints` into consideration - if the parent is partially outside
        * the viewport then this function may return a smaller than expected size.
        *
        * Values are rounded to the nearest pixel.
        *
        * @method Phaser.ScaleManager#getParentBounds
        * @protected
        * @param {Phaser.Rectangle} [target=(new Rectangle)] - The rectangle to update; a new one is created as needed.
        * @return {Phaser.Rectangle} The established parent bounds.
        */
        getParentBounds(target?: Rectangle): Rectangle;

        /**
        * Load configuration settings.
        * 
        * @method Phaser.ScaleManager#parseConfig
        * @protected
        * @param {object} config - The game configuration object.
        */
        parseConfig(config: any): void;

        /**
        * The ScaleManager.preUpdate is called automatically by the core Game loop.
        * 
        * @method Phaser.ScaleManager#preUpdate
        * @protected
        */
        preUpdate(): void;

        /**
        * Update method while paused.
        *
        * @method Phaser.ScaleManager#pauseUpdate
        * @private
        */
        pauseUpdate(): void;

        /**
        * The `refresh` methods informs the ScaleManager that a layout refresh is required.
        *
        * The ScaleManager automatically queues a layout refresh (eg. updates the Game size or Display canvas layout)
        * when the browser is resized, the orientation changes, or when there is a detected change
        * of the Parent size. Refreshing is also done automatically when public properties,
        * such as `scaleMode`, are updated or state-changing methods are invoked.
        *
        * The `refresh` method _may_ need to be used in a few (rare) situtations when
        *
        * - a device change event is not correctly detected; or
        * - the Parent size changes (and an immediate reflow is desired); or
        * - the ScaleManager state is updated by non-standard means.
        *
        * The queued layout refresh is not immediate but will run promptly in an upcoming `preRender`.
        * 
        * @method Phaser.ScaleManager#refresh
        * @public
        */
        refresh(): void;

        /**
        * Set the actual Game size.
        * Use this instead of directly changing `game.width` or `game.height`.
        *
        * The actual physical display (Canvas element size) depends on various settings including
        * - Scale mode
        * - Scaling factor
        * - Size of Canvas's parent element or CSS rules such as min-height/max-height;
        * - The size of the Window
        *
        * @method Phaser.ScaleManager#setGameSize
        * @public
        * @param {integer} width - _Game width_, in pixels.
        * @param {integer} height - _Game height_, in pixels.
        */
        setGameSize(width: number, height: number): void;

        /**
        * Sets the callback that will be invoked before sizing calculations.
        *
        * This is the appropriate place to call `setUserScale` if needing custom dynamic scaling.
        *
        * The callback is supplied with two arguments `scale` and `parentBounds` where `scale` is the ScaleManager
        * and `parentBounds`, a Phaser.Rectangle, is the size of the Parent element.
        *
        * This callback
        * - May be invoked even though the parent container or canvas sizes have not changed
        * - Unlike `onSizeChange`, it runs _before_ the canvas is guaranteed to be updated
        * - Will be invoked from `preUpdate`, _even when_ the game is paused    
        *
        * See `onSizeChange` for a better way of reacting to layout updates.
        * 
        * @method Phaser.ScaleManager#setResizeCallback
        * @public
        * @param {function} callback - The callback that will be called each time a window.resize event happens or if set, the parent container resizes.
        * @param {object} context - The context in which the callback will be called.
        */
        setResizeCallback(callback: ResizeCallback, context: any): void;

        /**
        * Set a User scaling factor used in the USER_SCALE scaling mode.
        *
        * The target canvas size is computed by:
        *
        *     canvas.width = (game.width * hScale) - hTrim
        *     canvas.height = (game.height * vScale) - vTrim
        *
        * This method can be used in the {@link Phaser.ScaleManager#setResizeCallback resize callback}.
        *
        * @method Phaser.ScaleManager#setUserScale
        * @param {number} hScale - Horizontal scaling factor.
        * @param {numer} vScale - Vertical scaling factor.
        * @param {integer} [hTrim=0] - Horizontal trim, applied after scaling.
        * @param {integer} [vTrim=0] - Vertical trim, applied after scaling.
        */
        setUserScale(hScale: number, vScale: number, hTrim?: number, vTrim?: number): void;

        /**
        * Set the min and max dimensions for the Display canvas.
        * 
        * _Note:_ The min/max dimensions are only applied in some cases
        * - When the device is not in an incorrect orientation; or
        * - The scale mode is EXACT_FIT when not in fullscreen
        *
        * @method Phaser.ScaleManager#setMinMax
        * @public
        * @param {number} minWidth - The minimum width the game is allowed to scale down to.
        * @param {number} minHeight - The minimum height the game is allowed to scale down to.
        * @param {number} [maxWidth] - The maximum width the game is allowed to scale up to; only changed if specified.
        * @param {number} [maxHeight] - The maximum height the game is allowed to scale up to; only changed if specified.
        * @todo These values are only sometimes honored.
        */
        setMinMax(minWidth: number, minHeight: number, maxWidth?: number, maxHeight?: number): void;

        /**
        * Calculates and sets the game dimensions based on the given width and height.
        *
        * This should _not_ be called when in fullscreen mode.
        * 
        * @method Phaser.ScaleManager#setupScale
        * @protected
        * @param {number|string} width - The width of the game.
        * @param {number|string} height - The height of the game.
        */
        setupScale(width: number, height: number): void;

        /**
        * Calculates and sets the game dimensions based on the given width and height.
        *
        * This should _not_ be called when in fullscreen mode.
        * 
        * @method Phaser.ScaleManager#setupScale
        * @protected
        * @param {number|string} width - The width of the game.
        * @param {number|string} height - The height of the game.
        */
        setupScale(width: string, height: string): void;

        /**
        * Takes a Sprite or Image object and scales it to fit the given dimensions.
        * Scaling happens proportionally without distortion to the sprites texture.
        * The letterBox parameter controls if scaling will produce a letter-box effect or zoom the
        * sprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either
        * the horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.
        *
        * @method Phaser.ScaleManager#scaleSprite
        * @protected
        * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite we want to scale.
        * @param {integer} [width] - The target width that we want to fit the sprite in to. If not given it defaults to ScaleManager.width.
        * @param {integer} [height] - The target height that we want to fit the sprite in to. If not given it defaults to ScaleManager.height.
        * @param {boolean} [letterBox=false] - True if we want the `fitted` mode. Otherwise, the function uses the `zoom` mode.
        * @return {Phaser.Sprite|Phaser.Image} The scaled sprite.
        */
        scaleSprite(sprite: Sprite, width?: number, height?: number, letterBox?: boolean): Sprite;

        /**
        * Takes a Sprite or Image object and scales it to fit the given dimensions.
        * Scaling happens proportionally without distortion to the sprites texture.
        * The letterBox parameter controls if scaling will produce a letter-box effect or zoom the
        * sprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either
        * the horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.
        *
        * @method Phaser.ScaleManager#scaleSprite
        * @protected
        * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite we want to scale.
        * @param {integer} [width] - The target width that we want to fit the sprite in to. If not given it defaults to ScaleManager.width.
        * @param {integer} [height] - The target height that we want to fit the sprite in to. If not given it defaults to ScaleManager.height.
        * @param {boolean} [letterBox=false] - True if we want the `fitted` mode. Otherwise, the function uses the `zoom` mode.
        * @return {Phaser.Sprite|Phaser.Image} The scaled sprite.
        */
        scaleSprite(sprite: Image, width?: number, height?: number, letterBox?: boolean): Sprite;

        /**
        * Start the browsers fullscreen mode - this _must_ be called from a user input Pointer or Mouse event.
        *
        * The Fullscreen API must be supported by the browser for this to work - it is not the same as setting
        * the game size to fill the browser window. See `compatibility.supportsFullScreen` to check if the current
        * device is reported to support fullscreen mode.
        *
        * The `fullScreenFailed` signal will be dispatched if the fullscreen change request failed or the game does not support the Fullscreen API.
        *
        * @method Phaser.ScaleManager#startFullScreen
        * @public
        * @param {boolean} [antialias] - Changes the anti-alias feature of the canvas before jumping in to fullscreen (false = retain pixel art, true = smooth art). If not specified then no change is made. Only works in CANVAS mode.
        * @param {boolean} [allowTrampoline=undefined] - Internal argument. If `false` click trampolining is suppressed.
        * @return {boolean} Returns true if the device supports fullscreen mode and fullscreen mode was attempted to be started. (It might not actually start, wait for the signals.)
        */
        startFullScreen(antialias?: boolean, allowTrampoline?: boolean): boolean;

        /**
        * Stops / exits fullscreen mode, if active.
        *
        * @method Phaser.ScaleManager#stopFullScreen
        * @public
        * @return {boolean} Returns true if the browser supports fullscreen mode and fullscreen mode will be exited.
        */
        stopFullScreen(): boolean;

    }
    /**
    * DOM utility class.
    *
    * Provides a useful Window and Element functions as well as cross-browser compatibility buffer.
    *
    * Some code originally derived from {@link https://github.com/ryanve/verge verge}.
    * Some parts were inspired by the research of Ryan Van Etten, released under MIT License 2013.
    * 
    * @class Phaser.DOM
    * @static
    */
    class DOM {

        static visualBounds: Phaser.Rectangle;

        static layoutBounds: Phaser.Rectangle;

        static documentBounds: Phaser.Rectangle;

        /**
        * Calibrates element coordinates for `inViewport` checks.
        *
        * @method Phaser.DOM.calibrate
        * @private
        * @param {object} coords - An object containing the following properties: `{top: number, right: number, bottom: number, left: number}`
        * @param {number} [cushion] - A value to adjust the coordinates by.
        * @return {object} The calibrated element coordinates
        */
        static calibrate(coords: any, cushion?: number): any;

        /**
        * Get the Visual viewport aspect ratio (or the aspect ratio of an object or element)    
        * 
        * @method Phaser.DOM.getAspectRatio
        * @param {(DOMElement|Object)} [object=(visualViewport)] - The object to determine the aspect ratio for. Must have public `width` and `height` properties or methods.
        * @return {number} The aspect ratio.
        */
        static getAspectRatio(object: any): number;

        /**
        * Returns the device screen orientation.
        *
        * Orientation values: 'portrait-primary', 'landscape-primary', 'portrait-secondary', 'landscape-secondary'.
        *
        * Order of resolving:
        * - Screen Orientation API, or variation of - Future track. Most desktop and mobile browsers.
        * - Screen size ratio check - If fallback is 'screen', suited for desktops.
        * - Viewport size ratio check - If fallback is 'viewport', suited for mobile.
        * - window.orientation - If fallback is 'window.orientation', works iOS and probably most Android; non-recommended track.
        * - Media query
        * - Viewport size ratio check (probably only IE9 and legacy mobile gets here..)
        *
        * See
        * - https://w3c.github.io/screen-orientation/ (conflicts with mozOrientation/msOrientation)
        * - https://developer.mozilla.org/en-US/docs/Web/API/Screen.orientation (mozOrientation)
        * - http://msdn.microsoft.com/en-us/library/ie/dn342934(v=vs.85).aspx
        * - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Testing_media_queries
        * - http://stackoverflow.com/questions/4917664/detect-viewport-orientation
        * - http://www.matthewgifford.com/blog/2011/12/22/a-misconception-about-window-orientation
        *
        * @method Phaser.DOM.getScreenOrientation
        * @protected
        * @param {string} [primaryFallback=(none)] - Specify 'screen', 'viewport', or 'window.orientation'.
        */
        static getScreenOrientation(primaryFallback?: string): string;

        /**
        * A cross-browser element.getBoundingClientRect method with optional cushion.
        * 
        * Returns a plain object containing the properties `top/bottom/left/right/width/height` with respect to the top-left corner of the current viewport.
        * Its properties match the native rectangle.
        * The cushion parameter is an amount of pixels (+/-) to cushion the element.
        * It adjusts the measurements such that it is possible to detect when an element is near the viewport.
        * 
        * @method Phaser.DOM.getBounds
        * @param {DOMElement|Object} element - The element or stack (uses first item) to get the bounds for.
        * @param {number} [cushion] - A +/- pixel adjustment amount.
        * @return {Object|boolean} A plain object containing the properties `top/bottom/left/right/width/height` or `false` if a non-valid element is given.
        */
        static getBounds(element: any, cushion?: number): any;

        /**
        * Get the [absolute] position of the element relative to the Document.
        *
        * The value may vary slightly as the page is scrolled due to rounding errors.
        *
        * @method Phaser.DOM.getOffset
        * @param {DOMElement} element - The targeted element that we want to retrieve the offset.
        * @param {Phaser.Point} [point] - The point we want to take the x/y values of the offset.
        * @return {Phaser.Point} - A point objet with the offsetX and Y as its properties.
        */
        static getOffset(element: any, point?: Point): Point;

        static inLayoutViewport(element: any, cushion?: number): boolean;

    }
    /**
    * This is a base State class which can be extended if you are creating your own game.
    * It provides quick access to common functions such as the camera, cache, input, match, sound and more.
    *
    * @class Phaser.State
    * @constructor
    */
    class State {

        /**
        * @property {Phaser.GameObjectFactory} add - A reference to the GameObjectFactory which can be used to add new objects to the World.
        */
        add: Phaser.GameObjectFactory;

        /**
        * @property {Phaser.Cache} cache - A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.
        */
        cache: Phaser.Cache;

        /**
        * @property {Phaser.Camera} camera - A handy reference to World.camera.
        */
        camera: Phaser.Camera;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.Input;

        /**
        * @property {Phaser.Loader} load - A reference to the Loader, which you mostly use in the preload method of your state to load external assets.
        */
        load: Phaser.Loader;

        /**
        * @property {Phaser.GameObjectCreator} make - A reference to the GameObjectCreator which can be used to make new objects.
        */
        make: Phaser.GameObjectCreator;

        /**
        * @property {Phaser.Math} math - A reference to Math class with lots of helpful functions.
        */
        math: Phaser.Math;

        /**
        * @property {Phaser.Particles} particles - The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.
        */
        particles: Phaser.Particles;

        /**
        * @property {Phaser.Physics} physics - A reference to the physics manager which looks after the different physics systems available within Phaser.
        */
        physics: Phaser.Physics;

        /**
        * @property {Phaser.RandomDataGenerator} rnd - A reference to the seeded and repeatable random data generator.
        */
        rnd: Phaser.RandomDataGenerator;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.ScaleManager;

        /**
        * @property {Phaser.SoundManager} sound - A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.
        */
        sound: Phaser.SoundManager;

        /**
        * @property {Phaser.Stage} stage - A reference to the Stage.
        */
        stage: Phaser.Stage;

        /**
        * @property {Phaser.Time} time - A reference to the game clock and timed events system.
        */
        time: Phaser.Time;

        /**
        * @property {Phaser.TweenManager} tweens - A reference to the tween manager.
        */
        tweens: Phaser.TweenManager;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.World;

        /**
        * create is called once preload has completed, this includes the loading of any assets from the Loader.
        * If you don't have a preload method then create is the first method called in your State.
        *
        * @method Phaser.State#create
        */
        create(): void;

        /**
        * loadRender is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.
        * The difference between loadRender and render is that any objects you render in this method you must be sure their assets exist.
        *
        * @method Phaser.State#loadRender
        */
        loadRender(): void;

        /**
        * loadUpdate is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.
        *
        * @method Phaser.State#loadUpdate
        */
        loadUpdate(): void;

        /**
        * This method will be called if the core game loop is paused.
        *
        * @method Phaser.State#paused
        */
        paused(): void;

        /**
        * preload is called first. Normally you'd use this to load your game assets (or those needed for the current State)
        * You shouldn't create any objects in this method that require assets that you're also loading in this method, as
        * they won't yet be available.
        *
        * @method Phaser.State#preload
        */
        preload(): void;

        /**
        * Nearly all display objects in Phaser render automatically, you don't need to tell them to render.
        * However the render method is called AFTER the game renderer and plugins have rendered, so you're able to do any
        * final post-processing style effects here. Note that this happens before plugins postRender takes place.
        *
        * @method Phaser.State#render
        */
        render(): void;

        /**
        * If your game is set to Scalemode RESIZE then each time the browser resizes it will call this function, passing in the new width and height.
        *
        * @method Phaser.State#resize
        */
        resize(): void;

        /**
        * This method will be called when the State is shutdown (i.e. you switch to another state from this one).
        *
        * @method Phaser.State#shutdown
        */
        shutdown(): void;

        /**
        * The update method is left empty for your own use.
        * It is called during the core game loop AFTER debug, physics, plugins and the Stage have had their preUpdate methods called.
        * If is called BEFORE Stage, Tweens, Sounds, Input, Physics, Particles and Plugins have had their postUpdate methods called.
        *
        * @method Phaser.State#update
        */
        update(): void;

    }
    class StateCycle {

        preUpdate(): void;

        update(): void;

        render(): void;

        postRender(): void;

        destroy(): void;

    }
    /**
    * The State Manager is responsible for loading, setting up and switching game states.
    *
    * @class Phaser.StateManager
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {Phaser.State|Object} [pendingState=null] - A State object to seed the manager with.
    */
    class StateManager {

        constructor(game: Phaser.Game, pendingState?: Phaser.State);

        /**
        * @property {string} current - The current active State object (defaults to null).
        */
        current: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {function} onCreateCallback - This is called when the state preload has finished and creation begins.
        */
        onCreateCallback: Function;

        /**
        * @property {function} onInitCallback - This is called when the state is set as the active state.
        */
        onInitCallback: Function;

        /**
        * @property {function} onLoadRenderCallback - This is called when the State is rendered during the preload phase.
        */
        onLoadRenderCallback: Function;

        /**
        * @property {function} onLoadUpdateCallback - This is called when the State is updated during the preload phase.
        */
        onLoadUpdateCallback: Function;

        /**
        * @property {function} onPausedCallback - This is called when the game is paused.
        */
        onPausedCallback: Function;

        /**
        * @property {function} onPauseUpdateCallback - This is called every frame while the game is paused.
        */
        onPauseUpdateCallback: Function;

        /**
        * @property {function} onPreloadCallback - This is called when the state starts to load assets.
        */
        onPreloadCallback: Function;

        /**
        * @property {function} onPreRenderCallback - This is called before the state is rendered and before the stage is cleared but after all game objects have had their final properties adjusted.
        */
        onPreRenderCallback: Function;

        /**
        * @property {function} onRenderCallback - This is called post-render. It doesn't happen during preload (see onLoadRenderCallback).
        */
        onRenderCallback: Function;

        /**
        * @property {function} onResumedCallback - This is called when the game is resumed from a paused state.
        */
        onResumedCallback: Function;

        /**
        * @property {function} onResizeCallback - This is called if ScaleManager.scalemode is RESIZE and a resize event occurs. It's passed the new width and height.
        */
        onResizeCallback: Function;

        /**
        * @property {function} onShutDownCallback - This is called when the state is shut down (i.e. swapped to another state).
        */
        onShutDownCallback: Function;

        /**
        * @property {function} onUpdateCallback - This is called when the state is updated, every game loop. It doesn't happen during preload (@see onLoadUpdateCallback).
        */
        onUpdateCallback: Function;

        /**
        * @property {object} states - The object containing Phaser.States.
        */
        states: any;

        /**
        * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.
        * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.
        * If a function is given a new state object will be created by calling it.
        *
        * @method Phaser.StateManager#add
        * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
        * @param {Phaser.State|object|function} state  - The state you want to switch to.
        * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.
        */
        add(key: string, state: any, autoStart?: boolean): void;

        /**
        * Checks if a given phaser state is valid. A State is considered valid if it has at least one of the core functions: preload, create, update or render.
        *
        * @method Phaser.StateManager#checkState
        * @param {string} key - The key of the state you want to check.
        * @return {boolean} true if the State has the required functions, otherwise false.
        */
        checkState(key: string): boolean;

        /**
        * This method clears the current State, calling its shutdown callback. The process also removes any active tweens,
        * resets the camera, resets input, clears physics, removes timers and if set clears the world and cache too.
        *
        * @method Phaser.StateManager#clearCurrentState
        */
        clearCurrentState(): void;

        /**
        * Removes all StateManager callback references to the State object, nulls the game reference and clears the States object.
        * You don't recover from this without rebuilding the Phaser instance again.
        * @method Phaser.StateManager#destroy
        */
        destroy(): void;

        /**
        * Gets the current State.
        *
        * @method Phaser.StateManager#getCurrentState
        * @return Phaser.State
        * @public
        */
        getCurrentState(): Phaser.State;

        /**
        * Links game properties to the State given by the key.
        *
        * @method Phaser.StateManager#link
        * @param {string} key - State key.
        * @protected
        */
        link(key: string): void;

        /**
        * @method Phaser.StateManager#loadComplete
        * @protected
        */
        loadComplete(): void;

        /**
        * @method Phaser.StateManager#pause
        * @protected
        */
        pause(): void;

        /**
        * @method Phaser.StateManager#preRender
        * @protected
        * @param {number} elapsedTime - The time elapsed since the last update.
        */
        preRender(elapsedTime: number): void;

        /**
        * preUpdate is called right at the start of the game loop. It is responsible for changing to a new state that was requested previously.
        *
        * @method Phaser.StateManager#preUpdate
        */
        preUpdate(): void;

        /**
        * @method Phaser.StateManager#render
        * @protected
        */
        render(): void;

        /**
        * Delete the given state.
        * @method Phaser.StateManager#remove
        * @param {string} key - A unique key you use to reference this state, i.e. "MainMenu", "Level1".
        */
        remove(key: string): void;

        /**
        * @method Phaser.StateManager#resume
        * @protected
        */
        resume(): void;

        /**
        * Restarts the current State. State.shutDown will be called (if it exists) before the State is restarted.
        *
        * @method Phaser.StateManager#restart
        * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)
        * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.
        * @param {...*} parameter - Additional parameters that will be passed to the State.init function if it has one.
        */
        restart(clearWorld?: boolean, clearCache?: boolean): void;

        /**
        * @method Phaser.StateManager#resize
        * @protected
        */
        resize(width: number, height: number): void;

        /**
        * Start the given State. If a State is already running then State.shutDown will be called (if it exists) before switching to the new State.
        *
        * @method Phaser.StateManager#start
        * @param {string} key - The key of the state you want to start.
        * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)
        * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.
        * @param {...*} parameter - Additional parameters that will be passed to the State.init function (if it has one).
        */
        start(key: string, clearWorld?: boolean, clearCache?: boolean, ...args: any[]): void;

        /**
        * @method Phaser.StateManager#update
        * @protected
        */
        update(): void;

        /**
        * Nulls all State level Phaser properties, including a reference to Game.
        *
        * @method Phaser.StateManager#unlink
        * @param {string} key - State key.
        * @protected
        */
        unlink(key: string): void;

    }
    /**
    * Create a new `Text` object. This uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for renderning to the view.
    * Because of this you can only display fonts that are currently loaded and available to the browser. It won't load the fonts for you.
    * Here is a compatibility table showing the available default fonts across different mobile browsers: http://www.jordanm.co.uk/tinytype
    *
    * @class Phaser.Text
    * @extends PIXI.Text
    * @constructor
    * @param {Phaser.Game} game - Current game instance.
    * @param {number} x - X position of the new text object.
    * @param {number} y - Y position of the new text object.
    * @param {string} text - The actual text that will be written.
    * @param {object} style - The style object containing style attributes like font, font size, etc.
    */
    class Text extends PIXI.Text {

        constructor(game: Phaser.Game, x: number, y: number, text: string, style: any);

        /**
        * @name Phaser.Text#align
        * @property {string} align - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.
        */
        align: string;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        /**
        * @property {array} colors - An array of the color values as specified by `Text.addColor`.
        */
        colors: string[];

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * @name Phaser.Text#fill
        * @property {object} fill - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.
        */
        fill: any;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Text#font
        * @property {string} font - The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.
        */
        font: string;

        /**
        * @name Phaser.Text#fontSize
        * @property {number} fontSize - The size of the font in pixels.
        */
        fontSize: number;

        /**
        * @name Phaser.Text#fontWeight
        * @property {number} fontWeight - The weight of the font: 'normal', 'bold', 'italic'. You can combine settings too, such as 'bold italic'.
        */
        fontWeight: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * @property {number} lineSpacing - Additional spacing (in pixels) between each line of text if multi-line.
        * @private
        */
        lineSpacing: number;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @name Phaser.Text#shadowBlur
        * @property {number} shadowBlur - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).
        */
        shadowBlur: number;

        /**
        * @name Phaser.Text#shadowColor
        * @property {string} shadowColor - The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.
        */
        shadowColor: string;

        /**
        * @name Phaser.Text#shadowOffsetX
        * @property {number} shadowOffsetX - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.
        */
        shadowOffsetX: number;

        /**
        * @name Phaser.Text#shadowOffsetY
        * @property {number} shadowOffsetY - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.
        */
        shadowOffsetY: number;

        /**
        * @name Phaser.Text#stroke
        * @property {string} stroke - A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'.
        */
        stroke: string;

        /**
        * @name Phaser.Text#strokeThickness
        * @property {number} strokeThickness - A number that represents the thickness of the stroke. Default is 0 (no stroke)
        */
        strokeThickness: number;

        /**
        * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot
        */
        scale: Phaser.Point;

        /**
        * The text string to be displayed by this Text object, taking into account the style settings.
        * @name Phaser.Text#text
        * @property {string} text - The text string to be displayed by this Text object, taking into account the style settings.
        */
        text: string;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @name Phaser.Text#wordWrap
        * @property {boolean} wordWrap - Indicates if word wrap should be used.
        */
        wordWrap: boolean;

        /**
        * @name Phaser.Text#wordWrapWidth
        * @property {number} wordWrapWidth - The width at which text will wrap.
        */
        wordWrapWidth: number;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * This method allows you to set specific colors within the Text.
        * It works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.
        * The position value is the index of the character in the Text string to start applying this color to.
        * Once set the color remains in use until either another color or the end of the string is encountered.
        * For example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.
        *
        * @method Phaser.Text#addColor
        * @param {string} color - A canvas fillstyle that will be used on the text eg `red`, `#00FF00`, `rgba()`.
        * @param {number} position - The index of the character in the string to start applying this color value from.
        */
        addColor(color: string, position: number): void;

        /**
        * Clears any previously set color stops.
        *
        * @method Phaser.Text#clearColors
        */
        clearColors(): void;

        /**
        * @method Phaser.Text#destroy
        * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?
        */
        destroy(destroyChildren?: boolean): void;

        /**
        * Automatically called by World.postUpdate.
        * 
        * @method Phaser.Text#postUpdate
        */
        postUpdate(): void;

        /**
        * Automatically called by World.preUpdate.
        * 
        * @method Phaser.Text#preUpdate
        */
        preUpdate(): void;

        /**
        * Sets a drop shadow effect on the Text. You can specify the horizontal and vertical distance of the drop shadow with the `x` and `y` parameters.
        * The color controls the shade of the shadow (default is black) and can be either an `rgba` or `hex` value.
        * The blur is the strength of the shadow. A value of zero means a hard shadow, a value of 10 means a very soft shadow.
        * To remove a shadow already in place you can call this method with no parameters set.
        * 
        * @method Phaser.Text#setShadow
        * @param {number} [x=0] - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.
        * @param {number} [y=0] - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.
        * @param {string} [color='rgba(0,0,0,1)'] - The color of the shadow, as given in CSS rgba or hex format. Set the alpha component to 0 to disable the shadow.
        * @param {number} [blur=0] - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).
        */
        setShadow(x?: number, y?: number, color?: any, blur?: number): void;

        /**
        * Set the style of the text by passing a single style object to it.
        *
        * @method Phaser.Text#setStyle
        * @param {object} [style] - The style properties to be set on the Text.
        * @param {string} [style.font='bold 20pt Arial'] - The style and size of the font.
        * @param {string} [style.fill='black'] - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.
        * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.
        * @param {string} [style.stroke='black'] - A canvas stroke style that will be used on the text stroke eg 'blue', '#FCFF00'.
        * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke. Default is 0 (no stroke).
        * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used.
        * @param {number} [style.wordWrapWidth=100] - The width in pixels at which text will wrap.
        */
        setStyle(style?: { font?: string; fill?: any; align?: string; stroke?: string; strokeThickness?: number; wordWrap?: boolean; wordWrapWidth?: number; shadowOffsetX?: number; shadowOffsetY?: number; shadowColor?: string; shadowBlur?: number; }): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        *
        * @method Phaser.Text#update
        */
        update(): void;

    }
    /**
    * A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled and will automatically wrap on the edges as it does so.
    * Please note that TileSprites, as with normal Sprites, have no input handler or physics bodies by default. Both need enabling.
    *
    * @class Phaser.TileSprite
    * @constructor
    * @extends PIXI.TilingSprite
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate (in world space) to position the TileSprite at.
    * @param {number} y - The y coordinate (in world space) to position the TileSprite at.
    * @param {number} width - The width of the TileSprite.
    * @param {number} height - The height of the TileSprite.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
    * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    */
    class Tile {

        constructor(layer: any, index: number, x: number, y: Number, width: number, height: number);//

        /**
        * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.
        */
        alpha: number;

        /**
        * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#bottom
        * @property {number} bottom - Gets or sets the bottom of the circle.
        */
        bottom: number;

        /**
        * @property {function} callback - The callback that will be called when the TimerEvent occurs.
        */
        callback: Function;

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        /**
        * The x coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerX
        * @property {number} centerX - The x coordinate of the center of the Rectangle.
        */
        centerX: number;

        /**
        * The y coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerY
        * @property {number} centerY - The y coordinate of the center of the Rectangle.
        */
        centerY: number;

        /**
        * @name Phaser.Tile#canCollide
        * @property {boolean} canCollide - True if this tile can collide on any of its faces or has a collision callback set.
        * @readonly
        */
        canCollide: boolean;

        /**
        * @property {boolean} collideDown - Indicating collide with any object on the bottom.
        * @default
        */
        collideDown: boolean;

        /**
        * @property {boolean} collideLeft - Indicating collide with any object on the left.
        * @default
        */
        collideLeft: boolean;

        collideNone: boolean;

        /**
        * @property {boolean} collideRight - Indicating collide with any object on the right.
        * @default
        */
        collideRight: boolean;

        /**
        * @property {function} collisionCallback - Tile collision callback.
        * @default
        */
        collisionCallback: Function;

        /**
        * @property {object} collisionCallbackContext - The context in which the collision callback will be called.
        * @default
        */
        collisionCallbackContext: any;

        /**
        * @name Phaser.Tile#collides
        * @property {boolean} collides - True if this tile can collide on any of its faces.
        * @readonly
        */
        collides: boolean;

        /**
        * @property {boolean} collideUp - Indicating collide with any object on the top.
        * @default
        */
        collideUp: boolean;

        /**
        * @property {boolean} faceBottom - Is the bottom of this tile an interesting edge?
        */
        faceBottom: boolean;

        /**
        * @property {boolean} faceLeft - Is the left of this tile an interesting edge?
        */
        faceLeft: boolean;

        /**
        * @property {boolean} faceRight - Is the right of this tile an interesting edge?
        */
        faceRight: boolean;

        /**
        * @property {boolean} faceTop - Is the top of this tile an interesting edge?
        */
        faceTop: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {number} index - The gamepad index as per browsers data
        * @readonly
        */
        index: number;

        /**
        * @property {object} layer - The layer in the Tilemap data that this tile belongs to.
        */
        layer: any;

        /**
        * The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
        * @name Phaser.Rectangle#left
        * @property {number} left - The x coordinate of the left of the Rectangle.
        */
        left: number;

        /**
        * @property {object} properties - Target property cache used when building the child data values.
        */
        properties: any;

        /**
        * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
        * @name Phaser.Circle#right
        * @property {number} right - Gets or sets the value of the rightmost point of the circle.
        */
        right: number;

        /**
        * @property {boolean} scanned - Has this tile been walked / turned into a poly?
        */
        scanned: boolean;

        /**
        * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
        * @name Phaser.Circle#top
        * @property {number} top - Gets or sets the top of the circle.
        */
        top: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * The world X coordinate of the most recently active pointer.
        * @name Phaser.Input#worldX
        * @property {number} worldX - The world X coordinate of the most recently active pointer.
        * @readonly
        */
        worldX: number;

        /**
        * The world Y coordinate of the most recently active pointer.
        * @name Phaser.Input#worldY
        * @property {number} worldY - The world Y coordinate of the most recently active pointer.
        * @readonly
        */
        worldY: number;

        /**
        * @property {number} x - The x coordinate of the center of the circle.
        */
        x: number;

        /**
        * @property {number} y - The y coordinate of the center of the circle.
        */
        y: number;

        /**
        * Copies the tile data and properties from the given tile to this tile.
        *
        * @method Phaser.Tile#copy
        * @param {Phaser.Tile} tile - The tile to copy from.
        */
        copy(tile: Phaser.Tile): Phaser.Tile;

        /**
        * Check if the given x and y world coordinates are within this Tile.
        *
        * @method Phaser.Tile#containsPoint
        * @param {number} x - The x coordinate to test.
        * @param {number} y - The y coordinate to test.
        * @return {boolean} True if the coordinates are within this Tile, otherwise false.
        */
        containsPoint(x: number, y: number): boolean;

        /**
        * Clean up memory.
        *
        * @method Phaser.Tile#destroy
        */
        destroy(): void;

        /**
        * Check for intersection with this tile.
        *
        * @method Phaser.Tile#intersects
        * @param {number} x - The x axis in pixels.
        * @param {number} y - The y axis in pixels.
        * @param {number} right - The right point.
        * @param {number} bottom - The bottom point.
        */
        intersects(x: number, y: number, right: number, bottom: number): boolean;

        isInterested(collides: boolean, faces: boolean): boolean;

        /**
        * Reset collision status flags.
        *
        * @method Phaser.Tile#resetCollision
        */
        resetCollision(): void;

        /**
        * Set a callback to be called when this tile is hit by an object.
        * The callback must true true for collision processing to take place.
        *
        * @method Phaser.Tile#setCollisionCallback
        * @param {function} callback - Callback function.
        * @param {object} context - Callback will be called within this context.
        */
        setCollision(left: boolean, right: boolean, up: boolean, down: boolean): void;

        /**
        * Set a callback to be called when this tile is hit by an object.
        * The callback must true true for collision processing to take place.
        *
        * @method Phaser.Tile#setCollisionCallback
        * @param {function} callback - Callback function.
        * @param {object} context - Callback will be called within this context.
        */
        setCollisionCallback(callback: Function, context: any): void;

    }
    /**
    * Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.
    * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
    * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
    * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
    * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
    * A Tile map is rendered to the display using a TilemapLayer. It is not added to the display list directly itself.
    * A map may have multiple layers. You can perform operations on the map data such as copying, pasting, filling and shuffling the tiles around.
    *
    * @class Phaser.Tilemap
    * @constructor
    * @param {Phaser.Game} game - Game reference to the currently running game.
    * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.
    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
    */
    class Tilemap {

        constructor(game: Phaser.Game, key?: string, tileWidth?: number, tileHeight?: number, width?: number, height?: number);

        static CSV: number;

        static TILED_JSON: number;

        static NORTH: number;

        static EAST: number;

        static SOUTH: number;

        static WEST: number;

        /**
        * @property {array} collision - An array of collision data (polylines, etc).
        */
        collision: any[];

        /**
        * @property {array} collideIndexes - An array of tile indexes that collide.
        */
        collideIndexes: any[];

        /**
        * @property {number} currentLayer - The current layer.
        */
        currentLayer: number;

        /**
        * @property {array} debugMap - Map data used for debug values only.
        */
        debugMap: any[];

        /**
        * @property {number} format - The format of the map data, either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.
        */
        format: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * @property {number} heightInPixels - The height of the map in pixels based on height * tileHeight.
        */
        heightInPixels: number;

        /**
        * @property {array} images - An array of Tiled Image Layers.
        */
        images: any[];

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: string;

        /**
        * @property {object} layer - The layer in the Tilemap data that this tile belongs to.
        */
        layer: Phaser.TilemapLayer[];

        /**
        * @property {array} layers - An array of Tilemap layer data.
        */
        layers: any[];

        /**
        * @property {array} objects - Array of quadtree children.
        */
        objects: any[];

        /**
        * @property {string} orientation - The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
        */
        orientation: string;

        /**
        * @property {object} properties - Target property cache used when building the child data values.
        */
        properties: any;

        /**
        * @property {number} tileHeight - The base height of the tiles in the map (in pixels).
        */
        tileHeight: number;

        /**
        * @property {array} tiles - The super array of Tiles.
        */
        tiles: Phaser.Tile[];

        /**
        * @property {array} tilesets - An array of Tilesets.
        */
        tilesets: Phaser.Tileset[];

        /**
        * @property {number} tileWidth - The base width of the tiles in the map (in pixels).
        */
        tileWidth: number;

        /**
        * @property {number} version - The version of the map data (as specified in Tiled, usually 1).
        */
        version: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * @property {number} widthInPixels - The width of the map in pixels based on width * tileWidth.
        */
        widthInPixels: number;

        /**
        * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.
        * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled editor.
        *
        * @method Phaser.Tilemap#addTilesetImage
        * @param {string} tileset - The name of the tileset as specified in the map data.
        * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If not specified it will look for an image with a key matching the tileset parameter.
        * @param {number} [tileWidth=32] - The width of the tiles in the Tileset Image. If not given it will default to the map.tileWidth value, if that isn't set then 32.
        * @param {number} [tileHeight=32] - The height of the tiles in the Tileset Image. If not given it will default to the map.tileHeight value, if that isn't set then 32.
        * @param {number} [tileMargin=0] - The width of the tiles in the Tileset Image. If not given it will default to the map.tileWidth value.
        * @param {number} [tileSpacing=0] - The height of the tiles in the Tileset Image. If not given it will default to the map.tileHeight value.
        * @param {number} [gid=0] - If adding multiple tilesets to a blank/dynamic map, specify the starting GID the set will use here.
        * @return {Phaser.Tileset} Returns the Tileset object that was created or updated, or null if it failed.
        */
        addTilesetImage(tileset: string, key?: string, tileWidth?: number, tileHeight?: number, tileMargin?: number, tileSpacing?: number, gid?: number): Phaser.Tileset;

        /**
        * Internal function.
        *
        * @method Phaser.Tilemap#calculateFaces
        * @protected
        * @param {number} layer - The index of the TilemapLayer to operate on.
        */
        calculateFaces(layer: number): void;

        /**
        * Copies all of the tiles in the given rectangular block into the tilemap data buffer.
        *
        * @method Phaser.Tilemap#copy
        * @param {integer} x - X position of the top left of the area to copy (given in tiles, not pixels)
        * @param {integer} y - Y position of the top left of the area to copy (given in tiles, not pixels)
        * @param {integer} width - The width of the area to copy (given in tiles, not pixels)
        * @param {integer} height - The height of the area to copy (given in tiles, not pixels)
        * @param {integer|string|Phaser.TilemapLayer} [layer] - The layer to copy the tiles from.
        * @return {array} An array of the tiles that were copied.
        */
        copy(x: number, y: number, width: number, height: number, layer?: any): Phaser.Tile[];

        /**
        * Creates an empty map of the given dimensions and one blank layer. If layers already exist they are erased.
        *
        * @method Phaser.Tilemap#create
        * @param {string} name - The name of the default layer of the map.
        * @param {number} width - The width of the map in tiles.
        * @param {number} height - The height of the map in tiles.
        * @param {number} tileWidth - The width of the tiles the map uses for calculations.
        * @param {number} tileHeight - The height of the tiles the map uses for calculations.
        * @param {Phaser.Group} [group] - Optional Group to add the layer to. If not specified it will be added to the World group.
        * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Image and can be moved around the display list accordingly.
        */
        create(name: string, width: number, height: number, tileWidth: number, tileHeight: number, group?: Phaser.Group): Phaser.TilemapLayer;

        /**
        * Creates a new and empty layer on this Tilemap. By default TilemapLayers are fixed to the camera.
        *
        * @method Phaser.Tilemap#createBlankLayer
        * @param {string} name - The name of this layer. Must be unique within the map.
        * @param {number} width - The width of the layer in tiles.
        * @param {number} height - The height of the layer in tiles.
        * @param {number} tileWidth - The width of the tiles the layer uses for calculations.
        * @param {number} tileHeight - The height of the tiles the layer uses for calculations.
        * @param {Phaser.Group} [group] - Optional Group to add the layer to. If not specified it will be added to the World group.
        * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Image and can be moved around the display list accordingly.
        */
        createBlankLayer(name: string, width: number, height: number, tileWidth: number, tileHeight: number, group?: Phaser.Group): Phaser.TilemapLayer;

        /**
        * Creates a Sprite for every object matching the given gid in the map data. You can optionally specify the group that the Sprite will be created in. If none is
        * given it will be created in the World. All properties from the map data objectgroup are copied across to the Sprite, so you can use this as an easy way to
        * configure Sprite properties from within the map editor. For example giving an object a property of alpha: 0.5 in the map editor will duplicate that when the
        * Sprite is created. You could also give it a value like: body.velocity.x: 100 to set it moving automatically.
        *
        * @method Phaser.Tilemap#createFromObjects
        * @param {string} name - The name of the Object Group to create Sprites from.
        * @param {number} gid - The layer array index value, or if a string is given the layer name within the map data.
        * @param {string} key - The Game.cache key of the image that this Sprite will use.
        * @param {number|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.
        * @param {boolean} [exists=true] - The default exists state of the Sprite.
        * @param {boolean} [autoCull=false] - The default autoCull state of the Sprite. Sprites that are autoCulled are culled from the camera if out of its range.
        * @param {Phaser.Group} [group=Phaser.World] - Group to add the Sprite to. If not specified it will be added to the World group.
        * @param {object} [CustomClass=Phaser.Sprite] - If you wish to create your own class, rather than Phaser.Sprite, pass the class here. Your class must extend Phaser.Sprite and have the same constructor parameters.
        * @param {boolean} [adjustY=true] - By default the Tiled map editor uses a bottom-left coordinate system. Phaser uses top-left. So most objects will appear too low down. This parameter moves them up by their height.
        */
        createFromObjects(name: string, gid: number, key: string, frame?: any, exists?: boolean, autoCull?: boolean, group?: Phaser.Group, CustomClass?: any, adjustY?: boolean): void;

        /**
        * Creates a Sprite for every object matching the given tile indexes in the map data.
        * You can specify the group that the Sprite will be created in. If none is given it will be created in the World.
        * You can optional specify if the tile will be replaced with another after the Sprite is created. This is useful if you want to lay down special 
        * tiles in a level that are converted to Sprites, but want to replace the tile itself with a floor tile or similar once converted.
        *
        * @method Phaser.Tilemap#createFromTiles
        * @param {integer|Array} tiles - The tile index, or array of indexes, to create Sprites from.
        * @param {integer|Array} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to not change.
        * @param {string} key - The Game.cache key of the image that this Sprite will use.
        * @param {Phaser.Group} [group=Phaser.World] - Group to add the Sprite to. If not specified it will be added to the World group.
        * @param {object} [properties] - An object that contains the default properties for your newly created Sprite. This object will be iterated and any matching Sprite property will be set.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        * @return {integer} The number of Sprites that were created.
        */
        createFromTiles(tiles: any, replacements: any, key: string, layer?: any, group?: Phaser.Group, properties?: any): number;

        /**
        * Creates a new TilemapLayer object. By default TilemapLayers are fixed to the camera.
        * The `layer` parameter is important. If you've created your map in Tiled then you can get this by looking in Tiled and looking at the Layer name.
        * Or you can open the JSON file it exports and look at the layers[].name value. Either way it must match.
        * If you wish to create a blank layer to put your own tiles on then see Tilemap.createBlankLayer.
        *
        * @method Phaser.Tilemap#createLayer
        * @param {number|string} layer - The layer array index value, or if a string is given the layer name, within the map data that this TilemapLayer represents.
        * @param {number} [width] - The rendered width of the layer, should never be wider than Game.width. If not given it will be set to Game.width.
        * @param {number} [height] - The rendered height of the layer, should never be wider than Game.height. If not given it will be set to Game.height.
        * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.
        * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Sprite and can be moved around the display list accordingly.
        */
        createLayer(layer: any, width?: number, height?: number, group?: Phaser.Group): Phaser.TilemapLayer;

        /**
        * Removes all layer data from this tile map and nulls the game reference.
        * Note: You are responsible for destroying any TilemapLayer objects you generated yourself, as Tilemap doesn't keep a reference to them.
        *
        * @method Phaser.Tilemap#destroy
        */
        destroy(): void;

        /**
        * Dumps the tilemap data out to the console.
        *
        * @method Phaser.Tilemap#dump
        */
        dump(): void;

        /**
        * Fills the given area with the specified tile.
        *
        * @method Phaser.Tilemap#fill
        * @param {number} index - The index of the tile that the area will be filled with.
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        fill(index: number, x: number, y: number, width: number, height: number, layer?: any): void;

        /**
        * For each tile in the given area defined by x/y and width/height run the given callback.
        *
        * @method Phaser.Tilemap#forEach
        * @param {number} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.
        * @param {number} context - The context under which the callback should be run.
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        forEach(callback: Function, context: any, x: number, y: Number, width: number, height: number, layer?: any): void;

        /**
        * Gets the image index based on its name.
        *
        * @method Phaser.Tilemap#getImageIndex
        * @param {string} name - The name of the image to get.
        * @return {number} The index of the image in this tilemap, or null if not found.
        */
        getImageIndex(name: string): number;

        /**
        * Gets the layer index based on the layers name.
        *
        * @method Phaser.Tilemap#getIndex
        * @protected
        * @param {array} location - The local array to search.
        * @param {string} name - The name of the array element to get.
        * @return {number} The index of the element in the array, or null if not found.
        */
        getIndex(location: any[], name: string): number;

        /**
        * Gets the layer index based on its name.
        *
        * @method Phaser.Tilemap#getLayerIndex
        * @param {string} name - The name of the layer to get.
        * @return {number} The index of the layer in this tilemap, or null if not found.
        */
        getLayer(layer: any): number;

        /**
        * Gets the layer index based on its name.
        *
        * @method Phaser.Tilemap#getLayerIndex
        * @param {string} name - The name of the layer to get.
        * @return {number} The index of the layer in this tilemap, or null if not found.
        */
        getLayerIndex(name: string): number;

        /**
        * Gets the object index based on its name.
        *
        * @method Phaser.Tilemap#getObjectIndex
        * @param {string} name - The name of the object to get.
        * @return {number} The index of the object in this tilemap, or null if not found.
        */
        getObjectIndex(name: string): number;

        /**
        * Gets the tileset index based on its name.
        *
        * @method Phaser.Tilemap#getTilesetIndex
        * @param {string} name - The name of the tileset to get.
        * @return {number} The index of the tileset in this tilemap, or null if not found.
        */
        getTile(x: number, y: number, layer?: any, nonNull?: boolean): Phaser.Tile;

        /**
        * Gets the tile above the tile coordinates given.
        * Mostly used as an internal function by calculateFaces.
        *
        * @method Phaser.Tilemap#getTileAbove
        * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().
        * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.
        * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.
        */
        getTileAbove(layer: number, x: number, y: number): Phaser.Tile;

        /**
        * Gets the tile below the tile coordinates given.
        * Mostly used as an internal function by calculateFaces.
        *
        * @method Phaser.Tilemap#getTileBelow
        * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().
        * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.
        * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.
        */
        getTileBelow(layer: number, x: number, y: number): Phaser.Tile;

        /**
        * Gets the tile to the left of the tile coordinates given.
        * Mostly used as an internal function by calculateFaces.
        *
        * @method Phaser.Tilemap#getTileLeft
        * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().
        * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.
        * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.
        */
        getTileLeft(layer: number, x: number, y: number): Phaser.Tile;

        /**
        * Gets the tile to the right of the tile coordinates given.
        * Mostly used as an internal function by calculateFaces.
        *
        * @method Phaser.Tilemap#getTileRight
        * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().
        * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.
        * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.
        */
        getTileRight(layer: number, x: number, y: number): Phaser.Tile;

        /**
        * Gets the tileset index based on its name.
        *
        * @method Phaser.Tilemap#getTilesetIndex
        * @param {string} name - The name of the tileset to get.
        * @return {number} The index of the tileset in this tilemap, or null if not found.
        */
        getTilesetIndex(name: string): number;

        /**
        * Gets a tile from the Tilemap layer. The coordinates are given in pixel values.
        *
        * @method Phaser.Tilemap#getTileWorldXY
        * @param {number} x - X position to get the tile from (given in pixels)
        * @param {number} y - Y position to get the tile from (given in pixels)
        * @param {number} [tileWidth] - The width of the tiles. If not given the map default is used.
        * @param {number} [tileHeight] - The height of the tiles. If not given the map default is used.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.
        * @return {Phaser.Tile} The tile at the given coordinates.
        */
        getTileWorldXY(x: number, y: number, tileWidth?: number, tileHeight?: number, layer?: any): Phaser.Tile;

        /**
        * Checks if there is a tile at the given location.
        *
        * @method Phaser.Tilemap#hasTile
        * @param {number} x - X position to check if a tile exists at (given in tile units, not pixels)
        * @param {number} y - Y position to check if a tile exists at (given in tile units, not pixels)
        * @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.
        * @return {boolean} True if there is a tile at the given location, otherwise false.
        */
        hasTile(x: number, y: number, layer: Phaser.TilemapLayer): boolean;

        /**
        * Pastes a previously copied block of tile data into the given x/y coordinates. Data should have been prepared with Tilemap.copy.
        *
        * @method Phaser.Tilemap#paste
        * @param {number} x - X position of the top left of the area to paste to (given in tiles, not pixels)
        * @param {number} y - Y position of the top left of the area to paste to (given in tiles, not pixels)
        * @param {array} tileblock - The block of tiles to paste.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to paste the tiles into.
        */
        paste(x: number, y: number, tileblock: Phaser.Tile[], layer?: any): void;

        /**
        * Puts a tile of the given index value at the coordinate specified.
        * If you pass `null` as the tile it will pass your call over to Tilemap.removeTile instead.
        *
        * @method Phaser.Tilemap#putTile
        * @param {Phaser.Tile|number|null} tile - The index of this tile to set or a Phaser.Tile object. If null the tile is removed from the map.
        * @param {number} x - X position to place the tile (given in tile units, not pixels)
        * @param {number} y - Y position to place the tile (given in tile units, not pixels)
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.
        * @return {Phaser.Tile} The Tile object that was created or added to this map.
        */
        putTile(tile: any, x: number, y: number, layer?: any): Phaser.Tile;

        /**
        * Puts a tile into the Tilemap layer. The coordinates are given in pixel values.
        *
        * @method Phaser.Tilemap#putTileWorldXY
        * @param {Phaser.Tile|number} tile - The index of this tile to set or a Phaser.Tile object.
        * @param {number} x - X position to insert the tile (given in pixels)
        * @param {number} y - Y position to insert the tile (given in pixels)
        * @param {number} tileWidth - The width of the tile in pixels.
        * @param {number} tileHeight - The height of the tile in pixels.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.
        * @return {Phaser.Tile} The Tile object that was created or added to this map.
        */
        putTileWorldXY(tile: any, x: number, y: number, tileWidth: number, tileHeight: number, layer?: any): void;

        /**
        * Randomises a set of tiles in a given area.
        *
        * @method Phaser.Tilemap#random
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        random(x: number, y: number, width: number, height: number, layer?: any): void;

        /**
        * Removes all layers from this tile map.
        *
        * @method Phaser.Tilemap#removeAllLayers
        */
        removeAllLayers(): void;

        /**
        * Removes the tile located at the given coordinates and updates the collision data.
        *
        * @method Phaser.Tilemap#removeTile
        * @param {number} x - X position to place the tile (given in tile units, not pixels)
        * @param {number} y - Y position to place the tile (given in tile units, not pixels)
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.
        * @return {Phaser.Tile} The Tile object that was removed from this map.
        */
        removeTile(x: number, y: number, layer?: any): Phaser.Tile;

        /**
        * Removes the tile located at the given coordinates and updates the collision data. The coordinates are given in pixel values.
        *
        * @method Phaser.Tilemap#removeTileWorldXY
        * @param {number} x - X position to insert the tile (given in pixels)
        * @param {number} y - Y position to insert the tile (given in pixels)
        * @param {number} tileWidth - The width of the tile in pixels.
        * @param {number} tileHeight - The height of the tile in pixels.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.
        * @return {Phaser.Tile} The Tile object that was removed from this map.
        */
        removeTileWorldXY(x: number, y: number, tileWidth: number, tileHeight: number, layer?: any): Phaser.Tile;

        /**
        * Scans the given area for tiles with an index matching `source` and updates their index to match `dest`.
        *
        * @method Phaser.Tilemap#replace
        * @param {number} source - The tile index value to scan for.
        * @param {number} dest - The tile index value to replace found tiles with.
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        replace(source: number, dest: number, x: number, y: number, width: number, height: number, layer?: any): void;

        /**
        * Searches the entire map layer for the first tile matching the given index, then returns that Phaser.Tile object.
        * If no match is found it returns null.
        * The search starts from the top-left tile and continues horizontally until it hits the end of the row, then it drops down to the next column.
        * If the reverse boolean is true, it scans starting from the bottom-right corner travelling up to the top-left.
        *
        * @method Phaser.Tilemap#searchTileIndex
        * @param {number} index - The tile index value to search for.
        * @param {number} [skip=0] - The number of times to skip a matching tile before returning.
        * @param {number} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.
        * @return {Phaser.Tile} The first (or n skipped) tile with the matching index.
        */
        searchTileIndex(index: number, skip?: number, reverse?: boolean, layer?: any): Phaser.Tile;

        /**
        * Sets collision the given tile or tiles. You can pass in either a single numeric index or an array of indexes: [ 2, 3, 15, 20].
        * The `collides` parameter controls if collision will be enabled (true) or disabled (false).
        *
        * @method Phaser.Tilemap#setCollision
        * @param {number|array} indexes - Either a single tile index, or an array of tile IDs to be checked for collision.
        * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        * @param {boolean} [recalculate=true] - Recalculates the tile faces after the update.
        */
        setCollision(indexes: any, collides?: boolean, layer?: any, recalculate?: boolean): void;

        /**
        * Sets collision on a range of tiles where the tile IDs increment sequentially.
        * Calling this with a start value of 10 and a stop value of 14 would set collision for tiles 10, 11, 12, 13 and 14.
        * The `collides` parameter controls if collision will be enabled (true) or disabled (false).
        *
        * @method Phaser.Tilemap#setCollisionBetween
        * @param {number} start - The first index of the tile to be set for collision.
        * @param {number} stop - The last index of the tile to be set for collision.
        * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        * @param {boolean} [recalculate=true] - Recalculates the tile faces after the update.
        */
        setCollisionBetween(start: number, stop: number, collides?: boolean, layer?: any, recalculate?: boolean): void;

        /**
        * Sets collision on all tiles in the given layer, except for the IDs of those in the given array.
        * The `collides` parameter controls if collision will be enabled (true) or disabled (false).
        *
        * @method Phaser.Tilemap#setCollisionByExclusion
        * @param {array} indexes - An array of the tile IDs to not be counted for collision.
        * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        * @param {boolean} [recalculate=true] - Recalculates the tile faces after the update.
        */
        setCollisionByExclusion(indexes: any[], collides?: boolean, layer?: any, recalculate?: boolean): void;

        /**
        * Sets collision values on a tile in the set.
        * You shouldn't usually call this method directly, instead use setCollision, setCollisionBetween or setCollisionByExclusion.
        *
        * @method Phaser.Tilemap#setCollisionByIndex
        * @protected
        * @param {number} index - The index of the tile on the layer.
        * @param {boolean} [collides=true] - If true it will enable collision on the tile. If false it will clear collision values from the tile.
        * @param {number} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        * @param {boolean} [recalculate=true] - Recalculates the tile faces after the update.
        */
        setCollisionByIndex(index: number, collides?: boolean, layer?: number, recalculate?: boolean): void;

        /**
        * Sets the current layer to the given index.
        *
        * @method Phaser.Tilemap#setLayer
        * @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.
        */
        setLayer(layer: any): void;

        /**
        * Turn off/on the recalculation of faces for tile or collision updates. 
        * `setPreventRecalculate(true)` puts recalculation on hold while `setPreventRecalculate(false)` recalculates all the changed layers.
        *
        * @method Phaser.Tilemap#setPreventRecalculate
        * @param {boolean} value - If true it will put the recalculation on hold.
        */
        setPreventRecalculate(value: boolean): void;

        /**
        * Sets a global collision callback for the given tile index within the layer. This will affect all tiles on this layer that have the same index.
        * If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.
        * If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.
        *
        * @method Phaser.Tilemap#setTileIndexCallback
        * @param {number|array} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.
        * @param {function} callback - The callback that will be invoked when the tile is collided with.
        * @param {object} callbackContext - The context under which the callback is called.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        */
        setTileIndexCallback(indexes: any, callback: Function, callbackContext: any, layer?: any): void;

        /**
        * Sets a global collision callback for the given map location within the layer. This will affect all tiles on this layer found in the given area.
        * If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.
        * If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.
        *
        * @method Phaser.Tilemap#setTileLocationCallback
        * @param {number} x - X position of the top left of the area to copy (given in tiles, not pixels)
        * @param {number} y - Y position of the top left of the area to copy (given in tiles, not pixels)
        * @param {number} width - The width of the area to copy (given in tiles, not pixels)
        * @param {number} height - The height of the area to copy (given in tiles, not pixels)
        * @param {function} callback - The callback that will be invoked when the tile is collided with.
        * @param {object} callbackContext - The context under which the callback is called.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.
        */
        setTileLocationCallback(x: number, y: number, width: number, height: number, callback: Function, callbackContext: any, layer?: any): void;

        /**
        * Sets the base tile size for the map.
        *
        * @method Phaser.Tilemap#setTileSize
        * @param {number} tileWidth - The width of the tiles the map uses for calculations.
        * @param {number} tileHeight - The height of the tiles the map uses for calculations.
        */
        setTileSize(tileWidth: number, tileHeight: number): void;

        /**
        * Shuffles a set of tiles in a given area. It will only randomise the tiles in that area, so if they're all the same nothing will appear to have changed!
        *
        * @method Phaser.Tilemap#shuffle
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        shuffle(x: number, y: number, width: number, height: number, layer: any): void;

        /**
        * Scans the given area for tiles with an index matching tileA and swaps them with tileB.
        *
        * @method Phaser.Tilemap#swap
        * @param {number} tileA - First tile index.
        * @param {number} tileB - Second tile index.
        * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.
        * @param {number} width - The width in tiles of the area to operate on.
        * @param {number} height - The height in tiles of the area to operate on.
        * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.
        */
        swap(tileA: number, tileB: number, x: number, y: number, width: number, height: number, layer?: any): void;

    }
    /**
    * A TilemapLayer is a Phaser.Image/Sprite that renders a specific TileLayer of a Tilemap.
    *
    * Since a TilemapLayer is a Sprite it can be moved around the display, added to other groups or display objects, etc.
    * By default TilemapLayers have fixedToCamera set to `true`. Changing this will break Camera follow and scrolling behaviour.
    *
    * @class Phaser.TilemapLayer
    * @extends {Phaser.Image}
    * @constructor
    * @param {Phaser.Game} game - Game reference to the currently running game.
    * @param {Phaser.Tilemap} tilemap - The tilemap to which this layer belongs.
    * @param {integer} index - The index of the TileLayer to render within the Tilemap.
    * @param {integer} width - Width of the renderable area of the layer (in pixels).
    * @param {integer} height - Height of the renderable area of the layer (in pixels).
    */
    class TilemapLayer extends Phaser.Image {

        constructor(game: Phaser.Game, tilemap: Phaser.Tilemap, index: number, width?: number, height?: number);

        /**
        * @property {PIXI.BaseTexture} baseTexture - The PIXI.BaseTexture.
        * @default
        */
        baseTexture: PIXI.BaseTexture;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        /**
        * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
        */
        canvas: HTMLCanvasElement;

        collisionHeight: number;

        collisionWidth: number;

        /**
        * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        */
        context: CanvasRenderingContext2D;

        /**
        * @property {Phaser.Utils.Debug} debug - A set of useful debug utilitie.
        */
        debug: boolean;

        /**
        * Settings used for debugging and diagnostics.
        *
        * @property {?string} missingImageFill - A tile is rendered as a rectangle using the following fill if a valid tileset/image cannot be found. A value of `null` prevents additional rendering for tiles without a valid tileset image. _This takes effect even when debug rendering for the layer is not enabled._
        *
        * @property {?string} debuggedTileOverfill - If a Tile has `Tile#debug` true then, after normal tile image rendering, a rectangle with the following fill is drawn above/over it. _This takes effect even when debug rendering for the layer is not enabled._
        *
        * @property {boolean} forceFullRedraw - When debug rendering (`debug` is true), and this option is enabled, the a full redraw is forced and rendering optimization is suppressed.
        *
        * @property {number} debugAlpha - When debug rendering (`debug` is true), the tileset is initially rendered with this alpha level. This can make the tile edges clearer.
        *
        * @property {?string} facingEdgeStroke - When debug rendering (`debug` is true), this color/stroke is used to draw "face" edges. A value of `null` disables coloring facing edges.
        *
        * @property {?string} collidingTileOverfill - When debug rendering (`debug` is true), this fill is used for tiles that are collidable. A value of `null` disables applying the additional overfill.
        *
        */
        debugAlpha: number;

        debugCallbackColor: string;

        debugColor: string;

        debugSettings: { missingImageFill: string; debuggedTileOverfill: string; forceFullRedraw: boolean; debugAlpha: number; facingEdgeStroke: string; collidingTileOverfill: string; };

        /**
        * @property {boolean} dirty - Internal PIXI var.
        * @default
        */
        dirty: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} index - The gamepad index as per browsers data
        * @readonly
        */
        index: number;

        /**
        * @property {object} layer - The layer in the Tilemap data that this tile belongs to.
        */
        layer: Phaser.TilemapLayer;

        map: Phaser.Tilemap;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        rayStepRate: number;

        renderSettings: { enableScrollDelta: boolean; overdrawRatio: number; };

        scrollFactorX: number;

        scrollFactorY: number;

        scrollX: number;

        scrollY: number;

        /**
        * @property {PIXI.Texture} texture - The PIXI.Texture.
        * @default
        */
        texture: PIXI.Texture;

        /**
        * @property {Phaser.Frame} textureFrame - The Frame this BitmapData uses for rendering.
        * @default
        */
        textureFrame: Phaser.Frame;

        tileColor: string;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        wrap: boolean;

        /**
        * Gets all tiles that intersect with the given line.
        *
        * @method Phaser.TilemapLayer#getRayCastTiles
        * @public
        * @param {Phaser.Line} line - The line used to determine which tiles to return.
        * @param {integer} [stepRate=(rayStepRate)] - How many steps through the ray will we check? Defaults to `rayStepRate`.
        * @param {boolean} [collides=false] - If true, _only_ return tiles that collide on one or more faces.
        * @param {boolean} [interestingFace=false] - If true, _only_ return tiles that have interesting faces.
        * @return {Phaser.Tile[]} An array of Phaser.Tiles.
        */
        getRayCastTiles(line: Phaser.Line, stepRate?: number, collides?: boolean, interestingFace?: boolean): Phaser.Tile[];

        /**
        * Get all tiles that exist within the given area, defined by the top-left corner, width and height. Values given are in pixels, not tiles.
        *
        * @method Phaser.TilemapLayer#getTiles
        * @public
        * @param {number} x - X position of the top left corner (in pixels).
        * @param {number} y - Y position of the top left corner (in pixels).
        * @param {number} width - Width of the area to get (in pixels).
        * @param {number} height - Height of the area to get (in pixels).
        * @param {boolean} [collides=false] - If true, _only_ return tiles that collide on one or more faces.
        * @param {boolean} [interestingFace=false] - If true, _only_ return tiles that have interesting faces.
        * @return {array<Phaser.Tile>} An array of Tiles.
        */
        getTiles(x: number, y: number, width: number, height: number, collides?: boolean, interestingFace?: boolean): Phaser.Tile[];

        /**
        * Convert a pixel value to a tile coordinate.
        *
        * @method Phaser.TilemapLayer#getTileX
        * @public
        * @param {number} x - X position of the point in target tile (in pixels).
        * @return {integer} The X map location of the tile.
        */
        getTileX(x: number): number;

        /**
        * Convert a pixel coordinate to a tile coordinate.
        *
        * @method Phaser.TilemapLayer#getTileXY
        * @public
        * @param {number} x - X position of the point in target tile (in pixels).
        * @param {number} y - Y position of the point in target tile (in pixels).
        * @param {(Phaser.Point|object)} point - The Point/object to update.
        * @return {(Phaser.Point|object)} A Point/object with its `x` and `y` properties set.
        */
        getTileXY(x: number, y: number, point: Phaser.Point): Phaser.Point;

        /**
        * Convert a pixel value to a tile coordinate.
        *
        * @method Phaser.TilemapLayer#getTileY
        * @public
        * @param {number} y - Y position of the point in target tile (in pixels).
        * @return {integer} The Y map location of the tile.
        */
        getTileY(y: number): number;

        /**
        * Automatically called by World.postUpdate. Handles cache updates.
        *
        * @method Phaser.TilemapLayer#postUpdate
        * @protected
        */
        postUpdate(): void;

        /**
        * Render tiles in the given area given by the virtual tile coordinates biased by the given scroll factor.
        * This will constrain the tile coordinates based on wrapping but not physical coordinates.
        *
        * @method Phaser.TilemapLayer#renderRegion
        * @private
        * @param {integer} scrollX - Render x offset/scroll.
        * @param {integer} scrollY - Render y offset/scroll.
        * @param {integer} left - Leftmost column to render.
        * @param {integer} top - Topmost row to render.
        * @param {integer} right - Rightmost column to render.
        * @param {integer} bottom - Bottommost row to render.
        */
        render(): void;

        /**
        * Sets the world size to match the size of this layer.
        *
        * @method Phaser.TilemapLayer#resizeWorld
        * @public
        */
        resizeWorld(): void;

        /**
        * The TilemapLayer caches tileset look-ups. Call this method of clear the cache if tilesets have been added or updated after the layer has been rendered.
        *
        * @method Phaser.TilemapLayer#resetTilesetCache
        * @public
        */
        resetTilesetCache(): void;

        updateMax(): void;

    }
    /**
    * Phaser.TilemapParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into a Tilemap.
    *
    * @class Phaser.TilemapParser
    */
    class TilemapParser {

        /**
        * Returns an empty map data object.
        *
        * @method Phaser.TilemapParser.getEmptyData
        * @return {object} Generated map data.
        */
        static getEmptyData(tileWidth?: number, tileHeight?: number, width?: number, height?: number): any;

        /**
        * Parse tilemap data from the cache and creates a Tilemap object.
        *
        * @method Phaser.TilemapParser.parse
        * @param {Phaser.Game} game - Game reference to the currently running game.
        * @param {string} key - The key of the tilemap in the Cache.
        * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
        * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.
        * @return {object} The parsed map object.
        */
        static parse(game: Phaser.Game, key: string, tileWidth?: number, tileHeight?: number, width?: number, height?: number): any;

        /**
        * Parses a CSV file into valid map data.
        *
        * @method Phaser.TilemapParser.parseCSV
        * @param {string} data - The CSV file data.
        * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.
        * @return {object} Generated map data.
        */
        static parseCSV(key: string, data: string, tileWidth?: number, tileHeight?: number): any;

        /**
        * Parses a Tiled JSON file into valid map data.
        * @method Phaser.TilemapParser.parseJSON
        * @param {object} json - The JSON map data.
        * @return {object} Generated and parsed map data.
        */
        static parseJSON(json: any): any;

    }
    /**
    * A Tile set is a combination of an image containing the tiles and collision data per tile.
    *
    * Tilesets are normally created automatically when Tiled data is loaded.
    *
    * @class Phaser.Tileset
    * @constructor
    * @param {string} name - The name of the tileset in the map data.
    * @param {integer} firstgid - The first tile index this tileset contains.
    * @param {integer} [width=32] - Width of each tile (in pixels).
    * @param {integer} [height=32] - Height of each tile (in pixels).
    * @param {integer} [margin=0] - The margin around all tiles in the sheet (in pixels).
    * @param {integer} [spacing=0] - The spacing between each tile in the sheet (in pixels).
    * @param {object} [properties={}] - Custom Tileset properties.
    */
    class Tileset {

        constructor(name: string, firstgid: number, width?: number, height?: number, margin?: number, spacing?: number, properties?: any);

        columns: number;

        firstgid: number;

        image: any;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {object} properties - Target property cache used when building the child data values.
        */
        properties: any;

        rows: number;

        /**
        * @property {number} tileHeight - The base height of the tiles in the map (in pixels).
        */
        tileHeight: number;

        tileMargin: number;

        tileSpacing: number;

        /**
        * @property {number} tileWidth - The base width of the tiles in the map (in pixels).
        */
        tileWidth: number;

        /**
        * @name Phaser.FrameData#total
        * @property {number} total - The total number of frames in this FrameData set.
        * @readonly
        */
        total: number;

        /**
        * Returns true if and only if this tileset contains the given tile index.
        *
        * @method Phaser.Tileset#containsTileIndex
        * @public
        * @return {boolean} True if this tileset contains the given index.
        */
        containsTileIndex(tileIndex: number): boolean;

        /**
        * Draws a tile from this Tileset at the given coordinates on the context.
        *
        * @method Phaser.Tileset#draw
        * @public
        * @param {CanvasRenderingContext2D} context - The context to draw the tile onto.
        * @param {number} x - The x coordinate to draw to.
        * @param {number} y - The y coordinate to draw to.
        * @param {integer} index - The index of the tile within the set to draw.
        */
        draw(context: CanvasRenderingContext2D, x: number, y: number, index: number): void;

        /**
        * Set the image associated with this Tileset and update the tile data.
        *
        * @method Phaser.Tileset#setImage
        * @public
        * @param {Image} image - The image that contains the tiles.
        */
        setImage(image: any): void;

        /**
        * Sets tile spacing and margins.
        *
        * @method Phaser.Tileset#setSpacing
        * @public
        * @param {integer} tileMargin - The margin around the tiles in the sheet (in pixels).
        * @param {integer} tileSpacing - The spacing between the tiles in the sheet (in pixels).
        */
        setSpacing(margin?: number, spacing?: number): void;

    }
    /**
    * A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled and will automatically wrap on the edges as it does so.
    * Please note that TileSprites, as with normal Sprites, have no input handler or physics bodies by default. Both need enabling.
    *
    * @class Phaser.TileSprite
    * @constructor
    * @extends PIXI.TilingSprite
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {number} x - The x coordinate (in world space) to position the TileSprite at.
    * @param {number} y - The y coordinate (in world space) to position the TileSprite at.
    * @param {number} width - The width of the TileSprite.
    * @param {number} height - The height of the TileSprite.
    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
    * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
    */
    class TileSprite extends PIXI.TilingSprite {

        constructor(game: Phaser.Game, x: number, y: number, width: number, height: number, key?: any, frame?: any);

        /**
        * @property {boolean} alive - A useful boolean to control if the Sprite is alive or dead (in terms of your gameplay, it doesn't effect rendering). Also linked to Sprite.health and Sprite.damage.
        * @default
        */
        alive: boolean;

        /**
        * @name Phaser.Line#angle
        * @property {number} angle - Gets the angle of the line.
        * @readonly
        */
        angle: number;

        /**
        * @property {Phaser.AnimationManager} animations - This manages animations of the sprite. You can modify animations through it (see Phaser.AnimationManager)
        */
        animations: Phaser.AnimationManager;

        /**
        * Should this Sprite be automatically culled if out of range of the camera?
        * A culled sprite has its renderable property set to 'false'.
        * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.
        *
        * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.
        * @default
        */
        autoCull: boolean;

        /**
        * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.
        */
        body: any;

        /**
        * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.
        */
        cameraOffset: Phaser.Point;

        checkWorldBounds: boolean;

        /**
        * @name Phaser.Sprite#destroyPhase
        * @property {boolean} destroyPhase - True if this object is currently being destroyed.
        */
        destroyPhase: boolean;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Events;

        /**
        * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.
        * @default
        */
        exists: boolean;

        /**
        * An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.
        * Note that the cameraOffset values are in addition to any parent in the display list.
        * So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x
        *
        * @name Phaser.Sprite#fixedToCamera
        * @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.
        */
        fixedToCamera: boolean;

        /**
        * @name Phaser.Sprite#frame
        * @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.
        */
        frame: number;

        /**
        * @name Phaser.Sprite#frameName
        * @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.
        */
        frameName: string;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {Phaser.Input} input - A reference to the Input Manager.
        */
        input: Phaser.InputHandler;

        /**
        * By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is
        * activated for this object and it will then start to process click/touch events and more.
        *
        * @name Phaser.Sprite#inputEnabled
        * @property {boolean} inputEnabled - Set to true to allow this object to receive input events.
        */
        inputEnabled: boolean;

        /**
        * @property {string} key - The key of the BitmapData in the Cache, if stored there.
        */
        key: any;

        /**
        * @property {string} name - The name of this object.
        * @default
        */
        name: string;

        /**
        * @property {Phaser.Point} position - Current position of the camera in world.
        * @private
        * @default
        */
        position: Phaser.Point;

        /**
        * @property {number} type - The base object type.
        */
        type: number;

        /**
        * @property {Phaser.World} world - A reference to the game world.
        */
        world: Phaser.Point;

        /**
        * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.
        */
        z: number;

        /**
        * Sets this TileSprite to automatically scroll in the given direction until stopped via TileSprite.stopScroll().
        * The scroll speed is specified in pixels per second.
        * A negative x value will scroll to the left. A positive x value will scroll to the right.
        * A negative y value will scroll up. A positive y value will scroll down.
        *
        * @method Phaser.TileSprite#autoScroll
        * @memberof Phaser.TileSprite
        * @param {number} x - Horizontal scroll speed in pixels per second.
        * @param {number} y - Vertical scroll speed in pixels per second.
        */
        autoScroll(x: number, y: number): void;

        /**
        * Destroys the TileSprite. This removes it from its parent group, destroys the event and animation handlers if present
        * and nulls its reference to game, freeing it up for garbage collection.
        *
        * @method Phaser.TileSprite#destroy
        * @memberof Phaser.TileSprite
        * @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?
        */
        destroy(destroyChildren: boolean): void;

        /**
        * Changes the Texture the TileSprite is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.
        * This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.
        *
        * @method Phaser.TileSprite#loadTexture
        * @memberof Phaser.TileSprite
        * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.
        * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
        */
        loadTexture(key: any, frame: any): void;

        /**
        * Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()
        * If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.
        *
        * @method Phaser.TileSprite#play
        * @memberof Phaser.TileSprite
        * @param {string} name - The name of the animation to be played, e.g. "fire", "walk", "jump".
        * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.
        * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.
        * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.
        * @return {Phaser.Animation} A reference to playing Animation instance.
        */
        play(name: string, frameRate?: number, loop?: boolean, killOnComplete?: boolean): Phaser.Animation;

        /**
        * Internal function called by the World postUpdate cycle.
        *
        * @method Phaser.TileSprite#postUpdate
        * @memberof Phaser.TileSprite
        */
        postUpdate(): void;

        /**
        * Automatically called by World.preUpdate.
        *
        * @method Phaser.TileSprite#preUpdate
        * @memberof Phaser.TileSprite
        */
        preUpdate(): void;

        /**
        * Resets the TileSprite. This places the TileSprite at the given x/y world coordinates, resets the tilePosition and then
        * sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.
        * If the TileSprite has a physics body that too is reset.
        *
        * @method Phaser.TileSprite#reset
        * @memberof Phaser.TileSprite
        * @param {number} x - The x coordinate (in world space) to position the Sprite at.
        * @param {number} y - The y coordinate (in world space) to position the Sprite at.
        * @return (Phaser.TileSprite) This instance.
        */
        reset(x: number, y: number): Phaser.TileSprite;

        /**
        * Sets the Texture frame the TileSprite uses for rendering.
        * This is primarily an internal method used by TileSprite.loadTexture, although you may call it directly.
        *
        * @method Phaser.TileSprite#setFrame
        * @memberof Phaser.TileSprite
        * @param {Phaser.Frame} frame - The Frame to be used by the TileSprite texture.
        */
        setFrame(frame: Phaser.Frame): void;

        /**
        * Stops an automatically scrolling TileSprite.
        *
        * @method Phaser.TileSprite#stopScroll
        * @memberof Phaser.TileSprite
        */
        stopScroll(): void;

        /**
        * Override and use this function in your own custom objects to handle any update requirements you may have.
        *
        * @method Phaser.TileSprite#update
        * @memberof Phaser.TileSprite
        */
        update(): void;

    }
    /**
    * This is the core internal game clock.
    *
    * It manages the elapsed time and calculation of elapsed values, used for game object motion and tweens,
    * and also handlers the standard Timer pool.
    *
    * To create a general timed event, use the master {@link Phaser.Timer} accessible through {@link Phaser.Time.events events}.
    *
    * @class Phaser.Time
    * @constructor
    * @param {Phaser.Game} game A reference to the currently running game.
    */
    class Time {

        constructor(game: Phaser.Game);

        advancedTiming: boolean;

        desiredFps: number;

        /**
        * @property {number} elapsed - Elapsed time since the last frame (in ms).
        * @protected
        */
        elapsed: number;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.Timer;

        /**
        * The time in ms since the last time update, in milliseconds, based on `time`.
        *
        * This value is corrected for game pauses and will be "about zero" after a game is resumed.
        *
        * _Note:_ This is updated once per game loop - even if multiple logic update steps are done.
        * Use {@link Phaser.Timer#physicsTime physicsTime} as a basis of game/logic calculations instead.
        *
        * @property {integer} elapsedMS 
        * @protected
        */
        elapsedMS: number;

        fps: number;

        fpsMax: number;

        fpsMin: number;

        frames: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        lastTime: number;

        msMax: number;

        msMin: number;

        now: number;

        /**
        * @property {number} pausedTime - The game time at which the sound was paused.
        */
        pausedTime: number;

        pauseDuration: number;

        physicsElapsed: number;

        physicsElapsedMS: number;

        prevTime: number;

        slowMotion: number;

        suggestedFps: number;

        /**
        * @property {Phaser.Time} time - A reference to the game clock and timed events system.
        */
        time: number;

        /**
        * @property {number} timeExpected - The time when the next call is expected when using setTimer to control the update loop
        * @protected
        */
        timeExpected: number;

        /**
        * @property {number} timeToCall - The value that setTimeout needs to work out when to next update
        * @protected
        */
        timeToCall: number;

        /**
        * Adds an existing Phaser.Timer object to the Timer pool.
        *
        * @method Phaser.Time#add
        * @param {Phaser.Timer} timer - An existing Phaser.Timer object.
        * @return {Phaser.Timer} The given Phaser.Timer object.
        */
        add(timer: Phaser.Timer): Phaser.Timer;

        /**
        * Called automatically by Phaser.Game after boot. Should not be called directly.
        *
        * @method Phaser.Time#boot
        * @protected
        */
        boot(): void;

        /**
        * Creates a new stand-alone Phaser.Timer object.
        *
        * @method Phaser.Time#create
        * @param {boolean} [autoDestroy=true] - A Timer that is set to automatically destroy itself will do so after all of its events have been dispatched (assuming no looping events).
        * @return {Phaser.Timer} The Timer object that was created.
        */
        create(autoDestroy?: boolean): Phaser.Timer;

        /**
        * How long has passed since the given time (in seconds).
        *
        * @method Phaser.Time#elapsedSecondsSince
        * @param {number} since - The time you want to measure (in seconds).
        * @return {number} Duration between given time and now (in seconds).
        */
        elapsedSecondsSince(since: number): number;

        /**
        * How long has passed since the given time.
        *
        * @method Phaser.Time#elapsedSince
        * @param {number} since - The time you want to measure against.
        * @return {number} The difference between the given time and now.
        */
        elapsedSince(since: number): number;

        /**
        * Remove all Timer objects, regardless of their state and clears all Timers from the {@link Phaser.Time#events events} timer.
        *
        * @method Phaser.Time#removeAll
        */
        removeAll(): void;

        /**
        * Resets the private _started value to now and removes all currently running Timers.
        *
        * @method Phaser.Time#reset
        */
        reset(): void;

        /**
        * The number of seconds that have elapsed since the game was started.
        *
        * @method Phaser.Time#totalElapsedSeconds
        * @return {number} The number of seconds that have elapsed since the game was started.
        */
        totalElapsedSeconds(): number;

        /**
        * Updates the game clock and if enabled the advanced timing data. This is called automatically by Phaser.Game.
        *
        * @method Phaser.Time#update
        * @protected
        * @param {number} time - The current relative timestamp; see {@link Phaser.Time#now now}.
        */
        update(time: number): void;

    }
    /**
    * A Timer is a way to create small re-usable (or disposable) objects that wait for a specific moment in time,
    * and then run the specified callbacks.
    *
    * You can many events to a Timer, each with their own delays. A Timer uses milliseconds as its unit of time (there are 1000 ms in 1 second).
    * So a delay to 250 would fire the event every quarter of a second.
    *
    * Timers are based on real-world (not physics) time, adjusted for game pause durations.
    *
    * @class Phaser.Timer
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {boolean} [autoDestroy=true] - If true, the timer will automatically destroy itself after all the events have been dispatched (assuming no looping events).
    */
    class Timer {

        constructor(game: Phaser.Game, autoDestroy?: boolean);

        static HALF: number;

        static MINUTE: number;

        static QUARTER: number;

        static SECOND: number;

        autoDestroy: boolean;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.
        */
        events: Phaser.TimerEvent[];

        /**
        * @property {boolean} expired - An expired Timer is one in which all of its events have been dispatched and none are pending.
        * @readonly
        * @default
        */
        expired: boolean;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @name Phaser.Line#length
        * @property {number} length - Gets the length of the line segment.
        * @readonly
        */
        length: number;

        /**
        * @name Phaser.Timer#ms
        * @property {number} ms - The duration in milliseconds that this Timer has been running for.
        * @readonly
        */
        ms: number;

        /**
        * @name Phaser.Timer#next
        * @property {number} next - The time at which the next event will occur.
        * @readonly
        */
        next: number;

        /**
        * @property {number} nextTick - The time the next tick will occur.
        * @readonly
        * @protected
        */
        nextTick: number;

        /**
        * @property {Phaser.Signal} onComplete - This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onAnimationLoop instead.
        */
        onComplete: Phaser.Signal;

        running: boolean;

        /**
        * The paused state of the Game. A paused game doesn't update any of its subsystems.
        * When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.
        * @name Phaser.Game#paused
        * @property {boolean} paused - Gets and sets the paused state of the Game.
        */
        paused: boolean;

        /**
        * @name Phaser.Timer#seconds
        * @property {number} seconds - The duration in seconds that this Timer has been running for.
        * @readonly
        */
        seconds: number;

        /**
        * Adds a new Event to this Timer.
        *
        * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
        * The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.
        *
        * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.
        *
        * @method Phaser.Timer#add
        * @param {number} delay - The number of milliseconds that should elapse before the callback is invoked.
        * @param {function} callback - The callback that will be called when the Timer event occurs.
        * @param {object} callbackContext - The context in which the callback will be called.
        * @param {...*} arguments - Additional arguments that will be supplied to the callback.
        * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.
        */
        add(delay: number, callback: Function, callbackContext: any, ...args: any[]): Phaser.TimerEvent;

        /**
        * Clears any events from the Timer which have pendingDelete set to true and then resets the private _len and _i values.
        *
        * @method Phaser.Timer#clearPendingEvents
        * @protected
        */
        clearPendingEvents(): void;

        /**
        * Destroys this Timer. Any pending Events are not dispatched.
        * The onComplete callbacks won't be called.
        *
        * @method Phaser.Timer#destroy
        */
        destroy(): void;

        /**
        * Adds a new looped Event to this Timer that will repeat forever or until the Timer is stopped.
        *
        * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
        * The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.
        *
        * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.
        *
        * @method Phaser.Timer#loop
        * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.
        * @param {function} callback - The callback that will be called when the Timer event occurs.
        * @param {object} callbackContext - The context in which the callback will be called.
        * @param {...*} arguments - Additional arguments that will be supplied to the callback.
        * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.
        */
        loop(delay: number, callback: Function, callbackContext: any, ...args: any[]): Phaser.TimerEvent;

        /**
        * Orders the events on this Timer so they are in tick order.
        * This is called automatically when new events are created.
        * @method Phaser.Timer#order
        * @protected
        */
        order(): void;

        /**
        * Pauses the Timer and all events in the queue.
        * @method Phaser.Timer#pause
        */
        pause(): void;

        /**
        * Removes a pending TimerEvent from the queue.
        * @param {Phaser.TimerEvent} event - The event to remove from the queue.
        * @method Phaser.Timer#remove
        */
        remove(event: Phaser.TimerEvent): boolean;

        /**
        * Removes all Events from this Timer and all callbacks linked to onComplete, but leaves the Timer running.    
        * The onComplete callbacks won't be called.
        *
        * @method Phaser.Timer#removeAll
        */
        removeAll(): void;

        /**
        * Adds a new TimerEvent that will always play through once and then repeat for the given number of iterations.
        *
        * The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
        * The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.
        *
        * Make sure to call {@link Phaser.Timer#start start} after adding all of the Events you require for this Timer.
        *
        * @method Phaser.Timer#repeat
        * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.
        * @param {number} repeatCount - The number of times the event will repeat once is has finished playback. A repeatCount of 1 means it will repeat itself once, playing the event twice in total.
        * @param {function} callback - The callback that will be called when the Timer event occurs.
        * @param {object} callbackContext - The context in which the callback will be called.
        * @param {...*} arguments - Additional arguments that will be supplied to the callback.
        * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.
        */
        repeat(delay: number, repeatCount: number, callback: Function, callbackContext: any, ...args: any[]): Phaser.TimerEvent;

        /**
        * Resumes the Timer and updates all pending events.
        *
        * @method Phaser.Timer#resume
        */
        resume(): void;

        /**
        * Sort handler used by Phaser.Timer.order.
        * @method Phaser.Timer#sortHandler
        * @private
        */
        sortHandler(a: any, b: any): number;

        /**
        * Starts this Timer running.
        * @method Phaser.Timer#start
        * @param {number} [delay=0] - The number of milliseconds that should elapse before the Timer will start.
        */
        start(startDelay?: number): void;

        /**
        * Stops this Timer from running. Does not cause it to be destroyed if autoDestroy is set to true.
        * @method Phaser.Timer#stop
        * @param {boolean} [clearEvents=true] - If true all the events in Timer will be cleared, otherwise they will remain.
        */
        stop(clearEvents?: boolean): void;

        /**
        * The main Timer update event, called automatically by Phaser.Time.update.
        *
        * @method Phaser.Timer#update
        * @protected
        * @param {number} time - The time from the core game clock.
        * @return {boolean} True if there are still events waiting to be dispatched, otherwise false if this Timer can be destroyed.
        */
        update(time: number): boolean;

    }
    /**
    * A TimerEvent is a single event that is processed by a Phaser.Timer.
    *
    * It consists of a delay, which is a value in milliseconds after which the event will fire.
    * When the event fires it calls a specific callback with the specified arguments.
    *
    * Use {@link Phaser.Timer#add}, {@link Phaser.Timer#add}, or {@link Phaser.Timer#add} methods to create a new event.
    *
    * @class Phaser.TimerEvent
    * @constructor
    * @param {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.
    * @param {number} delay - The delay in ms at which this TimerEvent fires.
    * @param {number} tick - The tick is the next game clock time that this event will fire at.
    * @param {number} repeatCount - If this TimerEvent repeats it will do so this many times.
    * @param {boolean} loop - True if this TimerEvent loops, otherwise false.
    * @param {function} callback - The callback that will be called when the TimerEvent occurs.
    * @param {object} callbackContext - The context in which the callback will be called.
    * @param {any[]} arguments - Additional arguments to be passed to the callback.
    */
    class TimerEvent {

        constructor(timer: Phaser.Timer, delay: number, tick: number, repeatCount: number, loop: boolean, callback: Function, callbackContext: any, ...args: any[]);

        args: any[];

        /**
        * @property {function} callback - The callback that will be called when the TimerEvent occurs.
        */
        callback: Function;

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        /**
        * @property {number} delay - The amount to delay by until the Tween starts (in ms).
        * @default
        */
        delay: number;

        /**
        * @property {boolean} loop - True if this TimerEvent loops, otherwise false.
        */
        loop: boolean;

        /**
        * @property {boolean} pendingDelete - True if this Tween is ready to be deleted by the TweenManager.
        * @default
        * @readonly
        */
        pendingDelete: boolean;

        /**
        * @property {number} repeatCount - If this TimerEvent repeats it will do so this many times.
        */
        repeatCount: number;

        /**
        * @property {number} tick - The tick is the next game clock time that this event will fire at.
        */
        tick: number;

        /**
        * @property {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.
        * @protected
        * @readonly
        */
        timer: Phaser.Timer;

    }
    /**
    * Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.
    *
    * @class Phaser.Touch
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Touch {

        constructor(game: Phaser.Game);

        /**
        * @property {object} callbackContext - The context under which the callbacks are run.
        */
        callbackContext: any;

        disabled: boolean;

        /**
        * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.
        * @default
        */
        enabled: boolean;

        /**
        * @property {object} event - Stores the most recent DOM event.
        * @readonly
        */
        event: any;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} preventDefault - If true the TouchEvent will have prevent.default called on it.
        * @default
        */
        preventDefault: boolean;

        /**
        * @property {function} touchCancelCallback - A callback that can be fired on a touchCancel event.
        */
        touchCancelCallback: Function;

        /**
        * @property {function} touchEndCallback - A callback that can be fired on a touchEnd event.
        */
        touchEndCallback: Function;

        /**
        * @property {function} touchEnterCallback - A callback that can be fired on a touchEnter event.
        */
        touchEnterCallback: Function;

        /**
        * @property {function} touchLeaveCallback - A callback that can be fired on a touchLeave event.
        */
        touchLeaveCallback: Function;

        /**
        * @property {function} touchMoveCallback - A callback that can be fired on a touchMove event.
        */
        touchMoveCallback: Function;

        /**
        * @property {function} touchStartCallback - A callback that can be fired on a touchStart event.
        */
        touchStartCallback: Function;

        /**
        * Consumes all touchmove events on the document (only enable this if you know you need it!).
        * @method Phaser.Touch#consumeTouchMove
        */
        consumeTouchMove(): void;

        /**
        * Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome).
        * Occurs for example on iOS when you put down 4 fingers and the app selector UI appears.
        * @method Phaser.Touch#onTouchCancel
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchCancel(event: any): void;

        /**
        * The handler for the touchend events.
        * @method Phaser.Touch#onTouchEnd
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchEnd(event: any): void;

        /**
        * For touch enter and leave its a list of the touch points that have entered or left the target.
        * Doesn't appear to be supported by most browsers on a canvas element yet.
        * @method Phaser.Touch#onTouchEnter
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchEnter(event: any): void;

        /**
        * For touch enter and leave its a list of the touch points that have entered or left the target.
        * Doesn't appear to be supported by most browsers on a canvas element yet.
        * @method Phaser.Touch#onTouchLeave
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchLeave(event: any): void;

        /**
        * The handler for the touchmove events.
        * @method Phaser.Touch#onTouchMove
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchMove(event: any): void;

        /**
        * The internal method that handles the touchstart event from the browser.
        * @method Phaser.Touch#onTouchStart
        * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.
        */
        onTouchStart(event: any): void;

        /**
        * Starts the event listeners running.
        * @method Phaser.Touch#start
        */
        start(): void;

        /**
        * Stop the event listeners.
        * @method Phaser.Touch#stop
        */
        stop(): void;

    }
    /**
    * Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.
    * Tweens are hooked into the game clock and pause system, adjusting based on the game state.
    *
    * TweenManager is based heavily on tween.js by http://soledadpenades.com.
    * The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.
    * It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.
    * Please see https://github.com/sole/tween.js for a full list of contributors.
    * 
    * @class Phaser.TweenManager
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class Tween {

        constructor(target: any, game: Phaser.Game, manager: Phaser.TweenManager);

        /**
        * @property {Phaser.Tween} chainedTween - If this Tween is chained to another this holds a reference to it.
        */
        chainedTween: Phaser.Tween;

        /**
        * @property {string} current - The current active State object (defaults to null).
        */
        current: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} isRunning - Is game running or paused?
        * @readonly
        */
        isRunning: boolean;

        /**
        * @property {boolean} isPaused - Is this Tween paused or not?
        * @default
        */
        isPaused: boolean;

        /**
        * @property {Phaser.TweenManager} manager - Reference to the TweenManager responsible for updating this Tween.
        */
        manager: Phaser.TweenManager;

        onChildComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onComplete - This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onAnimationLoop instead.
        */
        onComplete: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onLoop - This event is dispatched when this Animation loops.
        */
        onLoop: Phaser.Signal;

        onRepeat: Phaser.Signal;

        /**
        * @property {Phaser.Signal} onStart - This event is dispatched when this Animation starts playback.
        */
        onStart: Phaser.Signal;

        /**
        * @property {boolean} pendingDelete - True if this Tween is ready to be deleted by the TweenManager.
        * @default
        * @readonly
        */
        pendingDelete: boolean;

        /**
        * @property {object} properties - Target property cache used when building the child data values.
        */
        properties: any;

        /**
        * @property {number} repeatCounter - If the Tween and any child tweens are set to repeat this contains the current repeat count.
        */
        repeatCounter: number;

        /**
        * @property {number} repeatDelay - The amount of time in ms between repeats of this tween and any child tweens.
        */
        repeatDelay: number;

        reverse: boolean;

        /**
        * @property {Phaser.Sprite} target - If the camera is tracking a Sprite, this is a reference to it, otherwise null.
        * @default
        */
        target: any;

        /**
        * @property {Array} timeline - An Array of TweenData objects that comprise the different parts of this Tween.
        */
        timeline: Phaser.TweenData[];

        timeScale: number;

        /**
        * @name Phaser.Tween#totalDuration
        * @property {Phaser.TweenData} totalDuration - Gets the total duration of this Tween, including all child tweens, in milliseconds.
        */
        totalDuration: number;

        /**
        * This method allows you to chain tweens together. Any tween chained to this tween will have its `Tween.start` method called
        * as soon as this tween completes. If this tween never completes (i.e. repeatAll or loop is set) then the chain will never progress.
        * Note that `Tween.onComplete` will fire when *this* tween completes, not when the whole chain completes.
        * For that you should listen to `onComplete` on the final tween in your chain.
        * 
        * If you pass multiple tweens to this method they will be joined into a single long chain.
        * For example if this is Tween A and you pass in B, C and D then B will be chained to A, C will be chained to B and D will be chained to C.
        * Any previously chained tweens that may have been set will be overwritten.
        *
        * @method Phaser.Tween#chain
        * @param {...Phaser.Tween} tweens - One or more tweens that will be chained to this one.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        chain(...args: any[]): Phaser.Tween;

        /**
        * Sets the delay in milliseconds before this tween will start. If there are child tweens it sets the delay before the first child starts.
        * The delay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.
        * If you have child tweens and pass -1 as the index value it sets the delay across all of them.
        *
        * @method Phaser.Tween#delay
        * @param {number} duration - The amount of time in ms that the Tween should wait until it begins once started is called. Set to zero to remove any active delay.
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the delay on all the children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        delay(duration: number, index?: number): Phaser.Tween;

        /**
        * Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        * If you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.
        *
        * @method Phaser.Tween#easing
        * @param {function|string} ease - The easing function this tween will use, i.e. Phaser.Easing.Linear.None.
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the easing function on all children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        easing(ease: Function, index?: number): Phaser.Tween;

        /**
        * Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        * If you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.
        *
        * @method Phaser.Tween#easing
        * @param {function|string} ease - The easing function this tween will use, i.e. Phaser.Easing.Linear.None.
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the easing function on all children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        easing(ease: string, index?: number): Phaser.Tween;

        /**
        * Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.
        * For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        *
        * @method Phaser.Tween#from
        * @param {object} properties - An object containing the properties you want to tween., such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.
        * @param {number} [duration=1000] - Duration of this tween in ms.
        * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.
        * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().
        * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.
        * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this induvidual tween, not any chained tweens.
        * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.
        * @return {Phaser.Tween} This Tween object.
        */
        from(properties: any, duration?: number, ease?: Function, autoStart?: boolean, delay?: number, repeat?: number, yoyo?: boolean): Phaser.Tween;

        /**
        * Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.
        * For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        *
        * @method Phaser.Tween#from
        * @param {object} properties - An object containing the properties you want to tween., such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.
        * @param {number} [duration=1000] - Duration of this tween in ms.
        * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.
        * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().
        * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.
        * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this induvidual tween, not any chained tweens.
        * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.
        * @return {Phaser.Tween} This Tween object.
        */
        from(properties: any, duration?: number, ease?: string, autoStart?: boolean, delay?: number, repeat?: number, yoyo?: boolean): Phaser.Tween;

        /**
        * This will generate an array populated with the tweened object values from start to end.
        * It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.
        * It ignores delay and repeat counts and any chained tweens, but does include child tweens.
        * Just one play through of the tween data is returned, including yoyo if set.
        *
        * @method Phaser.Tween#generateData
        * @param {number} [frameRate=60] - The speed in frames per second that the data should be generated at. The higher the value, the larger the array it creates.
        * @param {array} [data] - If given the generated data will be appended to this array, otherwise a new array will be returned.
        * @return {array} An array of tweened values.
        */
        generateData(frameRate?: number, data?: any): any[];

        /**
        * Sets the interpolation function the tween will use. By default it uses Phaser.Math.linearInterpolation.
        * Also available: Phaser.Math.bezierInterpolation and Phaser.Math.catmullRomInterpolation.
        * The interpolation function is only used if the target properties is an array.
        * If you have child tweens and pass -1 as the index value it sets the interpolation function across all of them.
        *
        * @method Phaser.Tween#interpolation
        * @param {function} interpolation - The interpolation function to use (Phaser.Math.linearInterpolation by default)
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the easing function on all children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        interpolation(interpolation: Function, index?: number): Phaser.Tween;

        /**
        * Enables the looping of this tween and all child tweens. If this tween has no children this setting has no effect.
        * If `value` is `true` then this is the same as setting `Tween.repeatAll(-1)`.
        * If `value` is `false` it is the same as setting `Tween.repeatAll(0)` and will reset the `repeatCounter` to zero.
        *
        * Usage:
        * game.add.tween(p).to({ x: 700 }, 1000, Phaser.Easing.Linear.None, true)
        * .to({ y: 300 }, 1000, Phaser.Easing.Linear.None)
        * .to({ x: 0 }, 1000, Phaser.Easing.Linear.None)
        * .to({ y: 0 }, 1000, Phaser.Easing.Linear.None)
        * .loop();
        * @method Phaser.Tween#loop
        * @param {boolean} [value=true] - If `true` this tween and any child tweens will loop once they reach the end. Set to `false` to remove an active loop.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        loop(value?: boolean): Phaser.Tween;

        /**
        * Sets a callback to be fired each time this tween updates.
        *
        * @method Phaser.Tween#onUpdateCallback
        * @param {function} callback - The callback to invoke each time this tween is updated. Set to `null` to remove an already active callback.
        * @param {object} callbackContext - The context in which to call the onUpdate callback.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        onUpdateCallback(callback: Function, callbackContext: any): Phaser.Tween;

        /**
        * Pauses the tween. Resume playback with Tween.resume.
        *
        * @method Phaser.Tween#pause
        */
        pause(): void;

        /**
        * Sets the number of times this tween will repeat.
        * If you have child tweens and pass -1 as the index value it sets the number of times they'll repeat across all of them.
        * If you wish to define how many times this Tween and all children will repeat see Tween.repeatAll.
        *
        * @method Phaser.Tween#repeat
        * @param {number} total - How many times a tween should repeat before completing. Set to zero to remove an active repeat. Set to -1 to repeat forever.
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set the repeat value on all the children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        repeat(total: number, index?: number): Phaser.Tween;

        repeatAll(total?: number): Phaser.Tween;

        /**
        * Resumes a paused tween.
        *
        * @method Phaser.Tween#resume
        */
        resume(): void;

        /**
        * Starts the tween running. Can also be called by the autoStart parameter of `Tween.to` or `Tween.from`.
        * This sets the `Tween.isRunning` property to `true` and dispatches a `Tween.onStart` signal.
        * If the Tween has a delay set then nothing will start tweening until the delay has expired.
        *
        * @method Phaser.Tween#start
        * @param {number} [index=0] - If this Tween contains child tweens you can specify which one to start from. The default is zero, i.e. the first tween created.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        start(index?: number): Phaser.Tween;

        /**
        * Stops the tween if running and flags it for deletion from the TweenManager.
        * If called directly the `Tween.onComplete` signal is not dispatched and no chained tweens are started unless the complete parameter is set to `true`.
        * If you just wish to pause a tween then use Tween.pause instead.
        *
        * @method Phaser.Tween#stop
        * @param {boolean} [complete=false] - Set to `true` to dispatch the Tween.onComplete signal.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        stop(complete?: boolean): Phaser.Tween;

        /**
        * Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.
        * For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        *
        * @method Phaser.Tween#to
        * @param {object} properties - An object containing the properties you want to tween., such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.
        * @param {number} [duration=1000] - Duration of this tween in ms.
        * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.
        * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().
        * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.
        * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this induvidual tween, not any chained tweens.
        * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.
        * @return {Phaser.Tween} This Tween object.
        */
        to(properties: any, duration?: number, ease?: Function, autoStart?: boolean, delay?: number, repeat?: number, yoyo?: boolean): Phaser.Tween;

        /**
        * Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.
        * For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.
        * The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
        * ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
        *
        * @method Phaser.Tween#to
        * @param {object} properties - An object containing the properties you want to tween., such as `Sprite.x` or `Sound.volume`. Given as a JavaScript object.
        * @param {number} [duration=1000] - Duration of this tween in ms.
        * @param {function|string} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Default, which is Phaser.Easing.Linear.None by default but can be over-ridden.
        * @param {boolean} [autoStart=false] - Set to `true` to allow this tween to start automatically. Otherwise call Tween.start().
        * @param {number} [delay=0] - Delay before this tween will start in milliseconds. Defaults to 0, no delay.
        * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as -1. This only effects this induvidual tween, not any chained tweens.
        * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.
        * @return {Phaser.Tween} This Tween object.
        */
        to(properties: any, duration?: number, ease?: string, autoStart?: boolean, delay?: number, repeat?: number, yoyo?: boolean): Phaser.Tween;

        /**
        * Core tween update function called by the TweenManager. Does not need to be invoked directly.
        *
        * @method Phaser.Tween#update
        * @param {number} time - A timestamp passed in by the TweenManager.
        * @return {boolean} false if the tween and all child tweens have completed and should be deleted from the manager, otherwise true (still active).
        */
        update(time: number): boolean;

        /**
        * A Tween that has yoyo set to true will run through from its starting values to its end values and then play back in reverse from end to start.
        * Used in combination with repeat you can create endless loops.
        * If you have child tweens and pass -1 as the index value it sets the yoyo property across all of them.
        * If you wish to yoyo this Tween and all of its children then see Tween.yoyoAll.
        *
        * @method Phaser.Tween#yoyo
        * @param {boolean} enable - Set to true to yoyo this tween, or false to disable an already active yoyo.
        * @param {number} [index=0] - If this tween has more than one child this allows you to target a specific child. If set to -1 it will set yoyo on all the children.
        * @return {Phaser.Tween} This tween. Useful for method chaining.
        */
        yoyo(enable: boolean, index?: number): Phaser.Tween;

    }
    /**
    * A Phaser.Tween contains at least one TweenData object. It contains all of the tween data values, such as the
    * starting and ending values, the ease function, interpolation and duration. The Tween acts as a timeline manager for
    * TweenData objects and can contain multiple TweenData objects.
    *
    * @class Phaser.TweenData
    * @constructor
    * @param {Phaser.Tween} parent - The Tween that owns this TweenData object.
    */
    class TweenData {

        constructor(parent: Phaser.Tween);

        static COMPLETE: number;

        static LOOPED: number;

        static PENDING: number;

        static RUNNING: number;

        /**
        * @property {number} delay - The amount to delay by until the Tween starts (in ms).
        * @default
        */
        delay: number;

        /**
        * @property {number} dt - Current time value.
        */
        dt: number;

        /**
        * If the key is down this value holds the duration of that key press and is constantly updated.
        * If the key is up it holds the duration of the previous down session.
        * @property {number} duration - The number of milliseconds this key has been held down for.
        * @default
        */
        duration: number;

        /**
        * @property {function} easingFunction - The easing function used for the Tween.
        * @default Phaser.Easing.Default
        */
        easingFunction: Function;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {boolean} inReverse - When a Tween is yoyoing this value holds if it's currently playing forwards (false) or in reverse (true).
        * @default
        */
        inReverse: boolean;

        /**
        * @property {function} interpolationFunction - The interpolation function used for the Tween.
        * @default Phaser.Math.linearInterpolation
        */
        interpolationFunction: Function;

        /**
        * @property {boolean} isRunning - Is game running or paused?
        * @readonly
        */
        isRunning: boolean;

        /**
        * @property {boolean} isFrom - Is this a from tween or a to tween?
        * @default
        */
        isFrom: boolean;

        /**
        * @property {any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
        */
        parent: Phaser.Tween;

        /**
        * @property {number} percent - A value between 0 and 1 that represents how far through the duration this tween is.
        * @readonly
        */
        percent: number;

        /**
        * @property {number} repeatCounter - If the Tween and any child tweens are set to repeat this contains the current repeat count.
        */
        repeatCounter: number;

        /**
        * @property {number} startTime - The time the Tween started or null if it hasn't yet started.
        */
        startTime: number;

        /**
        * @property {number} value - Button value. Mainly useful for checking analog buttons (like shoulder triggers)
        * @default
        */
        value: number;

        /**
        * @property {boolean} yoyo - True if the Tween is set to yoyo, otherwise false.
        * @default
        */
        yoyo: boolean;

        from(properties: any, duration?: number, ease?: Function, delay?: number, repeat?: number, yoyo?: boolean): Phaser.TweenData;

        /**
        * This will generate an array populated with the tweened object values from start to end.
        * It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.
        * Just one play through of the tween data is returned, including yoyo if set.
        *
        * @method Phaser.TweenData#generateData
        * @param {number} [frameRate=60] - The speed in frames per second that the data should be generated at. The higher the value, the larger the array it creates.
        * @return {array} An array of tweened values.
        */
        generateData(frameRate?: number): any[];

        /**
        * Checks if this Tween is meant to repeat or yoyo and handles doing so.
        *
        * @private
        * @method Phaser.TweenData#repeat
        * @return {number} Either Phaser.TweenData.LOOPED or Phaser.TweenData.COMPLETE.
        */
        repeat(): number;

        /**
        * Starts the Tween running.
        *
        * @method Phaser.TweenData#start
        * @return {Phaser.TweenData} This Tween object.
        */
        start(): Phaser.TweenData;

        to(properties: any, duration?: number, ease?: Function, delay?: number, repeat?: number, yoyo?: boolean): Phaser.TweenData;

        /**
        * Updates this Tween. This is called automatically by Phaser.Tween.
        *
        * @protected
        * @method Phaser.TweenData#update
        * @return {number} The current status of this Tween. One of the Phaser.TweenData constants: PENDING, RUNNING, LOOPED or COMPLETE.
        */
        update(): number;

    }
    /**
    * Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.
    * Tweens are hooked into the game clock and pause system, adjusting based on the game state.
    *
    * TweenManager is based heavily on tween.js by http://soledadpenades.com.
    * The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.
    * It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.
    * Please see https://github.com/sole/tween.js for a full list of contributors.
    * 
    * @class Phaser.TweenManager
    * @constructor
    * @param {Phaser.Game} game - A reference to the currently running game.
    */
    class TweenManager {

        constructor(game: Phaser.Game);

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * Add a new tween into the TweenManager.
        *
        * @method Phaser.TweenManager#add
        * @param {Phaser.Tween} tween - The tween object you want to add.
        * @returns {Phaser.Tween} The tween object you added to the manager.
        */
        add(tween: Phaser.Tween): Phaser.Tween;

        /**
        * Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.
        *
        * @method Phaser.TweenManager#create
        * @param {object} object - Object the tween will be run on.
        * @returns {Phaser.Tween} The newly created tween object.
        */
        create(object: any): Phaser.Tween;

        /**
        * Get all the tween objects in an array.
        * @method Phaser.TweenManager#getAll
        * @returns {Phaser.Tween[]} Array with all tween objects.
        */
        getAll(): Phaser.Tween[];

        /**
        * Checks to see if a particular Sprite is currently being tweened.
        *
        * @method Phaser.TweenManager#isTweening
        * @param {object} object - The object to check for tweens against.
        * @returns {boolean} Returns true if the object is currently being tweened, false if not.
        */
        isTweening(object: any): boolean;

        /**
        * Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.
        * @method Phaser.TweenManager#removeAll
        */
        remove(tween: Phaser.Tween): Phaser.Tween;

        /**
        * Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.
        * @method Phaser.TweenManager#removeAll
        */
        removeAll(): void;

        /**
        * Remove all tweens from a specific object, array of objects or Group.
        * 
        * @method Phaser.TweenManager#removeFrom
        * @param {object|object[]|Phaser.Group} obj - The object you want to remove the tweens from.
        * @param {boolean} [children=true] - If passing a group, setting this to true will remove the tweens from all of its children instead of the group itself.
        */
        removeFrom(obj: any, children?: boolean): void;

        /**
        * Resumes all currently paused tweens.
        *
        * @method Phaser.TweenManager#resumeAll
        */
        resumeAll(): void;

        /**
        * Update all the tween objects you added to this manager.
        *
        * @method Phaser.TweenManager#update
        * @returns {boolean} Return false if there's no tween to update, otherwise return true.
        */
        update(): boolean;

        /**
        * Pauses all currently running tweens.
        *
        * @method Phaser.TweenManager#pauseAll
        */
        pauseAll(): void;

    }
    /**
    * @class Phaser.Utils
    * @static
    */
    class Utils {

        /**
        * This is a slightly modified version of http://api.jquery.com/jQuery.extend/
        * @method Phaser.Utils.extend
        * @param {boolean} deep - Perform a deep copy?
        * @param {object} target - The target object to copy to.
        * @return {object} The extended object.
        */
        static extend(deep: boolean, target: any): any;

        /**
        * Gets an objects property by string.
        *
        * @method Phaser.Utils.getProperty
        * @param {object} obj - The object to traverse.
        * @param {string} prop - The property whose value will be returned.
        * @return {*} the value of the property or null if property isn't found .
        */
        static getProperty(obj: any, prop: string): any;

        /**
        * This is a slightly modified version of jQuery.isPlainObject.
        * A plain object is an object whose internal class property is [object Object].
        * @method Phaser.Utils.isPlainObject
        * @param {object} obj - The object to inspect.
        * @return {boolean} - true if the object is plain, otherwise false.
        */
        static isPlainObject(object: any): boolean;

        /**
        * Mixes the source object into the destination object, returning the newly modified destination object.
        * Based on original code by @mudcube
        *
        * @method Phaser.Utils.mixin
        * @param {object} from - The object to copy (the source object).
        * @param {object} to - The object to copy to (the destination object).
        * @return {object} The modified destination object.
        */
        static mixin(from: any, to: any): any;

        /**
        * Javascript string pad http://www.webtoolkit.info/.
        *
        * @method Phaser.Utils.pad
        * @param {string} str - The target string.
        * @param {number} len - The number of characters to be added.
        * @param {number} pad - The string to pad it out with (defaults to a space).
        * @param {number} [dir=3] The direction dir = 1 (left), 2 (right), 3 (both).
        * @return {string} The padded string
        */
        static pad(str: string, len: number, pad: number, dir?: number): string;

        /**
        * Get a unit dimension from a string.
        *
        * @method Phaser.Utils.parseDimension
        * @param {string|number} size - The size to parse.
        * @param {number} dimension - The window dimension to check.
        * @return {number} The parsed dimension.
        */
        static parseDimension(size: any, dimension: number): number;

        static rotateArray<T>(array: T[], direction: any): T;

        /**
        * Sets an objects property by string.
        *
        * @method Phaser.Utils.setProperty
        * @param {object} obj - The object to traverse
        * @param {string} prop - The property whose value will be changed
        * @return {object} The object on which the property was set.
        */
        static setProperty(obj: any, prop: string, value: any): any;

        static shuffle<T>(array: T[]): T[];

        static transposeArray<T>(array: T[]): T[];

    }
    module Utils {

        /**
        * A collection of methods for displaying debug information about game objects.
        * If your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture
        * to it, which must be uploaded every frame. Be advised: this is very expensive, especially in browsers like Firefox. So please only enable Debug
        * in WebGL mode if you really need it (or your desktop can cope with it well) and disable it for production!
        * If your game is using a Canvas renderer then the debug information is literally drawn on the top of the active game canvas and no Sprite is used.
        *
        * @class Phaser.Utils.Debug
        * @constructor
        * @param {Phaser.Game} game - A reference to the currently running game.
        */
        class Debug {

            constructor(game: Phaser.Game);

            /**
            * @property {Phaser.BitmapData} bmd - In WebGL mode this BitmapData contains a copy of the debug canvas.
            */
            bmd: Phaser.BitmapData;

            /**
            * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.
            */
            canvas: HTMLCanvasElement;

            /**
            * @property {number} columnWidth - The spacing between columns.
            */
            columnWidth: number;

            /**
            * @property {?object} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
            */
            context: CanvasRenderingContext2D;

            /**
            * @property {number} currentAlpha - The current alpha the debug information will be rendered at.
            * @default
            */
            currentAlpha: number;

            /**
            * @property {number} currentX - The current X position the debug information will be rendered at.
            * @default
            */
            currentX: number;

            /**
            * @property {number} currentY - The current Y position the debug information will be rendered at.
            * @default
            */
            currentY: number;

            /**
            * @property {boolean} dirty - Internal PIXI var.
            * @default
            */
            dirty: boolean;

            /**
            * @name Phaser.Text#font
            * @property {string} font - The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.
            */
            font: string;

            /**
            * @property {Phaser.Game} game - A reference to the currently running Game.
            */
            game: Phaser.Game;

            /**
            * @property {number} lineHeight - The line height between the debug text.
            */
            lineHeight: number;

            /**
            * @property {boolean} renderShadow - Should the text be rendered with a slight shadow? Makes it easier to read on different types of background.
            */
            renderShadow: boolean;

            /**
            * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.
            */
            sprite: Phaser.Image;

            AStar(astar: Phaser.Plugin.AStar, x: number, y: number, showVisited: boolean): void;

            /**
            * Internal method that boots the debug displayer.
            *
            * @method Phaser.Utils.Debug#boot
            * @protected
            */
            boot(): void;

            /**
            * Render a Sprites Physics body if it has one set. Note this only works for Arcade and
            * Ninja (AABB, circle only) Physics.
            * To display a P2 body you should enable debug mode on the body when creating it.
            *
            * @method Phaser.Utils.Debug#body
            * @param {Phaser.Sprite} sprite - The sprite whos body will be rendered.
            * @param {string} [color='rgba(0,255,0,0.4)'] - color of the debug info to be rendered. (format is css color string).
            * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)
            */
            body(sprite: Phaser.Sprite, color?: string, filled?: boolean): void;

            /**
            * Render a Sprites Physic Body information.
            *
            * @method Phaser.Utils.Debug#bodyInfo
            * @param {Phaser.Sprite} sprite - The sprite to be rendered.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            bodyInfo(sprite: Phaser.Sprite, x: number, y: Number, color?: string): void;

            /**
            * Renders 'debug draw' data for the given Box2D body.
            * This uses the standard debug drawing feature of Box2D, so colors will be decided by the Box2D engine.
            *
            * @method Phaser.Utils.Debug#box2dBody
            * @param {Phaser.Sprite} sprite - The sprite whos body will be rendered.
            * @param {string} [color='rgb(0,255,0)'] - color of the debug info to be rendered. (format is css color string).
            */
            box2dBody(body: Phaser.Sprite, color?: string): void;

            /**
            * Renders 'debug draw' data for the Box2D world if it exists.
            * This uses the standard debug drawing feature of Box2D, so colors will be decided by
            * the Box2D engine.
            *
            * @method Phaser.Utils.Debug#box2dWorld
            */
            box2dWorld(): void;

            /**
            * Render camera information including dimensions and location.
            *
            * @method Phaser.Utils.Debug#cameraInfo
            * @param {Phaser.Camera} camera - The Phaser.Camera to show the debug information for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            cameraInfo(camera: Phaser.Camera, x: number, y: number, color?: string): void;

            /**
            * Renders a Phaser geometry object including Rectangle, Circle, Point or Line.
            *
            * @method Phaser.Utils.Debug#geom
            * @param {Phaser.Rectangle|Phaser.Circle|Phaser.Point|Phaser.Line} object - The geometry object to render.
            * @param {string} [color] - Color of the debug info to be rendered (format is css color string).
            * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)
            * @param {number} [forceType=0] - Force rendering of a specific type. If 0 no type will be forced, otherwise 1 = Rectangle, 2 = Circle, 3 = Point and 4 = Line.
            */
            geom(object: any, color?: string, fiiled?: boolean, forceType?: number): void;

            /**
            * Render debug information about the Input object.
            *
            * @method Phaser.Utils.Debug#inputInfo
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            inputInfo(x: number, y: number, color?: string): void;

            /**
            * Renders Line information in the given color.
            *
            * @method Phaser.Utils.Debug#lineInfo
            * @param {Phaser.Line} line - The Line to display the data for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            lineInfo(line: Phaser.Line, x: number, y: number, color?: string): void;

            /**
            * Renders Phaser.Key object information.
            *
            * @method Phaser.Utils.Debug#key
            * @param {Phaser.Key} key - The Key to render the information for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            key(key: Phaser.Key, x?: number, y?: number, color?: string): void;

            /**
            * Internal method that outputs a single line of text split over as many columns as needed, one per parameter.
            *
            * @method Phaser.Utils.Debug#line
            * @protected
            */
            line(): void;

            /**
            * Internal method that clears the canvas (if a Sprite) ready for a new debug session.
            *
            * @method Phaser.Utils.Debug#preUpdate
            */
            preUpdate(): void;

            /**
            * Renders a single pixel at the given size.
            *
            * @method Phaser.Utils.Debug#pixel
            * @param {number} x - X position of the pixel to be rendered.
            * @param {number} y - Y position of the pixel to be rendered.
            * @param {string} [color] - Color of the pixel (format is css color string).
            * @param {number} [size=2] - The 'size' to render the pixel at.
            */
            pixel(x: number, y: number, color?: string, size?: number): void;

            /**
            * Renders the Pointer.circle object onto the stage in green if down or red if up along with debug text.
            *
            * @method Phaser.Utils.Debug#pointer
            * @param {Phaser.Pointer} pointer - The Pointer you wish to display.
            * @param {boolean} [hideIfUp=false] - Doesn't render the circle if the pointer is up.
            * @param {string} [downColor='rgba(0,255,0,0.5)'] - The color the circle is rendered in if down.
            * @param {string} [upColor='rgba(255,0,0,0.5)'] - The color the circle is rendered in if up (and hideIfUp is false).
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            pointer(pointer: Phaser.Pointer, hideIfUp?: boolean, downColor?: string, upColor?: string, color?: string): void;

            /**
            * Visually renders a QuadTree to the display.
            *
            * @method Phaser.Utils.Debug#quadTree
            * @param {Phaser.QuadTree} quadtree - The quadtree to render.
            * @param {string} color - The color of the lines in the quadtree.
            */
            quadTree(quadtree: Phaser.QuadTree, color?: string): void;

            rectangle(object: Phaser.Rectangle, color?: string, filled?: boolean): void;

            /**
            * Clears the Debug canvas.
            *
            * @method Phaser.Utils.Debug#reset
            */
            reset(): void;

            /**
            * Renders the Rope's segments. Note: This is really expensive as it has to calculate new segments everytime you call it
            *
            * @method Phaser.Utils.Debug#ropeSegments
            * @param {Phaser.Rope} rope - The rope to display the segments of.
            * @param {string} [color] - Color of the debug info to be rendered (format is css color string).
            * @param {boolean} [filled=true] - Render the rectangle as a fillRect (default, true) or a strokeRect (false)
            */
            ropeSegments(rope: Phaser.Rope, color?: number, filled?: boolean): void;

            /**
            * Render Sound information, including decoded state, duration, volume and more.
            *
            * @method Phaser.Utils.Debug#soundInfo
            * @param {Phaser.Sound} sound - The sound object to debug.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            soundInfo(sound: Phaser.Sound, x: number, y: number, color?: string): void;

            /**
            * Renders the Sprites bounds. Note: This is really expensive as it has to calculate the bounds every time you call it!
            *
            * @method Phaser.Utils.Debug#spriteBounds
            * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the bounds of.
            * @param {string} [color] - Color of the debug info to be rendered (format is css color string).
            * @param {boolean} [filled=true] - Render the rectangle as a fillRect (default, true) or a strokeRect (false)
            */
            spriteBounds(sprite: any, color?: string, filled?: boolean): void;

            /**
            * Renders the sprite coordinates in local, positional and world space.
            *
            * @method Phaser.Utils.Debug#spriteCoords
            * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the coordinates for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            spriteCoords(sprite: any, x: number, y: number, color?: string): void;

            /**
            * Render debug infos (including name, bounds info, position and some other properties) about the Sprite.
            *
            * @method Phaser.Utils.Debug#spriteInfo
            * @param {Phaser.Sprite} sprite - The Sprite to display the information of.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            spriteInfo(sprite: Phaser.Sprite, x: number, y: number, color?: string): void;

            /**
            * Render Sprite Input Debug information.
            *
            * @method Phaser.Utils.Debug#spriteInputInfo
            * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the input data for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            spriteInputInfo(sprite: Phaser.Sprite, x: number, y: number, color?: string): void;

            /**
            * Internal method that resets and starts the debug output values.
            *
            * @method Phaser.Utils.Debug#start
            * @protected
            * @param {number} [x=0] - The X value the debug info will start from.
            * @param {number} [y=0] - The Y value the debug info will start from.
            * @param {string} [color='rgb(255,255,255)'] - The color the debug text will drawn in.
            * @param {number} [columnWidth=0] - The spacing between columns.
            */
            start(x?: number, y?: number, color?: string, columnWidth?: number): void;

            /**
            * Internal method that stops the debug output.
            *
            * @method Phaser.Utils.Debug#stop
            * @protected
            */
            stop(): void;

            /**
            * Render a string of text.
            *
            * @method Phaser.Utils.Debug#text
            * @param {string} text - The line of text to draw.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color] - Color of the debug info to be rendered (format is css color string).
            * @param {string} [font] - The font of text to draw.
            */
            text(text: string, x: number, y: number, color?: string, font?: string): void;

            /**
            * Render Timer information.
            *
            * @method Phaser.Utils.Debug#timer
            * @param {Phaser.Timer} timer - The Phaser.Timer to show the debug information for.
            * @param {number} x - X position of the debug info to be rendered.
            * @param {number} y - Y position of the debug info to be rendered.
            * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).
            */
            timer(timer: Phaser.Timer, x: number, y: number, color?: string): void;

        }
    }
    /**
    * "This world is but a canvas to our imagination." - Henry David Thoreau
    *
    * A game has only one world. The world is an abstract place in which all game objects live. It is not bound
    * by stage limits and can be any size. You look into the world via cameras. All game objects live within
    * the world at world-based coordinates. By default a world is created the same size as your Stage.
    *
    * @class Phaser.World
    * @extends Phaser.Group
    * @constructor
    * @param {Phaser.Game} game - Reference to the current game instance.
    */
    class World extends Phaser.Group {

        constructor(game: Phaser.Game);

        /**
        * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
        * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
        * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world.
        * 
        * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
        */
        bounds: Phaser.Rectangle;

        /**
        * @property {Phaser.Camera} camera - A handy reference to World.camera.
        */
        camera: Phaser.Camera;

        /**
        * The x coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerX
        * @property {number} centerX - The x coordinate of the center of the Rectangle.
        */
        centerX: number;

        /**
        * The y coordinate of the center of the Rectangle.
        * @name Phaser.Rectangle#centerY
        * @property {number} centerY - The y coordinate of the center of the Rectangle.
        */
        centerY: number;

        /**
        * @property {Phaser.Game} game - A reference to the currently running Game.
        */
        game: Phaser.Game;

        /**
        * @property {number} height - The height of the Rectangle. This value should never be set to a negative.
        */
        height: number;

        /**
        * A random value between the left and right values (inclusive) of the Rectangle.
        *
        * @name Phaser.Rectangle#randomX
        * @property {number} randomX - A random value between the left and right values (inclusive) of the Rectangle.
        */
        randomX: number;

        /**
        * A random value between the top and bottom values (inclusive) of the Rectangle.
        *
        * @name Phaser.Rectangle#randomY
        * @property {number} randomY - A random value between the top and bottom values (inclusive) of the Rectangle.
        */
        randomY: number;

        /**
        * @property {number} width - The width of the Rectangle. This value should never be set to a negative.
        */
        width: number;

        /**
        * Initialises the game world.
        *
        * @method Phaser.World#boot
        * @protected
        */
        boot(): void;

        getObjectsUnderPointer(pointer: Phaser.Pointer, group: Phaser.Group, callback?: Function, callbackContext?: any): Phaser.Sprite;

        /**
        * Updates the size of this world. Note that this doesn't modify the world x/y coordinates, just the width and height.
        *
        * @method Phaser.World#resize
        * @param {number} width - New width of the game world in pixels.
        * @param {number} height - New height of the game world in pixels.
        */
        resize(width: number, height: number): void;

        /**
        * Updates the size of this world. Note that this doesn't modify the world x/y coordinates, just the width and height.
        * The Camera bounds and Physics bounds (if set) are also updated to match the new World bounds.
        *
        * @method Phaser.World#setBounds
        * @param {number} x - Top left most corner of the world.
        * @param {number} y - Top left most corner of the world.
        * @param {number} width - New width of the game world in pixels.
        * @param {number} height - New height of the game world in pixels.
        */
        setBounds(x: number, y: number, width: number, height: number): void;

        /**
        * Destroyer of worlds.
        *
        * @method Phaser.World#shutdown
        */
        shutdown(): void;

        /**
        * This will take the given game object and check if its x/y coordinates fall outside of the world bounds.
        * If they do it will reposition the object to the opposite side of the world, creating a wrap-around effect.
        * If sprite has a P2 body then the body (sprite.body) should be passed as first parameter to the function.
        *
        * @method Phaser.World#wrap
        * @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Text} sprite - The object you wish to wrap around the world bounds.
        * @param {number} [padding=0] - Extra padding added equally to the sprite.x and y coordinates before checking if within the world bounds. Ignored if useBounds is true.
        * @param {boolean} [useBounds=false] - If useBounds is false wrap checks the object.x/y coordinates. If true it does a more accurate bounds check, which is more expensive.
        * @param {boolean} [horizontal=true] - If horizontal is false, wrap will not wrap the object.x coordinates horizontally.
        * @param {boolean} [vertical=true] - If vertical is false, wrap will not wrap the object.y coordinates vertically.
        */
        wrap(sprite: any, padding?: number, useBounds?: boolean, horizontal?: boolean, vertical?: boolean): void;

    }
}
// Type definitions for p2.js v0.6.0
// Project: https://github.com/schteppe/p2.js/

declare module p2 {

    export class AABB {
        constructor(options?: {
            upperBound?: number[];
            lowerBound?: number[];
        });
        setFromPoints(points: number[][], position: number[], angle: number, skinSize: number): void;
        copy(aabb: AABB): void;
        extend(aabb: AABB): void;
        overlaps(aabb: AABB): boolean;
    }
    export class Broadphase {
        static AABB: number;
        static BOUNDING_CIRCLE: number;
        static NAIVE: number;
        static SAP: number;
        static boundingRadiusCheck(bodyA: Body, bodyB: Body): boolean;
        static aabbCheck(bodyA: Body, bodyB: Body): boolean;
        static canCollide(bodyA: Body, bodyB: Body): boolean;
        constructor(type: number);
        type: number;
        result: Body[];
        world: World;
        boundingVolumeType: number;
        setWorld(world: World): void;
        getCollisionPairs(world: World): Body[];
        boundingVolumeCheck(bodyA: Body, bodyB: Body): boolean;
    }
    export class GridBroadphase extends Broadphase {
        constructor(options?: {
            xmin?: number;
            xmax?: number;
            ymin?: number;
            ymax?: number;
            nx?: number;
            ny?: number;
        });
        xmin: number;
        xmax: number;
        ymin: number;
        ymax: number;
        nx: number;
        ny: number;
        binsizeX: number;
        binsizeY: number;
    }
    export class NativeBroadphase extends Broadphase {
    }
    export class Narrowphase {
        contactEquations: ContactEquation[];
        frictionEquations: FrictionEquation[];
        enableFriction: boolean;
        slipForce: number;
        frictionCoefficient: number;
        surfaceVelocity: number;
        reuseObjects: boolean;
        resuableContactEquations: any[];
        reusableFrictionEquations: any[];
        restitution: number;
        stiffness: number;
        relaxation: number;
        frictionStiffness: number;
        frictionRelaxation: number;
        enableFrictionReduction: boolean;
        contactSkinSize: number;
        collidedLastStep(bodyA: Body, bodyB: Body): boolean;
        reset(): void;
        createContactEquation(bodyA: Body, bodyB: Body, shapeA: Shape, shapeB: Shape): ContactEquation;
        createFrictionFromContact(c: ContactEquation): FrictionEquation;
    }
    export class SAPBroadphase extends Broadphase {
        axisList: Body[];
        axisIndex: number;
    }
    export class Constraint {
        static DISTANCE: number;
        static GEAR: number;
        static LOCK: number;
        static PRISMATIC: number;
        static REVOLUTE: number;
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
        });
        type: number;
        equeations: Equation[];
        bodyA: Body;
        bodyB: Body;
        collideConnected: boolean;
        update(): void;
        setStiffness(stiffness: number): void;
        setRelaxation(relaxation: number): void;
    }
    export class DistanceConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
            distance?: number;
            localAnchorA?: number[];
            localAnchorB?: number[];
            maxForce?: number;
        });
        localAnchorA: number[];
        localAnchorB: number[];
        distance: number;
        maxForce: number;
        upperLimitEnabled: boolean;
        upperLimit: number;
        lowerLimitEnabled: boolean;
        lowerLimit: number;
        position: number;
        setMaxForce(f: number): void;
        getMaxForce(): number;
    }
    export class GearConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
            angle?: number;
            ratio?: number;
            maxTorque?: number;
        });
        ratio: number;
        angle: number;
        setMaxTorque(torque: number): void;
        getMaxTorque(): number;
    }
    export class LockConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
            localOffsetB?: number[];
            localAngleB?: number;
            maxForce?: number;
        });
        setMaxForce(force: number): void;
        getMaxForce(): number;
    }
    export class PrismaticConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
            maxForce?: number;
            localAnchorA?: number[];
            localAnchorB?: number[];
            localAxisA?: number[];
            disableRotationalLock?: boolean;
            upperLimit?: number;
            lowerLimit?: number;
        });
        localAnchorA: number[];
        localAnchorB: number[];
        localAxisA: number[];
        position: number;
        velocity: number;
        lowerLimitEnabled: boolean;
        upperLimitEnabled: boolean;
        lowerLimit: number;
        upperLimit: number;
        upperLimitEquation: ContactEquation;
        lowerLimitEquation: ContactEquation;
        motorEquation: Equation;
        motorEnabled: boolean;
        motorSpeed: number;
        enableMotor(): void;
        disableMotor(): void;
        setLimits(lower: number, upper: number): void;
    }
    export class RevoluteConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, type: number, options?: {
            collideConnected?: boolean;
            wakeUpBodies?: boolean;
            worldPivot?: number[];
            localPivotA?: number[];
            localPivotB?: number[];
            maxForce?: number;
        });
        pivotA: number[];
        pivotB: number[];
        motorEquation: RotationalVelocityEquation;
        motorEnabled: boolean;
        angle: number;
        lowerLimitEnabled: boolean;
        upperLimitEnabled: boolean;
        lowerLimit: number;
        upperLimit: number;
        upperLimitEquation: ContactEquation;
        lowerLimitEquation: ContactEquation;
        enableMotor(): void;
        disableMotor(): void;
        motorIsEnabled(): boolean;
        setLimits(lower: number, upper: number): void;
        setMotorSpeed(speed: number): void;
        getMotorSpeed(): number;
    }
    export class AngleLockEquation extends Equation {
        constructor(bodyA: Body, bodyB: Body, options?: {
            angle?: number;
            ratio?: number;
        });
        computeGq(): number;
        setRatio(ratio: number): number;
        setMaxTorque(torque: number): number;
    }
    export class ContactEquation extends Equation {
        constructor(bodyA: Body, bodyB: Body);
        contactPointA: number[];
        penetrationVec: number[];
        contactPointB: number[];
        normalA: number[];
        restitution: number;
        firstImpact: boolean;
        shapeA: Shape;
        shapeB: Shape;
        computeB(a: number, b: number, h: number): number;
    }
    export class Equation {
        static DEFAULT_STIFFNESS: number;
        static DEFAULT_RELAXATION: number;
        constructor(bodyA: Body, bodyB: Body, minForce?: number, maxForce?: number);
        minForce: number;
        maxForce: number;
        bodyA: Body;
        bodyB: Body;
        stiffness: number;
        relaxation: number;
        G: number[];
        offset: number;
        a: number;
        b: number;
        epsilon: number;
        timeStep: number;
        needsUpdate: boolean;
        multiplier: number;
        relativeVelocity: number;
        enabled: boolean;
        gmult(G: number[], vi: number[], wi: number[], vj: number[], wj: number[]): number;
        computeB(a: number, b: number, h: number): number;
        computeGq(): number;
        computeGW(): number;
        computeGWlambda(): number;
        computeGiMf(): number;
        computeGiMGt(): number;
        addToWlambda(deltalambda: number): number;
        computeInvC(eps: number): number;
    }
    export class FrictionEquation extends Equation {
        constructor(bodyA: Body, bodyB: Body, slipForce: number);
        contactPointA: number[];
        contactPointB: number[];
        t: number[];
        shapeA: Shape;
        shapeB: Shape;
        frictionCoefficient: number;
        setSlipForce(slipForce: number): number;
        getSlipForce(): number;
        computeB(a: number, b: number, h: number): number;
    }
    export class RotationalLockEquation extends Equation {
        constructor(bodyA: Body, bodyB: Body, options?: {
            angle?: number;
        });
        angle: number;
        computeGq(): number;
    }
    export class RotationalVelocityEquation extends Equation {
        constructor(bodyA: Body, bodyB: Body);
        computeB(a: number, b: number, h: number): number;
    }
    export class EventEmitter {
        on(type: string, listener: Function, context: any): EventEmitter;
        has(type: string, listener: Function): boolean;
        off(type: string, listener: Function): EventEmitter;
        emit(event: any): EventEmitter;
    }
    export class ContactMaterialOptions {
        friction: number;
        restitution: number;
        stiffness: number;
        relaxation: number;
        frictionStiffness: number;
        frictionRelaxation: number;
        surfaceVelocity: number;
    }
    export class ContactMaterial {
        static idCounter: number;
        constructor(materialA: Material, materialB: Material, options?: ContactMaterialOptions);
        id: number;
        materialA: Material;
        materialB: Material;
        friction: number;
        restitution: number;
        stiffness: number;
        relaxation: number;
        frictionStuffness: number;
        frictionRelaxation: number;
        surfaceVelocity: number;
        contactSkinSize: number;
    }
    export class Material {
        static idCounter: number;
        constructor(id: number);
        id: number;
    }
    export class vec2 {
        static crossLength(a: number[], b: number[]): number;
        static crossVZ(out: number[], vec: number[], zcomp: number): number;
        static crossZV(out: number[], zcomp: number, vec: number[]): number;
        static rotate(out: number[], a: number[], angle: number): void;
        static rotate90cw(out: number[], a: number[]): number;
        static centroid(out: number[], a: number[], b: number[], c: number[]): number[];
        static create(): number[];
        static clone(a: number[]): number[];
        static fromValues(x: number, y: number): number[];
        static copy(out: number[], a: number[]): number[];
        static set(out: number[], x: number, y: number): number[];
        static toLocalFrame(out: number[], worldPoint: number[], framePosition: number[], frameAngle: number): void;
        static toGlobalFrame(out: number[], localPoint: number[], framePosition: number[], frameAngle: number): void;
        static add(out: number[], a: number[], b: number[]): number[];
        static subtract(out: number[], a: number[], b: number[]): number[];
        static sub(out: number[], a: number[], b: number[]): number[];
        static multiply(out: number[], a: number[], b: number[]): number[];
        static mul(out: number[], a: number[], b: number[]): number[];
        static divide(out: number[], a: number[], b: number[]): number[];
        static div(out: number[], a: number[], b: number[]): number[];
        static scale(out: number[], a: number[], b: number): number[];
        static distance(a: number[], b: number[]): number;
        static dist(a: number[], b: number[]): number;
        static squaredDistance(a: number[], b: number[]): number;
        static sqrDist(a: number[], b: number[]): number;
        static length(a: number[]): number;
        static len(a: number[]): number;
        static squaredLength(a: number[]): number;
        static sqrLen(a: number[]): number;
        static negate(out: number[], a: number[]): number[];
        static normalize(out: number[], a: number[]): number[];
        static dot(a: number[], b: number[]): number;
        static str(a: number[]): string;
    }
    export class BodyOptions {
        mass: number;
        position: number[];
        velocity: number[];
        angle: number;
        angularVelocity: number;
        force: number[];
        angularForce: number;
        fixedRotation: number;
    }
    export class Body extends EventEmitter {
        sleepyEvent: {
            type: string;
        };
        sleepEvent: {
            type: string;
        };
        wakeUpEvent: {
            type: string;
        };
        static DYNAMIC: number;
        static STATIC: number;
        static KINEMATIC: number;
        static AWAKE: number;
        static SLEEPY: number;
        static SLEEPING: number;
        constructor(options?: BodyOptions);
        id: number;
        world: World;
        shapes: Shape[];
        shapeOffsets: number[][];
        shapeAngles: number[];
        mass: number;
        invMass: number;
        inertia: number;
        invInertia: number;
        invMassSolve: number;
        invInertiaSolve: number;
        fixedRotation: number;
        position: number[];
        interpolatedPosition: number[];
        interpolatedAngle: number;
        previousPosition: number[];
        previousAngle: number;
        velocity: number[];
        vlambda: number[];
        wlambda: number[];
        angle: number;
        angularVelocity: number;
        force: number[];
        angularForce: number;
        damping: number;
        angularDamping: number;
        type: number;
        boundingRadius: number;
        aabb: AABB;
        aabbNeedsUpdate: boolean;
        allowSleep: boolean;
        wantsToSleep: boolean;
        sleepState: number;
        sleepSpeedLimit: number;
        sleepTimeLimit: number;
        gravityScale: number;
        updateSolveMassProperties(): void;
        setDensity(density: number): void;
        getArea(): number;
        getAABB(): AABB;
        updateAABB(): void;
        updateBoundingRadius(): void;
        addShape(shape: Shape, offset?: number[], angle?: number): void;
        removeShape(shape: Shape): boolean;
        updateMassProperties(): void;
        applyForce(force: number[], worldPoint: number[]): void;
        toLocalFrame(out: number[], worldPoint: number[]): void;
        toWorldFrame(out: number[], localPoint: number[]): void;
        fromPolygon(path: number[][], options?: {
            optimalDecomp?: boolean;
            skipSimpleCheck?: boolean;
            removeCollinearPoints?: any; //boolean | number
        }): boolean;
        adjustCenterOfMass(): void;
        setZeroForce(): void;
        resetConstraintVelocity(): void;
        applyDamping(dy: number): void;
        wakeUp(): void;
        sleep(): void;
        sleepTick(time: number, dontSleep: boolean, dt: number): void;
        getVelocityFromPosition(story: number[], dt: number): number[];
        getAngularVelocityFromPosition(timeStep: number): number;
        overlaps(body: Body): boolean;
    }
    export class Spring {
        constructor(bodyA: Body, bodyB: Body, options?: {
            stiffness?: number;
            damping?: number;
            localAnchorA?: number[];
            localAnchorB?: number[];
            worldAnchorA?: number[];
            worldAnchorB?: number[];
        });
        stiffness: number;
        damping: number;
        bodyA: Body;
        bodyB: Body;
        applyForce(): void;
    }
    export class LinearSpring extends Spring {
        localAnchorA: number[];
        localAnchorB: number[];
        restLength: number;
        setWorldAnchorA(worldAnchorA: number[]): void;
        setWorldAnchorB(worldAnchorB: number[]): void;
        getWorldAnchorA(result: number[]): number[];
        getWorldAnchorB(result: number[]): number[];
        applyForce(): void;
    }
    export class RotationalSpring extends Spring {
        constructor(bodyA: Body, bodyB: Body, options?: {
            restAngle?: number;
            stiffness?: number;
            damping?: number;
        });
        restAngle: number;
    }
    export class Capsule extends Shape {
        constructor(length?: number, radius?: number);
        length: number;
        radius: number;
    }
    export class Circle extends Shape {
        constructor(radius: number);
        radius: number;
    }
    export class Convex extends Shape {
        static triangleArea(a: number[], b: number[], c: number[]): number;
        constructor(vertices: number[][], axes: number[]);
        vertices: number[][];
        axes: number[];
        centerOfMass: number[];
        triangles: number[];
        boundingRadius: number;
        projectOntoLocalAxis(localAxis: number[], result: number[]): void;
        projectOntoWorldAxis(localAxis: number[], shapeOffset: number[], shapeAngle: number, result: number[]): void;
        updateCenterOfMass(): void;
    }
    export class Heightfield extends Shape {
        constructor(data: number[], options?: {
            minValue?: number;
            maxValue?: number;
            elementWidth: number;
        });
        data: number[];
        maxValue: number;
        minValue: number;
        elementWidth: number;
    }
    export class Shape {
        static idCounter: number;
        static CIRCLE: number;
        static PARTICLE: number;
        static PLANE: number;
        static CONVEX: number;
        static LINE: number;
        static RECTANGLE: number;
        static CAPSULE: number;
        static HEIGHTFIELD: number;
        constructor(type: number);
        type: number;
        id: number;
        boundingRadius: number;
        collisionGroup: number;
        collisionMask: number;
        material: Material;
        area: number;
        sensor: boolean;
        computeMomentOfInertia(mass: number): number;
        updateBoundingRadius(): number;
        updateArea(): void;
        computeAABB(out: AABB, position: number[], angle: number): void;
    }
    export class Line extends Shape {
        constructor(length?: number);
        length: number;
    }
    export class Particle extends Shape {
    }
    export class Plane extends Shape {
    }
    export class Rectangle extends Shape {
        static sameDimensions(a: Rectangle, b: Rectangle): boolean;
        constructor(width?: number, height?: number);
        width: number;
        height: number;
    }
    export class Solver extends EventEmitter {
        static GS: number;
        static ISLAND: number;
        constructor(options?: {}, type?: number);
        type: number;
        equations: Equation[];
        equationSortFunction: Equation; //Equation | boolean
        solve(dy: number, world: World): void;
        solveIsland(dy: number, island: Island): void;
        sortEquations(): void;
        addEquation(eq: Equation): void;
        addEquations(eqs: Equation[]): void;
        removeEquation(eq: Equation): void;
        removeAllEquations(): void;
    }
    export class GSSolver extends Solver {
        constructor(options?: {
            iterations?: number;
            tolerance?: number;
        });
        iterations: number;
        tolerance: number;
        useZeroRHS: boolean;
        frictionIterations: number;
        usedIterations: number;
        solve(h: number, world: World): void;
    }
    export class OverlapKeeper {
        constructor(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Shape);
        shapeA: Shape;
        shapeB: Shape;
        bodyA: Body;
        bodyB: Body;
        tick(): void;
        setOverlapping(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Body): void;
        bodiesAreOverlapping(bodyA: Body, bodyB: Body): boolean;
        set(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Shape): void;
    }
    export class TupleDictionary {
        data: number[];
        keys: number[];
        getKey(id1: number, id2: number): string;
        getByKey(key: number): number;
        get(i: number, j: number): number;
        set(i: number, j: number, value: number): number;
        reset(): void;
        copy(dict: TupleDictionary): void;
    }
    export class Utils {
        static appendArray<T>(a: Array<T>, b: Array<T>): Array<T>;
        static chanceRoll(chance: number): boolean;
        static defaults(options: any, defaults: any): any;
        static extend(a: any, b: any): void;
        static randomChoice(choice1: any, choice2: any): any;
        static rotateArray(matrix: any[], direction: any): any[];
        static splice<T>(array: Array<T>, index: number, howMany: number): void;
        static shuffle<T>(array: T[]): T[];
        static transposeArray<T>(array: T[]): T[];
    }
    export class Island {
        equations: Equation[];
        bodies: Body[];
        reset(): void;
        getBodies(result: any): Body[];
        wantsToSleep(): boolean;
        sleep(): boolean;
    }
    export class IslandManager extends Solver {
        static getUnvisitedNode(nodes: Node[]): IslandNode; // IslandNode | boolean
        equations: Equation[];
        islands: Island[];
        nodes: IslandNode[];
        visit(node: IslandNode, bds: Body[], eqs: Equation[]): void;
        bfs(root: IslandNode, bds: Body[], eqs: Equation[]): void;
        split(world: World): Island[];
    }
    export class IslandNode {
        constructor(body: Body);
        body: Body;
        neighbors: IslandNode[];
        equations: Equation[];
        visited: boolean;
        reset(): void;
    }
    export class World extends EventEmitter {
        postStepEvent: {
            type: string;
        };
        addBodyEvent: {
            type: string;
        };
        removeBodyEvent: {
            type: string;
        };
        addSpringEvent: {
            type: string;
        };
        impactEvent: {
            type: string;
            bodyA: Body;
            bodyB: Body;
            shapeA: Shape;
            shapeB: Shape;
            contactEquation: ContactEquation;
        };
        postBroadphaseEvent: {
            type: string;
            pairs: Body[];
        };
        beginContactEvent: {
            type: string;
            shapeA: Shape;
            shapeB: Shape;
            bodyA: Body;
            bodyB: Body;
            contactEquations: ContactEquation[];
        };
        endContactEvent: {
            type: string;
            shapeA: Shape;
            shapeB: Shape;
            bodyA: Body;
            bodyB: Body;
        };
        preSolveEvent: {
            type: string;
            contactEquations: ContactEquation[];
            frictionEquations: FrictionEquation[];
        };
        static NO_SLEEPING: number;
        static BODY_SLEEPING: number;
        static ISLAND_SLEEPING: number;
        static integrateBody(body: Body, dy: number): void;
        constructor(options?: {
            solver?: Solver;
            gravity?: number[];
            broadphase?: Broadphase;
            islandSplit?: boolean;
            doProfiling?: boolean;
        });
        springs: Spring[];
        bodies: Body[];
        solver: Solver;
        narrowphase: Narrowphase;
        islandManager: IslandManager;
        gravity: number[];
        frictionGravity: number;
        useWorldGravityAsFrictionGravity: boolean;
        useFrictionGravityOnZeroGravity: boolean;
        doProfiling: boolean;
        lastStepTime: number;
        broadphase: Broadphase;
        constraints: Constraint[];
        defaultMaterial: Material;
        defaultContactMaterial: ContactMaterial;
        lastTimeStep: number;
        applySpringForces: boolean;
        applyDamping: boolean;
        applyGravity: boolean;
        solveConstraints: boolean;
        contactMaterials: ContactMaterial[];
        time: number;
        stepping: boolean;
        islandSplit: boolean;
        emitImpactEvent: boolean;
        sleepMode: number;
        addConstraint(c: Constraint): void;
        addContactMaterial(contactMaterial: ContactMaterial): void;
        removeContactMaterial(cm: ContactMaterial): void;
        getContactMaterial(materialA: Material, materialB: Material): ContactMaterial; // ContactMaterial | boolean
        removeConstraint(c: Constraint): void;
        step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
        runNarrowphase(np: Narrowphase, bi: Body, si: Shape, xi: any[], ai: number, bj: Body, sj: Shape, xj: any[], aj: number, cm: number, glen: number): void;
        addSpring(s: Spring): void;
        removeSpring(s: Spring): void;
        addBody(body: Body): void;
        removeBody(body: Body): void;
        getBodyByID(id: number): Body; //Body | boolean
        disableBodyCollision(bodyA: Body, bodyB: Body): void;
        enableBodyCollision(bodyA: Body, bodyB: Body): void;
        clear(): void;
        clone(): World;
        hitTest(worldPoint: number[], bodies: Body[], precision: number): Body[];
        setGlobalEquationParameters(parameters: {
            relaxation?: number;
            stiffness?: number;
        }): void;
        setGlobalStiffness(stiffness: number): void;
        setGlobalRelaxation(relaxation: number): void;
    }
}

