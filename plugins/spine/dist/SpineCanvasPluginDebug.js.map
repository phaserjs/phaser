{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///D:/wamp/www/phaser/node_modules/eventemitter3/index.js","webpack:///D:/wamp/www/phaser/src/data/DataManager.js","webpack:///D:/wamp/www/phaser/src/data/events/CHANGE_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/REMOVE_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/SET_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/index.js","webpack:///D:/wamp/www/phaser/src/gameobjects/BuildGameObject.js","webpack:///D:/wamp/www/phaser/src/gameobjects/GameObject.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ComputedSize.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Depth.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Flip.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ScrollFactor.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ToJSON.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Transform.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/TransformMatrix.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Visible.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/DESTROY_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/index.js","webpack:///D:/wamp/www/phaser/src/loader/File.js","webpack:///D:/wamp/www/phaser/src/loader/FileTypesManager.js","webpack:///D:/wamp/www/phaser/src/loader/GetURL.js","webpack:///D:/wamp/www/phaser/src/loader/MergeXHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/MultiFile.js","webpack:///D:/wamp/www/phaser/src/loader/XHRLoader.js","webpack:///D:/wamp/www/phaser/src/loader/XHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/const.js","webpack:///D:/wamp/www/phaser/src/loader/events/ADD_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_LOAD_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_PROGRESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/POST_PROCESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/PROGRESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/START_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/index.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/ImageFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/JSONFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/TextFile.js","webpack:///D:/wamp/www/phaser/src/math/Average.js","webpack:///D:/wamp/www/phaser/src/math/Bernstein.js","webpack:///D:/wamp/www/phaser/src/math/Between.js","webpack:///D:/wamp/www/phaser/src/math/CatmullRom.js","webpack:///D:/wamp/www/phaser/src/math/CeilTo.js","webpack:///D:/wamp/www/phaser/src/math/Clamp.js","webpack:///D:/wamp/www/phaser/src/math/DegToRad.js","webpack:///D:/wamp/www/phaser/src/math/Difference.js","webpack:///D:/wamp/www/phaser/src/math/Factorial.js","webpack:///D:/wamp/www/phaser/src/math/FloatBetween.js","webpack:///D:/wamp/www/phaser/src/math/FloorTo.js","webpack:///D:/wamp/www/phaser/src/math/FromPercent.js","webpack:///D:/wamp/www/phaser/src/math/GetSpeed.js","webpack:///D:/wamp/www/phaser/src/math/IsEven.js","webpack:///D:/wamp/www/phaser/src/math/IsEvenStrict.js","webpack:///D:/wamp/www/phaser/src/math/Linear.js","webpack:///D:/wamp/www/phaser/src/math/Matrix3.js","webpack:///D:/wamp/www/phaser/src/math/Matrix4.js","webpack:///D:/wamp/www/phaser/src/math/MaxAdd.js","webpack:///D:/wamp/www/phaser/src/math/MinSub.js","webpack:///D:/wamp/www/phaser/src/math/Percent.js","webpack:///D:/wamp/www/phaser/src/math/Quaternion.js","webpack:///D:/wamp/www/phaser/src/math/RadToDeg.js","webpack:///D:/wamp/www/phaser/src/math/RandomXY.js","webpack:///D:/wamp/www/phaser/src/math/RandomXYZ.js","webpack:///D:/wamp/www/phaser/src/math/RandomXYZW.js","webpack:///D:/wamp/www/phaser/src/math/Rotate.js","webpack:///D:/wamp/www/phaser/src/math/RotateAround.js","webpack:///D:/wamp/www/phaser/src/math/RotateAroundDistance.js","webpack:///D:/wamp/www/phaser/src/math/RotateVec3.js","webpack:///D:/wamp/www/phaser/src/math/RoundAwayFromZero.js","webpack:///D:/wamp/www/phaser/src/math/RoundTo.js","webpack:///D:/wamp/www/phaser/src/math/SinCosTableGenerator.js","webpack:///D:/wamp/www/phaser/src/math/SmoothStep.js","webpack:///D:/wamp/www/phaser/src/math/SmootherStep.js","webpack:///D:/wamp/www/phaser/src/math/ToXY.js","webpack:///D:/wamp/www/phaser/src/math/TransformXY.js","webpack:///D:/wamp/www/phaser/src/math/Vector2.js","webpack:///D:/wamp/www/phaser/src/math/Vector3.js","webpack:///D:/wamp/www/phaser/src/math/Vector4.js","webpack:///D:/wamp/www/phaser/src/math/Within.js","webpack:///D:/wamp/www/phaser/src/math/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/Between.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenPoints.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenPointsY.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenY.js","webpack:///D:/wamp/www/phaser/src/math/angle/CounterClockwise.js","webpack:///D:/wamp/www/phaser/src/math/angle/Normalize.js","webpack:///D:/wamp/www/phaser/src/math/angle/Reverse.js","webpack:///D:/wamp/www/phaser/src/math/angle/RotateTo.js","webpack:///D:/wamp/www/phaser/src/math/angle/ShortestBetween.js","webpack:///D:/wamp/www/phaser/src/math/angle/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/WrapDegrees.js","webpack:///D:/wamp/www/phaser/src/math/angle/index.js","webpack:///D:/wamp/www/phaser/src/math/const.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistanceBetween.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistancePower.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistanceSquared.js","webpack:///D:/wamp/www/phaser/src/math/distance/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/linear/Linear.js","webpack:///D:/wamp/www/phaser/src/math/easing/linear/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/stepped/Stepped.js","webpack:///D:/wamp/www/phaser/src/math/easing/stepped/index.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Ceil.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Equal.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Floor.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/GreaterThan.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/LessThan.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/index.js","webpack:///D:/wamp/www/phaser/src/math/index.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/BezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/CatmullRomInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/CubicBezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/LinearInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/QuadraticBezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/SmoothStepInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/SmootherStepInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/index.js","webpack:///D:/wamp/www/phaser/src/math/pow2/GetPowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/IsSizePowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/IsValuePowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/index.js","webpack:///D:/wamp/www/phaser/src/math/random-data-generator/RandomDataGenerator.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapCeil.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapFloor.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapTo.js","webpack:///D:/wamp/www/phaser/src/math/snap/index.js","webpack:///D:/wamp/www/phaser/src/plugins/BasePlugin.js","webpack:///D:/wamp/www/phaser/src/plugins/ScenePlugin.js","webpack:///D:/wamp/www/phaser/src/renderer/BlendModes.js","webpack:///D:/wamp/www/phaser/src/renderer/ScaleModes.js","webpack:///D:/wamp/www/phaser/src/scale/events/RESIZE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/BOOT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/CREATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/DESTROY_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/PAUSE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/POST_UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/PRE_UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/READY_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/RENDER_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/RESUME_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/SHUTDOWN_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/SLEEP_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/START_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_INIT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_OUT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_START_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/WAKE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/index.js","webpack:///D:/wamp/www/phaser/src/utils/Class.js","webpack:///D:/wamp/www/phaser/src/utils/NOOP.js","webpack:///D:/wamp/www/phaser/src/utils/object/Extend.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetAdvancedValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetFastValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/IsPlainObject.js","webpack:///./SpineFile.js","webpack:///./SpinePlugin.js","webpack:///./events/COMPLETE_EVENT.js","webpack:///./events/DISPOSE_EVENT.js","webpack:///./events/END_EVENT.js","webpack:///./events/EVENT_EVENT.js","webpack:///./events/INTERRUPTED_EVENT.js","webpack:///./events/START_EVENT.js","webpack:///./events/index.js","webpack:///./gameobject/SpineGameObject.js","webpack:///./gameobject/SpineGameObjectCanvasRenderer.js","webpack:///./gameobject/SpineGameObjectRender.js","webpack:///./runtimes/spine-canvas.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,OAAO;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE,uEAAuE;AACvE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,aAAa,mBAAO,CAAC,mDAAU;;AAE/B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAA2D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,qBAAqB,mBAAO,CAAC,kFAAyB;AACtD,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,cAAc,mBAAO,CAAC,oEAAkB;;AAExC;;;;;;;;;;;;ACjBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,mEAAwB;AACjD,uBAAuB,mBAAO,CAAC,uFAAkC;AACjE,iBAAiB,mBAAO,CAAC,mEAAwB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,8BAA8B;AACzC,WAAW,0CAA0C;AACrD;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,WAAW,KAAK,SAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB,KAAK,gBAAgB;;AAExD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,cAAc,KAAK,UAAU;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9HA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,uBAAuB,mBAAO,CAAC,0EAAqB;AACpD,kBAAkB,mBAAO,CAAC,6DAAqB;AAC/C,mBAAmB,mBAAO,CAAC,mEAAe;AAC1C,aAAa,mBAAO,CAAC,0DAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAA2D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D,eAAe,mCAAmC;AAClD,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9IA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACtFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC7JA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,sBAAsB,mBAAO,CAAC,iFAAmB;AACjD,gBAAgB,mBAAO,CAAC,8DAAuB;AAC/C,uBAAuB,mBAAO,CAAC,4EAA8B;;AAE7D;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oCAAoC;AACtE,mCAAmC,sCAAsC;;AAEzE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;;AAE3E;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E,yCAAyC,sCAAsC;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/gBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,cAAc,mBAAO,CAAC,wDAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;;AAEvC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,+CAA+C;AAC9D;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA,kCAAkC,UAAU,cAAc;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,mCAAmC,wBAAwB;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACj8BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,kBAAkB,UAAU,mBAAO,CAAC,yEAAiB;;;;;;;;;;;;ACVrD;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,YAAY,mBAAO,CAAC,6CAAS;AAC7B,aAAa,mBAAO,CAAC,qDAAU;AAC/B,mBAAmB,mBAAO,CAAC,+EAA8B;AACzD,aAAa,mBAAO,CAAC,+CAAU;AAC/B,uBAAuB,mBAAO,CAAC,mEAAoB;AACnD,gBAAgB,mBAAO,CAAC,qDAAa;AACrC,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,+BAA+B;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,4GAA4G;AAC5G;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACthBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,mEAAwB;AAC7C,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,sCAAsC;AACjD;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC3LA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,mEAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,sCAAsC;AACjD;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD,8BAA8B,cAAc;AAC5C,6BAA6B,WAAW;AACxC,iCAAiC,eAAe;AAChD,gCAAgC,aAAa;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjJA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,2BAA2B;AACtC,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,uDAAuD;AACjJ;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oFAAoF,mDAAmD;AACvI;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;AC/CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,4DAAa;AAC9B,cAAc,mBAAO,CAAC,sEAAkB;AACxC,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,uBAAuB,mBAAO,CAAC,wFAA2B;AAC1D,qBAAqB,mBAAO,CAAC,oFAAyB;AACtD,eAAe,mBAAO,CAAC,wEAAmB;AAC1C,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,8EAAsB;AAChD,cAAc,mBAAO,CAAC,sEAAkB;AACxC,WAAW,mBAAO,CAAC,gEAAe;;AAElC;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,uDAAuD;AAClE,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD,WAAW,+CAA+C;AAC1D;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uGAAuG;AAClH,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC3QA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,eAAe,mBAAO,CAAC,0EAA6B;AACpD,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC/NA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACxKA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,mDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1kBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;;;;;;;;;;;;AC/6CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,eAAe;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,cAAc,mBAAO,CAAC,+CAAW;AACjC,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC7vBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,+BAA+B,YAAY;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,qDAAiB;AACvC,cAAc,mBAAO,CAAC,qDAAiB;AACvC,iBAAiB,mBAAO,CAAC,2DAAoB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,+BAA+B,YAAY;AAC3C,kCAAkC,eAAe;;AAEjD;;AAEA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,4BAA4B,qBAAqB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,+CAA+C;AAC1D;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA,+BAA+B,wBAAwB;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;;AAEzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,6BAA6B,YAAY;;AAEzC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACxnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACnyBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1hBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,4CAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,yDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,4CAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AC1CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,eAAe,mBAAO,CAAC,0CAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,0CAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,qDAAW;AAChC,mBAAmB,mBAAO,CAAC,iEAAiB;AAC5C,oBAAoB,mBAAO,CAAC,mEAAkB;AAC9C,cAAc,mBAAO,CAAC,uDAAY;AAClC,sBAAsB,mBAAO,CAAC,uEAAoB;AAClD,eAAe,mBAAO,CAAC,yDAAa;AACpC,aAAa,mBAAO,CAAC,qDAAW;AAChC,cAAc,mBAAO,CAAC,uDAAY;AAClC,qBAAqB,mBAAO,CAAC,qEAAmB;AAChD,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,iBAAiB,mBAAO,CAAC,6DAAe;;AAExC;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,SAAS;;AAErC;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,wEAAmB;AACxC,WAAW,mBAAO,CAAC,oEAAiB;AACpC,aAAa,mBAAO,CAAC,wEAAmB;;AAExC;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,mDAAM;AACtB,SAAS,mBAAO,CAAC,qDAAO;AACxB,WAAW,mBAAO,CAAC,yDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,qDAAM;AACtB,SAAS,mBAAO,CAAC,uDAAO;AACxB,WAAW,mBAAO,CAAC,2DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,kDAAM;AACtB,SAAS,mBAAO,CAAC,oDAAO;AACxB,WAAW,mBAAO,CAAC,wDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,cAAc,mBAAO,CAAC,8DAAY;AAClC,WAAW,mBAAO,CAAC,wDAAS;AAC5B,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,eAAe,mBAAO,CAAC,gEAAa;AACpC,aAAa,mBAAO,CAAC,4DAAW;AAChC,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,aAAa,mBAAO,CAAC,4DAAW;;AAEhC;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2DAAU;;;;;;;;;;;;ACVnC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,sDAAM;AACtB,SAAS,mBAAO,CAAC,wDAAO;AACxB,WAAW,mBAAO,CAAC,4DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,8DAAW;;;;;;;;;;;;ACVpC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,iBAAiB,mBAAO,CAAC,6DAAe;AACxC,cAAc,mBAAO,CAAC,uDAAY;;AAElC;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;AAC7B,aAAa,mBAAO,CAAC,mEAAwB;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,kDAAU;AAC7B,cAAc,mBAAO,CAAC,wDAAa;AACnC,YAAY,mBAAO,CAAC,oDAAW;AAC/B,WAAW,mBAAO,CAAC,kDAAU;AAC7B,mBAAmB,mBAAO,CAAC,kEAAkB;AAC7C,UAAU,mBAAO,CAAC,gDAAS;AAC3B,UAAU,mBAAO,CAAC,gDAAS;;AAE3B;AACA,yBAAyB,mBAAO,CAAC,mHAA6C;;AAE9E;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,eAAe,mBAAO,CAAC,mDAAa;AACpC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,WAAW,mBAAO,CAAC,2CAAS;AAC5B,cAAc,mBAAO,CAAC,iDAAY;AAClC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,eAAe,mBAAO,CAAC,mDAAa;AACpC,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,aAAa,mBAAO,CAAC,+CAAW;AAChC,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,cAAc,mBAAO,CAAC,iDAAY;AAClC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,aAAa,mBAAO,CAAC,+CAAW;AAChC,cAAc,mBAAO,CAAC,iDAAY;AAClC,cAAc,mBAAO,CAAC,iDAAY;AAClC,eAAe,mBAAO,CAAC,mDAAa;AACpC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,uBAAuB,mBAAO,CAAC,mEAAqB;AACpD,aAAa,mBAAO,CAAC,+CAAW;AAChC,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,UAAU,mBAAO,CAAC,yCAAQ;AAC1B,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,UAAU,mBAAO,CAAC,yCAAQ;;AAE1B;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,gBAAgB,mBAAO,CAAC,qDAAc;;AAEtC;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,oDAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,8CAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,0DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,iBAAiB,mBAAO,CAAC,+FAA4B;AACrD,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,qBAAqB,mBAAO,CAAC,uGAAgC;AAC7D,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,kBAAkB,mBAAO,CAAC,iGAA6B;;AAEvD;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,gEAAiB;AACtC,YAAY,mBAAO,CAAC,sEAAoB;AACxC,aAAa,mBAAO,CAAC,wEAAqB;;AAE1C;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC,qDAAqD;;AAEvF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;AAEA,kDAAkD;AAClD,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC5eA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAY;AAC9B,WAAW,mBAAO,CAAC,wDAAa;AAChC,QAAQ,mBAAO,CAAC,kDAAU;;AAE1B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC9KA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,iBAAiB,mBAAO,CAAC,wDAAc;AACvC,YAAY,mBAAO,CAAC,mDAAgB;AACpC,kBAAkB,mBAAO,CAAC,2DAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4EAA4E;AACvF;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C;AACpF;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,sDAAsD;AAClI;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,6DAAc;AAChC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,aAAa,mBAAO,CAAC,mEAAiB;AACtC,WAAW,mBAAO,CAAC,+DAAe;AAClC,iBAAiB,mBAAO,CAAC,2EAAqB;AAC9C,gBAAgB,mBAAO,CAAC,yEAAoB;AAC5C,WAAW,mBAAO,CAAC,+DAAe;AAClC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,cAAc,mBAAO,CAAC,qEAAkB;AACxC,WAAW,mBAAO,CAAC,+DAAe;AAClC,WAAW,mBAAO,CAAC,+DAAe;AAClC,yBAAyB,mBAAO,CAAC,2FAA6B;AAC9D,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,oBAAoB,mBAAO,CAAC,iFAAwB;AACpD,sBAAsB,mBAAO,CAAC,qFAA0B;AACxD,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,YAAY,mBAAO,CAAC,iEAAgB;AACpC,UAAU,mBAAO,CAAC,6DAAc;;AAEhC;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,oBAAoB,mBAAO,CAAC,mEAAiB;;AAE7C,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5FA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,8CAAY;AAC/B,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,8CAA8C,aAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,mBAAmB,mBAAO,CAAC,yFAAwC;AACnE,gBAAgB,mBAAO,CAAC,8FAA4C;AACpE,oBAAoB,mBAAO,CAAC,2FAAyC;AACrE,eAAe,mBAAO,CAAC,4FAA2C;AAClE,gBAAgB,mBAAO,CAAC,0EAAkC;AAC1D,eAAe,mBAAO,CAAC,4FAA2C;;AAElE;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,mEAAmE;;AAEzG;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACtPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,sBAAsB,mBAAO,CAAC,6FAA0C;AACxE,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,eAAe,mBAAO,CAAC,iFAAoC;AAC3D,kBAAkB,mBAAO,CAAC,yFAAwC;AAClE,kBAAkB,mBAAO,CAAC,6EAAkC;AAC5D,YAAY,mBAAO,CAAC,yCAAO;AAC3B,gBAAgB,mBAAO,CAAC,mCAAa;AACrC,sBAAsB,mBAAO,CAAC,qEAA8B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qGAAqG;AACpH,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,eAAe,sCAAsC;AACrD,eAAe,sCAAsC;AACrD;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,QAAQ;AACvB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,mCAAmC,aAAa;;AAEhD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,WAAW;AAC1B;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACnmCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,mBAAO,CAAC,oDAAkB;AACxC,aAAa,mBAAO,CAAC,kDAAiB;AACtC,SAAS,mBAAO,CAAC,0CAAa;AAC9B,WAAW,mBAAO,CAAC,8CAAe;AAClC,iBAAiB,mBAAO,CAAC,0DAAqB;AAC9C,WAAW,mBAAO,CAAC,8CAAe;;AAElC;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,8EAAoC;AAC/D,YAAY,mBAAO,CAAC,8DAA4B;AAChD,YAAY,mBAAO,CAAC,gEAA6B;AACjD,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,sBAAsB,mBAAO,CAAC,kGAA8C;AAC5E,qBAAqB,mBAAO,CAAC,gGAA6C;AAC1E,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,0BAA0B,mBAAO,CAAC,0GAAkD;AACpF,wBAAwB,mBAAO,CAAC,sGAAgD;AAChF,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,iBAAiB,mBAAO,CAAC,sFAAwC;AACjE,eAAe,mBAAO,CAAC,oEAA+B;AACtD,kBAAkB,mBAAO,CAAC,qCAAY;AACtC,4BAA4B,mBAAO,CAAC,sEAAyB;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA,kCAAkC,6BAA6B;AAC/D,mCAAmC,+BAA+B;AAClE,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,uCAAuC,gBAAgB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,4CAA4C,yBAAyB;;AAErE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,qCAAqC,cAAc;AACnD,qCAAqC,gBAAgB;;AAErD;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACnjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,WAAW,mBAAO,CAAC,4DAA2B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5HA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,kBAAkB,mBAAO,CAAC,8DAA4B;AACtD,mBAAmB,mBAAO,CAAC,8DAA4B;;AAEvD,IAAI,KAAqB;AACzB,EAEC;;AAED,IAAI,IAAsB;AAC1B;AACA,mBAAmB,mBAAO,CAAC,sFAAiC;AAC5D;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;;AAEA;AACA;AACA,IAAI,gBAAgB,sCAAsC,iBAAiB,EAAE;AAC7E,mBAAmB,uDAAuD;AAC1E;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,mDAAmD;AACrD;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6CAA6C;AACtD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA,EAAE,yDAAyD;AAC3D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,4DAA4D;AAC5D,+CAA+C;AAC/C;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAqE;AACvE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,+CAA+C,8CAA8C,EAAE;AAC/F;AACA;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE,+DAA+D;AAC/D,kDAAkD;AAClD;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;;AAEA;AACA;AACA,CAAC,e","file":"SpineCanvasPluginDebug.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./SpinePlugin.js\");\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @callback DataEachCallback\r\n *\r\n * @param {*} parent - The parent object of the DataManager.\r\n * @param {string} key - The key of the value.\r\n * @param {*} value - The value.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The Data Manager Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManager\r\n * @memberof Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} parent - The object that this DataManager belongs to.\r\n * @param {Phaser.Events.EventEmitter} eventEmitter - The DataManager's event emitter.\r\n */\r\nvar DataManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function DataManager (parent, eventEmitter)\r\n    {\r\n        /**\r\n         * The object that this DataManager belongs to.\r\n         *\r\n         * @name Phaser.Data.DataManager#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * The DataManager's event emitter.\r\n         *\r\n         * @name Phaser.Data.DataManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = eventEmitter;\r\n\r\n        if (!eventEmitter)\r\n        {\r\n            this.events = (parent.events) ? parent.events : parent;\r\n        }\r\n\r\n        /**\r\n         * The data list.\r\n         *\r\n         * @name Phaser.Data.DataManager#list\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = {};\r\n\r\n        /**\r\n         * The public values list. You can use this to access anything you have stored\r\n         * in this Data Manager. For example, if you set a value called `gold` you can\r\n         * access it via:\r\n         *\r\n         * ```javascript\r\n         * this.data.values.gold;\r\n         * ```\r\n         *\r\n         * You can also modify it directly:\r\n         * \r\n         * ```javascript\r\n         * this.data.values.gold += 1000;\r\n         * ```\r\n         *\r\n         * Doing so will emit a `setdata` event from the parent of this Data Manager.\r\n         * \r\n         * Do not modify this object directly. Adding properties directly to this object will not\r\n         * emit any events. Always use `DataManager.set` to create new items the first time around.\r\n         *\r\n         * @name Phaser.Data.DataManager#values\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.10.0\r\n         */\r\n        this.values = {};\r\n\r\n        /**\r\n         * Whether setting data is frozen for this DataManager.\r\n         *\r\n         * @name Phaser.Data.DataManager#_frozen\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._frozen = false;\r\n\r\n        if (!parent.hasOwnProperty('sys') && this.events)\r\n        {\r\n            this.events.once('destroy', this.destroy, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     * \r\n     * ```javascript\r\n     * this.data.get('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     * \r\n     * ```javascript\r\n     * this.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     * \r\n     * ```javascript\r\n     * this.data.get([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.Data.DataManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    get: function (key)\r\n    {\r\n        var list = this.list;\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            var output = [];\r\n\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                output.push(list[key[i]]);\r\n            }\r\n\r\n            return output;\r\n        }\r\n        else\r\n        {\r\n            return list[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves all data values in a new object.\r\n     *\r\n     * @method Phaser.Data.DataManager#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Object.<string, *>} All data values.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Queries the DataManager for the values of keys matching the given regular expression.\r\n     *\r\n     * @method Phaser.Data.DataManager#query\r\n     * @since 3.0.0\r\n     *\r\n     * @param {RegExp} search - A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).\r\n     *\r\n     * @return {Object.<string, *>} The values of the keys matching the search string.\r\n     */\r\n    query: function (search)\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key) && key.match(search))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.\r\n     * \r\n     * ```javascript\r\n     * data.set('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `get`:\r\n     * \r\n     * ```javascript\r\n     * data.get('gold');\r\n     * ```\r\n     * \r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     * \r\n     * ```javascript\r\n     * data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#set\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    set: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            return this.setValue(key, data);\r\n        }\r\n        else\r\n        {\r\n            for (var entry in key)\r\n            {\r\n                this.setValue(entry, key[entry]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value setter, called automatically by the `set` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#setValue\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     * @param {*} data - The value to set.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setValue: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.has(key))\r\n        {\r\n            //  Hit the key getter, which will in turn emit the events.\r\n            this.values[key] = data;\r\n        }\r\n        else\r\n        {\r\n            var _this = this;\r\n            var list = this.list;\r\n            var events = this.events;\r\n            var parent = this.parent;\r\n\r\n            Object.defineProperty(this.values, key, {\r\n\r\n                enumerable: true,\r\n                \r\n                configurable: true,\r\n\r\n                get: function ()\r\n                {\r\n                    return list[key];\r\n                },\r\n\r\n                set: function (value)\r\n                {\r\n                    if (!_this._frozen)\r\n                    {\r\n                        var previousValue = list[key];\r\n                        list[key] = value;\r\n\r\n                        events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);\r\n                        events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            list[key] = data;\r\n\r\n            events.emit(Events.SET_DATA, parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all data entries to the given callback.\r\n     *\r\n     * @method Phaser.Data.DataManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {DataEachCallback} callback - The function to call.\r\n     * @param {*} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ this.parent, null, undefined ];\r\n\r\n        for (var i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (var key in this.list)\r\n        {\r\n            args[1] = key;\r\n            args[2] = this.list[key];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Merge the given object of key value pairs into this DataManager.\r\n     *\r\n     * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)\r\n     * will emit a `changedata` event.\r\n     *\r\n     * @method Phaser.Data.DataManager#merge\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Object.<string, *>} data - The data to merge.\r\n     * @param {boolean} [overwrite=true] - Whether to overwrite existing data. Defaults to true.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    merge: function (data, overwrite)\r\n    {\r\n        if (overwrite === undefined) { overwrite = true; }\r\n\r\n        //  Merge data from another component into this one\r\n        for (var key in data)\r\n        {\r\n            if (data.hasOwnProperty(key) && (overwrite || (!overwrite && !this.has(key))))\r\n            {\r\n                this.setValue(key, data[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Remove the value for the given key.\r\n     *\r\n     * If the key is found in this Data Manager it is removed from the internal lists and a\r\n     * `removedata` event is emitted.\r\n     * \r\n     * You can also pass in an array of keys, in which case all keys in the array will be removed:\r\n     * \r\n     * ```javascript\r\n     * this.data.remove([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * @method Phaser.Data.DataManager#remove\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key to remove, or an array of keys to remove.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                this.removeValue(key[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return this.removeValue(key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value remover, called automatically by the `remove` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#removeValue\r\n     * @private\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    removeValue: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            var data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.\r\n     *\r\n     * @method Phaser.Data.DataManager#pop\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the value to retrieve and delete.\r\n     *\r\n     * @return {*} The value of the given key.\r\n     */\r\n    pop: function (key)\r\n    {\r\n        var data = undefined;\r\n\r\n        if (!this._frozen && this.has(key))\r\n        {\r\n            data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Determines whether the given key is set in this Data Manager.\r\n     * \r\n     * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check.\r\n     *\r\n     * @return {boolean} Returns `true` if the key exists, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return this.list.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts\r\n     * to create new values or update existing ones.\r\n     *\r\n     * @method Phaser.Data.DataManager#setFreeze\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Whether to freeze or unfreeze the Data Manager.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setFreeze: function (value)\r\n    {\r\n        this._frozen = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all data in this Data Manager and unfreeze it.\r\n     *\r\n     * @method Phaser.Data.DataManager#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    reset: function ()\r\n    {\r\n        for (var key in this.list)\r\n        {\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n        }\r\n\r\n        this._frozen = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy this data manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.events.off(Events.CHANGE_DATA);\r\n        this.events.off(Events.SET_DATA);\r\n        this.events.off(Events.REMOVE_DATA);\r\n\r\n        this.parent = null;\r\n    },\r\n\r\n    /**\r\n     * Gets or sets the frozen state of this Data Manager.\r\n     * A frozen Data Manager will block all attempts to create new values or update existing ones.\r\n     *\r\n     * @name Phaser.Data.DataManager#freeze\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    freeze: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._frozen;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._frozen = (value) ? true : false;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Return the total number of entries in this Data Manager.\r\n     *\r\n     * @name Phaser.Data.DataManager#count\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    count: {\r\n\r\n        get: function ()\r\n        {\r\n            var i = 0;\r\n\r\n            for (var key in this.list)\r\n            {\r\n                if (this.list[key] !== undefined)\r\n                {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            return i;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DataManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Change Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item in the data store is changed.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * a change data event from a Game Object you would use: `sprite.data.on('changedata', listener)`.\r\n * \r\n * This event is dispatched for all items that change in the Data Manager.\r\n * To listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.\r\n *\r\n * @event Phaser.Data.Events#CHANGE_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that the Data Manager responsible for this event belongs to.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} value - The new value of the item in the Data Manager.\r\n * @param {any} previousValue - The previous value of the item in the Data Manager.\r\n */\r\nmodule.exports = 'changedata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Change Data Key Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item in the data store is changed.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the change of a specific data item from a Game Object you would use: `sprite.data.on('changedata-key', listener)`,\r\n * where `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`\r\n * then you can listen for `sprite.data.on('changedata-gold')`.\r\n *\r\n * @event Phaser.Data.Events#CHANGE_DATA_KEY\r\n * @since 3.16.1\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} value - The item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n * @param {any} previousValue - The previous item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'changedata-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Remove Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item is removed from it.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the removal of a data item on a Game Object you would use: `sprite.data.on('removedata', listener)`.\r\n *\r\n * @event Phaser.Data.Events#REMOVE_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} data - The item that was removed from the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'removedata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Set Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when a new item is added to the data store.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the addition of a new data item on a Game Object you would use: `sprite.data.on('setdata', listener)`.\r\n *\r\n * @event Phaser.Data.Events#SET_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} data - The item that was added to the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'setdata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Data.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CHANGE_DATA: require('./CHANGE_DATA_EVENT'),\r\n    CHANGE_DATA_KEY: require('./CHANGE_DATA_KEY_EVENT'),\r\n    REMOVE_DATA: require('./REMOVE_DATA_EVENT'),\r\n    SET_DATA: require('./SET_DATA_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../renderer/BlendModes');\r\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\r\nvar ScaleModes = require('../renderer/ScaleModes');\r\n\r\n/**\r\n * Builds a Game Object using the provided configuration object.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The initial GameObject.\r\n * @param {Phaser.Types.GameObjects.GameObjectConfig} config - The config to build the GameObject with.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\r\n */\r\nvar BuildGameObject = function (scene, gameObject, config)\r\n{\r\n    //  Position\r\n\r\n    gameObject.x = GetAdvancedValue(config, 'x', 0);\r\n    gameObject.y = GetAdvancedValue(config, 'y', 0);\r\n    gameObject.depth = GetAdvancedValue(config, 'depth', 0);\r\n\r\n    //  Flip\r\n\r\n    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);\r\n    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);\r\n\r\n    //  Scale\r\n    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\r\n\r\n    var scale = GetAdvancedValue(config, 'scale', null);\r\n\r\n    if (typeof scale === 'number')\r\n    {\r\n        gameObject.setScale(scale);\r\n    }\r\n    else if (scale !== null)\r\n    {\r\n        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);\r\n        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);\r\n    }\r\n\r\n    //  ScrollFactor\r\n    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\r\n\r\n    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);\r\n\r\n    if (typeof scrollFactor === 'number')\r\n    {\r\n        gameObject.setScrollFactor(scrollFactor);\r\n    }\r\n    else if (scrollFactor !== null)\r\n    {\r\n        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);\r\n        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);\r\n    }\r\n\r\n    //  Rotation\r\n\r\n    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);\r\n\r\n    var angle = GetAdvancedValue(config, 'angle', null);\r\n\r\n    if (angle !== null)\r\n    {\r\n        gameObject.angle = angle;\r\n    }\r\n\r\n    //  Alpha\r\n\r\n    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);\r\n\r\n    //  Origin\r\n    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\r\n\r\n    var origin = GetAdvancedValue(config, 'origin', null);\r\n\r\n    if (typeof origin === 'number')\r\n    {\r\n        gameObject.setOrigin(origin);\r\n    }\r\n    else if (origin !== null)\r\n    {\r\n        var ox = GetAdvancedValue(origin, 'x', 0.5);\r\n        var oy = GetAdvancedValue(origin, 'y', 0.5);\r\n\r\n        gameObject.setOrigin(ox, oy);\r\n    }\r\n\r\n    //  ScaleMode\r\n\r\n    gameObject.scaleMode = GetAdvancedValue(config, 'scaleMode', ScaleModes.DEFAULT);\r\n\r\n    //  BlendMode\r\n\r\n    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);\r\n\r\n    //  Visible\r\n\r\n    gameObject.visible = GetAdvancedValue(config, 'visible', true);\r\n\r\n    //  Add to Scene\r\n\r\n    var add = GetAdvancedValue(config, 'add', true);\r\n\r\n    if (add)\r\n    {\r\n        scene.sys.displayList.add(gameObject);\r\n    }\r\n\r\n    if (gameObject.preUpdate)\r\n    {\r\n        scene.sys.updateList.add(gameObject);\r\n    }\r\n\r\n    return gameObject;\r\n};\r\n\r\nmodule.exports = BuildGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ComponentsToJSON = require('./components/ToJSON');\r\nvar DataManager = require('../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\r\nvar GameObject = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GameObject (scene, type)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Game Object belongs.\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         * \r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         * \r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could move from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#state\r\n         * @type {(integer|string)}\r\n         * @since 3.16.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {integer}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     * \r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     * \r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(integer|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function (shape, callback, dropZone)\r\n    {\r\n        this.scene.sys.input.enable(this, shape, callback, dropZone);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will disable it.\r\n     *\r\n     * An object that is disabled for input stops processing or being considered for\r\n     * input events, but can be turned back on again at any time by simply calling\r\n     * `setInteractive()` with no arguments provided.\r\n     *\r\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#disableInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        if (this.input)\r\n        {\r\n            this.input.enabled = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will queue it\r\n     * for removal, causing it to no longer be interactive. The removal happens on\r\n     * the next game step, it is not immediate.\r\n     *\r\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n     * removed from the Input Manager and cleared from this Game Object.\r\n     *\r\n     * If you wish to re-enable this Game Object at a later date you will need to\r\n     * re-create its InteractiveObject by calling `setInteractive` again.\r\n     *\r\n     * If you wish to only temporarily stop an object from receiving input then use\r\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n     * this erases it completely.\r\n     * \r\n     * If you wish to resize a hit area, don't remove and then set it as being\r\n     * interactive. Instead, access the hitarea object directly and resize the shape\r\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n     * shape is a Rectangle, which it is by default.)\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        this.scene.sys.input.clear(this);\r\n\r\n        this.input = undefined;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            // indexes.unshift([parent.getIndex(child), parent.name]);\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\r\n        indexes.unshift(this.scene.sys.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\r\n     */\r\n    destroy: function (fromScene)\r\n    {\r\n        if (fromScene === undefined) { fromScene = false; }\r\n\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.preDestroy)\r\n        {\r\n            this.preDestroy.call(this);\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        var sys = this.scene.sys;\r\n\r\n        if (!fromScene)\r\n        {\r\n            sys.displayList.remove(this);\r\n            sys.updateList.remove(this);\r\n        }\r\n\r\n        if (this.input)\r\n        {\r\n            sys.input.clear(this);\r\n            this.input = undefined;\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        if (this.body)\r\n        {\r\n            this.body.destroy();\r\n            this.body = undefined;\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        if (!fromScene)\r\n        {\r\n            sys.queueDepthSort();\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.scene = undefined;\r\n\r\n        this.parentContainer = undefined;\r\n\r\n        this.removeAllListeners();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\r\nGameObject.RENDER_MASK = 15;\r\n\r\nmodule.exports = GameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for calculating and setting the size of a non-Frame based Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.ComputedSize\r\n * @since 3.0.0\r\n */\r\n\r\nvar ComputedSize = {\r\n\r\n    /**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayWidth` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    width: 0,\r\n\r\n    /**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayHeight` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    height: 0,\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     * \r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     * \r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setSize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Game Object.\r\n     * \r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ComputedSize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the depth of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Depth\r\n * @since 3.0.0\r\n */\r\n\r\nvar Depth = {\r\n\r\n    /**\r\n     * Private internal value. Holds the depth of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#_depth\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _depth: 0,\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#depth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    depth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._depth;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scene.sys.queueDepthSort();\r\n            this._depth = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Depth#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} value - The depth of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDepth: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.depth = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Depth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for visually flipping a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Flip\r\n * @since 3.0.0\r\n */\r\n\r\nvar Flip = {\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipX: false,\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipY: false,\r\n\r\n    /**\r\n     * Toggles the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipX: function ()\r\n    {\r\n        this.flipX = !this.flipX;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipY: function ()\r\n    {\r\n        this.flipY = !this.flipY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped will render inversed on the flipped axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Flip;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.ScrollFactor\r\n * @since 3.0.0\r\n */\r\n\r\nvar ScrollFactor = {\r\n\r\n    /**\r\n     * The horizontal scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorX: 1,\r\n\r\n    /**\r\n     * The vertical scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorY: 1,\r\n\r\n    /**\r\n     * Sets the scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ScrollFactor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Build a JSON representation of the given Game Object.\r\n *\r\n * This is typically extended further by Game Object specific implementations.\r\n *\r\n * @method Phaser.GameObjects.Components.ToJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to export as JSON.\r\n *\r\n * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n */\r\nvar ToJSON = function (gameObject)\r\n{\r\n    var out = {\r\n        name: gameObject.name,\r\n        type: gameObject.type,\r\n        x: gameObject.x,\r\n        y: gameObject.y,\r\n        depth: gameObject.depth,\r\n        scale: {\r\n            x: gameObject.scaleX,\r\n            y: gameObject.scaleY\r\n        },\r\n        origin: {\r\n            x: gameObject.originX,\r\n            y: gameObject.originY\r\n        },\r\n        flipX: gameObject.flipX,\r\n        flipY: gameObject.flipY,\r\n        rotation: gameObject.rotation,\r\n        alpha: gameObject.alpha,\r\n        visible: gameObject.visible,\r\n        scaleMode: gameObject.scaleMode,\r\n        blendMode: gameObject.blendMode,\r\n        textureKey: '',\r\n        frameKey: '',\r\n        data: {}\r\n    };\r\n\r\n    if (gameObject.texture)\r\n    {\r\n        out.textureKey = gameObject.texture.key;\r\n        out.frameKey = gameObject.frame.name;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToJSON;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar TransformMatrix = require('./TransformMatrix');\r\nvar WrapAngle = require('../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\r\n\r\nvar Transform = {\r\n\r\n    /**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleX: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the vertical scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleY: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _rotation: 0,\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    x: 0,\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    y: 0,\r\n\r\n    /**\r\n     * The z position of this Game Object.\r\n     * Note: Do not use this value to set the z-index, instead see the `depth` property.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    z: 0,\r\n\r\n    /**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    w: 0,\r\n\r\n    /**\r\n     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\r\n     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\r\n     * \r\n     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\r\n     * isn't the case, use the `scaleX` or `scaleY` properties instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.18.0\r\n     */\r\n    scale: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this._scaleX + this._scaleY) / 2;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     * \r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object in radians.\r\n     * \r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPosition: function (x, y, z, w)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n        if (z === undefined) { z = 0; }\r\n        if (w === undefined) { w = 0; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object to be a random position within the confines of\r\n     * the given area.\r\n     * \r\n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n     *\r\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n     * guaranteed to be within the area.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n     * @since 3.8.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the top-left of the random area.\r\n     * @param {number} [y=0] - The y position of the top-left of the random area.\r\n     * @param {number} [width] - The width of the random area.\r\n     * @param {number} [height] - The height of the random area.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRandomPosition: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n\r\n        this.x = x + (Math.random() * width);\r\n        this.y = y + (Math.random() * height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this.rotation = radians;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.z = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setW: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.w = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getLocalTransformMatrix: function (tempMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n\r\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n    },\r\n\r\n    /**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        if (!parent)\r\n        {\r\n            return this.getLocalTransformMatrix(tempMatrix);\r\n        }\r\n\r\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n\r\n        while (parent)\r\n        {\r\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\r\n\r\n            parentMatrix.multiply(tempMatrix, tempMatrix);\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return tempMatrix;\r\n    },\r\n\r\n    /**\r\n     * Gets the sum total rotation of all of this Game Objects parent Containers.\r\n     * \r\n     * The returned value is in radians and will be zero if this Game Object has no parent container.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getParentRotation\r\n     * @since 3.18.0\r\n     *\r\n     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\r\n     */\r\n    getParentRotation: function ()\r\n    {\r\n        var rotation = 0;\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        while (parent)\r\n        {\r\n            rotation += parent.rotation;\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return rotation;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Matrix used for display transformations for rendering.\r\n *\r\n * It is represented like so:\r\n *\r\n * ```\r\n * | a | c | tx |\r\n * | b | d | ty |\r\n * | 0 | 0 | 1  |\r\n * ```\r\n *\r\n * @class TransformMatrix\r\n * @memberof Phaser.GameObjects.Components\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [a=1] - The Scale X value.\r\n * @param {number} [b=0] - The Skew Y value.\r\n * @param {number} [c=0] - The Skew X value.\r\n * @param {number} [d=1] - The Scale Y value.\r\n * @param {number} [tx=0] - The Translate X value.\r\n * @param {number} [ty=0] - The Translate Y value.\r\n */\r\nvar TransformMatrix = new Class({\r\n\r\n    initialize:\r\n\r\n    function TransformMatrix (a, b, c, d, tx, ty)\r\n    {\r\n        if (a === undefined) { a = 1; }\r\n        if (b === undefined) { b = 0; }\r\n        if (c === undefined) { c = 0; }\r\n        if (d === undefined) { d = 1; }\r\n        if (tx === undefined) { tx = 0; }\r\n        if (ty === undefined) { ty = 0; }\r\n\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#matrix\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The decomposed matrix.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.decomposedMatrix = {\r\n            translateX: 0,\r\n            translateY: 0,\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            rotation: 0\r\n        };\r\n    },\r\n\r\n    /**\r\n     * The Scale X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#a\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    a: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[0];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[0] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Skew Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#b\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    b: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[1];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[1] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Skew X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#c\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    c: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[2];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[2] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Scale Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#d\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    d: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[3];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[3] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#e\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    e: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#f\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    f: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#tx\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    tx: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#ty\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    ty: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Matrix. Value is in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotation\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.acos(this.a / this.scaleX) * ((Math.atan(-this.c / this.a) < 0) ? -1 : 1);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Matrix, normalized to be within the Phaser right-handed\r\n     * clockwise rotation space. Value is in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotationNormalized\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.19.0\r\n     */\r\n    rotationNormalized: {\r\n\r\n        get: function ()\r\n        {\r\n            var matrix = this.matrix;\r\n\r\n            var a = matrix[0];\r\n            var b = matrix[1];\r\n            var c = matrix[2];\r\n            var d = matrix[3];\r\n\r\n            if (a || b)\r\n            {\r\n                // var r = Math.sqrt(a * a + b * b);\r\n    \r\n                return (b > 0) ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);\r\n            }\r\n            else if (c || d)\r\n            {\r\n                // var s = Math.sqrt(c * c + d * d);\r\n    \r\n                return MATH_CONST.TAU - ((d > 0) ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The decomposed horizontal scale of the Matrix. This value is always positive.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.a * this.a) + (this.b * this.b));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The decomposed vertical scale of the Matrix. This value is always positive.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.c * this.c) + (this.d * this.d));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Reset the Matrix to an identity matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    loadIdentity: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = 1;\r\n        matrix[1] = 0;\r\n        matrix[2] = 0;\r\n        matrix[3] = 1;\r\n        matrix[4] = 0;\r\n        matrix[5] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation value.\r\n     * @param {number} y - The vertical translation value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    translate: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\r\n        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale value.\r\n     * @param {number} y - The vertical scale value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    scale: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] *= x;\r\n        matrix[1] *= x;\r\n        matrix[2] *= y;\r\n        matrix[3] *= y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle of rotation in radians.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    rotate: function (angle)\r\n    {\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        matrix[0] = a * cos + c * sin;\r\n        matrix[1] = b * cos + d * sin;\r\n        matrix[2] = a * -sin + c * cos;\r\n        matrix[3] = b * -sin + d * cos;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     * \r\n     * If an `out` Matrix is given then the results will be stored in it.\r\n     * If it is not given, this matrix will be updated in place instead.\r\n     * Use an `out` Matrix if you do not wish to mutate this matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - The Matrix to multiply by.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [out] - An optional Matrix to store the results in.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} Either this TransformMatrix, or the `out` Matrix, if given in the arguments.\r\n     */\r\n    multiply: function (rhs, out)\r\n    {\r\n        var matrix = this.matrix;\r\n        var source = rhs.matrix;\r\n\r\n        var localA = matrix[0];\r\n        var localB = matrix[1];\r\n        var localC = matrix[2];\r\n        var localD = matrix[3];\r\n        var localE = matrix[4];\r\n        var localF = matrix[5];\r\n\r\n        var sourceA = source[0];\r\n        var sourceB = source[1];\r\n        var sourceC = source[2];\r\n        var sourceD = source[3];\r\n        var sourceE = source[4];\r\n        var sourceF = source[5];\r\n\r\n        var destinationMatrix = (out === undefined) ? this : out;\r\n\r\n        destinationMatrix.a = (sourceA * localA) + (sourceB * localC);\r\n        destinationMatrix.b = (sourceA * localB) + (sourceB * localD);\r\n        destinationMatrix.c = (sourceC * localA) + (sourceD * localC);\r\n        destinationMatrix.d = (sourceC * localB) + (sourceD * localD);\r\n        destinationMatrix.e = (sourceE * localA) + (sourceF * localC) + localE;\r\n        destinationMatrix.f = (sourceE * localB) + (sourceF * localD) + localF;\r\n\r\n        return destinationMatrix;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the matrix given, including the offset.\r\n     * \r\n     * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.\r\n     * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiplyWithOffset\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     * @param {number} offsetX - Horizontal offset to factor in to the multiplication.\r\n     * @param {number} offsetY - Vertical offset to factor in to the multiplication.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    multiplyWithOffset: function (src, offsetX, offsetY)\r\n    {\r\n        var matrix = this.matrix;\r\n        var otherMatrix = src.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        var pse = offsetX * a0 + offsetY * c0 + tx0;\r\n        var psf = offsetX * b0 + offsetY * d0 + ty0;\r\n\r\n        var a1 = otherMatrix[0];\r\n        var b1 = otherMatrix[1];\r\n        var c1 = otherMatrix[2];\r\n        var d1 = otherMatrix[3];\r\n        var tx1 = otherMatrix[4];\r\n        var ty1 = otherMatrix[5];\r\n\r\n        matrix[0] = a1 * a0 + b1 * c0;\r\n        matrix[1] = a1 * b0 + b1 * d0;\r\n        matrix[2] = c1 * a0 + d1 * c0;\r\n        matrix[3] = c1 * b0 + d1 * d0;\r\n        matrix[4] = tx1 * a0 + ty1 * c0 + pse;\r\n        matrix[5] = tx1 * b0 + ty1 * d0 + psf;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    transform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        matrix[0] = a * a0 + b * c0;\r\n        matrix[1] = a * b0 + b * d0;\r\n        matrix[2] = c * a0 + d * c0;\r\n        matrix[3] = c * b0 + d * d0;\r\n        matrix[4] = tx * a0 + ty * c0 + tx0;\r\n        matrix[5] = tx * b0 + ty * d0 + ty0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform a point using this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point to transform.\r\n     * @param {number} y - The y coordinate of the point to transform.\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The Point object to store the transformed coordinates.\r\n     *\r\n     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} The Point containing the transformed coordinates.\r\n     */\r\n    transformPoint: function (x, y, point)\r\n    {\r\n        if (point === undefined) { point = { x: 0, y: 0 }; }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        point.x = x * a + y * c + tx;\r\n        point.y = x * b + y * d + ty;\r\n\r\n        return point;\r\n    },\r\n\r\n    /**\r\n     * Invert the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var n = a * d - b * c;\r\n\r\n        matrix[0] = d / n;\r\n        matrix[1] = -b / n;\r\n        matrix[2] = -c / n;\r\n        matrix[3] = a / n;\r\n        matrix[4] = (c * ty - d * tx) / n;\r\n        matrix[5] = -(a * ty - b * tx) / n;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the matrix given.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFrom\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFrom: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src.a;\r\n        matrix[1] = src.b;\r\n        matrix[2] = src.c;\r\n        matrix[3] = src.d;\r\n        matrix[4] = src.e;\r\n        matrix[5] = src.f;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the array given.\r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFromArray\r\n     * @since 3.11.0\r\n     *\r\n     * @param {array} src - The array of values to set into this matrix.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFromArray: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src[0];\r\n        matrix[1] = src[1];\r\n        matrix[2] = src[2];\r\n        matrix[3] = src[3];\r\n        matrix[4] = src[4];\r\n        matrix[5] = src[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.transform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    copyToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.setTransform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    setToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values in this Matrix to the array given.\r\n     * \r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToArray\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} [out] - The array to copy the matrix values in to.\r\n     *\r\n     * @return {array} An array where elements 0 to 5 contain the values from this matrix.\r\n     */\r\n    copyToArray: function (out)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        if (out === undefined)\r\n        {\r\n            out = [ matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5] ];\r\n        }\r\n        else\r\n        {\r\n            out[0] = matrix[0];\r\n            out[1] = matrix[1];\r\n            out[2] = matrix[2];\r\n            out[3] = matrix[3];\r\n            out[4] = matrix[4];\r\n            out[5] = matrix[5];\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    setTransform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = a;\r\n        matrix[1] = b;\r\n        matrix[2] = c;\r\n        matrix[3] = d;\r\n        matrix[4] = tx;\r\n        matrix[5] = ty;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.\r\n     * \r\n     * The result must be applied in the following order to reproduce the current matrix:\r\n     * \r\n     * translate -> rotate -> scale\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The decomposed Matrix.\r\n     */\r\n    decomposeMatrix: function ()\r\n    {\r\n        var decomposedMatrix = this.decomposedMatrix;\r\n\r\n        var matrix = this.matrix;\r\n\r\n        //  a = scale X (1)\r\n        //  b = shear Y (0)\r\n        //  c = shear X (0)\r\n        //  d = scale Y (1)\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        var determ = a * d - b * c;\r\n\r\n        decomposedMatrix.translateX = matrix[4];\r\n        decomposedMatrix.translateY = matrix[5];\r\n\r\n        if (a || b)\r\n        {\r\n            var r = Math.sqrt(a * a + b * b);\r\n\r\n            decomposedMatrix.rotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);\r\n            decomposedMatrix.scaleX = r;\r\n            decomposedMatrix.scaleY = determ / r;\r\n        }\r\n        else if (c || d)\r\n        {\r\n            var s = Math.sqrt(c * c + d * d);\r\n\r\n            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));\r\n            decomposedMatrix.scaleX = determ / s;\r\n            decomposedMatrix.scaleY = s;\r\n        }\r\n        else\r\n        {\r\n            decomposedMatrix.rotation = 0;\r\n            decomposedMatrix.scaleX = 0;\r\n            decomposedMatrix.scaleY = 0;\r\n        }\r\n\r\n        return decomposedMatrix;\r\n    },\r\n\r\n    /**\r\n     * Apply the identity, translate, rotate and scale operations on the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation.\r\n     * @param {number} y - The vertical translation.\r\n     * @param {number} rotation - The angle of rotation in radians.\r\n     * @param {number} scaleX - The horizontal scale.\r\n     * @param {number} scaleY - The vertical scale.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    applyITRS: function (x, y, rotation, scaleX, scaleY)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var radianSin = Math.sin(rotation);\r\n        var radianCos = Math.cos(rotation);\r\n\r\n        // Translate\r\n        matrix[4] = x;\r\n        matrix[5] = y;\r\n\r\n        // Rotate and Scale\r\n        matrix[0] = radianCos * scaleX;\r\n        matrix[1] = radianSin * scaleX;\r\n        matrix[2] = -radianSin * scaleY;\r\n        matrix[3] = radianCos * scaleY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of\r\n     * the current matrix with its transformation applied.\r\n     * \r\n     * Can be used to translate points from world to local space.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyInverse\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} x - The x position to translate.\r\n     * @param {number} y - The y position to translate.\r\n     * @param {Phaser.Math.Vector2} [output] - A Vector2, or point-like object, to store the results in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates, inverse-transformed through this matrix.\r\n     */\r\n    applyInverse: function (x, y, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var id = 1 / ((a * d) + (c * -b));\r\n\r\n        output.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n        output.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the X component of this matrix multiplied by the given values.\r\n     * This is the same as `x * a + y * c + e`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getX\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated x value.\r\n     */\r\n    getX: function (x, y)\r\n    {\r\n        return x * this.a + y * this.c + this.e;\r\n    },\r\n\r\n    /**\r\n     * Returns the Y component of this matrix multiplied by the given values.\r\n     * This is the same as `x * b + y * d + f`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getY\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated y value.\r\n     */\r\n    getY: function (x, y)\r\n    {\r\n        return x * this.b + y * this.d + this.f;\r\n    },\r\n\r\n    /**\r\n     * Returns a string that can be used in a CSS Transform call as a `matrix` property.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getCSSMatrix\r\n     * @since 3.12.0\r\n     *\r\n     * @return {string} A string containing the CSS Transform matrix values.\r\n     */\r\n    getCSSMatrix: function ()\r\n    {\r\n        var m = this.matrix;\r\n\r\n        return 'matrix(' + m[0] + ',' + m[1] + ',' + m[2] + ',' + m[3] + ',' + m[4] + ',' + m[5] + ')';\r\n    },\r\n\r\n    /**\r\n     * Destroys this Transform Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#destroy\r\n     * @since 3.4.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.matrix = null;\r\n        this.decomposedMatrix = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TransformMatrix;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 1; // 0001\r\n\r\n/**\r\n * Provides methods used for setting the visibility of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Visible\r\n * @since 3.0.0\r\n */\r\n\r\nvar Visible = {\r\n\r\n    /**\r\n     * Private internal value. Holds the visible value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#_visible\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    _visible: true,\r\n\r\n    /**\r\n     * The visible state of the Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value)\r\n            {\r\n                this._visible = true;\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n            else\r\n            {\r\n                this._visible = false;\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Visible#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = Visible;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Object Destroy Event.\r\n * \r\n * This event is dispatched when a Game Object instance is being destroyed.\r\n * \r\n * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#DESTROY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object which is being destroyed.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Events\r\n */\r\n\r\nmodule.exports = { DESTROY: require('./DESTROY_EVENT') };\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Error calling \\'Loader.' + this.type + '\\' invalid key provided.');\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         * Automatically has Loader.path prepended to it.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (this.url === undefined)\r\n        {\r\n            this.url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof(this.url) !== 'function')\r\n        {\r\n            this.url = loader.path + this.url;\r\n        }\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //  \r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        var localFileOk = ((xhr.responseURL && xhr.responseURL.indexOf('file://') === 0 && event.target.status === 0));\r\n\r\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\r\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\r\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @since 3.7.0\r\n * \r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @since 3.7.0\r\n * \r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar types = {};\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypesManager\r\n */\r\n\r\nvar FileTypesManager = {\r\n\r\n    /**\r\n     * Static method called when a LoaderPlugin is created.\r\n     * \r\n     * Loops through the local types object and injects all of them as\r\n     * properties into the LoaderPlugin instance.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.install\r\n     * @since 3.0.0\r\n     * \r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.\r\n     */\r\n    install: function (loader)\r\n    {\r\n        for (var key in types)\r\n        {\r\n            loader[key] = types[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Static method called directly by the File Types.\r\n     * \r\n     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.register\r\n     * @since 3.0.0\r\n     * \r\n     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.\r\n     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.\r\n     */\r\n    register: function (key, factoryFunction)\r\n    {\r\n        types[key] = factoryFunction;\r\n    },\r\n\r\n    /**\r\n     * Removed all associated file types.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        types = {};\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = FileTypesManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n * \r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = files;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = files.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < files.length; i++)\r\n        {\r\n            files[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file, xhr);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {integer} [timeout=0] - Optional XHR timeout value.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Add File Event.\r\n * \r\n * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('addfile', listener)`.\r\n * \r\n * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.\r\n *\r\n * @event Phaser.Loader.Events#ADD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The unique key of the file that was added to the Loader.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.\r\n */\r\nmodule.exports = 'addfile';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Complete Event.\r\n * \r\n * This event is dispatched when the Loader has fully processed everything in the load queue.\r\n * By this point every loaded file will now be in its associated cache and ready for use.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('complete', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {integer} totalComplete - The total number of files that successfully loaded.\r\n * @param {integer} totalFailed - The total number of files that failed to load.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.\r\n * \r\n * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * It uses a special dynamic event name constructed from the key and type of the file.\r\n * \r\n * For example, if you have loaded an `image` with a key of `monster`, you can listen for it\r\n * using the following:\r\n *\r\n * ```javascript\r\n * this.load.on('filecomplete-image-monster', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n *\r\n * Or, if you have loaded a texture `atlas` with a key of `Level1`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Error Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file fails to load.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD_ERROR\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n */\r\nmodule.exports = 'loaderror';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file finishes loading,\r\n * but _before_ it is processed and added to the internal Phaser caches.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('load', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.\r\n */\r\nmodule.exports = 'load';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Progress Event.\r\n * \r\n * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\r\n * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.\r\n */\r\nmodule.exports = 'fileprogress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Post Process Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\r\n * It is dispatched before the internal lists are cleared and each File is destroyed.\r\n * \r\n * Use this hook to perform any last minute processing of files that can only happen once the\r\n * Loader has completed, but prior to it emitting the `complete` event.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#POST_PROCESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'postprocess';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Progress Event.\r\n * \r\n * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('progress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {number} progress - The current progress of the load. A value between 0 and 1.\r\n */\r\nmodule.exports = 'progress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Start Event.\r\n * \r\n * This event is dispatched when the Loader starts running. At this point load progress is zero.\r\n * \r\n * This event is dispatched even if there aren't any files in the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('start', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD: require('./ADD_EVENT'),\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    FILE_COMPLETE: require('./FILE_COMPLETE_EVENT'),\r\n    FILE_KEY_COMPLETE: require('./FILE_KEY_COMPLETE_EVENT'),\r\n    FILE_LOAD_ERROR: require('./FILE_LOAD_ERROR_EVENT'),\r\n    FILE_LOAD: require('./FILE_LOAD_EVENT'),\r\n    FILE_PROGRESS: require('./FILE_PROGRESS_EVENT'),\r\n    POST_PROCESS: require('./POST_PROCESS_EVENT'),\r\n    PROGRESS: require('./PROGRESS_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            var json = JSON.parse(this.xhrLoader.responseText);\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n * \r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'txt';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.text,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the mean average of the given values.\r\n *\r\n * @function Phaser.Math.Average\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} values - The values to average.\r\n *\r\n * @return {number} The average value.\r\n */\r\nvar Average = function (values)\r\n{\r\n    var sum = 0;\r\n\r\n    for (var i = 0; i < values.length; i++)\r\n    {\r\n        sum += (+values[i]);\r\n    }\r\n\r\n    return sum / values.length;\r\n};\r\n\r\nmodule.exports = Average;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Factorial = require('./Factorial');\r\n\r\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Bernstein\r\n * @since 3.0.0\r\n *\r\n * @param {number} n - [description]\r\n * @param {number} i - [description]\r\n *\r\n * @return {number} [description]\r\n */\r\nvar Bernstein = function (n, i)\r\n{\r\n    return Factorial(n) / Factorial(i) / Factorial(n - i);\r\n};\r\n\r\nmodule.exports = Bernstein;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random integer between the `min` and `max` values, inclusive.\r\n *\r\n * @function Phaser.Math.Between\r\n * @since 3.0.0\r\n *\r\n * @param {integer} min - The minimum value.\r\n * @param {integer} max - The maximum value.\r\n *\r\n * @return {integer} The random integer.\r\n */\r\nvar Between = function (min, max)\r\n{\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a Catmull-Rom value.\r\n *\r\n * @function Phaser.Math.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - [description]\r\n * @param {number} p0 - [description]\r\n * @param {number} p1 - [description]\r\n * @param {number} p2 - [description]\r\n * @param {number} p3 - [description]\r\n *\r\n * @return {number} The Catmull-Rom value.\r\n */\r\nvar CatmullRom = function (t, p0, p1, p2, p3)\r\n{\r\n    var v0 = (p2 - p0) * 0.5;\r\n    var v1 = (p3 - p1) * 0.5;\r\n    var t2 = t * t;\r\n    var t3 = t * t2;\r\n\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n};\r\n\r\nmodule.exports = CatmullRom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Ceils to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.CeilTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {number} [place=0] - The place to round to.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar CeilTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.ceil(value * p) / p;\r\n};\r\n\r\nmodule.exports = CeilTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {integer} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the positive difference of two given numbers.\r\n *\r\n * @function Phaser.Math.Difference\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first number in the calculation.\r\n * @param {number} b - The second number in the calculation.\r\n *\r\n * @return {number} The positive difference of the two given numbers.\r\n */\r\nvar Difference = function (a, b)\r\n{\r\n    return Math.abs(a - b);\r\n};\r\n\r\nmodule.exports = Difference;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the factorial of a given number for integer values greater than 0.\r\n *\r\n * @function Phaser.Math.Factorial\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - A positive integer to calculate the factorial of.\r\n *\r\n * @return {number} The factorial of the given number.\r\n */\r\nvar Factorial = function (value)\r\n{\r\n    if (value === 0)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    var res = value;\r\n\r\n    while (--value)\r\n    {\r\n        res *= value;\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\nmodule.exports = Factorial;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a random floating point number between the two given bounds, minimum inclusive, maximum exclusive.\r\n *\r\n * @function Phaser.Math.FloatBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} min - The lower bound for the float, inclusive.\r\n * @param {number} max - The upper bound for the float exclusive.\r\n *\r\n * @return {number} A random float within the given range.\r\n */\r\nvar FloatBetween = function (min, max)\r\n{\r\n    return Math.random() * (max - min) + min;\r\n};\r\n\r\nmodule.exports = FloatBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Floors to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.FloorTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {integer} [place=0] - The place to round to.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar FloorTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.floor(value * p) / p;\r\n};\r\n\r\nmodule.exports = FloorTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the speed required to cover a distance in the time given.\r\n *\r\n * @function Phaser.Math.GetSpeed\r\n * @since 3.0.0\r\n *\r\n * @param {number} distance - The distance to travel in pixels.\r\n * @param {integer} time - The time, in ms, to cover the distance in.\r\n *\r\n * @return {number} The amount you will need to increment the position by each step in order to cover the distance in the time given.\r\n */\r\nvar GetSpeed = function (distance, time)\r\n{\r\n    return (distance / time) / 1000;\r\n};\r\n\r\nmodule.exports = GetSpeed;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number.\r\n *\r\n * @function Phaser.Math.IsEven\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEven = function (value)\r\n{\r\n    // Use abstract equality == for \"is number\" test\r\n\r\n    // eslint-disable-next-line eqeqeq\r\n    return (value == parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEven;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number using a strict type check.\r\n *\r\n * @function Phaser.Math.IsEvenStrict\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEvenStrict = function (value)\r\n{\r\n    // Use strict equality === for \"is number\" test\r\n    return (value === parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEvenStrict;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a linear (interpolation) value over t.\r\n *\r\n * @function Phaser.Math.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} p0 - The first point.\r\n * @param {number} p1 - The second point.\r\n * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.\r\n *\r\n * @return {number} The step t% of the way between p0 and p1.\r\n */\r\nvar Linear = function (p0, p1, t)\r\n{\r\n    return (p1 - p0) * t + p0;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A three-dimensional matrix.\r\n *\r\n * Defaults to the identity matrix when instantiated.\r\n *\r\n * @class Matrix3\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix3} [m] - Optional Matrix3 to copy values from.\r\n */\r\nvar Matrix3 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Matrix3 (m)\r\n    {\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.Math.Matrix3#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.val = new Float32Array(9);\r\n\r\n        if (m)\r\n        {\r\n            //  Assume Matrix3 with val:\r\n            this.copy(m);\r\n        }\r\n        else\r\n        {\r\n            //  Default to identity\r\n            this.identity();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Matrix3.\r\n     *\r\n     * @method Phaser.Math.Matrix3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} A clone of this Matrix3.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Matrix3(this);\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Matrix3.copy`.\r\n     *\r\n     * @method Phaser.Math.Matrix3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to set the values of this Matrix's from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    set: function (src)\r\n    {\r\n        return this.copy(src);\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix into this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        var out = this.val;\r\n        var a = src.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix4 into this Matrix3.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - The Matrix4 to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromMat4: function (m)\r\n    {\r\n        var a = m.val;\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[4];\r\n        out[4] = a[5];\r\n        out[5] = a[6];\r\n        out[6] = a[8];\r\n        out[7] = a[9];\r\n        out[8] = a[10];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given array.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - The array to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromArray: function (a)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    identity: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 1;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 1;\r\n        out[5] = 0;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transpose this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    transpose: function ()\r\n    {\r\n        var a = this.val;\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a12 = a[5];\r\n\r\n        a[1] = a[3];\r\n        a[2] = a[6];\r\n        a[3] = a01;\r\n        a[5] = a[7];\r\n        a[6] = a02;\r\n        a[7] = a12;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        var b01 = a22 * a11 - a12 * a21;\r\n        var b11 = -a22 * a10 + a12 * a20;\r\n        var b21 = a21 * a10 - a11 * a20;\r\n\r\n        // Calculate the determinant\r\n        var det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        a[0] = b01 * det;\r\n        a[1] = (-a22 * a01 + a02 * a21) * det;\r\n        a[2] = (a12 * a01 - a02 * a11) * det;\r\n        a[3] = b11 * det;\r\n        a[4] = (a22 * a00 - a02 * a20) * det;\r\n        a[5] = (-a12 * a00 + a02 * a10) * det;\r\n        a[6] = b21 * det;\r\n        a[7] = (-a21 * a00 + a01 * a20) * det;\r\n        a[8] = (a11 * a00 - a01 * a10) * det;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the adjoint, or adjugate, of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    adjoint: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        a[0] = (a11 * a22 - a12 * a21);\r\n        a[1] = (a02 * a21 - a01 * a22);\r\n        a[2] = (a01 * a12 - a02 * a11);\r\n        a[3] = (a12 * a20 - a10 * a22);\r\n        a[4] = (a00 * a22 - a02 * a20);\r\n        a[5] = (a02 * a10 - a00 * a12);\r\n        a[6] = (a10 * a21 - a11 * a20);\r\n        a[7] = (a01 * a20 - a00 * a21);\r\n        a[8] = (a00 * a11 - a01 * a10);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the determinant of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The determinant of this Matrix.\r\n     */\r\n    determinant: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to multiply this Matrix by.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        var b = src.val;\r\n\r\n        var b00 = b[0];\r\n        var b01 = b[1];\r\n        var b02 = b[2];\r\n        var b10 = b[3];\r\n        var b11 = b[4];\r\n        var b12 = b[5];\r\n        var b20 = b[6];\r\n        var b21 = b[7];\r\n        var b22 = b[8];\r\n\r\n        a[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n        a[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n        a[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n\r\n        a[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n        a[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n        a[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n\r\n        a[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n        a[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n        a[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix3#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    translate: function (v)\r\n    {\r\n        var a = this.val;\r\n        var x = v.x;\r\n        var y = v.y;\r\n\r\n        a[6] = x * a[0] + y * a[3] + a[6];\r\n        a[7] = x * a[1] + y * a[4] + a[7];\r\n        a[8] = x * a[2] + y * a[5] + a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a rotation transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    rotate: function (rad)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        a[0] = c * a00 + s * a10;\r\n        a[1] = c * a01 + s * a11;\r\n        a[2] = c * a02 + s * a12;\r\n\r\n        a[3] = c * a10 - s * a00;\r\n        a[4] = c * a11 - s * a01;\r\n        a[5] = c * a12 - s * a02;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * Uses the `x` and `y` components of the given Vector to scale the Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    scale: function (v)\r\n    {\r\n        var a = this.val;\r\n        var x = v.x;\r\n        var y = v.y;\r\n\r\n        a[0] = x * a[0];\r\n        a[1] = x * a[1];\r\n        a[2] = x * a[2];\r\n\r\n        a[3] = y * a[3];\r\n        a[4] = y * a[4];\r\n        a[5] = y * a[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromQuat: function (q)\r\n    {\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        var out = this.val;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[3] = xy + wz;\r\n        out[6] = xz - wy;\r\n\r\n        out[1] = xy - wz;\r\n        out[4] = 1 - (xx + zz);\r\n        out[7] = yz + wx;\r\n\r\n        out[2] = xz + wy;\r\n        out[5] = yz - wx;\r\n        out[8] = 1 - (xx + yy);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#normalFromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    normalFromMat4: function (m)\r\n    {\r\n        var a = m.val;\r\n        var out = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n\r\n        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n\r\n        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Matrix3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\nvar EPSILON = 0.000001;\r\n\r\n/**\r\n * @classdesc\r\n * A four-dimensional matrix.\r\n *\r\n * @class Matrix4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix4} [m] - Optional Matrix4 to copy values from.\r\n */\r\nvar Matrix4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Matrix4 (m)\r\n    {\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.Math.Matrix4#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.val = new Float32Array(16);\r\n\r\n        if (m)\r\n        {\r\n            //  Assume Matrix4 with val:\r\n            this.copy(m);\r\n        }\r\n        else\r\n        {\r\n            //  Default to identity\r\n            this.identity();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Matrix4.\r\n     *\r\n     * @method Phaser.Math.Matrix4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} A clone of this Matrix4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Matrix4(this);\r\n    },\r\n\r\n    //  TODO - Should work with basic values\r\n\r\n    /**\r\n     * This method is an alias for `Matrix4.copy`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    set: function (src)\r\n    {\r\n        return this.copy(src);\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix into this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        var out = this.val;\r\n        var a = src.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given array.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - The array to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromArray: function (a)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix.\r\n     *\r\n     * Sets all values to `0`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#zero\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    zero: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 0;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 0;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 0;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y` and `z` values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#xyz\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     * @param {number} z - The z value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    xyz: function (x, y, z)\r\n    {\r\n        this.identity();\r\n\r\n        var out = this.val;\r\n\r\n        out[12] = x;\r\n        out[13] = y;\r\n        out[14] = z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the scaling values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaling\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x scaling value.\r\n     * @param {number} y - The y scaling value.\r\n     * @param {number} z - The z scaling value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaling: function (x, y, z)\r\n    {\r\n        this.zero();\r\n\r\n        var out = this.val;\r\n\r\n        out[0] = x;\r\n        out[5] = y;\r\n        out[10] = z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    identity: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 1;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 1;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 1;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transpose this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    transpose: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n        var a23 = a[11];\r\n\r\n        a[1] = a[4];\r\n        a[2] = a[8];\r\n        a[3] = a[12];\r\n        a[4] = a01;\r\n        a[6] = a[9];\r\n        a[7] = a[13];\r\n        a[8] = a02;\r\n        a[9] = a12;\r\n        a[11] = a[14];\r\n        a[12] = a03;\r\n        a[13] = a13;\r\n        a[14] = a23;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n        a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n        a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n        a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n        a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n        a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n        a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n        a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n        a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n        a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the adjoint, or adjugate, of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    adjoint: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        a[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\r\n        a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n        a[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\r\n        a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n        a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n        a[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\r\n        a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n        a[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\r\n        a[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\r\n        a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n        a[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\r\n        a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n        a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n        a[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\r\n        a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n        a[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the determinant of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The determinant of this Matrix.\r\n     */\r\n    determinant: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b = src.val;\r\n\r\n        // Cache only the current line of the second matrix\r\n        var b0 = b[0];\r\n        var b1 = b[1];\r\n        var b2 = b[2];\r\n        var b3 = b[3];\r\n\r\n        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[4];\r\n        b1 = b[5];\r\n        b2 = b[6];\r\n        b3 = b[7];\r\n\r\n        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[8];\r\n        b1 = b[9];\r\n        b2 = b[10];\r\n        b3 = b[11];\r\n\r\n        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[12];\r\n        b1 = b[13];\r\n        b2 = b[14];\r\n        b3 = b[15];\r\n\r\n        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiplyLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiplyLocal: function (src)\r\n    {\r\n        var a = [];\r\n        var m1 = this.val;\r\n        var m2 = src.val;\r\n\r\n        a[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];\r\n        a[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];\r\n        a[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];\r\n        a[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];\r\n\r\n        a[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];\r\n        a[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];\r\n        a[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];\r\n        a[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];\r\n\r\n        a[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];\r\n        a[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];\r\n        a[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];\r\n        a[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];\r\n\r\n        a[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];\r\n        a[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];\r\n        a[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];\r\n        a[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];\r\n\r\n        return this.fromArray(a);\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translate: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translateXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translateXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scale: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaleXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaleXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Derive a rotation matrix around the given axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#makeRotationAxis\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.\r\n     * @param {number} angle - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    makeRotationAxis: function (axis, angle)\r\n    {\r\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n        var c = Math.cos(angle);\r\n        var s = Math.sin(angle);\r\n        var t = 1 - c;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var tx = t * x;\r\n        var ty = t * y;\r\n\r\n        this.fromArray([\r\n            tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n            tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a rotation transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotate: function (rad, axis)\r\n    {\r\n        var a = this.val;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n\r\n        if (Math.abs(len) < EPSILON)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        len = 1 / len;\r\n        x *= len;\r\n        y *= len;\r\n        z *= len;\r\n\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n        var t = 1 - c;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Construct the elements of the rotation matrix\r\n        var b00 = x * x * t + c;\r\n        var b01 = y * x * t + z * s;\r\n        var b02 = z * x * t - y * s;\r\n\r\n        var b10 = x * y * t - z * s;\r\n        var b11 = y * y * t + c;\r\n        var b12 = z * y * t + x * s;\r\n\r\n        var b20 = x * z * t + y * s;\r\n        var b21 = y * z * t - x * s;\r\n        var b22 = z * z * t + c;\r\n\r\n        // Perform rotation-specific matrix multiplication\r\n        a[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        a[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        a[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        a[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n        a[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        a[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        a[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        a[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n        a[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        a[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        a[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        a[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its X axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateX: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[4] = a10 * c + a20 * s;\r\n        a[5] = a11 * c + a21 * s;\r\n        a[6] = a12 * c + a22 * s;\r\n        a[7] = a13 * c + a23 * s;\r\n        a[8] = a20 * c - a10 * s;\r\n        a[9] = a21 * c - a11 * s;\r\n        a[10] = a22 * c - a12 * s;\r\n        a[11] = a23 * c - a13 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Y axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateY: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c - a20 * s;\r\n        a[1] = a01 * c - a21 * s;\r\n        a[2] = a02 * c - a22 * s;\r\n        a[3] = a03 * c - a23 * s;\r\n        a[8] = a00 * s + a20 * c;\r\n        a[9] = a01 * s + a21 * c;\r\n        a[10] = a02 * s + a22 * c;\r\n        a[11] = a03 * s + a23 * c;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Z axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateZ: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c + a10 * s;\r\n        a[1] = a01 * c + a11 * s;\r\n        a[2] = a02 * c + a12 * s;\r\n        a[3] = a03 * c + a13 * s;\r\n        a[4] = a10 * c - a00 * s;\r\n        a[5] = a11 * c - a01 * s;\r\n        a[6] = a12 * c - a02 * s;\r\n        a[7] = a13 * c - a03 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given rotation Quaternion and translation Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromRotationTranslation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.\r\n     * @param {Phaser.Math.Vector3} v - The Vector to set translation from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromRotationTranslation: function (q, v)\r\n    {\r\n        // Quaternion math\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = v.x;\r\n        out[13] = v.y;\r\n        out[14] = v.z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromQuat: function (q)\r\n    {\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a frustum matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#frustum\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    frustum: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        var rl = 1 / (right - left);\r\n        var tb = 1 / (top - bottom);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = (near * 2) * rl;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (near * 2) * tb;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = (right + left) * rl;\r\n        out[9] = (top + bottom) * tb;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (far * near * 2) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspective\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} fovy - Vertical field of view in radians\r\n     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspective: function (fovy, aspect, near, far)\r\n    {\r\n        var out = this.val;\r\n        var f = 1.0 / Math.tan(fovy / 2);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = f / aspect;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = f;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (2 * far * near) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspectiveLH\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the frustum.\r\n     * @param {number} height - The height of the frustum.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspectiveLH: function (width, height, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = (2 * near) / width;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (2 * near) / height;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = -far / (near - far);\r\n        out[11] = 1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (near * far) / (near - far);\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate an orthogonal projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#ortho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    ortho: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n        var lr = left - right;\r\n        var bt = bottom - top;\r\n        var nf = near - far;\r\n\r\n        //  Avoid division by zero\r\n        lr = (lr === 0) ? lr : 1 / lr;\r\n        bt = (bt === 0) ? bt : 1 / bt;\r\n        nf = (nf === 0) ? nf : 1 / nf;\r\n\r\n        out[0] = -2 * lr;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = -2 * bt;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 2 * nf;\r\n        out[11] = 0;\r\n\r\n        out[12] = (left + right) * lr;\r\n        out[13] = (top + bottom) * bt;\r\n        out[14] = (far + near) * nf;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a look-at matrix with the given eye position, focal point, and up axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} eye - Position of the viewer\r\n     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\r\n     * @param {Phaser.Math.Vector3} up - vec3 pointing up.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    lookAt: function (eye, center, up)\r\n    {\r\n        var out = this.val;\r\n\r\n        var eyex = eye.x;\r\n        var eyey = eye.y;\r\n        var eyez = eye.z;\r\n\r\n        var upx = up.x;\r\n        var upy = up.y;\r\n        var upz = up.z;\r\n\r\n        var centerx = center.x;\r\n        var centery = center.y;\r\n        var centerz = center.z;\r\n\r\n        if (Math.abs(eyex - centerx) < EPSILON &&\r\n            Math.abs(eyey - centery) < EPSILON &&\r\n            Math.abs(eyez - centerz) < EPSILON)\r\n        {\r\n            return this.identity();\r\n        }\r\n\r\n        var z0 = eyex - centerx;\r\n        var z1 = eyey - centery;\r\n        var z2 = eyez - centerz;\r\n\r\n        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n\r\n        z0 *= len;\r\n        z1 *= len;\r\n        z2 *= len;\r\n\r\n        var x0 = upy * z2 - upz * z1;\r\n        var x1 = upz * z0 - upx * z2;\r\n        var x2 = upx * z1 - upy * z0;\r\n\r\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n\r\n        if (!len)\r\n        {\r\n            x0 = 0;\r\n            x1 = 0;\r\n            x2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            x0 *= len;\r\n            x1 *= len;\r\n            x2 *= len;\r\n        }\r\n\r\n        var y0 = z1 * x2 - z2 * x1;\r\n        var y1 = z2 * x0 - z0 * x2;\r\n        var y2 = z0 * x1 - z1 * x0;\r\n\r\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n\r\n        if (!len)\r\n        {\r\n            y0 = 0;\r\n            y1 = 0;\r\n            y2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            y0 *= len;\r\n            y1 *= len;\r\n            y2 *= len;\r\n        }\r\n\r\n        out[0] = x0;\r\n        out[1] = y0;\r\n        out[2] = z0;\r\n        out[3] = 0;\r\n\r\n        out[4] = x1;\r\n        out[5] = y1;\r\n        out[6] = z1;\r\n        out[7] = 0;\r\n\r\n        out[8] = x2;\r\n        out[9] = y2;\r\n        out[10] = z2;\r\n        out[11] = 0;\r\n\r\n        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#yawPitchRoll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yaw - [description]\r\n     * @param {number} pitch - [description]\r\n     * @param {number} roll - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    yawPitchRoll: function (yaw, pitch, roll)\r\n    {\r\n        this.zero();\r\n        _tempMat1.zero();\r\n        _tempMat2.zero();\r\n\r\n        var m0 = this.val;\r\n        var m1 = _tempMat1.val;\r\n        var m2 = _tempMat2.val;\r\n\r\n        //  Rotate Z\r\n        var s = Math.sin(roll);\r\n        var c = Math.cos(roll);\r\n\r\n        m0[10] = 1;\r\n        m0[15] = 1;\r\n        m0[0] = c;\r\n        m0[1] = s;\r\n        m0[4] = -s;\r\n        m0[5] = c;\r\n\r\n        //  Rotate X\r\n        s = Math.sin(pitch);\r\n        c = Math.cos(pitch);\r\n\r\n        m1[0] = 1;\r\n        m1[15] = 1;\r\n        m1[5] = c;\r\n        m1[10] = c;\r\n        m1[9] = -s;\r\n        m1[6] = s;\r\n\r\n        //  Rotate Y\r\n        s = Math.sin(yaw);\r\n        c = Math.cos(yaw);\r\n\r\n        m2[5] = 1;\r\n        m2[15] = 1;\r\n        m2[0] = c;\r\n        m2[2] = -s;\r\n        m2[8] = s;\r\n        m2[10] = c;\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#setWorldMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.\r\n     * @param {Phaser.Math.Vector3} position - The position of the world matrix.\r\n     * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.\r\n     * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.\r\n     * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix)\r\n    {\r\n        this.yawPitchRoll(rotation.y, rotation.x, rotation.z);\r\n\r\n        _tempMat1.scaling(scale.x, scale.y, scale.z);\r\n        _tempMat2.xyz(position.x, position.y, position.z);\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        if (viewMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(viewMatrix);\r\n        }\r\n\r\n        if (projectionMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(projectionMatrix);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nvar _tempMat1 = new Matrix4();\r\nvar _tempMat2 = new Matrix4();\r\n\r\nmodule.exports = Matrix4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Add an `amount` to a `value`, limiting the maximum result to `max`.\r\n *\r\n * @function Phaser.Math.MaxAdd\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to add to.\r\n * @param {number} amount - The amount to add.\r\n * @param {number} max - The maximum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MaxAdd = function (value, amount, max)\r\n{\r\n    return Math.min(value + amount, max);\r\n};\r\n\r\nmodule.exports = MaxAdd;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Subtract an `amount` from `value`, limiting the minimum result to `min`.\r\n *\r\n * @function Phaser.Math.MinSub\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to subtract from.\r\n * @param {number} amount - The amount to subtract.\r\n * @param {number} min - The minimum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MinSub = function (value, amount, min)\r\n{\r\n    return Math.max(value - amount, min);\r\n};\r\n\r\nmodule.exports = MinSub;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Work out what percentage `value` is of the range between `min` and `max`.\r\n * If `max` isn't given then it will return the percentage of `value` to `min`.\r\n *\r\n * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.\r\n *\r\n * @function Phaser.Math.Percent\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to determine the percentage of.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n * @param {number} [upperMax] - The mid-way point in the range that represents 100%.\r\n *\r\n * @return {number} A value between 0 and 1 representing the percentage.\r\n */\r\nvar Percent = function (value, min, max, upperMax)\r\n{\r\n    if (max === undefined) { max = min + 1; }\r\n\r\n    var percentage = (value - min) / (max - min);\r\n\r\n    if (percentage > 1)\r\n    {\r\n        if (upperMax !== undefined)\r\n        {\r\n            percentage = ((upperMax - value)) / (upperMax - max);\r\n\r\n            if (percentage < 0)\r\n            {\r\n                percentage = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            percentage = 1;\r\n        }\r\n    }\r\n    else if (percentage < 0)\r\n    {\r\n        percentage = 0;\r\n    }\r\n\r\n    return percentage;\r\n};\r\n\r\nmodule.exports = Percent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\nvar Vector3 = require('./Vector3');\r\nvar Matrix3 = require('./Matrix3');\r\n\r\nvar EPSILON = 0.000001;\r\n\r\n//  Some shared 'private' arrays\r\nvar siNext = new Int8Array([ 1, 2, 0 ]);\r\nvar tmp = new Float32Array([ 0, 0, 0 ]);\r\n\r\nvar xUnitVec3 = new Vector3(1, 0, 0);\r\nvar yUnitVec3 = new Vector3(0, 1, 0);\r\n\r\nvar tmpvec = new Vector3();\r\nvar tmpMat3 = new Matrix3();\r\n\r\n/**\r\n * @classdesc\r\n * A quaternion.\r\n *\r\n * @class Quaternion\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Quaternion = new Class({\r\n\r\n    initialize:\r\n\r\n    function Quaternion (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The y component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The z component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The w component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Quaternion or Vector into this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z;\r\n        this.w = src.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the components of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.\r\n     * @param {number} [y=0] - The y component.\r\n     * @param {number} [z=0] - The z component.\r\n     * @param {number} [w=0] - The w component.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Quaternion#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        this.w += v.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Quaternion#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z;\r\n        this.w -= v.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Quaternion by the given value.\r\n     *\r\n     * @method Phaser.Math.Quaternion#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Quaternion by.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Quaternion.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Quaternion squared.\r\n     *\r\n     * @method Phaser.Math.Quaternion#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Quaternion, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Quaternion and the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.\r\n     *\r\n     * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.\r\n     * @param {number} [t=0] - The percentage of interpolation.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotationTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - [description]\r\n     * @param {Phaser.Math.Vector3} b - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotationTo: function (a, b)\r\n    {\r\n        var dot = a.x * b.x + a.y * b.y + a.z * b.z;\r\n\r\n        if (dot < -0.999999)\r\n        {\r\n            if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON)\r\n            {\r\n                tmpvec.copy(yUnitVec3).cross(a);\r\n            }\r\n\r\n            tmpvec.normalize();\r\n\r\n            return this.setAxisAngle(tmpvec, Math.PI);\r\n\r\n        }\r\n        else if (dot > 0.999999)\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.z = 0;\r\n            this.w = 1;\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            tmpvec.copy(a).cross(b);\r\n\r\n            this.x = tmpvec.x;\r\n            this.y = tmpvec.y;\r\n            this.z = tmpvec.z;\r\n            this.w = 1 + dot;\r\n\r\n            return this.normalize();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Set the axes of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxes\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} view - The view axis.\r\n     * @param {Phaser.Math.Vector3} right - The right axis.\r\n     * @param {Phaser.Math.Vector3} up - The upwards axis.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    setAxes: function (view, right, up)\r\n    {\r\n        var m = tmpMat3.val;\r\n\r\n        m[0] = right.x;\r\n        m[3] = right.y;\r\n        m[6] = right.z;\r\n\r\n        m[1] = up.x;\r\n        m[4] = up.y;\r\n        m[7] = up.z;\r\n\r\n        m[2] = -view.x;\r\n        m[5] = -view.y;\r\n        m[8] = -view.z;\r\n\r\n        return this.fromMat3(tmpMat3).normalize();\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    identity: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the axis angle of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxisAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} axis - The axis.\r\n     * @param {number} rad - The angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    setAxisAngle: function (axis, rad)\r\n    {\r\n        rad = rad * 0.5;\r\n\r\n        var s = Math.sin(rad);\r\n\r\n        this.x = s * axis.x;\r\n        this.y = s * axis.y;\r\n        this.z = s * axis.z;\r\n        this.w = Math.cos(rad);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Quaternion by the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    multiply: function (b)\r\n    {\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n        var bw = b.w;\r\n\r\n        this.x = ax * bw + aw * bx + ay * bz - az * by;\r\n        this.y = ay * bw + aw * by + az * bx - ax * bz;\r\n        this.z = az * bw + aw * bz + ax * by - ay * bx;\r\n        this.w = aw * bw - ax * bx - ay * by - az * bz;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#slerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.\r\n     * @param {number} t - The percentage of interpolation.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    slerp: function (b, t)\r\n    {\r\n        // benchmarks: http://jsperf.com/quaternion-slerp-implementations\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n        var bw = b.w;\r\n\r\n        // calc cosine\r\n        var cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n\r\n        // adjust signs (if necessary)\r\n        if (cosom < 0)\r\n        {\r\n            cosom = -cosom;\r\n            bx = - bx;\r\n            by = - by;\r\n            bz = - bz;\r\n            bw = - bw;\r\n        }\r\n\r\n        // \"from\" and \"to\" quaternions are very close\r\n        //  ... so we can do a linear interpolation\r\n        var scale0 = 1 - t;\r\n        var scale1 = t;\r\n\r\n        // calculate coefficients\r\n        if ((1 - cosom) > EPSILON)\r\n        {\r\n            // standard case (slerp)\r\n            var omega = Math.acos(cosom);\r\n            var sinom = Math.sin(omega);\r\n\r\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n            scale1 = Math.sin(t * omega) / sinom;\r\n        }\r\n\r\n        // calculate final values\r\n        this.x = scale0 * ax + scale1 * bx;\r\n        this.y = scale0 * ay + scale1 * by;\r\n        this.z = scale0 * az + scale1 * bz;\r\n        this.w = scale0 * aw + scale1 * bw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a0 = this.x;\r\n        var a1 = this.y;\r\n        var a2 = this.z;\r\n        var a3 = this.w;\r\n\r\n        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n        var invDot = (dot) ? 1 / dot : 0;\r\n\r\n        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n\r\n        this.x = -a0 * invDot;\r\n        this.y = -a1 * invDot;\r\n        this.z = -a2 * invDot;\r\n        this.w = a3 * invDot;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Convert this Quaternion into its conjugate.\r\n     *\r\n     * Sets the x, y and z components.\r\n     *\r\n     * @method Phaser.Math.Quaternion#conjugate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    conjugate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the X axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateX: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw + aw * bx;\r\n        this.y = ay * bw + az * bx;\r\n        this.z = az * bw - ay * bx;\r\n        this.w = aw * bw - ax * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the Y axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateY: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var by = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw - az * by;\r\n        this.y = ay * bw + aw * by;\r\n        this.z = az * bw + ax * by;\r\n        this.w = aw * bw - ay * by;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the Z axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateZ: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bz = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw + ay * bz;\r\n        this.y = ay * bw - ax * bz;\r\n        this.z = az * bw + aw * bz;\r\n        this.w = aw * bw - az * bz;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Create a unit (or rotation) Quaternion from its x, y, and z components.\r\n     *\r\n     * Sets the w component.\r\n     *\r\n     * @method Phaser.Math.Quaternion#calculateW\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    calculateW: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        this.w = -Math.sqrt(1.0 - x * x - y * y - z * z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Convert the given Matrix into this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#fromMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    fromMat3: function (mat)\r\n    {\r\n        // benchmarks:\r\n        //    http://jsperf.com/typed-array-access-speed\r\n        //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion\r\n\r\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n        // article \"Quaternion Calculus and Fast Animation\".\r\n        var m = mat.val;\r\n        var fTrace = m[0] + m[4] + m[8];\r\n        var fRoot;\r\n\r\n        if (fTrace > 0)\r\n        {\r\n            // |w| > 1/2, may as well choose w > 1/2\r\n            fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n\r\n            this.w = 0.5 * fRoot;\r\n\r\n            fRoot = 0.5 / fRoot; // 1/(4w)\r\n\r\n            this.x = (m[7] - m[5]) * fRoot;\r\n            this.y = (m[2] - m[6]) * fRoot;\r\n            this.z = (m[3] - m[1]) * fRoot;\r\n        }\r\n        else\r\n        {\r\n            // |w| <= 1/2\r\n            var i = 0;\r\n\r\n            if (m[4] > m[0])\r\n            {\r\n                i = 1;\r\n            }\r\n\r\n            if (m[8] > m[i * 3 + i])\r\n            {\r\n                i = 2;\r\n            }\r\n\r\n            var j = siNext[i];\r\n            var k = siNext[j];\r\n\r\n            //  This isn't quite as clean without array access\r\n            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);\r\n            tmp[i] = 0.5 * fRoot;\r\n\r\n            fRoot = 0.5 / fRoot;\r\n\r\n            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n\r\n            this.x = tmp[0];\r\n            this.y = tmp[1];\r\n            this.z = tmp[2];\r\n            this.w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Quaternion;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle in radians, to the equivalent angle in degrees.\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {number} radians - The angle in radians to convert ot degrees.\r\n *\r\n * @return {integer} The given angle converted to degrees.\r\n */\r\nvar RadToDeg = function (radians)\r\n{\r\n    return radians * CONST.RAD_TO_DEG;\r\n};\r\n\r\nmodule.exports = RadToDeg;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random unit vector.\r\n *\r\n * Computes random values for the given vector between -1 and 1 that can be used to represent a direction.\r\n *\r\n * Optionally accepts a scale value to scale the resulting vector by.\r\n *\r\n * @function Phaser.Math.RandomXY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2} vector - The Vector to compute random values for.\r\n * @param {number} [scale=1] - The scale of the random values.\r\n *\r\n * @return {Phaser.Math.Vector2} The given Vector.\r\n */\r\nvar RandomXY = function (vector, scale)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n\r\n    var r = Math.random() * 2 * Math.PI;\r\n\r\n    vector.x = Math.cos(r) * scale;\r\n    vector.y = Math.sin(r) * scale;\r\n\r\n    return vector;\r\n};\r\n\r\nmodule.exports = RandomXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random position vector in a spherical area, optionally defined by the given radius.\r\n *\r\n * @function Phaser.Math.RandomXYZ\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec3 - The Vector to compute random values for.\r\n * @param {number} [radius=1] - The radius.\r\n *\r\n * @return {Phaser.Math.Vector3} The given Vector.\r\n */\r\nvar RandomXYZ = function (vec3, radius)\r\n{\r\n    if (radius === undefined) { radius = 1; }\r\n\r\n    var r = Math.random() * 2 * Math.PI;\r\n    var z = (Math.random() * 2) - 1;\r\n    var zScale = Math.sqrt(1 - z * z) * radius;\r\n\r\n    vec3.x = Math.cos(r) * zScale;\r\n    vec3.y = Math.sin(r) * zScale;\r\n    vec3.z = z * radius;\r\n\r\n    return vec3;\r\n};\r\n\r\nmodule.exports = RandomXYZ;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random four-dimensional vector.\r\n *\r\n * @function Phaser.Math.RandomXYZW\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector4} vec4 - The Vector to compute random values for.\r\n * @param {number} [scale=1] - The scale of the random values.\r\n *\r\n * @return {Phaser.Math.Vector4} The given Vector.\r\n */\r\nvar RandomXYZW = function (vec4, scale)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n\r\n    // TODO: Not spherical; should fix this for more uniform distribution\r\n    vec4.x = (Math.random() * 2 - 1) * scale;\r\n    vec4.y = (Math.random() * 2 - 1) * scale;\r\n    vec4.z = (Math.random() * 2 - 1) * scale;\r\n    vec4.w = (Math.random() * 2 - 1) * scale;\r\n\r\n    return vec4;\r\n};\r\n\r\nmodule.exports = RandomXYZW;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a given point by a given angle around the origin (0, 0), in an anti-clockwise direction.\r\n *\r\n * @function Phaser.Math.Rotate\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} angle - The angle to be rotated by in an anticlockwise direction.\r\n *\r\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle in an anticlockwise direction.\r\n */\r\nvar Rotate = function (point, angle)\r\n{\r\n    var x = point.x;\r\n    var y = point.y;\r\n\r\n    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));\r\n    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle`.\r\n *\r\n * @function Phaser.Math.RotateAround\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle around the given coordinates.\r\n */\r\nvar RotateAround = function (point, x, y, angle)\r\n{\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var tx = point.x - x;\r\n    var ty = point.y - y;\r\n\r\n    point.x = tx * c - ty * s + x;\r\n    point.y = tx * s + ty * c + y;\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAround;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.\r\n *\r\n * @function Phaser.Math.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n * @param {number} distance - The distance from (x, y) to place the point at.\r\n *\r\n * @return {Phaser.Geom.Point} The given point.\r\n */\r\nvar RotateAroundDistance = function (point, x, y, angle, distance)\r\n{\r\n    var t = angle + Math.atan2(point.y - y, point.x - x);\r\n\r\n    point.x = x + (distance * Math.cos(t));\r\n    point.y = y + (distance * Math.sin(t));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAroundDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector3 = require('../math/Vector3');\r\nvar Matrix4 = require('../math/Matrix4');\r\nvar Quaternion = require('../math/Quaternion');\r\n\r\nvar tmpMat4 = new Matrix4();\r\nvar tmpQuat = new Quaternion();\r\nvar tmpVec3 = new Vector3();\r\n\r\n/**\r\n * Rotates a vector in place by axis angle.\r\n *\r\n * This is the same as transforming a point by an\r\n * axis-angle quaternion, but it has higher precision.\r\n *\r\n * @function Phaser.Math.RotateVec3\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec - The vector to be rotated.\r\n * @param {Phaser.Math.Vector3} axis - The axis to rotate around.\r\n * @param {number} radians - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Math.Vector3} The given vector.\r\n */\r\nvar RotateVec3 = function (vec, axis, radians)\r\n{\r\n    //  Set the quaternion to our axis angle\r\n    tmpQuat.setAxisAngle(axis, radians);\r\n\r\n    //  Create a rotation matrix from the axis angle\r\n    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));\r\n\r\n    //  Multiply our vector by the rotation matrix\r\n    return vec.transformMat4(tmpMat4);\r\n};\r\n\r\nmodule.exports = RotateVec3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.\r\n *\r\n * @function Phaser.Math.RoundAwayFromZero\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to round.\r\n *\r\n * @return {number} The rounded number, rounded away from zero.\r\n */\r\nvar RoundAwayFromZero = function (value)\r\n{\r\n    // \"Opposite\" of truncate.\r\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\r\n};\r\n\r\nmodule.exports = RoundAwayFromZero;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a value to the given precision.\r\n * \r\n * For example:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456, 0) = 123\r\n * RoundTo(123.456, 1) = 120\r\n * RoundTo(123.456, 2) = 100\r\n * ```\r\n * \r\n * To round the decimal, i.e. to round to precision, pass in a negative `place`:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456789, 0) = 123\r\n * RoundTo(123.456789, -1) = 123.5\r\n * RoundTo(123.456789, -2) = 123.46\r\n * RoundTo(123.456789, -3) = 123.457\r\n * ```\r\n *\r\n * @function Phaser.Math.RoundTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {integer} [place=0] - The place to round to. Positive to round the units, negative to round the decimal.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar RoundTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.round(value * p) / p;\r\n};\r\n\r\nmodule.exports = RoundTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a series of sine and cosine values.\r\n *\r\n * @function Phaser.Math.SinCosTableGenerator\r\n * @since 3.0.0\r\n *\r\n * @param {number} length - The number of values to generate.\r\n * @param {number} [sinAmp=1] - The sine value amplitude.\r\n * @param {number} [cosAmp=1] - The cosine value amplitude.\r\n * @param {number} [frequency=1] - The frequency of the values.\r\n *\r\n * @return {Phaser.Types.Math.SinCosTable} The generated values.\r\n */\r\nvar SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)\r\n{\r\n    if (sinAmp === undefined) { sinAmp = 1; }\r\n    if (cosAmp === undefined) { cosAmp = 1; }\r\n    if (frequency === undefined) { frequency = 1; }\r\n\r\n    frequency *= Math.PI / length;\r\n\r\n    var cos = [];\r\n    var sin = [];\r\n\r\n    for (var c = 0; c < length; c++)\r\n    {\r\n        cosAmp -= sinAmp * frequency;\r\n        sinAmp += cosAmp * frequency;\r\n\r\n        cos[c] = cosAmp;\r\n        sin[c] = sinAmp;\r\n    }\r\n\r\n    return {\r\n        sin: sin,\r\n        cos: cos,\r\n        length: length\r\n    };\r\n};\r\n\r\nmodule.exports = SinCosTableGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmoothStep = function (x, min, max)\r\n{\r\n    if (x <= min)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (x >= max)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    x = (x - min) / (max - min);\r\n\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smoother interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.\r\n *\r\n * @function Phaser.Math.SmootherStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmootherStep = function (x, min, max)\r\n{\r\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\r\n\r\n    return x * x * x * (x * (x * 6 - 15) + 10);\r\n};\r\n\r\nmodule.exports = SmootherStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Returns a Vec2 containing the x and y position of the given index in a `width` x `height` sized grid.\r\n * \r\n * For example, in a 6 x 4 grid, index 16 would equal x: 4 y: 2.\r\n * \r\n * If the given index is out of range an empty Vec2 is returned.\r\n *\r\n * @function Phaser.Math.ToXY\r\n * @since 3.19.0\r\n *\r\n * @param {integer} index - The position within the grid to get the x/y value for.\r\n * @param {integer} width - The width of the grid.\r\n * @param {integer} height - The height of the grid.\r\n * @param {Phaser.Math.Vector2} [out] - An optional Vector2 to store the result in. If not given, a new Vector2 instance will be created.\r\n *\r\n * @return {Phaser.Math.Vector2} A Vector2 where the x and y properties contain the given grid index.\r\n */\r\nvar ToXY = function (index, width, height, out)\r\n{\r\n    if (out === undefined) { out = new Vector2(); }\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n    var total = width * height;\r\n\r\n    if (index > 0 && index <= total)\r\n    {\r\n        if (index > width - 1)\r\n        {\r\n            y = Math.floor(index / width);\r\n            x = index - (y * width);\r\n        }\r\n        else\r\n        {\r\n            x = index;\r\n        }\r\n\r\n        out.set(x, y);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Takes the `x` and `y` coordinates and transforms them into the same space as\r\n * defined by the position, rotation and scale values.\r\n *\r\n * @function Phaser.Math.TransformXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x coordinate to be transformed.\r\n * @param {number} y - The y coordinate to be transformed.\r\n * @param {number} positionX - Horizontal position of the transform point.\r\n * @param {number} positionY - Vertical position of the transform point.\r\n * @param {number} rotation - Rotation of the transform point, in radians.\r\n * @param {number} scaleX - Horizontal scale of the transform point.\r\n * @param {number} scaleY - Vertical scale of the transform point.\r\n * @param {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} [output] - The output vector, point or object for the translated coordinates.\r\n *\r\n * @return {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} The translated point.\r\n */\r\nvar TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output)\r\n{\r\n    if (output === undefined) { output = new Vector2(); }\r\n\r\n    var radianSin = Math.sin(rotation);\r\n    var radianCos = Math.cos(rotation);\r\n\r\n    // Rotate and Scale\r\n    var a = radianCos * scaleX;\r\n    var b = radianSin * scaleX;\r\n    var c = -radianSin * scaleY;\r\n    var d = radianCos * scaleY;\r\n\r\n    //  Invert\r\n    var id = 1 / ((a * d) + (c * -b));\r\n\r\n    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);\r\n    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = TransformXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\r\nvar Vector2 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector2 (x, y)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n        }\r\n        else\r\n        {\r\n            if (y === undefined) { y = x; }\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector2.\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x || 0;\r\n        this.y = src.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the component values of this Vector from a given Vector2Like object.\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setFromObject: function (obj)\r\n    {\r\n        this.x = obj.x || 0;\r\n        this.y = obj.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    set: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setTo: function (x, y)\r\n    {\r\n        return this.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} azimuth - The angular coordinate, in radians.\r\n     * @param {number} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setToPolar: function (azimuth, radius)\r\n    {\r\n        if (radius == null) { radius = 1; }\r\n\r\n        this.x = Math.cos(azimuth) * radius;\r\n        this.y = Math.sin(azimuth) * radius;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n     *\r\n     * @return {boolean} Whether the given Vector is equal to this Vector.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y));\r\n    },\r\n\r\n    /**\r\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n     */\r\n    angle: function ()\r\n    {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n\r\n        var angle = Math.atan2(this.y, this.x);\r\n\r\n        if (angle < 0)\r\n        {\r\n            angle += 2 * Math.PI;\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    add: function (src)\r\n    {\r\n        this.x += src.x;\r\n        this.y += src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    subtract: function (src)\r\n    {\r\n        this.x -= src.x;\r\n        this.y -= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        this.x *= src.x;\r\n        this.y *= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    scale: function (value)\r\n    {\r\n        if (isFinite(value))\r\n        {\r\n            this.x *= value;\r\n            this.y *= value;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    divide: function (src)\r\n    {\r\n        this.x /= src.x;\r\n        this.y /= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x` and `y` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return x * x + y * y;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var len = x * x + y * y;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Right-hand normalize (make unit length) this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeRightHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y * -1;\r\n        this.y = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (src)\r\n    {\r\n        return this.x * src.x + this.y * src.y;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n     *\r\n     * @return {number} The cross product of this Vector and the given Vector.\r\n     */\r\n    cross: function (src)\r\n    {\r\n        return this.x * src.y - this.y * src.x;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    lerp: function (src, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n\r\n        this.x = ax + t * (src.x - ax);\r\n        this.y = ay + t * (src.y - ay);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[3] * y + m[6];\r\n        this.y = m[1] * x + m[4] * y + m[7];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[13];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\r\nVector2.ZERO = new Vector2();\r\n\r\n/**\r\n * A static right Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.RIGHT = new Vector2(1, 0);\r\n\r\n/**\r\n * A static left Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.LEFT = new Vector2(-1, 0);\r\n\r\n/**\r\n * A static up Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.UP = new Vector2(0, -1);\r\n\r\n/**\r\n * A static down Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.DOWN = new Vector2(0, 1);\r\n\r\n/**\r\n * A static one Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.ONE = new Vector2(1, 1);\r\n\r\nmodule.exports = Vector2;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 3D space.\r\n *\r\n * A three-component vector.\r\n *\r\n * @class Vector3\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n */\r\nvar Vector3 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector3 (x, y, z)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Set this Vector to point up.\r\n     *\r\n     * Sets the y component of the vector to 1, and the others to 0.\r\n     *\r\n     * @method Phaser.Math.Vector3#up\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    up: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 1;\r\n        this.z = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector3.\r\n     *\r\n     * @method Phaser.Math.Vector3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross (vector) product of two given Vectors.\r\n     *\r\n     * @method Phaser.Math.Vector3#crossVectors\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - The first Vector to multiply.\r\n     * @param {Phaser.Math.Vector3} b - The second Vector to multiply.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    crossVectors: function (a, b)\r\n    {\r\n        var ax = a.x;\r\n        var ay = a.y;\r\n        var az = a.z;\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector3#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.\r\n     *\r\n     * @return {boolean} True if the two vectors strictly match, otherwise false.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z));\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.\r\n     *\r\n     * @method Phaser.Math.Vector3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y and z components.\r\n     * @param {number} [y] - The y value to set for this Vector.\r\n     * @param {number} [z] - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    set: function (x, y, z)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector3#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector3#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        if (isFinite(scale))\r\n        {\r\n            this.x *= scale;\r\n            this.y *= scale;\r\n            this.z *= scale;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.z = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y` and `z` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector3#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector3#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        return x * x + y * y + z * z;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector3#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var len = x * x + y * y + z * z;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to dot product with this Vector3.\r\n     *\r\n     * @return {number} The dot product of this Vector and `v`.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector to cross product with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    cross: function (v)\r\n    {\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var bx = v.x;\r\n        var by = v.y;\r\n        var bz = v.z;\r\n\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        this.x = x * m[0] + y * m[3] + z * m[6];\r\n        this.y = x * m[1] + y * m[4] + z * m[7];\r\n        this.z = x * m[2] + y * m[5] + z * m[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13];\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms the coordinates of this Vector3 with the given Matrix4.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformCoordinates: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];\r\n        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];\r\n        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];\r\n        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];\r\n\r\n        this.x = tx / tw;\r\n        this.y = ty / tw;\r\n        this.z = tz / tw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,\r\n     * e.g. unprojecting a 2D point into 3D space.\r\n     *\r\n     * @method Phaser.Math.Vector3#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to multiply this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    project: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        var a00 = m[0];\r\n        var a01 = m[1];\r\n        var a02 = m[2];\r\n        var a03 = m[3];\r\n        var a10 = m[4];\r\n        var a11 = m[5];\r\n        var a12 = m[6];\r\n        var a13 = m[7];\r\n        var a20 = m[8];\r\n        var a21 = m[9];\r\n        var a22 = m[10];\r\n        var a23 = m[11];\r\n        var a30 = m[12];\r\n        var a31 = m[13];\r\n        var a32 = m[14];\r\n        var a33 = m[15];\r\n\r\n        var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);\r\n\r\n        this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;\r\n        this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;\r\n        this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Unproject this point from 2D space to 3D space.\r\n     * The point should have its x and y properties set to\r\n     * 2D screen space, and the z either at 0 (near plane)\r\n     * or 1 (far plane). The provided matrix is assumed to already\r\n     * be combined, i.e. projection * view * model.\r\n     *\r\n     * After this operation, this vector's (x, y, z) components will\r\n     * represent the unprojected 3D coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector3#unproject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.\r\n     * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    unproject: function (viewport, invProjectionView)\r\n    {\r\n        var viewX = viewport.x;\r\n        var viewY = viewport.y;\r\n        var viewWidth = viewport.z;\r\n        var viewHeight = viewport.w;\r\n\r\n        var x = this.x - viewX;\r\n        var y = (viewHeight - this.y - 1) - viewY;\r\n        var z = this.z;\r\n\r\n        this.x = (2 * x) / viewWidth - 1;\r\n        this.y = (2 * y) / viewHeight - 1;\r\n        this.z = 2 * z - 1;\r\n\r\n        return this.project(invProjectionView);\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector3#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.ZERO\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.ZERO = new Vector3();\r\n\r\n/**\r\n * A static right Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.RIGHT\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.RIGHT = new Vector3(1, 0, 0);\r\n\r\n/**\r\n * A static left Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.LEFT\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.LEFT = new Vector3(-1, 0, 0);\r\n\r\n/**\r\n * A static up Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.UP\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.UP = new Vector3(0, -1, 0);\r\n\r\n/**\r\n * A static down Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.DOWN\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.DOWN = new Vector3(0, 1, 0);\r\n\r\n/**\r\n * A static forward Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.FORWARD\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.FORWARD = new Vector3(0, 0, 1);\r\n\r\n/**\r\n * A static back Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.BACK\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.BACK = new Vector3(0, 0, -1);\r\n\r\n/**\r\n * A static one Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.ONE\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.ONE = new Vector3(1, 1, 1);\r\n\r\nmodule.exports = Vector3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 4D space.\r\n *\r\n * A four-component vector.\r\n *\r\n * @class Vector4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Vector4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector4 (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        /**\r\n         * The w component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.w = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector4.\r\n     *\r\n     * @method Phaser.Math.Vector4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} A clone of this Vector4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n        this.w = src.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict quality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector4#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The vector to check equality with.\r\n     *\r\n     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.\r\n     *\r\n     * @method Phaser.Math.Vector4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.\r\n     * @param {number} y - The y value to set for this Vector.\r\n     * @param {number} z - The z value to set for this Vector.\r\n     * @param {number} w - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n        this.w += v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n        this.w -= v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector4#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n        this.w *= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n        this.w /= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz + dw * dw;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y`, `z` and `w` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        this.w = -this.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        // TODO: is this really the same as Vector3?\r\n        // Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\r\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector4#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n//  TODO: Check if these are required internally, if not, remove.\r\nVector4.prototype.sub = Vector4.prototype.subtract;\r\nVector4.prototype.mul = Vector4.prototype.multiply;\r\nVector4.prototype.div = Vector4.prototype.divide;\r\nVector4.prototype.dist = Vector4.prototype.distance;\r\nVector4.prototype.distSq = Vector4.prototype.distanceSq;\r\nVector4.prototype.len = Vector4.prototype.length;\r\nVector4.prototype.lenSq = Vector4.prototype.lengthSq;\r\n\r\nmodule.exports = Vector4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the two values are within the given `tolerance` of each other.\r\n *\r\n * @function Phaser.Math.Within\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value to use in the calculation.\r\n * @param {number} b - The second value to use in the calculation.\r\n * @param {number} tolerance - The tolerance. Anything equal to or less than this value is considered as being within range.\r\n *\r\n * @return {boolean} Returns `true` if `a` is less than or equal to the tolerance of `b`.\r\n */\r\nvar Within = function (a, b, tolerance)\r\n{\r\n    return (Math.abs(a - b) <= tolerance);\r\n};\r\n\r\nmodule.exports = Within;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * @function Phaser.Math.Angle.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar Between = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * Calculates the angle of the vector from the first point to the second point.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPoints\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\r\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPoints = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\r\n};\r\n\r\nmodule.exports = BetweenPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.BetweenPoints} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPointsY\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\r\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPointsY = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.x - point1.x, point2.y - point1.y);\r\n};\r\n\r\nmodule.exports = BetweenPointsY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.Between} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenY = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(x2 - x1, y2 - y1);\r\n};\r\n\r\nmodule.exports = BetweenY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const');\r\n\r\n/**\r\n * Takes an angle in Phasers default clockwise format and converts it so that\r\n * 0 is North, 90 is West, 180 is South and 270 is East,\r\n * therefore running counter-clockwise instead of clockwise.\r\n * \r\n * You can pass in the angle from a Game Object using:\r\n * \r\n * ```javascript\r\n * var converted = CounterClockwise(gameobject.rotation);\r\n * ```\r\n * \r\n * All values for this function are in radians.\r\n *\r\n * @function Phaser.Math.Angle.CounterClockwise\r\n * @since 3.16.0\r\n *\r\n * @param {number} angle - The angle to convert, in radians.\r\n *\r\n * @return {number} The converted angle, in radians.\r\n */\r\nvar CounterClockwise = function (angle)\r\n{\r\n    if (angle > Math.PI)\r\n    {\r\n        angle -= CONST.PI2;\r\n    }\r\n\r\n    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);\r\n};\r\n\r\nmodule.exports = CounterClockwise;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Normalize an angle to the [0, 2pi] range.\r\n *\r\n * @function Phaser.Math.Angle.Normalize\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to normalize, in radians.\r\n *\r\n * @return {number} The normalized angle, in radians.\r\n */\r\nvar Normalize = function (angle)\r\n{\r\n    angle = angle % (2 * Math.PI);\r\n\r\n    if (angle >= 0)\r\n    {\r\n        return angle;\r\n    }\r\n    else\r\n    {\r\n        return angle + 2 * Math.PI;\r\n    }\r\n};\r\n\r\nmodule.exports = Normalize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Normalize = require('./Normalize');\r\n\r\n/**\r\n * Reverse the given angle.\r\n *\r\n * @function Phaser.Math.Angle.Reverse\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to reverse, in radians.\r\n *\r\n * @return {number} The reversed angle, in radians.\r\n */\r\nvar Reverse = function (angle)\r\n{\r\n    return Normalize(angle + Math.PI);\r\n};\r\n\r\nmodule.exports = Reverse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../const');\r\n\r\n/**\r\n * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.\r\n *\r\n * @function Phaser.Math.Angle.RotateTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} currentAngle - The current angle, in radians.\r\n * @param {number} targetAngle - The target angle to rotate to, in radians.\r\n * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\r\n *\r\n * @return {number} The adjusted angle.\r\n */\r\nvar RotateTo = function (currentAngle, targetAngle, lerp)\r\n{\r\n    if (lerp === undefined) { lerp = 0.05; }\r\n\r\n    if (currentAngle === targetAngle)\r\n    {\r\n        return currentAngle;\r\n    }\r\n\r\n    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))\r\n    {\r\n        currentAngle = targetAngle;\r\n    }\r\n    else\r\n    {\r\n        if (Math.abs(targetAngle - currentAngle) > Math.PI)\r\n        {\r\n            if (targetAngle < currentAngle)\r\n            {\r\n                targetAngle += MATH_CONST.PI2;\r\n            }\r\n            else\r\n            {\r\n                targetAngle -= MATH_CONST.PI2;\r\n            }\r\n        }\r\n\r\n        if (targetAngle > currentAngle)\r\n        {\r\n            currentAngle += lerp;\r\n        }\r\n        else if (targetAngle < currentAngle)\r\n        {\r\n            currentAngle -= lerp;\r\n        }\r\n    }\r\n\r\n    return currentAngle;\r\n};\r\n\r\nmodule.exports = RotateTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Gets the shortest angle between `angle1` and `angle2`.\r\n *\r\n * Both angles must be in the range -180 to 180, which is the same clamped\r\n * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n * this method and get the shortest angle back between the two of them.\r\n *\r\n * The angle returned will be in the same range. If the returned angle is\r\n * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n * a clockwise rotation.\r\n *\r\n * TODO: Wrap the angles in this function?\r\n *\r\n * @function Phaser.Math.Angle.ShortestBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle1 - The first angle in the range -180 to 180.\r\n * @param {number} angle2 - The second angle in the range -180 to 180.\r\n *\r\n * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\r\n */\r\nvar ShortestBetween = function (angle1, angle2)\r\n{\r\n    var difference = angle2 - angle1;\r\n\r\n    if (difference === 0)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    var times = Math.floor((difference - (-180)) / 360);\r\n\r\n    return difference - (times * 360);\r\n\r\n};\r\n\r\nmodule.exports = ShortestBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathWrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle.\r\n *\r\n * Wraps the angle to a value in the range of -PI to PI.\r\n *\r\n * @function Phaser.Math.Angle.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in radians.\r\n *\r\n * @return {number} The wrapped angle, in radians.\r\n */\r\nvar Wrap = function (angle)\r\n{\r\n    return MathWrap(angle, -Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Wrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle in degrees.\r\n *\r\n * Wraps the angle to a value in the range of -180 to 180.\r\n *\r\n * @function Phaser.Math.Angle.WrapDegrees\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in degrees.\r\n *\r\n * @return {number} The wrapped angle, in degrees.\r\n */\r\nvar WrapDegrees = function (angle)\r\n{\r\n    return Wrap(angle, -180, 180);\r\n};\r\n\r\nmodule.exports = WrapDegrees;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Angle\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./Between'),\r\n    BetweenPoints: require('./BetweenPoints'),\r\n    BetweenPointsY: require('./BetweenPointsY'),\r\n    BetweenY: require('./BetweenY'),\r\n    CounterClockwise: require('./CounterClockwise'),\r\n    Normalize: require('./Normalize'),\r\n    Reverse: require('./Reverse'),\r\n    RotateTo: require('./RotateTo'),\r\n    ShortestBetween: require('./ShortestBetween'),\r\n    Wrap: require('./Wrap'),\r\n    WrapDegrees: require('./WrapDegrees')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = {\r\n\r\n    /**\r\n     * The value of PI * 2.\r\n     * \r\n     * @name Phaser.Math.PI2\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PI2: Math.PI * 2,\r\n\r\n    /**\r\n     * The value of PI * 0.5.\r\n     * \r\n     * @name Phaser.Math.TAU\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TAU: Math.PI * 0.5,\r\n\r\n    /**\r\n     * An epsilon value (1.0e-6)\r\n     * \r\n     * @name Phaser.Math.EPSILON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    EPSILON: 1.0e-6,\r\n\r\n    /**\r\n     * For converting degrees to radians (PI / 180)\r\n     * \r\n     * @name Phaser.Math.DEG_TO_RAD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    DEG_TO_RAD: Math.PI / 180,\r\n\r\n    /**\r\n     * For converting radians to degrees (180 / PI)\r\n     * \r\n     * @name Phaser.Math.RAD_TO_DEG\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    RAD_TO_DEG: 180 / Math.PI,\r\n\r\n    /**\r\n     * An instance of the Random Number Generator.\r\n     * This is not set until the Game boots.\r\n     * \r\n     * @name Phaser.Math.RND\r\n     * @type {Phaser.Math.RandomDataGenerator}\r\n     * @since 3.0.0\r\n     */\r\n    RND: null\r\n\r\n};\r\n\r\nmodule.exports = MATH_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points) to the power of `pow`.\r\n *\r\n * @function Phaser.Math.Distance.Power\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n * @param {number} pow - The exponent.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistancePower = function (x1, y1, x2, y2, pow)\r\n{\r\n    if (pow === undefined) { pow = 2; }\r\n\r\n    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\r\n};\r\n\r\nmodule.exports = DistancePower;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points), squared.\r\n *\r\n * @function Phaser.Math.Distance.Squared\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point, squared.\r\n */\r\nvar DistanceSquared = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return dx * dx + dy * dy;\r\n};\r\n\r\nmodule.exports = DistanceSquared;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Distance\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./DistanceBetween'),\r\n    Power: require('./DistancePower'),\r\n    Squared: require('./DistanceSquared')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Back.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    return v * v * ((overshoot + 1) * v - overshoot);\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Back.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    var s = overshoot * 1.525;\r\n\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * (v * v * ((s + 1) * v - s));\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Back.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    return --v * v * ((overshoot + 1) * v + overshoot) + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Back\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    v = 1 - v;\r\n\r\n    if (v < 1 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * v * v);\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);\r\n    }\r\n    else\r\n    {\r\n        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    var reverse = false;\r\n\r\n    if (v < 0.5)\r\n    {\r\n        v = 1 - (v * 2);\r\n        reverse = true;\r\n    }\r\n    else\r\n    {\r\n        v = (v * 2) - 1;\r\n    }\r\n\r\n    if (v < 1 / 2.75)\r\n    {\r\n        v = 7.5625 * v * v;\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\r\n    }\r\n    else\r\n    {\r\n        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\r\n    }\r\n\r\n    if (reverse)\r\n    {\r\n        return (1 - v) * 0.5;\r\n    }\r\n    else\r\n    {\r\n        return v * 0.5 + 0.5;\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    if (v < 1 / 2.75)\r\n    {\r\n        return 7.5625 * v * v;\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\r\n    }\r\n    else\r\n    {\r\n        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Bounce\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Circular.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return 1 - Math.sqrt(1 - v * v);\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Circular.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return -0.5 * (Math.sqrt(1 - v * v) - 1);\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Circular.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return Math.sqrt(1 - (--v * v));\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Circular\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * v + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return --v * v * v + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Cubic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        if ((v *= 2) < 1)\r\n        {\r\n            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\r\n        }\r\n        else\r\n        {\r\n            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Elastic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Expo.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return Math.pow(2, 10 * (v - 1)) - 0.001;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Expo.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * Math.pow(2, 10 * (v - 1));\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Expo.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return 1 - Math.pow(2, -10 * v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Expo\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Back: require('./back'),\r\n    Bounce: require('./bounce'),\r\n    Circular: require('./circular'),\r\n    Cubic: require('./cubic'),\r\n    Elastic: require('./elastic'),\r\n    Expo: require('./expo'),\r\n    Linear: require('./linear'),\r\n    Quadratic: require('./quadratic'),\r\n    Quartic: require('./quartic'),\r\n    Quintic: require('./quintic'),\r\n    Sine: require('./sine'),\r\n    Stepped: require('./stepped')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Linear easing (no variation).\r\n *\r\n * @function Phaser.Math.Easing.Linear.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Linear = function (v)\r\n{\r\n    return v;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Linear\r\n */\r\n\r\nmodule.exports = require('./Linear');\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v;\r\n    }\r\n    else\r\n    {\r\n        return -0.5 * (--v * (v - 2) - 1);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return v * (2 - v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quadratic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return -0.5 * ((v -= 2) * v * v * v - 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return 1 - (--v * v * v * v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quartic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * v * v * v + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return --v * v * v * v * v + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quintic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Sine.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return 1 - Math.cos(v * Math.PI / 2);\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Sine.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (1 - Math.cos(Math.PI * v));\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Sine.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return Math.sin(v * Math.PI / 2);\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Sine\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Stepped easing.\r\n *\r\n * @function Phaser.Math.Easing.Stepped.Stepped\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [steps=1] - The number of steps in the ease.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Stepped = function (v, steps)\r\n{\r\n    if (steps === undefined) { steps = 1; }\r\n\r\n    if (v <= 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v >= 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return (((steps * v) | 0) + 1) * (1 / steps);\r\n    }\r\n};\r\n\r\nmodule.exports = Stepped;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Stepped\r\n */\r\n\r\nmodule.exports = require('./Stepped');\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy ceiling of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The fuzzy ceiling of the value.\r\n */\r\nvar Ceil = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.ceil(value - epsilon);\r\n};\r\n\r\nmodule.exports = Ceil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether the given values are fuzzily equal.\r\n *\r\n * Two numbers are fuzzily equal if their difference is less than `epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.Equal\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if the values are fuzzily equal, otherwise `false`.\r\n */\r\nvar Equal = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.abs(a - b) < epsilon;\r\n};\r\n\r\nmodule.exports = Equal;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy floor of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The floor of the value.\r\n */\r\nvar Floor = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.floor(value + epsilon);\r\n};\r\n\r\nmodule.exports = Floor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily greater than `b`.\r\n *\r\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.GreaterThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\r\n */\r\nvar GreaterThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a > b - epsilon;\r\n};\r\n\r\nmodule.exports = GreaterThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily less than `b`.\r\n *\r\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.LessThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\r\n */\r\nvar LessThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a < b + epsilon;\r\n};\r\n\r\nmodule.exports = LessThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Fuzzy\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./Ceil'),\r\n    Equal: require('./Equal'),\r\n    Floor: require('./Floor'),\r\n    GreaterThan: require('./GreaterThan'),\r\n    LessThan: require('./LessThan')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Math\r\n */\r\n\r\nvar PhaserMath = {\r\n\r\n    //  Collections of functions\r\n    Angle: require('./angle/'),\r\n    Distance: require('./distance/'),\r\n    Easing: require('./easing/'),\r\n    Fuzzy: require('./fuzzy/'),\r\n    Interpolation: require('./interpolation/'),\r\n    Pow2: require('./pow2/'),\r\n    Snap: require('./snap/'),\r\n\r\n    //  Expose the RNG Class\r\n    RandomDataGenerator: require('./random-data-generator/RandomDataGenerator'),\r\n\r\n    //  Single functions\r\n    Average: require('./Average'),\r\n    Bernstein: require('./Bernstein'),\r\n    Between: require('./Between'),\r\n    CatmullRom: require('./CatmullRom'),\r\n    CeilTo: require('./CeilTo'),\r\n    Clamp: require('./Clamp'),\r\n    DegToRad: require('./DegToRad'),\r\n    Difference: require('./Difference'),\r\n    Factorial: require('./Factorial'),\r\n    FloatBetween: require('./FloatBetween'),\r\n    FloorTo: require('./FloorTo'),\r\n    FromPercent: require('./FromPercent'),\r\n    GetSpeed: require('./GetSpeed'),\r\n    IsEven: require('./IsEven'),\r\n    IsEvenStrict: require('./IsEvenStrict'),\r\n    Linear: require('./Linear'),\r\n    MaxAdd: require('./MaxAdd'),\r\n    MinSub: require('./MinSub'),\r\n    Percent: require('./Percent'),\r\n    RadToDeg: require('./RadToDeg'),\r\n    RandomXY: require('./RandomXY'),\r\n    RandomXYZ: require('./RandomXYZ'),\r\n    RandomXYZW: require('./RandomXYZW'),\r\n    Rotate: require('./Rotate'),\r\n    RotateAround: require('./RotateAround'),\r\n    RotateAroundDistance: require('./RotateAroundDistance'),\r\n    RoundAwayFromZero: require('./RoundAwayFromZero'),\r\n    RoundTo: require('./RoundTo'),\r\n    SinCosTableGenerator: require('./SinCosTableGenerator'),\r\n    SmootherStep: require('./SmootherStep'),\r\n    SmoothStep: require('./SmoothStep'),\r\n    ToXY: require('./ToXY'),\r\n    TransformXY: require('./TransformXY'),\r\n    Within: require('./Within'),\r\n    Wrap: require('./Wrap'),\r\n\r\n    //  Vector classes\r\n    Vector2: require('./Vector2'),\r\n    Vector3: require('./Vector3'),\r\n    Vector4: require('./Vector4'),\r\n    Matrix3: require('./Matrix3'),\r\n    Matrix4: require('./Matrix4'),\r\n    Quaternion: require('./Quaternion'),\r\n    RotateVec3: require('./RotateVec3')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\n\r\nPhaserMath = Extend(false, PhaserMath, CONST);\r\n\r\n//  Export it\r\n\r\nmodule.exports = PhaserMath;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bernstein = require('../Bernstein');\r\n\r\n/**\r\n * A bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Bezier\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar BezierInterpolation = function (v, k)\r\n{\r\n    var b = 0;\r\n    var n = v.length - 1;\r\n\r\n    for (var i = 0; i <= n; i++)\r\n    {\r\n        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);\r\n    }\r\n\r\n    return b;\r\n};\r\n\r\nmodule.exports = BezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CatmullRom = require('../CatmullRom');\r\n\r\n/**\r\n * A Catmull-Rom interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CatmullRomInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (v[0] === v[m])\r\n    {\r\n        if (k < 0)\r\n        {\r\n            i = Math.floor(f = m * (1 + k));\r\n        }\r\n\r\n        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);\r\n    }\r\n    else\r\n    {\r\n        if (k < 0)\r\n        {\r\n            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);\r\n        }\r\n\r\n        if (k > 1)\r\n        {\r\n            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);\r\n        }\r\n\r\n        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);\r\n    }\r\n};\r\n\r\nmodule.exports = CatmullRomInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return 3 * k * k * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P3 (t, p)\r\n{\r\n    return t * t * t * p;\r\n}\r\n\r\n/**\r\n * A cubic bezier interpolation method.\r\n *\r\n * https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\r\n *\r\n * @function Phaser.Math.Interpolation.CubicBezier\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The first control point.\r\n * @param {number} p2 - The second control point.\r\n * @param {number} p3 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CubicBezierInterpolation = function (t, p0, p1, p2, p3)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\r\n};\r\n\r\nmodule.exports = CubicBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Linear = require('../Linear');\r\n\r\n/**\r\n * A linear interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Linear\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Linear_interpolation}\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {!number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {!number} The interpolated value.\r\n */\r\nvar LinearInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (k < 0)\r\n    {\r\n        return Linear(v[0], v[1], f);\r\n    }\r\n    else if (k > 1)\r\n    {\r\n        return Linear(v[m], v[m - 1], m - f);\r\n    }\r\n    else\r\n    {\r\n        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);\r\n    }\r\n};\r\n\r\nmodule.exports = LinearInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    return 2 * (1 - t) * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return t * t * p;\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\r\n\r\n/**\r\n * A quadratic bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.QuadraticBezier\r\n * @since 3.2.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The control point.\r\n * @param {number} p2 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar QuadraticBezierInterpolation = function (t, p0, p1, p2)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2);\r\n};\r\n\r\nmodule.exports = QuadraticBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmoothStep = require('../SmoothStep');\r\n\r\n/**\r\n * A Smooth Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmoothStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmoothStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmoothStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmoothStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmootherStep = require('../SmootherStep');\r\n\r\n/**\r\n * A Smoother Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmootherStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmootherStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmootherStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmootherStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Interpolation\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Bezier: require('./BezierInterpolation'),\r\n    CatmullRom: require('./CatmullRomInterpolation'),\r\n    CubicBezier: require('./CubicBezierInterpolation'),\r\n    Linear: require('./LinearInterpolation'),\r\n    QuadraticBezier: require('./QuadraticBezierInterpolation'),\r\n    SmoothStep: require('./SmoothStepInterpolation'),\r\n    SmootherStep: require('./SmootherStepInterpolation')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the nearest power of 2 to the given `value`.\r\n *\r\n * @function Phaser.Math.Pow2.GetPowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n *\r\n * @return {integer} The nearest power of 2 to `value`.\r\n */\r\nvar GetPowerOfTwo = function (value)\r\n{\r\n    var index = Math.log(value) / 0.6931471805599453;\r\n\r\n    return (1 << Math.ceil(index));\r\n};\r\n\r\nmodule.exports = GetPowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given `width` and `height` are a power of two.\r\n * Useful for checking texture dimensions.\r\n *\r\n * @function Phaser.Math.Pow2.IsSizePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} width - The width.\r\n * @param {number} height - The height.\r\n *\r\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\r\n */\r\nvar IsSizePowerOfTwo = function (width, height)\r\n{\r\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsSizePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tests the value and returns `true` if it is a power of two.\r\n *\r\n * @function Phaser.Math.Pow2.IsValuePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to check if it's a power of two.\r\n *\r\n * @return {boolean} Returns `true` if `value` is a power of two, otherwise `false`.\r\n */\r\nvar IsValuePowerOfTwo = function (value)\r\n{\r\n    return (value > 0 && (value & (value - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsValuePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Pow2\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    GetNext: require('./GetPowerOfTwo'),\r\n    IsSize: require('./IsSizePowerOfTwo'),\r\n    IsValue: require('./IsValuePowerOfTwo')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A seeded Random Data Generator.\r\n * \r\n * Access via `Phaser.Math.RND` which is an instance of this class pre-defined\r\n * by Phaser. Or, create your own instance to use as you require.\r\n * \r\n * The `Math.RND` generator is seeded by the Game Config property value `seed`.\r\n * If no such config property exists, a random number is used.\r\n * \r\n * If you create your own instance of this class you should provide a seed for it.\r\n * If no seed is given it will use a 'random' one based on Date.now.\r\n *\r\n * @class RandomDataGenerator\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|string[])} [seeds] - The seeds to use for the random number generator.\r\n */\r\nvar RandomDataGenerator = new Class({\r\n\r\n    initialize:\r\n\r\n    function RandomDataGenerator (seeds)\r\n    {\r\n        if (seeds === undefined) { seeds = [ (Date.now() * Math.random()).toString() ]; }\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#c\r\n         * @type {number}\r\n         * @default 1\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.c = 1;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s0\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s0 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s1\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s1 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s2\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s2 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#n\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.2.0\r\n         */\r\n        this.n = 0;\r\n\r\n        /**\r\n         * Signs to choose from.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#signs\r\n         * @type {number[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.signs = [ -1, 1 ];\r\n\r\n        if (seeds)\r\n        {\r\n            this.init(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Private random helper.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rnd\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @return {number} A random number.\r\n     */\r\n    rnd: function ()\r\n    {\r\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n\r\n        this.c = t | 0;\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        this.s2 = t - this.c;\r\n\r\n        return this.s2;\r\n    },\r\n\r\n    /**\r\n     * Internal method that creates a seed hash.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#hash\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @param {string} data - The value to hash.\r\n     *\r\n     * @return {number} The hashed value.\r\n     */\r\n    hash: function (data)\r\n    {\r\n        var h;\r\n        var n = this.n;\r\n\r\n        data = data.toString();\r\n\r\n        for (var i = 0; i < data.length; i++)\r\n        {\r\n            n += data.charCodeAt(i);\r\n            h = 0.02519603282416938 * n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            h *= n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            n += h * 0x100000000;// 2^32\r\n        }\r\n\r\n        this.n = n;\r\n\r\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\r\n    },\r\n\r\n    /**\r\n     * Initialize the state of the random data generator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.\r\n     */\r\n    init: function (seeds)\r\n    {\r\n        if (typeof seeds === 'string')\r\n        {\r\n            this.state(seeds);\r\n        }\r\n        else\r\n        {\r\n            this.sow(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reset the seed of the random data generator.\r\n     *\r\n     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.\r\n     */\r\n    sow: function (seeds)\r\n    {\r\n        // Always reset to default seed\r\n        this.n = 0xefc8249d;\r\n        this.s0 = this.hash(' ');\r\n        this.s1 = this.hash(' ');\r\n        this.s2 = this.hash(' ');\r\n        this.c = 1;\r\n\r\n        if (!seeds)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Apply any seeds\r\n        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)\r\n        {\r\n            var seed = seeds[i];\r\n\r\n            this.s0 -= this.hash(seed);\r\n            this.s0 += ~~(this.s0 < 0);\r\n            this.s1 -= this.hash(seed);\r\n            this.s1 += ~~(this.s1 < 0);\r\n            this.s2 -= this.hash(seed);\r\n            this.s2 += ~~(this.s2 < 0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integer\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random integer between 0 and 2^32.\r\n     */\r\n    integer: function ()\r\n    {\r\n        // 2^32\r\n        return this.rnd() * 0x100000000;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#frac\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 1.\r\n     */\r\n    frac: function ()\r\n    {\r\n        // 2^-53\r\n        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#real\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 2^32.\r\n     */\r\n    real: function ()\r\n    {\r\n        return this.integer() + this.frac();\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integerInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    integerInRange: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     * This method is an alias for RandomDataGenerator.integerInRange.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#between\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    between: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#realInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    realInRange: function (min, max)\r\n    {\r\n        return this.frac() * (max - min) + min;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between -1 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#normal\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between -1 and 1.\r\n     */\r\n    normal: function ()\r\n    {\r\n        return 1 - (2 * this.frac());\r\n    },\r\n\r\n    /**\r\n     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#uuid\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} A valid RFC4122 version4 ID hex string\r\n     */\r\n    uuid: function ()\r\n    {\r\n        var a = '';\r\n        var b = '';\r\n\r\n        for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')\r\n        {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n\r\n        return b;\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#pick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */\r\n    pick: function (array)\r\n    {\r\n        return array[this.integerInRange(0, array.length - 1)];\r\n    },\r\n\r\n    /**\r\n     * Returns a sign to be used with multiplication operator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sign\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} -1 or +1.\r\n     */\r\n    sign: function ()\r\n    {\r\n        return this.pick(this.signs);\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array, favoring the earlier entries.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#weightedPick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */\r\n    weightedPick: function (array)\r\n    {\r\n        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];\r\n    },\r\n\r\n    /**\r\n     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#timestamp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random timestamp between min and max.\r\n     */\r\n    timestamp: function (min, max)\r\n    {\r\n        return this.realInRange(min || 946684800000, max || 1577862000000);\r\n    },\r\n\r\n    /**\r\n     * Returns a random angle between -180 and 180.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -180 and 180.\r\n     */\r\n    angle: function ()\r\n    {\r\n        return this.integerInRange(-180, 180);\r\n    },\r\n\r\n    /**\r\n     * Returns a random rotation in radians, between -3.141 and 3.141\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -3.141 and 3.141\r\n     */\r\n    rotation: function ()\r\n    {\r\n        return this.realInRange(-3.1415926, 3.1415926);\r\n    },\r\n\r\n    /**\r\n     * Gets or Sets the state of the generator. This allows you to retain the values\r\n     * that the generator is using between games, i.e. in a game save file.\r\n     *\r\n     * To seed this generator with a previously saved state you can pass it as the\r\n     * `seed` value in your game config, or call this method directly after Phaser has booted.\r\n     *\r\n     * Call this method with no parameters to return the current state.\r\n     *\r\n     * If providing a state it should match the same format that this method\r\n     * returns, which is a string with a header `!rnd` followed by the `c`,\r\n     * `s0`, `s1` and `s2` values respectively, each comma-delimited.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#state\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [state] - Generator state to be set.\r\n     *\r\n     * @return {string} The current state of the generator.\r\n     */\r\n    state: function (state)\r\n    {\r\n        if (typeof state === 'string' && state.match(/^!rnd/))\r\n        {\r\n            state = state.split(',');\r\n\r\n            this.c = parseFloat(state[1]);\r\n            this.s0 = parseFloat(state[2]);\r\n            this.s1 = parseFloat(state[3]);\r\n            this.s2 = parseFloat(state[4]);\r\n        }\r\n\r\n        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');\r\n    },\r\n\r\n    /**\r\n     * Shuffles the given array, using the current seed.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#shuffle\r\n     * @since 3.7.0\r\n     *\r\n     * @param {array} [array] - The array to be shuffled.\r\n     *\r\n     * @return {array} The shuffled array.\r\n     */\r\n    shuffle: function (array)\r\n    {\r\n        var len = array.length - 1;\r\n\r\n        for (var i = len; i > 0; i--)\r\n        {\r\n            var randomIndex = Math.floor(this.frac() * (i + 1));\r\n            var itemAtIndex = array[randomIndex];\r\n\r\n            array[randomIndex] = array[i];\r\n            array[i] = itemAtIndex;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RandomDataGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using ceil.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `15`.\r\n * As will `14` snap to `15`... but `16` will snap to `20`.\r\n *\r\n * @function Phaser.Math.Snap.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapCeil = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.ceil(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapCeil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using floor.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\r\n * As will `14` snap to `10`... but `16` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapFloor = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapFloor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using rounding.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10` whereas `14` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.To\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapTo = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.round(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Snap\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./SnapCeil'),\r\n    Floor: require('./SnapFloor'),\r\n    To: require('./SnapTo')\r\n\r\n};\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Global Plugin is installed just once into the Game owned Plugin Manager.\r\n * It can listen for Game events and respond to them.\r\n *\r\n * @class BasePlugin\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar BasePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function BasePlugin (pluginManager)\r\n    {\r\n        /**\r\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\r\n         * Can be used as a route to gain access to game systems and  events.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#pluginManager\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.pluginManager = pluginManager;\r\n\r\n        /**\r\n         * A reference to the Game instance this plugin is running under.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.game = pluginManager.game;\r\n\r\n        /**\r\n         * A reference to the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#scene\r\n         * @type {?Phaser.Scene}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#systems\r\n         * @type {?Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.systems;\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is first instantiated.\r\n     * It will never be called again on this instance.\r\n     * In here you can set-up whatever you need for this plugin to run.\r\n     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#init\r\n     * @since 3.8.0\r\n     *\r\n     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).\r\n     */\r\n    init: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is started.\r\n     * If a plugin is stopped, and then started again, this will get called again.\r\n     * Typically called immediately after `BasePlugin.init`.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#start\r\n     * @since 3.8.0\r\n     */\r\n    start: function ()\r\n    {\r\n        //  Here are the game-level events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the game closes down.\r\n\r\n        // var eventEmitter = this.game.events;\r\n\r\n        // eventEmitter.once('destroy', this.gameDestroy, this);\r\n        // eventEmitter.on('pause', this.gamePause, this);\r\n        // eventEmitter.on('resume', this.gameResume, this);\r\n        // eventEmitter.on('resize', this.gameResize, this);\r\n        // eventEmitter.on('prestep', this.gamePreStep, this);\r\n        // eventEmitter.on('step', this.gameStep, this);\r\n        // eventEmitter.on('poststep', this.gamePostStep, this);\r\n        // eventEmitter.on('prerender', this.gamePreRender, this);\r\n        // eventEmitter.on('postrender', this.gamePostRender, this);\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is stopped.\r\n     * The game code has requested that your plugin stop doing whatever it does.\r\n     * It is now considered as 'inactive' by the PluginManager.\r\n     * Handle that process here (i.e. stop listening for events, etc)\r\n     * If the plugin is started again then `BasePlugin.start` will be called again.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#stop\r\n     * @since 3.8.0\r\n     */\r\n    stop: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        //  Here are the Scene events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the Scene closes down.\r\n\r\n        // var eventEmitter = this.systems.events;\r\n\r\n        // eventEmitter.once('destroy', this.sceneDestroy, this);\r\n        // eventEmitter.on('start', this.sceneStart, this);\r\n        // eventEmitter.on('preupdate', this.scenePreUpdate, this);\r\n        // eventEmitter.on('update', this.sceneUpdate, this);\r\n        // eventEmitter.on('postupdate', this.scenePostUpdate, this);\r\n        // eventEmitter.on('pause', this.scenePause, this);\r\n        // eventEmitter.on('resume', this.sceneResume, this);\r\n        // eventEmitter.on('sleep', this.sceneSleep, this);\r\n        // eventEmitter.on('wake', this.sceneWake, this);\r\n        // eventEmitter.on('shutdown', this.sceneShutdown, this);\r\n        // eventEmitter.on('destroy', this.sceneDestroy, this);\r\n    },\r\n\r\n    /**\r\n     * Game instance has been destroyed.\r\n     * You must release everything in here, all references, all objects, free it all up.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BasePlugin;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar BasePlugin = require('./BasePlugin');\r\nvar Class = require('../utils/Class');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * A Scene Level Plugin is installed into every Scene and belongs to that Scene.\r\n * It can listen for Scene events and respond to them.\r\n * It can map itself to a Scene property, or into the Scene Systems, or both.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Plugins\r\n * @extends Phaser.Plugins.BasePlugin\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    Extends: BasePlugin,\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene, pluginManager)\r\n    {\r\n        BasePlugin.call(this, pluginManager);\r\n\r\n        this.scene = scene;\r\n        this.systems = scene.sys;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called when the Scene boots. It is only ever called once.\r\n     * \r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     * \r\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n     * Here are the Scene events you can listen to:\r\n     * \r\n     * start\r\n     * ready\r\n     * preupdate\r\n     * update\r\n     * postupdate\r\n     * resize\r\n     * pause\r\n     * resume\r\n     * sleep\r\n     * wake\r\n     * transitioninit\r\n     * transitionstart\r\n     * transitioncomplete\r\n     * transitionout\r\n     * shutdown\r\n     * destroy\r\n     * \r\n     * At the very least you should offer a destroy handler for when the Scene closes down, i.e:\r\n     *\r\n     * ```javascript\r\n     * var eventEmitter = this.systems.events;\r\n     * eventEmitter.once('destroy', this.sceneDestroy, this);\r\n     * ```\r\n     *\r\n     * @method Phaser.Plugins.ScenePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScenePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Blend Modes.\r\n * \r\n * @namespace Phaser.BlendModes\r\n * @since 3.0.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Skips the Blend Mode check in the renderer.\r\n     * \r\n     * @name Phaser.BlendModes.SKIP_CHECK\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SKIP_CHECK: -1,\r\n\r\n    /**\r\n     * Normal blend mode. For Canvas and WebGL.\r\n     * This is the default setting and draws new shapes on top of the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.NORMAL\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    NORMAL: 0,\r\n\r\n    /**\r\n     * Add blend mode. For Canvas and WebGL.\r\n     * Where both shapes overlap the color is determined by adding color values.\r\n     * \r\n     * @name Phaser.BlendModes.ADD\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    ADD: 1,\r\n\r\n    /**\r\n     * Multiply blend mode. For Canvas and WebGL.\r\n     * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.\r\n     * \r\n     * @name Phaser.BlendModes.MULTIPLY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    MULTIPLY: 2,\r\n\r\n    /**\r\n     * Screen blend mode. For Canvas and WebGL.\r\n     * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)\r\n     * \r\n     * @name Phaser.BlendModes.SCREEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SCREEN: 3,\r\n\r\n    /**\r\n     * Overlay blend mode. For Canvas only.\r\n     * A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.\r\n     * \r\n     * @name Phaser.BlendModes.OVERLAY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    OVERLAY: 4,\r\n\r\n    /**\r\n     * Darken blend mode. For Canvas only.\r\n     * Retains the darkest pixels of both layers.\r\n     * \r\n     * @name Phaser.BlendModes.DARKEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DARKEN: 5,\r\n\r\n    /**\r\n     * Lighten blend mode. For Canvas only.\r\n     * Retains the lightest pixels of both layers.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LIGHTEN: 6,\r\n\r\n    /**\r\n     * Color Dodge blend mode. For Canvas only.\r\n     * Divides the bottom layer by the inverted top layer.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_DODGE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR_DODGE: 7,\r\n\r\n    /**\r\n     * Color Burn blend mode. For Canvas only.\r\n     * Divides the inverted bottom layer by the top layer, and then inverts the result.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_BURN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR_BURN: 8,\r\n\r\n    /**\r\n     * Hard Light blend mode. For Canvas only.\r\n     * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\r\n     * \r\n     * @name Phaser.BlendModes.HARD_LIGHT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    HARD_LIGHT: 9,\r\n\r\n    /**\r\n     * Soft Light blend mode. For Canvas only.\r\n     * A softer version of hard-light. Pure black or white does not result in pure black or white.\r\n     * \r\n     * @name Phaser.BlendModes.SOFT_LIGHT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOFT_LIGHT: 10,\r\n\r\n    /**\r\n     * Difference blend mode. For Canvas only.\r\n     * Subtracts the bottom layer from the top layer or the other way round to always get a positive value.\r\n     * \r\n     * @name Phaser.BlendModes.DIFFERENCE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DIFFERENCE: 11,\r\n\r\n    /**\r\n     * Exclusion blend mode. For Canvas only.\r\n     * Like difference, but with lower contrast.\r\n     * \r\n     * @name Phaser.BlendModes.EXCLUSION\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    EXCLUSION: 12,\r\n\r\n    /**\r\n     * Hue blend mode. For Canvas only.\r\n     * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.HUE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    HUE: 13,\r\n\r\n    /**\r\n     * Saturation blend mode. For Canvas only.\r\n     * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.SATURATION\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SATURATION: 14,\r\n\r\n    /**\r\n     * Color blend mode. For Canvas only.\r\n     * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR: 15,\r\n\r\n    /**\r\n     * Luminosity blend mode. For Canvas only.\r\n     * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.LUMINOSITY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LUMINOSITY: 16,\r\n\r\n    /**\r\n     * Alpha erase blend mode. For Canvas and WebGL.\r\n     * \r\n     * @name Phaser.BlendModes.ERASE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    ERASE: 17,\r\n\r\n    /**\r\n     * Source-in blend mode. For Canvas only.\r\n     * The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_IN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_IN: 18,\r\n\r\n    /**\r\n     * Source-out blend mode. For Canvas only.\r\n     * The new shape is drawn where it doesn't overlap the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_OUT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_OUT: 19,\r\n\r\n    /**\r\n     * Source-out blend mode. For Canvas only.\r\n     * The new shape is only drawn where it overlaps the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_ATOP\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_ATOP: 20,\r\n\r\n    /**\r\n     * Destination-over blend mode. For Canvas only.\r\n     * New shapes are drawn behind the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_OVER\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_OVER: 21,\r\n\r\n    /**\r\n     * Destination-in blend mode. For Canvas only.\r\n     * The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_IN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_IN: 22,\r\n\r\n    /**\r\n     * Destination-out blend mode. For Canvas only.\r\n     * The existing content is kept where it doesn't overlap the new shape.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_OUT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_OUT: 23,\r\n\r\n    /**\r\n     * Destination-out blend mode. For Canvas only.\r\n     * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_ATOP\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_ATOP: 24,\r\n\r\n    /**\r\n     * Lighten blend mode. For Canvas only.\r\n     * Where both shapes overlap the color is determined by adding color values.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTER\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LIGHTER: 25,\r\n\r\n    /**\r\n     * Copy blend mode. For Canvas only.\r\n     * Only the new shape is shown.\r\n     * \r\n     * @name Phaser.BlendModes.COPY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COPY: 26,\r\n\r\n    /**\r\n     * Xor blend mode. For Canvas only.\r\n     * Shapes are made transparent where both overlap and drawn normal everywhere else.\r\n     * \r\n     * @name Phaser.BlendModes.XOR\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    XOR: 27\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Scale Modes.\r\n * \r\n * @namespace Phaser.ScaleModes\r\n * @since 3.0.0\r\n */\r\n\r\nvar ScaleModes = {\r\n\r\n    /**\r\n     * Default Scale Mode (Linear).\r\n     * \r\n     * @name Phaser.ScaleModes.DEFAULT\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    DEFAULT: 0,\r\n\r\n    /**\r\n     * Linear Scale Mode.\r\n     * \r\n     * @name Phaser.ScaleModes.LINEAR\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    LINEAR: 0,\r\n\r\n    /**\r\n     * Nearest Scale Mode.\r\n     * \r\n     * @name Phaser.ScaleModes.NEAREST\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    NEAREST: 1\r\n\r\n};\r\n\r\nmodule.exports = ScaleModes;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Resize Event.\r\n * \r\n * This event is dispatched whenever the Scale Manager detects a resize event from the browser.\r\n * It sends three parameters to the callback, each of them being Size components. You can read\r\n * the `width`, `height`, `aspectRatio` and other properties of these components to help with\r\n * scaling your own game content.\r\n *\r\n * @event Phaser.Scale.Events#RESIZE\r\n * @since 3.16.1\r\n * \r\n * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.\r\n * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size multiplied by resolution.\r\n * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.\r\n * @param {number} resolution - The current resolution. Defaults to 1 at the moment.\r\n * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.\r\n * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Boot Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('boot', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#BOOT\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'boot';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Create Event.\r\n * \r\n * This event is dispatched by a Scene after it has been created by the Scene Manager.\r\n * \r\n * If a Scene has a `create` method then this event is emitted _after_ that has run.\r\n * \r\n * If there is a transition, this event will be fired after the `TRANSITION_START` event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('create', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#CREATE\r\n * @since 3.17.0\r\n * \r\n * @param {Phaser.Scene} scene - A reference to the Scene that emitted this event.\r\n */\r\nmodule.exports = 'create';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Destroy Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems destroy process.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('destroy', listener)`.\r\n * \r\n * You should destroy any resources that may be in use by your Scene in this event handler.\r\n * \r\n * @event Phaser.Scenes.Events#DESTROY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pause Event.\r\n * \r\n * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\r\n * action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('pause', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#PAUSE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was paused.\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Post Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('postupdate', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#POST_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'postupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pre Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('preupdate', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#PRE_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'preupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Ready Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems start process.\r\n * By this point in the process the Scene is now fully active and rendering.\r\n * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('ready', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#READY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was started.\r\n */\r\nmodule.exports = 'ready';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Render Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('render', listener)`.\r\n * \r\n * A Scene will only render if it is visible and active.\r\n * By the time this event is dispatched, the Scene will have already been rendered.\r\n * \r\n * @event Phaser.Scenes.Events#RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.\r\n */\r\nmodule.exports = 'render';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Resume Event.\r\n * \r\n * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('resume', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#RESUME\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was resumed.\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Shutdown Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems shutdown process.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('shutdown', listener)`.\r\n * \r\n * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding\r\n * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\r\n * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.\r\n * \r\n * @event Phaser.Scenes.Events#SHUTDOWN\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was shutdown.\r\n */\r\nmodule.exports = 'shutdown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Sleep Event.\r\n * \r\n * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('sleep', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#SLEEP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was sent to sleep.\r\n */\r\nmodule.exports = 'sleep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Start Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('start', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Complete Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition.\r\n * \r\n * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\r\n * of the transition.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitioncomplete', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} scene -The Scene on which the transitioned completed.\r\n */\r\nmodule.exports = 'transitioncomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Init Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition.\r\n * \r\n * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\r\n * this event is not dispatched.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitioninit', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_INIT\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitioninit';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Out Event.\r\n * \r\n * This event is dispatched by a Scene when it initiates a transition to another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionout', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_OUT\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} target - A reference to the Scene that is being transitioned to.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionout';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Start Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\r\n * \r\n * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\r\n * this event is dispatched anyway.\r\n * \r\n * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\r\n * dispatched instead of this event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionstart', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_START\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Wake Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\r\n * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionwake', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_WAKE\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionwake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('update', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'update';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Wake Event.\r\n * \r\n * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('wake', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#WAKE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was woken up.\r\n */\r\nmodule.exports = 'wake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Scenes.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BOOT: require('./BOOT_EVENT'),\r\n    CREATE: require('./CREATE_EVENT'),\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    POST_UPDATE: require('./POST_UPDATE_EVENT'),\r\n    PRE_UPDATE: require('./PRE_UPDATE_EVENT'),\r\n    READY: require('./READY_EVENT'),\r\n    RENDER: require('./RENDER_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    SHUTDOWN: require('./SHUTDOWN_EVENT'),\r\n    SLEEP: require('./SLEEP_EVENT'),\r\n    START: require('./START_EVENT'),\r\n    TRANSITION_COMPLETE: require('./TRANSITION_COMPLETE_EVENT'),\r\n    TRANSITION_INIT: require('./TRANSITION_INIT_EVENT'),\r\n    TRANSITION_OUT: require('./TRANSITION_OUT_EVENT'),\r\n    TRANSITION_START: require('./TRANSITION_START_EVENT'),\r\n    TRANSITION_WAKE: require('./TRANSITION_WAKE_EVENT'),\r\n    UPDATE: require('./UPDATE_EVENT'),\r\n    WAKE: require('./WAKE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsPlainObject = require('./IsPlainObject');\r\n\r\n// @param {boolean} deep - Perform a deep copy?\r\n// @param {object} target - The target object to copy to.\r\n// @return {object} The extended object.\r\n\r\n/**\r\n * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\r\n *\r\n * @function Phaser.Utils.Objects.Extend\r\n * @since 3.0.0\r\n *\r\n * @return {object} The extended object.\r\n */\r\nvar Extend = function ()\r\n{\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean')\r\n    {\r\n        deep = target;\r\n        target = arguments[1] || {};\r\n\r\n        // skip the boolean and the target\r\n        i = 2;\r\n    }\r\n\r\n    // extend Phaser if only one argument is passed\r\n    if (length === i)\r\n    {\r\n        target = this;\r\n        --i;\r\n    }\r\n\r\n    for (; i < length; i++)\r\n    {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null)\r\n        {\r\n            // Extend the base object\r\n            for (name in options)\r\n            {\r\n                src = target[name];\r\n                copy = options[name];\r\n\r\n                // Prevent never-ending loop\r\n                if (target === copy)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\r\n                {\r\n                    if (copyIsArray)\r\n                    {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n                    }\r\n                    else\r\n                    {\r\n                        clone = src && IsPlainObject(src) ? src : {};\r\n                    }\r\n\r\n                    // Never move original objects, clone them\r\n                    target[name] = Extend(deep, clone, copy);\r\n\r\n                // Don't bring in undefined values\r\n                }\r\n                else if (copy !== undefined)\r\n                {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};\r\n\r\nmodule.exports = Extend;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH = require('../../math');\r\nvar GetValue = require('./GetValue');\r\n\r\n/**\r\n * Retrieves a value from an object. Allows for more advanced selection options, including:\r\n *\r\n * Allowed types:\r\n * \r\n * Implicit\r\n * {\r\n *     x: 4\r\n * }\r\n *\r\n * From function\r\n * {\r\n *     x: function ()\r\n * }\r\n *\r\n * Randomly pick one element from the array\r\n * {\r\n *     x: [a, b, c, d, e, f]\r\n * }\r\n *\r\n * Random integer between min and max:\r\n * {\r\n *     x: { randInt: [min, max] }\r\n * }\r\n *\r\n * Random float between min and max:\r\n * {\r\n *     x: { randFloat: [min, max] }\r\n * }\r\n * \r\n *\r\n * @function Phaser.Utils.Objects.GetAdvancedValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetAdvancedValue = function (source, key, defaultValue)\r\n{\r\n    var value = GetValue(source, key, null);\r\n\r\n    if (value === null)\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (Array.isArray(value))\r\n    {\r\n        return MATH.RND.pick(value);\r\n    }\r\n    else if (typeof value === 'object')\r\n    {\r\n        if (value.hasOwnProperty('randInt'))\r\n        {\r\n            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);\r\n        }\r\n        else if (value.hasOwnProperty('randFloat'))\r\n        {\r\n            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);\r\n        }\r\n    }\r\n    else if (typeof value === 'function')\r\n    {\r\n        return value(key);\r\n    }\r\n\r\n    return value;\r\n};\r\n\r\nmodule.exports = GetAdvancedValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a slightly modified version of jQuery.isPlainObject.\r\n * A plain object is an object whose internal class property is [object Object].\r\n *\r\n * @function Phaser.Utils.Objects.IsPlainObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - The object to inspect.\r\n *\r\n * @return {boolean} `true` if the object is plain, otherwise `false`.\r\n */\r\nvar IsPlainObject = function (obj)\r\n{\r\n    // Not plain objects:\r\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n    // - DOM nodes\r\n    // - window\r\n    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Support: Firefox <20\r\n    // The try/catch suppresses exceptions thrown when attempting to access\r\n    // the \"constructor\" property of certain host objects, ie. |window.location|\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n    try\r\n    {\r\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n\r\nmodule.exports = IsPlainObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar GetFastValue = require('../../../src/utils/object/GetFastValue');\r\nvar ImageFile = require('../../../src/loader/filetypes/ImageFile.js');\r\nvar IsPlainObject = require('../../../src/utils/object/IsPlainObject');\r\nvar JSONFile = require('../../../src/loader/filetypes/JSONFile.js');\r\nvar MultiFile = require('../../../src/loader/MultiFile.js');\r\nvar TextFile = require('../../../src/loader/filetypes/TextFile.js');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.SpineFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Texture Manager.\r\n * @property {string} [textureURL] - The absolute or relative URL to load the texture image file from.\r\n * @property {string} [textureExtension='png'] - The default file extension to use for the image texture if no url is provided.\r\n * @property {XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture image file.\r\n * @property {string} [normalMap] - The filename of an associated normal map. It uses the same path and url to load as the texture image.\r\n * @property {string} [atlasURL] - The absolute or relative URL to load the atlas data file from.\r\n * @property {string} [atlasExtension='txt'] - The default file extension to use for the atlas data if no url is provided.\r\n * @property {XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas data file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Spine File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spine method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spine.\r\n *\r\n * @class SpineFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.SpineFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [jsonURL] - The absolute or relative URL to load the JSON file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {boolean} [preMultipliedAlpha=false] - Do the textures contain pre-multiplied alpha or not?\r\n * @param {XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar SpineFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function SpineFile (loader, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var i;\r\n        var json;\r\n        var atlas;\r\n        var files = [];\r\n        var cache = loader.cacheManager.custom.spine;\r\n\r\n        //  atlas can be an array of atlas files, not just a single one\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            json = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'jsonURL'),\r\n                extension: GetFastValue(config, 'jsonExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'jsonXhrSettings')\r\n            });\r\n\r\n            atlasURL = GetFastValue(config, 'atlasURL');\r\n            preMultipliedAlpha = GetFastValue(config, 'preMultipliedAlpha');\r\n\r\n            if (!Array.isArray(atlasURL))\r\n            {\r\n                atlasURL = [ atlasURL ];\r\n            }\r\n\r\n            for (i = 0; i < atlasURL.length; i++)\r\n            {\r\n                atlas = new TextFile(loader, {\r\n                    key: key,\r\n                    url: atlasURL[i],\r\n                    extension: GetFastValue(config, 'atlasExtension', 'atlas'),\r\n                    xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n                });\r\n\r\n                atlas.cache = cache;\r\n\r\n                files.push(atlas);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            json = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n            if (!Array.isArray(atlasURL))\r\n            {\r\n                atlasURL = [ atlasURL ];\r\n            }\r\n\r\n            for (i = 0; i < atlasURL.length; i++)\r\n            {\r\n                atlas = new TextFile(loader, key + '_' + i, atlasURL[i], atlasXhrSettings);\r\n                atlas.cache = cache;\r\n\r\n                files.push(atlas);\r\n            }\r\n        }\r\n\r\n        files.unshift(json);\r\n\r\n        MultiFile.call(this, loader, 'spine', key, files);\r\n\r\n        this.config.preMultipliedAlpha = preMultipliedAlpha;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpineFile#onFileComplete\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'text')\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var content = file.data.split('\\n');\r\n\r\n                //  Extract the textures\r\n                var textures = [];\r\n\r\n                for (var t = 0; t < content.length; t++)\r\n                {\r\n                    var line = content[t];\r\n\r\n                    if (line.trim() === '' && t < content.length - 1)\r\n                    {\r\n                        line = content[t + 1];\r\n\r\n                        textures.push(line);\r\n                    }\r\n                }\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\r\n                var path = GetFastValue(config, 'path', currentPath);\r\n                var prefix = GetFastValue(config, 'prefix', currentPrefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    var textureURL = textures[i];\r\n\r\n                    var key = '_SP_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpineFile#addToCache\r\n     * @since 3.19.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            fileJSON.addToCache();\r\n\r\n            var atlasCache;\r\n            var atlasKey = '';\r\n            var combinedAtlastData = '';\r\n            var preMultipliedAlpha = (this.config.preMultipliedAlpha) ? true : false;\r\n\r\n            for (var i = 1; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                if (file.type === 'text')\r\n                {\r\n                    atlasKey = file.key.substr(0, file.key.length - 2);\r\n\r\n                    atlasCache = file.cache;\r\n\r\n                    combinedAtlastData = combinedAtlastData.concat(file.data);\r\n                }\r\n                else\r\n                {\r\n                    var key = file.key.substr(4).trim();\r\n   \r\n                    this.loader.textureManager.addImage(key, file.data);\r\n                }\r\n\r\n                file.pendingDestroy();\r\n            }\r\n\r\n            atlasCache.add(atlasKey, { preMultipliedAlpha: preMultipliedAlpha, data: combinedAtlastData });\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../../../src/gameobjects/BuildGameObject');\r\nvar Class = require('../../../src/utils/Class');\r\nvar GetValue = require('../../../src/utils/object/GetValue');\r\nvar ResizeEvent = require('../../../src/scale/events/RESIZE_EVENT');\r\nvar ScenePlugin = require('../../../src/plugins/ScenePlugin');\r\nvar Spine = require('Spine');\r\nvar SpineFile = require('./SpineFile');\r\nvar SpineGameObject = require('./gameobject/SpineGameObject');\r\n\r\n/**\r\n * @classdesc\r\n * The Spine Plugin is a Scene based plugin that handles the creation and rendering of Spine Game objects.\r\n * \r\n * All rendering and object creation is handled via the official Spine Runtimes. This version of the plugin\r\n * uses the Spine 3.7 runtimes. Files created in a more recent version of Spine may not work as a result.\r\n * \r\n * You can find more details about Spine at http://esotericsoftware.com/.\r\n * \r\n * Please note that you require a Spine license in order to use Spine Runtimes in your games.\r\n * \r\n * You can install this plugin into your Phaser game by either importing it, if you're using ES6:\r\n * \r\n * ```javascript\r\n * import * as SpinePlugin from './SpinePlugin.js';\r\n * ```\r\n * \r\n * and then adding it to your Phaser Game configuration:\r\n * \r\n * ```javascript\r\n * plugins: {\r\n *     scene: [\r\n *         { key: 'SpinePlugin', plugin: window.SpinePlugin, mapping: 'spine' }\r\n *     ]\r\n * }\r\n * ```\r\n * \r\n * If you're using ES5 then you can load the Spine Plugin in a Scene files payload, _within_ your\r\n * Game Configuration object, like this:\r\n * \r\n * ```javascript\r\n * scene: {\r\n *     preload: preload,\r\n *     create: create,\r\n *     pack: {\r\n *         files: [\r\n *             { type: 'scenePlugin', key: 'SpinePlugin', url: 'plugins/SpinePlugin.js', sceneKey: 'spine' }\r\n *         ]\r\n *     }\r\n * }\r\n * ```\r\n * \r\n * Loading it like this allows you to then use commands such as `this.load.spine` from within the\r\n * same Scene. Alternatively, you can use the method `this.load.plugin` to load the plugin via the normal\r\n * Phaser Loader. However, doing so will not add it to the current Scene. It will be available from any\r\n * subsequent Scenes.\r\n * \r\n * Assuming a default environment you access it from within a Scene by using the `this.spine` reference.\r\n * \r\n * When this plugin is installed into a Scene it will add a Loader File Type, allowing you to load\r\n * Spine files directly, i.e.:\r\n * \r\n * ```javascript\r\n * this.load.spine('stretchyman', 'stretchyman-pro.json', [ 'stretchyman-pma.atlas' ], true);\r\n * ```\r\n * \r\n * It also installs a Game Object Factory method, allowin you to create Spine Game Objects:\r\n * \r\n * ```javascript\r\n * this.add.spine(512, 650, 'stretchyman')\r\n * ```\r\n * \r\n * The first argument is the key which you used when importing the Spine data. There are lots of\r\n * things you can specify, such as the animation name, skeleton, slot attachments and more. Please\r\n * see the respective documentation and examples for further details.\r\n * \r\n * Phaser expects the Spine data to be exported from the Spine application in a JSON format, not binary.\r\n * The associated atlas files are scanned for any texture files present in them, which are then loaded.\r\n * If you have exported your Spine data with preMultipiedAlpha set, then you should enable this in the\r\n * load arguments, or you may see black outlines around skeleton textures.\r\n * \r\n * The Spine plugin is local to the Scene in which it is installed. This means a change to something,\r\n * such as the Skeleton Debug Renderer, in this Scene, will not impact the renderer in any other Scene.\r\n * The only exception to this is with the caches this plugin creates. Spine atlas and texture data are\r\n * stored in their own caches, which are global, meaning they're accessible from any Scene in your\r\n * game, regardless if the Scene loaded the Spine data or not.\r\n * \r\n * For details about the Spine Runtime API see http://esotericsoftware.com/spine-api-reference\r\n *\r\n * @class SpinePlugin\r\n * @memberOf Phaser\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 3.19.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpinePlugin = new Class({\r\n\r\n    Extends: ScenePlugin,\r\n\r\n    initialize:\r\n\r\n    function SpinePlugin (scene, pluginManager)\r\n    {\r\n        ScenePlugin.call(this, scene, pluginManager);\r\n\r\n        var game = pluginManager.game;\r\n\r\n        /**\r\n         * A read-only flag that indicates if the game is running under WebGL or Canvas.\r\n         *\r\n         * @name SpinePlugin#isWebGL\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.isWebGL = (game.config.renderType === 2);\r\n\r\n        /**\r\n         * A custom cache that stores the Spine atlas data.\r\n         * \r\n         * This cache is global across your game, allowing you to access Spine data loaded from other Scenes,\r\n         * no matter which Scene you are in.\r\n         *\r\n         * @name SpinePlugin#cache\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.cache = game.cache.addCustom('spine');\r\n\r\n        /**\r\n         * A custom cache that stores the Spine Textures.\r\n         * \r\n         * This cache is global across your game, allowing you to access Spine data loaded from other Scenes,\r\n         * no matter which Scene you are in.\r\n         *\r\n         * @name SpinePlugin#spineTextures\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.spineTextures = game.cache.addCustom('spineTextures');\r\n\r\n        /**\r\n         * A reference to the global JSON Cache.\r\n         *\r\n         * @name SpinePlugin#json\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.json = game.cache.json;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         *\r\n         * @name SpinePlugin#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.19.0\r\n         */\r\n        this.textures = game.textures;\r\n\r\n        /**\r\n         * A flag that sets if the Skeleton Renderers will render debug information over the top\r\n         * of the skeleton or not.\r\n         *\r\n         * @name SpinePlugin#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.drawDebug = false;\r\n\r\n        /**\r\n         * The underlying WebGL context of the Phaser renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.19.0\r\n         */\r\n        this.gl;\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that this Game is using.\r\n         *\r\n         * @name SpinePlugin#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.19.0\r\n         */\r\n        this.renderer;\r\n\r\n        /**\r\n         * An instance of the Spine WebGL Scene Renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#sceneRenderer\r\n         * @type {spine.webgl.SceneRenderer}\r\n         * @since 3.19.0\r\n         */\r\n        this.sceneRenderer;\r\n\r\n        /**\r\n         * An instance of the Spine Skeleton Renderer.\r\n         *\r\n         * @name SpinePlugin#skeletonRenderer\r\n         * @type {(spine.canvas.SkeletonRenderer|spine.webgl.SkeletonRenderer)}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonRenderer;\r\n\r\n        /**\r\n         * An instance of the Spine Skeleton Debug Renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#skeletonDebugRenderer\r\n         * @type {spine.webgl.skeletonDebugRenderer}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonDebugRenderer;\r\n\r\n        /**\r\n         * A reference to the Spine runtime.\r\n         * This is the runtime created by Esoteric Software\r\n         *\r\n         * @name SpinePlugin#plugin\r\n         * @type {spine}\r\n         * @since 3.19.0\r\n         */\r\n        this.plugin = Spine;\r\n\r\n        /**\r\n         * An internal vector3 used by the screen to world method.\r\n         *\r\n         * @name SpinePlugin#temp1\r\n         * @private\r\n         * @type {spine.webgl.Vector3}\r\n         * @since 3.19.0\r\n         */\r\n        this.temp1;\r\n\r\n        /**\r\n         * An internal vector3 used by the screen to world method.\r\n         *\r\n         * @name SpinePlugin#temp2\r\n         * @private\r\n         * @type {spine.webgl.Vector3}\r\n         * @since 3.19.0\r\n         */\r\n        this.temp2;\r\n\r\n        if (this.isWebGL)\r\n        {\r\n            this.runtime = Spine.webgl;\r\n\r\n            this.renderer = game.renderer;\r\n            this.gl = game.renderer.gl;\r\n\r\n            this.getAtlas = this.getAtlasWebGL;\r\n        }\r\n        else\r\n        {\r\n            this.runtime = Spine.canvas;\r\n\r\n            this.renderer = game.renderer;\r\n\r\n            this.getAtlas = this.getAtlasCanvas;\r\n        }\r\n\r\n        pluginManager.registerFileType('spine', this.spineFileCallback, scene);\r\n\r\n        pluginManager.registerGameObject('spine', this.add.bind(this), this.make.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler.\r\n     *\r\n     * @method SpinePlugin#boot\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        if (this.isWebGL)\r\n        {\r\n            this.bootWebGL();\r\n            this.onResize();\r\n            this.game.scale.on(ResizeEvent, this.onResize, this);\r\n        }\r\n        else\r\n        {\r\n            this.bootCanvas();\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.once('shutdown', this.shutdown, this);\r\n        eventEmitter.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler for the Canvas Renderer.\r\n     *\r\n     * @method SpinePlugin#bootCanvas\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    bootCanvas: function ()\r\n    {\r\n        this.skeletonRenderer = new Spine.canvas.SkeletonRenderer(this.scene.sys.context);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler for the WebGL Renderer.\r\n     *\r\n     * @method SpinePlugin#bootWebGL\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    bootWebGL: function ()\r\n    {\r\n        this.sceneRenderer = new Spine.webgl.SceneRenderer(this.renderer.canvas, this.gl, true);\r\n\r\n        //  Monkeypatch the Spine setBlendMode functions, or batching is destroyed\r\n\r\n        var setBlendMode = function (srcBlend, dstBlend)\r\n        {\r\n            if (srcBlend !== this.srcBlend || dstBlend !== this.dstBlend)\r\n            {\r\n                var gl = this.context.gl;\r\n\r\n                this.srcBlend = srcBlend;\r\n                this.dstBlend = dstBlend;\r\n\r\n                if (this.isDrawing)\r\n                {\r\n                    this.flush();\r\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.sceneRenderer.batcher.setBlendMode = setBlendMode;\r\n        this.sceneRenderer.shapes.setBlendMode = setBlendMode;\r\n\r\n        this.skeletonRenderer = this.sceneRenderer.skeletonRenderer;\r\n        this.skeletonDebugRenderer = this.sceneRenderer.skeletonDebugRenderer;\r\n\r\n        this.temp1 = new Spine.webgl.Vector3(0, 0, 0);\r\n        this.temp2 = new Spine.webgl.Vector3(0, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Gets a loaded Spine Atlas from the cache and creates a new Spine Texture Atlas,\r\n     * then returns it. You do not normally need to invoke this method directly.\r\n     *\r\n     * @method SpinePlugin#getAtlasCanvas\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine Atlas to create.\r\n     * \r\n     * @return {spine.TextureAtlas} The Spine Texture Atlas, or undefined if the given key wasn't found.\r\n     */\r\n    getAtlasCanvas: function (key)\r\n    {\r\n        var atlasEntry = this.cache.get(key);\r\n\r\n        if (!atlasEntry)\r\n        {\r\n            console.warn('No atlas data for: ' + key);\r\n            return;\r\n        }\r\n\r\n        var atlas;\r\n        var spineTextures = this.spineTextures;\r\n\r\n        if (spineTextures.has(key))\r\n        {\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function ()\r\n            {\r\n                return spineTextures.get(key);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            var textures = this.textures;\r\n\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function (path)\r\n            {\r\n                var canvasTexture = new Spine.canvas.CanvasTexture(textures.get(path).getSourceImage());\r\n\r\n                spineTextures.add(key, canvasTexture);\r\n\r\n                return canvasTexture;\r\n            });\r\n        }\r\n\r\n        return atlas;\r\n    },\r\n\r\n    /**\r\n     * Gets a loaded Spine Atlas from the cache and creates a new Spine Texture Atlas,\r\n     * then returns it. You do not normally need to invoke this method directly.\r\n     *\r\n     * @method SpinePlugin#getAtlasWebGL\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine Atlas to create.\r\n     * \r\n     * @return {spine.TextureAtlas} The Spine Texture Atlas, or undefined if the given key wasn't found.\r\n     */\r\n    getAtlasWebGL: function (key)\r\n    {\r\n        var atlasEntry = this.cache.get(key);\r\n\r\n        if (!atlasEntry)\r\n        {\r\n            console.warn('No atlas data for: ' + key);\r\n            return;\r\n        }\r\n\r\n        var atlas;\r\n        var spineTextures = this.spineTextures;\r\n\r\n        if (spineTextures.has(key))\r\n        {\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function ()\r\n            {\r\n                return spineTextures.get(key);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            var textures = this.textures;\r\n\r\n            var gl = this.sceneRenderer.context.gl;\r\n\r\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function (path)\r\n            {\r\n                var glTexture = new Spine.webgl.GLTexture(gl, textures.get(path).getSourceImage(), false);\r\n\r\n                spineTextures.add(key, glTexture);\r\n\r\n                return glTexture;\r\n            });\r\n        }\r\n\r\n        return atlas;\r\n    },\r\n\r\n    /**\r\n     * Adds a Spine Skeleton and Atlas file, or array of files, to the current load queue.\r\n     *\r\n     * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n     * \r\n     * ```javascript\r\n     * function preload ()\r\n     * {\r\n     *     this.load.spine('spineBoy', 'boy.json', 'boy.atlas', true);\r\n     * }\r\n     * ```\r\n     *\r\n     * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n     * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n     * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n     * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n     * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n     * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n     * loaded.\r\n     * \r\n     * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n     * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n     * \r\n     * Phaser expects the Spine data to be exported from the Spine application in a JSON format, not binary. The associated\r\n     * atlas files are scanned for any texture files present in them, which are then loaded. If you have exported\r\n     * your Spine data with preMultipiedAlpha set, then you should enable this in the arguments, or you may see black\r\n     * outlines around skeleton textures.\r\n     * \r\n     * The key must be a unique String. It is used to add the file to the global Spine cache upon a successful load.\r\n     * The key should be unique both in terms of files being loaded and files already present in the Spine cache.\r\n     * Loading a file using a key that is already taken will result in a warning.\r\n     *\r\n     * Instead of passing arguments you can pass a configuration object, such as:\r\n     * \r\n     * ```javascript\r\n     * this.load.spine({\r\n     *     key: 'mainmenu',\r\n     *     jsonURL: 'boy.json',\r\n     *     atlasURL: 'boy.atlas',\r\n     *     preMultipliedAlpha: true\r\n     * });\r\n     * ```\r\n     * \r\n     * If you need to load multiple Spine atlas files, provide them as an array:\r\n     * \r\n     * ```javascript\r\n     * function preload ()\r\n     * {\r\n     *     this.load.spine('demos', 'demos.json', [ 'atlas1.atlas', 'atlas2.atlas' ], true);\r\n     * }\r\n     * ```\r\n     *\r\n     * See the documentation for `Phaser.Types.Loader.FileTypes.SpineFileConfig` for more details.\r\n     *\r\n     * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n     * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n     * this is what you would use to retrieve the data from the Spine plugin.\r\n     *\r\n     * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n     *\r\n     * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n     * and no URL is given then the Loader will set the URL to be \"alien.json\". It will always add `.json` as the extension, although\r\n     * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n     *\r\n     * Note: The ability to load this type of file will only be available if the Spine Plugin has been built or loaded into Phaser.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#spine\r\n     * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n     * @since 3.19.0\r\n     *\r\n     * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n     * @param {string} jsonURL - The absolute or relative URL to load the Spine json file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n     * @param {string|string[]} atlasURL - The absolute or relative URL to load the Spine atlas file from. If undefined or `null` it will be set to `<key>.atlas`, i.e. if `key` was \"alien\" then the URL will be \"alien.atlas\".\r\n     * @param {boolean} [preMultipiedAlpha=false] - Do the texture files include pre-multiplied alpha or not?\r\n     * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the Spine json file. Used in replacement of the Loaders default XHR Settings.\r\n     * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the Spine atlas file. Used in replacement of the Loaders default XHR Settings.\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n     */\r\n    spineFileCallback: function (key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var multifile;\r\n   \r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                multifile = new SpineFile(this, key[i]);\r\n    \r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            multifile = new SpineFile(this, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n        \r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Spine Game Object and adds it to the Scene.\r\n     * \r\n     * The x and y coordinate given is used to set the placement of the root Spine bone, which can vary from\r\n     * skeleton to skeleton. All rotation and scaling happens from the root bone placement. Spine Game Objects\r\n     * do not have a Phaser origin.\r\n     * \r\n     * If the Spine JSON file exported multiple Skeletons within it, then you can specify them by using a period\r\n     * character in the key. For example, if you loaded a Spine JSON using the key `monsters` and it contains\r\n     * multiple Skeletons, including one called `goblin` then you would use the key `monsters.goblin` to reference\r\n     * that.\r\n     * \r\n     * ```javascript\r\n     * let jelly = this.add.spine(512, 550, 'jelly', 'jelly-think', true);\r\n     * ```\r\n     * \r\n     * The key is optional. If not passed here, you need to call `SpineGameObject.setSkeleton()` to use it.\r\n     * \r\n     * The animation name is also optional and can be set later via `SpineGameObject.setAnimation`.\r\n     * \r\n     * Should you wish for more control over the object creation, such as setting a slot attachment or skin\r\n     * name, then use `SpinePlugin.make` instead.\r\n     *\r\n     * @method SpinePlugin#add\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} [key] - The key of the Spine Skeleton this Game Object will use, as stored in the Spine Plugin.\r\n     * @param {string} [animationName] - The name of the animation to set on this Skeleton.\r\n     * @param {boolean} [loop=false] - Should the animation playback be looped or not?\r\n     *\r\n     * @return {SpineGameObject} The Game Object that was created.\r\n     */\r\n    add: function (x, y, key, animationName, loop)\r\n    {\r\n        var spineGO = new SpineGameObject(this.scene, this, x, y, key, animationName, loop);\r\n\r\n        this.scene.sys.displayList.add(spineGO);\r\n        this.scene.sys.updateList.add(spineGO);\r\n    \r\n        return spineGO;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Spine Game Object from the given configuration file and optionally adds it to the Scene.\r\n     * \r\n     * The x and y coordinate given is used to set the placement of the root Spine bone, which can vary from\r\n     * skeleton to skeleton. All rotation and scaling happens from the root bone placement. Spine Game Objects\r\n     * do not have a Phaser origin.\r\n     * \r\n     * If the Spine JSON file exported multiple Skeletons within it, then you can specify them by using a period\r\n     * character in the key. For example, if you loaded a Spine JSON using the key `monsters` and it contains\r\n     * multiple Skeletons, including one called `goblin` then you would use the key `monsters.goblin` to reference\r\n     * that.\r\n     * \r\n     * ```javascript\r\n     * let jelly = this.make.spine({\r\n     *     x: 500, y: 500, key: 'jelly',\r\n     *     scale: 1.5,\r\n     *     skinName: 'square_Green',\r\n     *     animationName: 'jelly-idle', loop: true,\r\n     *     slotName: 'hat', attachmentName: 'images/La_14'\r\n     * });\r\n     * ```\r\n     *\r\n     * @method SpinePlugin#make\r\n     * @since 3.19.0\r\n     *\r\n     * @param {any} config - The configuration object this Game Object will use to create itself.\r\n     * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n     *\r\n     * @return {SpineGameObject} The Game Object that was created.\r\n     */\r\n    make: function (config, addToScene)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        var key = GetValue(config, 'key', null);\r\n        var animationName = GetValue(config, 'animationName', null);\r\n        var loop = GetValue(config, 'loop', false);\r\n\r\n        var spineGO = new SpineGameObject(this.scene, this, 0, 0, key, animationName, loop);\r\n\r\n        if (addToScene !== undefined)\r\n        {\r\n            config.add = addToScene;\r\n        }\r\n\r\n        BuildGameObject(this.scene, spineGO, config);\r\n\r\n        //  Spine specific\r\n        var skinName = GetValue(config, 'skinName', false);\r\n\r\n        if (skinName)\r\n        {\r\n            spineGO.setSkinByName(skinName);\r\n        }\r\n\r\n        var slotName = GetValue(config, 'slotName', false);\r\n        var attachmentName = GetValue(config, 'attachmentName', null);\r\n\r\n        if (slotName)\r\n        {\r\n            spineGO.setAttachment(slotName, attachmentName);\r\n        }\r\n\r\n        return spineGO.refresh();\r\n    },\r\n\r\n    /**\r\n     * Converts the given x and y screen coordinates into the world space of the given Skeleton.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#worldToLocal\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The screen space x coordinate to convert.\r\n     * @param {number} y - The screen space y coordinate to convert.\r\n     * @param {spine.Skeleton} skeleton - The Spine Skeleton to convert into.\r\n     * @param {spine.Bone} [bone] - Optional bone of the Skeleton to convert into.\r\n     * \r\n     * @return {spine.Vector2} A Vector2 containing the translated point.\r\n     */\r\n    worldToLocal: function (x, y, skeleton, bone)\r\n    {\r\n        var temp1 = this.temp1;\r\n        var temp2 = this.temp2;\r\n        var camera = this.sceneRenderer.camera;\r\n\r\n        temp1.set(x + skeleton.x, y - skeleton.y, 0);\r\n\r\n        var width = camera.viewportWidth;\r\n        var height = camera.viewportHeight;\r\n\r\n        camera.screenToWorld(temp1, width, height);\r\n\r\n        if (bone && bone.parent !== null)\r\n        {\r\n            bone.parent.worldToLocal(temp2.set(temp1.x - skeleton.x, temp1.y - skeleton.y, 0));\r\n\r\n            return new Spine.Vector2(temp2.x, temp2.y);\r\n        }\r\n        else if (bone)\r\n        {\r\n            return new Spine.Vector2(temp1.x - skeleton.x, temp1.y - skeleton.y);\r\n        }\r\n        else\r\n        {\r\n            return new Spine.Vector2(temp1.x, temp1.y);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a Spine Vector2 based on the given x and y values.\r\n     *\r\n     * @method SpinePlugin#getVector2\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The Vector x value.\r\n     * @param {number} y - The Vector y value.\r\n     * \r\n     * @return {spine.Vector2} A Spine Vector2 based on the given values.\r\n     */\r\n    getVector2: function (x, y)\r\n    {\r\n        return new Spine.Vector2(x, y);\r\n    },\r\n\r\n    /**\r\n     * Returns a Spine Vector2 based on the given x, y and z values.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#getVector3\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The Vector x value.\r\n     * @param {number} y - The Vector y value.\r\n     * @param {number} z - The Vector z value.\r\n     * \r\n     * @return {spine.Vector2} A Spine Vector2 based on the given values.\r\n     */\r\n    getVector3: function (x, y, z)\r\n    {\r\n        return new Spine.webgl.Vector3(x, y, z);\r\n    },\r\n\r\n    /**\r\n     * Sets `drawBones` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugBones\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugBones: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawBones = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawRegionAttachments` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugRegionAttachments\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugRegionAttachments: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawRegionAttachments = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawBoundingBoxes` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugBoundingBoxes\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugBoundingBoxes: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawBoundingBoxes = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawMeshHull` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugMeshHull\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugMeshHull: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawMeshHull = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawMeshTriangles` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugMeshTriangles\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugMeshTriangles: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawMeshTriangles = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawPaths` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugPaths\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugPaths: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawPaths = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawSkeletonXY` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugSkeletonXY\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugSkeletonXY: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawSkeletonXY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawClipping` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugClipping\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugClipping: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawClipping = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given vertex effect on the Spine Skeleton Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setEffect\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.VertexEffect} [effect] - The vertex effect to set on the Skeleton Renderer.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setEffect: function (effect)\r\n    {\r\n        this.sceneRenderer.skeletonRenderer.vertexEffect = effect;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a Spine Skeleton based on the given key and optional Skeleton JSON data.\r\n     * \r\n     * The Skeleton data should have already been loaded before calling this method.\r\n     *\r\n     * @method SpinePlugin#createSkeleton\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine skeleton data, as loaded by the plugin. If the Spine JSON contains multiple skeletons, reference them with a period, i.e. `set.spineBoy`.\r\n     * @param {object} [skeletonJSON] - Optional Skeleton JSON data to use, instead of getting it from the cache.\r\n     * \r\n     * @return {(any|null)} This Spine Skeleton data object, or `null` if the key was invalid.\r\n     */\r\n    createSkeleton: function (key, skeletonJSON)\r\n    {\r\n        var atlasKey = key;\r\n        var jsonKey = key;\r\n        var split = (key.indexOf('.') !== -1);\r\n\r\n        if (split)\r\n        {\r\n            var parts = key.split('.');\r\n\r\n            atlasKey = parts.shift();\r\n            jsonKey = parts.join('.');\r\n        }\r\n\r\n        var atlasData = this.cache.get(atlasKey);\r\n        var atlas = this.getAtlas(atlasKey);\r\n\r\n        if (!atlas)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var preMultipliedAlpha = atlasData.preMultipliedAlpha;\r\n\r\n        var atlasLoader = new Spine.AtlasAttachmentLoader(atlas);\r\n        \r\n        var skeletonJson = new Spine.SkeletonJson(atlasLoader);\r\n\r\n        var data;\r\n\r\n        if (skeletonJSON)\r\n        {\r\n            data = skeletonJSON;\r\n        }\r\n        else\r\n        {\r\n            var json = this.json.get(atlasKey);\r\n\r\n            data = (split) ? GetValue(json, jsonKey) : json;\r\n        }\r\n\r\n        if (data)\r\n        {\r\n            var skeletonData = skeletonJson.readSkeletonData(data);\r\n\r\n            var skeleton = new Spine.Skeleton(skeletonData);\r\n        \r\n            return { skeletonData: skeletonData, skeleton: skeleton, preMultipliedAlpha: preMultipliedAlpha };\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Animation State and Animation State Data for the given skeleton.\r\n     * \r\n     * The returned object contains two properties: `state` and `stateData` respectively.\r\n     *\r\n     * @method SpinePlugin#createAnimationState\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Skeleton} skeleton - The Skeleton to create the Animation State for.\r\n     * \r\n     * @return {any} An object containing the Animation State and Animation State Data instances.\r\n     */\r\n    createAnimationState: function (skeleton)\r\n    {\r\n        var stateData = new Spine.AnimationStateData(skeleton.data);\r\n\r\n        var state = new Spine.AnimationState(stateData);\r\n\r\n        return { stateData: stateData, state: state };\r\n    },\r\n\r\n    /**\r\n     * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * \r\n     * The returned object contains two properties: `offset` and `size`:\r\n     * \r\n     * `offset` - The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * `size` - The width and height of the AABB.\r\n     *\r\n     * @method SpinePlugin#getBounds\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Skeleton} skeleton - The Skeleton to get the bounds from.\r\n     * \r\n     * @return {any} The bounds object.\r\n     */\r\n    getBounds: function (skeleton)\r\n    {\r\n        var offset = new Spine.Vector2();\r\n        var size = new Spine.Vector2();\r\n\r\n        skeleton.getBounds(offset, size, []);\r\n\r\n        return { offset: offset, size: size };\r\n    },\r\n\r\n    /**\r\n     * Internal handler for when the renderer resizes.\r\n     * \r\n     * Only called if running in WebGL.\r\n     *\r\n     * @method SpinePlugin#onResize\r\n     * @since 3.19.0\r\n     */\r\n    onResize: function ()\r\n    {\r\n        var renderer = this.renderer;\r\n        var sceneRenderer = this.sceneRenderer;\r\n\r\n        var viewportWidth = renderer.width;\r\n        var viewportHeight = renderer.height;\r\n\r\n        sceneRenderer.camera.position.x = viewportWidth / 2;\r\n        sceneRenderer.camera.position.y = viewportHeight / 2;\r\n    \r\n        sceneRenderer.camera.viewportWidth = viewportWidth;\r\n        sceneRenderer.camera.viewportHeight = viewportHeight;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * \r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method SpinePlugin#shutdown\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n\r\n        this.sceneRenderer.dispose();\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * \r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method SpinePlugin#destroy\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.pluginManager.removeGameObject('spine', true, true);\r\n\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n\r\n        this.cache = null;\r\n        this.spineTextures = null;\r\n        this.json = null;\r\n        this.textures = null;\r\n        this.sceneRenderer = null;\r\n        this.skeletonRenderer = null;\r\n        this.gl = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpinePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#COMPLETE\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#DISPOSE\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'dispose';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#END\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'end';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#EVENT\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'event';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#INTERRUPTED\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'interrupted';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#START\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace SpinePluginEvents\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    DISPOSE: require('./DISPOSE_EVENT'),\r\n    END: require('./END_EVENT'),\r\n    EVENT: require('./EVENT_EVENT'),\r\n    INTERRUPTED: require('./INTERRUPTED_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar AngleBetween = require('../../../../src/math/angle/Between');\r\nvar Clamp = require('../../../../src/math/Clamp');\r\nvar Class = require('../../../../src/utils/Class');\r\nvar ComponentsComputedSize = require('../../../../src/gameobjects/components/ComputedSize');\r\nvar ComponentsDepth = require('../../../../src/gameobjects/components/Depth');\r\nvar ComponentsFlip = require('../../../../src/gameobjects/components/Flip');\r\nvar ComponentsScrollFactor = require('../../../../src/gameobjects/components/ScrollFactor');\r\nvar ComponentsTransform = require('../../../../src/gameobjects/components/Transform');\r\nvar ComponentsVisible = require('../../../../src/gameobjects/components/Visible');\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\nvar DegToRad = require('../../../../src/math/DegToRad');\r\nvar GameObject = require('../../../../src/gameobjects/GameObject');\r\nvar RadToDeg = require('../../../../src/math/RadToDeg');\r\nvar SpineEvents = require('../events/');\r\nvar SpineGameObjectRender = require('./SpineGameObjectRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Spine Game Object is a Phaser level object that can be added to your Phaser Scenes. It encapsulates\r\n * a Spine Skeleton with Spine Animation Data and Animation State, with helper methods to allow you to\r\n * easily change the skin, slot attachment, bone positions and more.\r\n * \r\n * Spine Game Objects can be created via the Game Object Factory, Game Object Creator, or directly.\r\n * You can only create them if the Spine plugin has been loaded into Phaser.\r\n * \r\n * The quickest way is the Game Object Factory:\r\n * \r\n * ```javascript\r\n * let jelly = this.add.spine(512, 550, 'jelly', 'jelly-think', true);\r\n * ```\r\n * \r\n * Here we are creating a new Spine Game Object positioned at 512 x 550. It's using the `jelly`\r\n * Spine data, which has previously been loaded into your Scene. The `jelly-think` argument is\r\n * an optional animation to start playing on the skeleton. The final argument `true` sets the\r\n * animation to loop. Look at the documentation for further details on each of these options.\r\n * \r\n * For more control, you can use the Game Object Creator, passing in a Spine Game Object\r\n * Configuration object:\r\n * \r\n * ```javascript\r\n * let jelly = this.make.spine({\r\n *     x: 512, y: 550, key: 'jelly',\r\n *     scale: 1.5,\r\n *     skinName: 'square_Green',\r\n *     animationName: 'jelly-think', loop: true,\r\n *     slotName: 'hat', attachmentName: 'images/La_14'\r\n * });\r\n * ```\r\n * \r\n * Here, you've got the ability to specify extra details, such as the slot name, attachments or\r\n * overall scale.\r\n * \r\n * If you wish to instantiate a Spine Game Object directly you can do so, but in order for it to\r\n * update and render, it must be added to the display and update lists of your Scene:\r\n * \r\n * ```javascript\r\n * let jelly = new SpineGameObject(this, this.spine, 512, 550, 'jelly', 'jelly-think', true);\r\n * this.sys.displayList.add(jelly);\r\n * this.sys.updateList.add(jelly);\r\n * ```\r\n * \r\n * It's possible to enable Spine Game Objects for input, but you should be aware that it will use\r\n * the bounds of the skeletons current pose to create the hit area from. Sometimes this is ok, but\r\n * often not. Make use of the `InputPlugin.enableDebug` method to view the input shape being created.\r\n * If it's not suitable, provide your own shape to the `setInteractive` method.\r\n * \r\n * Due to the way Spine handles scaling, it's not recommended to enable a Spine Game Object for\r\n * physics directly. Instead, you should look at creating a proxy body and syncing the Spine Game\r\n * Object position with it. See the examples for further details.\r\n * \r\n * If your Spine Game Object has black outlines around the different parts of the texture when it\r\n * renders then you have exported the files from Spine with pre-multiplied alpha enabled, but have\r\n * forgotten to set that flag when loading the Spine data. Please see the loader docs for more details.\r\n *\r\n * @class SpineGameObject\r\n * @constructor\r\n * @since 3.19.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Game Object belongs to.\r\n * @param {SpinePlugin} pluginManager - A reference to the Phaser Spine Plugin.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - The key of the Spine Skeleton this Game Object will use, as stored in the Spine Plugin.\r\n * @param {string} [animationName] - The name of the animation to set on this Skeleton.\r\n * @param {boolean} [loop=false] - Should the animation playback be looped or not?\r\n */\r\nvar SpineGameObject = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        ComponentsComputedSize,\r\n        ComponentsDepth,\r\n        ComponentsFlip,\r\n        ComponentsScrollFactor,\r\n        ComponentsTransform,\r\n        ComponentsVisible,\r\n        SpineGameObjectRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function SpineGameObject (scene, plugin, x, y, key, animationName, loop)\r\n    {\r\n        GameObject.call(this, scene, 'Spine');\r\n\r\n        /**\r\n         * A reference to the Spine Plugin.\r\n         *\r\n         * @name SpineGameObject#plugin\r\n         * @type {SpinePlugin}\r\n         * @since 3.19.0\r\n         */\r\n        this.plugin = plugin;\r\n\r\n        /**\r\n         * The Spine Skeleton this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#skeleton\r\n         * @type {spine.Skeleton}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeleton = null;\r\n\r\n        /**\r\n         * The Spine Skeleton Data associated with the Skeleton this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#skeletonData\r\n         * @type {spine.SkeletonData}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonData = null;\r\n\r\n        /**\r\n         * The Spine Animation State this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#state\r\n         * @type {spine.AnimationState}\r\n         * @since 3.19.0\r\n         */\r\n        this.state = null;\r\n\r\n        /**\r\n         * The Spine Animation State Data associated with the Animation State this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#stateData\r\n         * @type {spine.AnimationStateData}\r\n         * @since 3.19.0\r\n         */\r\n        this.stateData = null;\r\n\r\n        /**\r\n         * A reference to the root bone of the Skeleton.\r\n         *\r\n         * @name SpineGameObject#root\r\n         * @type {spine.Bone}\r\n         * @since 3.19.0\r\n         */\r\n        this.root = null;\r\n\r\n        /**\r\n         * This object holds the calculated bounds of the current\r\n         * pose, as set when a new Skeleton is applied.\r\n         *\r\n         * @name SpineGameObject#bounds\r\n         * @type {any}\r\n         * @since 3.19.0\r\n         */\r\n        this.bounds = null;\r\n        \r\n        /**\r\n         * A Game Object level flag that allows you to enable debug drawing\r\n         * to the Skeleton Debug Renderer by toggling it.\r\n         *\r\n         * @name SpineGameObject#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.drawDebug = false;\r\n\r\n        /**\r\n         * The factor to scale the Animation update time by.\r\n         *\r\n         * @name SpineGameObject#timeScale\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * The calculated Display Origin of this Game Object.\r\n         *\r\n         * @name SpineGameObject#displayOriginX\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.displayOriginX = 0;\r\n\r\n        /**\r\n         * The calculated Display Origin of this Game Object.\r\n         *\r\n         * @name SpineGameObject#displayOriginY\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.displayOriginY = 0;\r\n\r\n        /**\r\n         * A flag that stores if the texture associated with the current\r\n         * Skin being used by this Game Object, has its alpha pre-multiplied\r\n         * into it, or not.\r\n         *\r\n         * @name SpineGameObject#preMultipliedAlpha\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.preMultipliedAlpha = false;\r\n\r\n        /**\r\n         * A default Blend Mode. You cannot change the blend mode of a\r\n         * Spine Game Object.\r\n         *\r\n         * @name SpineGameObject#blendMode\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.blendMode = 0;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key)\r\n        {\r\n            this.setSkeleton(key, animationName, loop);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Overrides the default Game Object method and always returns true.\r\n     * Rendering is decided in the renderer functions.\r\n     *\r\n     * @method SpineGameObject#willRender\r\n     * @since 3.19.0\r\n     *\r\n     * @return {boolean} Always returns `true`.\r\n     */\r\n    willRender: function ()\r\n    {\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level for the whole Skeleton of this Game Object.\r\n     * \r\n     * The alpha controls the opacity of the Game Object as it renders.\r\n     * \r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * @method SpineGameObject#setAlpha\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} [value=1] - The alpha value used for the whole Skeleton.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlpha: function (value, slotName)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (slotName)\r\n        {\r\n            var slot = this.findSlot(slotName);\r\n\r\n            if (slot)\r\n            {\r\n                slot.color.a = Clamp(value, 0, 1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.alpha = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#alpha\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.a;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.a = v;\r\n            }\r\n\r\n            if (v === 0)\r\n            {\r\n                this.renderFlags &= ~2;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= 2;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of red used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#red\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    red: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.r;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.r = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of green used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#green\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    green: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.g;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.g = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of blue used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#blue\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    blue: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.b;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.b = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the color on the given attachment slot. Or, if no slot is given, on the whole skeleton.\r\n     *\r\n     * @method SpineGameObject#setColor\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} [color=0xffffff] - The color being applied to the Skeleton or named Slot. Set to white to disable any previously set color.\r\n     * @param {string} [slotName] - The name of the slot to set the color on. If not give, will be set on the whole skeleton.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setColor: function (color, slotName)\r\n    {\r\n        if (color === undefined) { color = 0xffffff; }\r\n\r\n        var red = (color >> 16 & 0xFF) / 255;\r\n        var green = (color >> 8 & 0xFF) / 255;\r\n        var blue = (color & 0xFF) / 255;\r\n        var alpha = (color > 16777215) ? (color >>> 24) / 255 : null;\r\n\r\n        var target = this.skeleton;\r\n\r\n        if (slotName)\r\n        {\r\n            var slot = this.findSlot(slotName);\r\n\r\n            if (slot)\r\n            {\r\n                target = slot;\r\n            }\r\n        }\r\n\r\n        target.color.r = red;\r\n        target.color.g = green;\r\n        target.color.b = blue;\r\n\r\n        if (alpha !== null)\r\n        {\r\n            target.color.a = alpha;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Game Object to use the given Skeleton based on the Atlas Data Key and a provided JSON object\r\n     * that contains the Skeleton data.\r\n     *\r\n     * @method SpineGameObject#setSkeletonFromJSON\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} atlasDataKey - The key of the Spine data to use for this Skeleton.\r\n     * @param {object} skeletonJSON - The JSON data for the Skeleton.\r\n     * @param {string} [animationName] - Optional name of the animation to set on the Skeleton.\r\n     * @param {boolean} [loop=false] - Should the animation, if set, loop or not?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkeletonFromJSON: function (atlasDataKey, skeletonJSON, animationName, loop)\r\n    {\r\n        return this.setSkeleton(atlasDataKey, skeletonJSON, animationName, loop);\r\n    },\r\n\r\n    /**\r\n     * Sets this Game Object to use the given Skeleton based on its cache key.\r\n     * \r\n     * Typically, once set, the Skeleton doesn't change. Instead, you change the skin,\r\n     * or slot attachment, or any other property to adjust it.\r\n     *\r\n     * @method SpineGameObject#setSkeleton\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} atlasDataKey - The key of the Spine data to use for this Skeleton.\r\n     * @param {object} skeletonJSON - The JSON data for the Skeleton.\r\n     * @param {string} [animationName] - Optional name of the animation to set on the Skeleton.\r\n     * @param {boolean} [loop=false] - Should the animation, if set, loop or not?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkeleton: function (atlasDataKey, animationName, loop, skeletonJSON)\r\n    {\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        var data = this.plugin.createSkeleton(atlasDataKey, skeletonJSON);\r\n\r\n        this.skeletonData = data.skeletonData;\r\n\r\n        this.preMultipliedAlpha = data.preMultipliedAlpha;\r\n\r\n        var skeleton = data.skeleton;\r\n\r\n        skeleton.setSkinByName('default');\r\n        skeleton.setToSetupPose();\r\n\r\n        this.skeleton = skeleton;\r\n\r\n        //  AnimationState\r\n        data = this.plugin.createAnimationState(skeleton);\r\n\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.state = data.state;\r\n        this.stateData = data.stateData;\r\n\r\n        this.state.addListener({\r\n            event: this.onEvent.bind(this),\r\n            complete: this.onComplete.bind(this),\r\n            start: this.onStart.bind(this),\r\n            end: this.onEnd.bind(this),\r\n            dispose: this.onDispose.bind(this),\r\n            interrupted: this.onInterrupted.bind(this)\r\n        });\r\n\r\n        if (animationName)\r\n        {\r\n            this.setAnimation(0, animationName, loop);\r\n        }\r\n\r\n        this.root = this.getRootBone();\r\n\r\n        if (this.root)\r\n        {\r\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\r\n        }\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        skeleton.updateCache();\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onComplete event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onComplete\r\n     * @fires SpinePluginEvents#COMPLETE\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onComplete: function (entry)\r\n    {\r\n        this.emit(SpineEvents.COMPLETE, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onDispose event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onDispose\r\n     * @fires SpinePluginEvents#DISPOSE\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onDispose: function (entry)\r\n    {\r\n        this.emit(SpineEvents.DISPOSE, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onEnd event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onEnd\r\n     * @fires SpinePluginEvents#END\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onEnd: function (entry)\r\n    {\r\n        this.emit(SpineEvents.END, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine Event event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onEvent\r\n     * @fires SpinePluginEvents#EVENT\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     * @param {spine.Event} event - The Spine event.\r\n     */\r\n    onEvent: function (entry, event)\r\n    {\r\n        this.emit(SpineEvents.EVENT, entry, event);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onInterrupted event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onInterrupted\r\n     * @fires SpinePluginEvents#INTERRUPTED\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onInterrupted: function (entry)\r\n    {\r\n        this.emit(SpineEvents.INTERRUPTED, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onStart event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onStart\r\n     * @fires SpinePluginEvents#START\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onStart: function (entry)\r\n    {\r\n        this.emit(SpineEvents.START, entry);\r\n    },\r\n\r\n    /**\r\n     * Refreshes the data about the current Skeleton.\r\n     * \r\n     * This will reset the rotation, position and size of the Skeleton to match this Game Object.\r\n     * \r\n     * Call this method if you need to access the Skeleton data directly, and it may have changed\r\n     * recently.\r\n     *\r\n     * @method SpineGameObject#refresh\r\n     * @since 3.19.0\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        if (this.root)\r\n        {\r\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\r\n        }\r\n\r\n        this.updateSize();\r\n\r\n        this.skeleton.updateCache();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * If no arguments are given it uses the current skeleton data dimensions.\r\n     * \r\n     * You can use this method to set a fixed size of this Game Object, such as for input detection,\r\n     * when the skeleton data doesn't match what is required in-game.\r\n     *\r\n     * @method SpineGameObject#setSize\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} [width] - The width of the Skeleton. If not given it defaults to the Skeleton Data width.\r\n     * @param {number} [height] - The height of the Skeleton. If not given it defaults to the Skeleton Data height.\r\n     * @param {number} [offsetX=0] - The horizontal offset of the Skeleton from its x and y coordinate.\r\n     * @param {number} [offsetY=0] - The vertical offset of the Skeleton from its x and y coordinate.\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    setSize: function (width, height, offsetX, offsetY)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        if (width === undefined) { width = skeleton.data.width; }\r\n        if (height === undefined) { height = skeleton.data.height; }\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.displayOriginX = skeleton.x - offsetX;\r\n        this.displayOriginY = skeleton.y - offsetY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of this Game Object from the Skeleton position.\r\n     * \r\n     * You can use this method to adjust how the position of this Game Object relates to the Skeleton it is using.\r\n     *\r\n     * @method SpineGameObject#setOffset\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} [offsetX=0] - The horizontal offset of the Skeleton from its x and y coordinate.\r\n     * @param {number} [offsetY=0] - The vertical offset of the Skeleton from its x and y coordinate.\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    setOffset: function (offsetX, offsetY)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n\r\n        this.displayOriginX = skeleton.x - offsetX;\r\n        this.displayOriginY = skeleton.y - offsetY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that syncs all of the Game Object position and scale data to the Skeleton.\r\n     * It then syncs the skeleton bounds back to this Game Object.\r\n     * \r\n     * This method is called automatically as needed internally, however, it's also exposed should\r\n     * you require overriding the size settings.\r\n     *\r\n     * @method SpineGameObject#updateSize\r\n     * @since 3.19.0\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    updateSize: function ()\r\n    {\r\n        var skeleton = this.skeleton;\r\n        var renderer = this.plugin.renderer;\r\n\r\n        var height = renderer.height;\r\n\r\n        var oldScaleX = this.scaleX;\r\n        var oldScaleY = this.scaleY;\r\n\r\n        skeleton.x = this.x;\r\n        skeleton.y = height - this.y;\r\n        skeleton.scaleX = 1;\r\n        skeleton.scaleY = 1;\r\n\r\n        skeleton.updateWorldTransform();\r\n\r\n        var bounds = this.getBounds();\r\n\r\n        this.width = bounds.size.x;\r\n        this.height = bounds.size.y;\r\n\r\n        this.displayOriginX = this.x - bounds.offset.x;\r\n        this.displayOriginY = this.y - (height - (this.height + bounds.offset.y));\r\n\r\n        skeleton.scaleX = oldScaleX;\r\n        skeleton.scaleY = oldScaleY;\r\n\r\n        skeleton.updateWorldTransform();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object, as applied to the Skeleton it is using.\r\n     *\r\n     * @name SpineGameObject#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.19.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            this.refresh();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object, as applied to the Skeleton it is using.\r\n     *\r\n     * @name SpineGameObject#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.19.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            this.refresh();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the bones in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getBoneList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the bones in the Skeleton Data.\r\n     */\r\n    getBoneList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.bones.length; i++)\r\n            {\r\n                output.push(skeletonData.bones[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the skins in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getSkinList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the skins in the Skeleton Data.\r\n     */\r\n    getSkinList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.skins.length; i++)\r\n            {\r\n                output.push(skeletonData.skins[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the slots in the Skeleton.\r\n     *\r\n     * @method SpineGameObject#getSlotList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the slots in the Skeleton.\r\n     */\r\n    getSlotList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeleton = this.skeleton;\r\n\r\n        for (var i = 0; i < skeleton.slots.length; i++)\r\n        {\r\n            output.push(skeleton.slots[i].data.name);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the animations in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getAnimationList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the animations in the Skeleton Data.\r\n     */\r\n    getAnimationList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.animations.length; i++)\r\n            {\r\n                output.push(skeletonData.animations[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the current animation being played on the given track, if any.\r\n     *\r\n     * @method SpineGameObject#getCurrentAnimation\r\n     * @since 3.19.0\r\n     * \r\n     * @param {integer} [trackIndex=0] - The track to return the current animation on.\r\n     * \r\n     * @return {?spine.Animation} The current Animation on the given track, or `undefined` if there is no current animation.\r\n     */\r\n    getCurrentAnimation: function (trackIndex)\r\n    {\r\n        if (trackIndex === undefined) { trackIndex = 0; }\r\n\r\n        var current = this.state.getCurrent(trackIndex);\r\n\r\n        if (current)\r\n        {\r\n            return current.animation;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current animation for a track, discarding any queued animations.\r\n     * If the formerly current track entry was never applied to a skeleton, it is replaced (not mixed from).\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     *\r\n     * @method SpineGameObject#play\r\n     * @fires SpinePluginEvents#START\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} animationName - The string-based key of the animation to play.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n     *\r\n     * @return {this} This Game Object. If you need the TrackEntry, see `setAnimation` instead.\r\n     */\r\n    play: function (animationName, loop, ignoreIfPlaying)\r\n    {\r\n        this.setAnimation(0, animationName, loop, ignoreIfPlaying);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current animation for a track, discarding any queued animations.\r\n     * If the formerly current track entry was never applied to a skeleton, it is replaced (not mixed from).\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     *\r\n     * @method SpineGameObject#setAnimation\r\n     * @fires SpinePluginEvents#START\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to play the animation on.\r\n     * @param {string} animationName - The string-based key of the animation to play.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n     *\r\n     * @return {spine.TrackEntry} A track entry to allow further customization of animation playback.\r\n     */\r\n    setAnimation: function (trackIndex, animationName, loop, ignoreIfPlaying)\r\n    {\r\n        if (loop === undefined) { loop = false; }\r\n        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }\r\n\r\n        if (ignoreIfPlaying && this.state)\r\n        {\r\n            var currentTrack = this.state.getCurrent(0);\r\n \r\n            if (currentTrack && currentTrack.animation.name === animationName && !currentTrack.isComplete())\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this.findAnimation(animationName))\r\n        {\r\n            return this.state.setAnimation(trackIndex, animationName, loop);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an animation to be played after the current or last queued animation for a track.\r\n     * If the track is empty, it is equivalent to calling setAnimation.\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     * \r\n     * The delay is a float. If > 0, sets delay. If <= 0, the delay set is the duration of the previous\r\n     * track entry minus any mix duration (from the AnimationStateData) plus the specified delay\r\n     * (ie the mix ends at (delay = 0) or before (delay < 0) the previous track entry duration).\r\n     * If the previous entry is looping, its next loop completion is used instead of its duration.\r\n     *\r\n     * @method SpineGameObject#addAnimation\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     * @param {string} animationName - The string-based key of the animation to add.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {integer} [delay=0] - A delay, in ms, before which this animation will start when played.\r\n     *\r\n     * @return {spine.TrackEntry} A track entry to allow further customization of animation playback.\r\n     */\r\n    addAnimation: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        return this.state.addAnimation(trackIndex, animationName, loop, delay);\r\n    },\r\n\r\n    /**\r\n     * Sets an empty animation for a track, discarding any queued animations, and sets the track\r\n     * entry's mixDuration. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     * \r\n     * Mixing out is done by setting an empty animation with a mix duration using either setEmptyAnimation,\r\n     * setEmptyAnimations, or addEmptyAnimation. Mixing to an empty animation causes the previous animation to be\r\n     * applied less and less over the mix duration. Properties keyed in the previous animation transition to\r\n     * the value from lower tracks or to the setup pose value if no lower tracks key the property.\r\n     * A mix duration of 0 still mixes out over one frame.\r\n     * \r\n     * Mixing in is done by first setting an empty animation, then adding an animation using addAnimation\r\n     * and on the returned track entry, set the mixDuration. Mixing from an empty animation causes the new\r\n     * animation to be applied more and more over the mix duration. Properties keyed in the new animation\r\n     * transition from the value from lower tracks or from the setup pose value if no lower tracks key the\r\n     * property to the value keyed in the new animation.\r\n     *\r\n     * @method SpineGameObject#setEmptyAnimation\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     * @param {integer} [mixDuration] - Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData getMix based on the animation before this animation (if any).\r\n     *\r\n     * @return {spine.TrackEntry} The returned Track Entry.\r\n     */\r\n    setEmptyAnimation: function (trackIndex, mixDuration)\r\n    {\r\n        return this.state.setEmptyAnimation(trackIndex, mixDuration);\r\n    },\r\n\r\n    /**\r\n     * Removes all animations from the track, leaving skeletons in their current pose.\r\n     * \r\n     * It may be desired to use setEmptyAnimation to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose.\r\n     *\r\n     * @method SpineGameObject#clearTrack\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        this.state.clearTrack(trackIndex);\r\n\r\n        return this;\r\n    },\r\n     \r\n    /**\r\n     * Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     * \r\n     * It may be desired to use setEmptyAnimation to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose.\r\n     *\r\n     * @method SpineGameObject#clearTracks\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clearTracks: function ()\r\n    {\r\n        this.state.clearTracks();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the skin used to look up attachments before looking in the defaultSkin.\r\n     * \r\n     * Attachments from the new skin are attached if the corresponding attachment from the\r\n     * old skin was attached. If there was no old skin, each slot's setup mode attachment is\r\n     * attached from the new skin.\r\n     * \r\n     * After changing the skin, the visible attachments can be reset to those attached in the\r\n     * setup pose by calling setSlotsToSetupPose. Also, often apply is called before the next time\r\n     * the skeleton is rendered to allow any attachment keys in the current animation(s) to hide\r\n     * or show attachments from the new skin.\r\n     *\r\n     * @method SpineGameObject#setSkinByName\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} skinName - The name of the skin to set.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.setSkinByName(skinName);\r\n\r\n        skeleton.setSlotsToSetupPose();\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the skin used to look up attachments before looking in the defaultSkin.\r\n     * \r\n     * Attachments from the new skin are attached if the corresponding attachment from the\r\n     * old skin was attached. If there was no old skin, each slot's setup mode attachment is\r\n     * attached from the new skin.\r\n     * \r\n     * After changing the skin, the visible attachments can be reset to those attached in the\r\n     * setup pose by calling setSlotsToSetupPose. Also, often apply is called before the next time\r\n     * the skeleton is rendered to allow any attachment keys in the current animation(s) to hide\r\n     * or show attachments from the new skin.\r\n     *\r\n     * @method SpineGameObject#setSkin\r\n     * @since 3.19.0\r\n     * \r\n     * @param {?spine.Skin} newSkin - The Skin to set. May be `null`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkin: function (newSkin)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.setSkin(newSkin);\r\n\r\n        skeleton.setSlotsToSetupPose();\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the mix duration when changing from the specified animation to the other.\r\n     *\r\n     * @method SpineGameObject#setMix\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} fromName - The animation to mix from.\r\n     * @param {string} toName - The animation to mix to.\r\n     * @param {number} [duration] - Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData getMix based on the animation before this animation (if any).\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setMix: function (fromName, toName, duration)\r\n    {\r\n        this.stateData.setMix(fromName, toName, duration);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Finds an attachment by looking in the skin and defaultSkin using the slot\r\n     * index and attachment name. First the skin is checked and if the attachment was not found,\r\n     * the default skin is checked.\r\n     *\r\n     * @method SpineGameObject#getAttachment\r\n     * @since 3.19.0\r\n     * \r\n     * @param {integer} slotIndex - The slot index to search.\r\n     * @param {string} attachmentName - The attachment name to look for.\r\n     *\r\n     * @return {?spine.Attachment} The Attachment, if found. May be null.\r\n     */\r\n    getAttachment: function (slotIndex, attachmentName)\r\n    {\r\n        return this.skeleton.getAttachment(slotIndex, attachmentName);\r\n    },\r\n\r\n    /**\r\n     * Finds an attachment by looking in the skin and defaultSkin using the slot name and attachment name.\r\n     *\r\n     * @method SpineGameObject#getAttachmentByName\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The slot name to search.\r\n     * @param {string} attachmentName - The attachment name to look for.\r\n     *\r\n     * @return {?spine.Attachment} The Attachment, if found. May be null.\r\n     */\r\n    getAttachmentByName: function (slotName, attachmentName)\r\n    {\r\n        return this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n    },\r\n\r\n    /**\r\n     * A convenience method to set an attachment by finding the slot with findSlot,\r\n     * finding the attachment with getAttachment, then setting the slot's attachment.\r\n     *\r\n     * @method SpineGameObject#setAttachment\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The slot name to add the attachment to.\r\n     * @param {string} attachmentName - The attachment name to add.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        if (Array.isArray(slotName) && Array.isArray(attachmentName) && slotName.length === attachmentName.length)\r\n        {\r\n            for (var i = 0; i < slotName.length; i++)\r\n            {\r\n                this.skeleton.setAttachment(slotName[i], attachmentName[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.skeleton.setAttachment(slotName, attachmentName);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the bones, constraints, slots, and draw order to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.skeleton.setToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the slots and draw order to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setSlotsToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        this.skeleton.setSlotsToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the bones and constraints to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setBonesToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        this.skeleton.setBonesToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the root bone, or null.\r\n     *\r\n     * @method SpineGameObject#getRootBone\r\n     * @since 3.19.0\r\n     *\r\n     * @return {spine.Bone} The root bone, or null.\r\n     */\r\n    getRootBone: function ()\r\n    {\r\n        return this.skeleton.getRootBone();\r\n    },\r\n\r\n    /**\r\n     * Takes a Bone object and a position in world space and rotates the Bone so it is angled\r\n     * towards the given position. You can set an optional angle offset, should the bone be\r\n     * designed at a specific angle already. You can also set a minimum and maximum range for the angle.\r\n     *\r\n     * @method SpineGameObject#angleBoneToXY\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Bone} bone - The bone to rotate towards the world position.\r\n     * @param {number} worldX - The world x coordinate to rotate the bone towards.\r\n     * @param {number} worldY - The world y coordinate to rotate the bone towards.\r\n     * @param {number} [offset=0] - An offset to add to the rotation angle.\r\n     * @param {number} [minAngle=0] - The minimum range of the rotation angle.\r\n     * @param {number} [maxAngle=360] - The maximum range of the rotation angle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    angleBoneToXY: function (bone, worldX, worldY, offset, minAngle, maxAngle)\r\n    {\r\n        if (offset === undefined) { offset = 0; }\r\n        if (minAngle === undefined) { minAngle = 0; }\r\n        if (maxAngle === undefined) { maxAngle = 360; }\r\n\r\n        var renderer = this.plugin.renderer;\r\n        var height = renderer.height;\r\n\r\n        var angle = CounterClockwise(AngleBetween(bone.worldX, height - bone.worldY, worldX, worldY) + DegToRad(offset));\r\n\r\n        bone.rotation = Clamp(RadToDeg(angle), minAngle, maxAngle);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Finds a bone by comparing each bone's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findBone\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} boneName - The name of the bone to find.\r\n     *\r\n     * @return {spine.Bone} The bone, or null.\r\n     */\r\n    findBone: function (boneName)\r\n    {\r\n        return this.skeleton.findBone(boneName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a bone by comparing each bone's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findBoneIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} boneName - The name of the bone to find.\r\n     *\r\n     * @return {integer} The bone index. Or -1 if the bone was not found.\r\n     */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        return this.skeleton.findBoneIndex(boneName);\r\n    },\r\n\r\n    /**\r\n     * Finds a slot by comparing each slot's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSlot\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The name of the slot to find.\r\n     *\r\n     * @return {spine.Slot} The Slot. May be null.\r\n     */\r\n    findSlot: function (slotName)\r\n    {\r\n        return this.skeleton.findSlot(slotName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a slot by comparing each slot's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSlotIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The name of the slot to find.\r\n     *\r\n     * @return {integer} The slot index. Or -1 if the Slot was not found.\r\n     */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        return this.skeleton.findSlotIndex(slotName);\r\n    },\r\n\r\n    /**\r\n     * Finds a skin by comparing each skin's name. It is more efficient to cache the results of\r\n     * this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSkin\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} skinName - The name of the skin to find.\r\n     *\r\n     * @return {spine.Skin} The Skin. May be null.\r\n     */\r\n    findSkin: function (skinName)\r\n    {\r\n        return this.skeletonData.findSkin(skinName);\r\n    },\r\n\r\n    /**\r\n     * Finds an event by comparing each events's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findEvent\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} eventDataName - The name of the event to find.\r\n     *\r\n     * @return {spine.EventData} The Event Data. May be null.\r\n     */\r\n    findEvent: function (eventDataName)\r\n    {\r\n        return this.skeletonData.findEvent(eventDataName);\r\n    },\r\n\r\n    /**\r\n     * Finds an animation by comparing each animation's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findAnimation\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} animationName - The name of the animation to find.\r\n     *\r\n     * @return {spine.Animation} The Animation. May be null.\r\n     */\r\n    findAnimation: function (animationName)\r\n    {\r\n        return this.skeletonData.findAnimation(animationName);\r\n    },\r\n\r\n    /**\r\n     * Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findIkConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.IkConstraintData} The IK constraint. May be null.\r\n     */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findIkConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds an transform constraint by comparing each transform constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findTransformConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.TransformConstraintData} The transform constraint. May be null.\r\n     */\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findTransformConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds a path constraint by comparing each path constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findPathConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.PathConstraintData} The path constraint. May be null.\r\n     */\r\n    findPathConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findPathConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a path constraint by comparing each path constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findPathConstraintIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {integer} The constraint index. Or -1 if the constraint was not found.\r\n     */\r\n    findPathConstraintIndex: function (constraintName)\r\n    {\r\n        return this.skeletonData.findPathConstraintIndex(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * \r\n     * The returned object contains two properties: `offset` and `size`:\r\n     * \r\n     * `offset` - The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * `size` - The width and height of the AABB.\r\n     *\r\n     * @method SpineGameObject#getBounds\r\n     * @since 3.19.0\r\n     * \r\n     * @return {any} The bounds object.\r\n     */\r\n    getBounds: function ()\r\n    {\r\n        return this.plugin.getBounds(this.skeleton);\r\n    },\r\n\r\n    /**\r\n     * Internal update handler.\r\n     *\r\n     * @method SpineGameObject#preUpdate\r\n     * @protected\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        this.state.update((delta / 1000) * this.timeScale);\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        // this.emit('spine.update', skeleton);\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method SpineGameObject#preDestroy\r\n     * @protected\r\n     * @since 3.19.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.plugin = null;\r\n\r\n        this.skeleton = null;\r\n        this.skeletonData = null;\r\n\r\n        this.state = null;\r\n        this.stateData = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\nvar RadToDeg = require('../../../../src/math/RadToDeg');\r\nvar Wrap = require('../../../../src/math/Wrap');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method SpineGameObject#renderCanvas\r\n * @since 3.19.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {SpineGameObject} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpineGameObjectCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var context = renderer.currentContext;\r\n\r\n    var plugin = src.plugin;\r\n    var skeleton = src.skeleton;\r\n    var skeletonRenderer = plugin.skeletonRenderer;\r\n\r\n    var GameObjectRenderMask = 15;\r\n\r\n    var willRender = !(GameObjectRenderMask !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)));\r\n\r\n    if (!skeleton || !willRender)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = renderer._tempMatrix1;\r\n    var spriteMatrix = renderer._tempMatrix2;\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, Math.abs(src.scaleX), Math.abs(src.scaleY));\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    skeleton.x = calcMatrix.tx;\r\n    skeleton.y = calcMatrix.ty;\r\n\r\n    skeleton.scaleX = calcMatrix.scaleX;\r\n\r\n    //  Inverse or we get upside-down skeletons\r\n    skeleton.scaleY = calcMatrix.scaleY * -1;\r\n\r\n    if (src.scaleX < 0)\r\n    {\r\n        skeleton.scaleX *= -1;\r\n\r\n        src.root.rotation = RadToDeg(calcMatrix.rotationNormalized);\r\n    }\r\n    else\r\n    {\r\n        //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n        src.root.rotation = Wrap(RadToDeg(CounterClockwise(calcMatrix.rotationNormalized)) + 90, 0, 360);\r\n    }\r\n\r\n    if (src.scaleY < 0)\r\n    {\r\n        skeleton.scaleY *= -1;\r\n\r\n        if (src.scaleX < 0)\r\n        {\r\n            src.root.rotation -= (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n        else\r\n        {\r\n            src.root.rotation += (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n    }\r\n\r\n    if (camera.renderToTexture)\r\n    {\r\n        skeleton.y = calcMatrix.ty;\r\n        skeleton.scaleY *= -1;\r\n    }\r\n\r\n    //  Add autoUpdate option\r\n    skeleton.updateWorldTransform();\r\n\r\n    skeletonRenderer.ctx = context;\r\n    skeletonRenderer.debugRendering = (plugin.drawDebug || src.drawDebug);\r\n\r\n    context.save();\r\n\r\n    skeletonRenderer.draw(skeleton);\r\n\r\n    context.restore();\r\n};\r\n\r\nmodule.exports = SpineGameObjectCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../../src/utils/NOOP');\r\nvar renderCanvas = require('../../../../src/utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpineGameObjectWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpineGameObjectCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\nvar __extends = (this && this.__extends) || (function () {\r\n\tvar extendStatics = Object.setPrototypeOf ||\r\n\t\t({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t\tfunction (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\treturn function (d, b) {\r\n\t\textendStatics(d, b);\r\n\t\tfunction __() { this.constructor = d; }\r\n\t\td.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Animation = (function () {\r\n\t\tfunction Animation(name, timelines, duration) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (timelines == null)\r\n\t\t\t\tthrow new Error(\"timelines cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.timelines = timelines;\r\n\t\t\tthis.duration = duration;\r\n\t\t}\r\n\t\tAnimation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (loop && this.duration != 0) {\r\n\t\t\t\ttime %= this.duration;\r\n\t\t\t\tif (lastTime > 0)\r\n\t\t\t\t\tlastTime %= this.duration;\r\n\t\t\t}\r\n\t\t\tvar timelines = this.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n\t\t};\r\n\t\tAnimation.binarySearch = function (values, target, step) {\r\n\t\t\tif (step === void 0) { step = 1; }\r\n\t\t\tvar low = 0;\r\n\t\t\tvar high = values.length / step - 2;\r\n\t\t\tif (high == 0)\r\n\t\t\t\treturn step;\r\n\t\t\tvar current = high >>> 1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (values[(current + 1) * step] <= target)\r\n\t\t\t\t\tlow = current + 1;\r\n\t\t\t\telse\r\n\t\t\t\t\thigh = current;\r\n\t\t\t\tif (low == high)\r\n\t\t\t\t\treturn (low + 1) * step;\r\n\t\t\t\tcurrent = (low + high) >>> 1;\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimation.linearSearch = function (values, target, step) {\r\n\t\t\tfor (var i = 0, last = values.length - step; i <= last; i += step)\r\n\t\t\t\tif (values[i] > target)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn Animation;\r\n\t}());\r\n\tspine.Animation = Animation;\r\n\tvar MixBlend;\r\n\t(function (MixBlend) {\r\n\t\tMixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\r\n\t\tMixBlend[MixBlend[\"first\"] = 1] = \"first\";\r\n\t\tMixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\r\n\t\tMixBlend[MixBlend[\"add\"] = 3] = \"add\";\r\n\t})(MixBlend = spine.MixBlend || (spine.MixBlend = {}));\r\n\tvar MixDirection;\r\n\t(function (MixDirection) {\r\n\t\tMixDirection[MixDirection[\"in\"] = 0] = \"in\";\r\n\t\tMixDirection[MixDirection[\"out\"] = 1] = \"out\";\r\n\t})(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\r\n\tvar TimelineType;\r\n\t(function (TimelineType) {\r\n\t\tTimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n\t\tTimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n\t\tTimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n\t\tTimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n\t\tTimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n\t\tTimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n\t\tTimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n\t\tTimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n\t\tTimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n\t\tTimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n\t\tTimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n\t\tTimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n\t})(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\r\n\tvar CurveTimeline = (function () {\r\n\t\tfunction CurveTimeline(frameCount) {\r\n\t\t\tif (frameCount <= 0)\r\n\t\t\t\tthrow new Error(\"frameCount must be > 0: \" + frameCount);\r\n\t\t\tthis.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n\t\t}\r\n\t\tCurveTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setLinear = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setStepped = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n\t\t\tvar index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tif (index == this.curves.length)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tvar type = this.curves[index];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn CurveTimeline.STEPPED;\r\n\t\t\treturn CurveTimeline.BEZIER;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n\t\t\tvar tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n\t\t\tvar dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n\t\t\tvar ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n\t\t\tvar dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tcurves[i++] = CurveTimeline.BEZIER;\r\n\t\t\tvar x = dfx, y = dfy;\r\n\t\t\tfor (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tcurves[i] = x;\r\n\t\t\t\tcurves[i + 1] = y;\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tx += dfx;\r\n\t\t\t\ty += dfy;\r\n\t\t\t}\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n\t\t\tpercent = spine.MathUtils.clamp(percent, 0, 1);\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar type = curves[i];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn percent;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn 0;\r\n\t\t\ti++;\r\n\t\t\tvar x = 0;\r\n\t\t\tfor (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tx = curves[i];\r\n\t\t\t\tif (x >= percent) {\r\n\t\t\t\t\tvar prevX = void 0, prevY = void 0;\r\n\t\t\t\t\tif (i == start) {\r\n\t\t\t\t\t\tprevX = 0;\r\n\t\t\t\t\t\tprevY = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tprevX = curves[i - 2];\r\n\t\t\t\t\t\tprevY = curves[i - 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar y = curves[i - 1];\r\n\t\t\treturn y + (1 - y) * (percent - x) / (1 - x);\r\n\t\t};\r\n\t\tCurveTimeline.LINEAR = 0;\r\n\t\tCurveTimeline.STEPPED = 1;\r\n\t\tCurveTimeline.BEZIER = 2;\r\n\t\tCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n\t\treturn CurveTimeline;\r\n\t}());\r\n\tspine.CurveTimeline = CurveTimeline;\r\n\tvar RotateTimeline = (function (_super) {\r\n\t\t__extends(RotateTimeline, _super);\r\n\t\tfunction RotateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount << 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRotateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.rotate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n\t\t\tframeIndex <<= 1;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tvar r_1 = bone.data.rotation - bone.rotation;\r\n\t\t\t\t\t\tbone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n\t\t\t\tvar r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tbone.rotation = bone.data.rotation + r_2 * alpha;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\t\tr_2 += bone.data.rotation - bone.rotation;\r\n\t\t\t\t\t\tr_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n\t\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\t\tbone.rotation += r_2 * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n\t\t\tvar prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\tvar r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\tr = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tr += bone.data.rotation - bone.rotation;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tbone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRotateTimeline.ENTRIES = 2;\r\n\t\tRotateTimeline.PREV_TIME = -2;\r\n\t\tRotateTimeline.PREV_ROTATION = -1;\r\n\t\tRotateTimeline.ROTATION = 1;\r\n\t\treturn RotateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.RotateTimeline = RotateTimeline;\r\n\tvar TranslateTimeline = (function (_super) {\r\n\t\t__extends(TranslateTimeline, _super);\r\n\t\tfunction TranslateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTranslateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.translate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n\t\t\tframeIndex *= TranslateTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.X] = x;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.Y] = y;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tbone.x = bone.data.x;\r\n\t\t\t\t\t\tbone.y = bone.data.y;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\r\n\t\t\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + TranslateTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + TranslateTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n\t\t\t\ty += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbone.x = bone.data.x + x * alpha;\r\n\t\t\t\t\tbone.y = bone.data.y + y * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\r\n\t\t\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tbone.x += x * alpha;\r\n\t\t\t\t\tbone.y += y * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTranslateTimeline.ENTRIES = 3;\r\n\t\tTranslateTimeline.PREV_TIME = -3;\r\n\t\tTranslateTimeline.PREV_X = -2;\r\n\t\tTranslateTimeline.PREV_Y = -1;\r\n\t\tTranslateTimeline.X = 1;\r\n\t\tTranslateTimeline.Y = 2;\r\n\t\treturn TranslateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TranslateTimeline = TranslateTimeline;\r\n\tvar ScaleTimeline = (function (_super) {\r\n\t\t__extends(ScaleTimeline, _super);\r\n\t\tfunction ScaleTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tScaleTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.scale << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tbone.scaleX = bone.data.scaleX;\r\n\t\t\t\t\t\tbone.scaleY = bone.data.scaleY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n\t\t\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n\t\t\t\ty = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ScaleTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ScaleTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n\t\t\t\ty = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\t\tbone.scaleX += x - bone.data.scaleX;\r\n\t\t\t\t\tbone.scaleY += y - bone.data.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbone.scaleX = x;\r\n\t\t\t\t\tbone.scaleY = y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar bx = 0, by = 0;\r\n\t\t\t\tif (direction == MixDirection.out) {\r\n\t\t\t\t\tswitch (blend) {\r\n\t\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\t\tbx = bone.data.scaleX;\r\n\t\t\t\t\t\t\tby = bone.data.scaleY;\r\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t\t\t\tbone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tswitch (blend) {\r\n\t\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\t\tbx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);\r\n\t\t\t\t\t\t\tby = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);\r\n\t\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\t\t\tbx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);\r\n\t\t\t\t\t\t\tby = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);\r\n\t\t\t\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\t\t\tbx = spine.MathUtils.signum(x);\r\n\t\t\t\t\t\t\tby = spine.MathUtils.signum(y);\r\n\t\t\t\t\t\t\tbone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n\t\t\t\t\t\t\tbone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ScaleTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ScaleTimeline = ScaleTimeline;\r\n\tvar ShearTimeline = (function (_super) {\r\n\t\t__extends(ShearTimeline, _super);\r\n\t\tfunction ShearTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tShearTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.shear << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tbone.shearX = bone.data.shearX;\r\n\t\t\t\t\t\tbone.shearY = bone.data.shearY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n\t\t\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + ShearTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ShearTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n\t\t\t\ty = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tswitch (blend) {\r\n\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\tbone.shearX = bone.data.shearX + x * alpha;\r\n\t\t\t\t\tbone.shearY = bone.data.shearY + y * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.first:\r\n\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n\t\t\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\tbone.shearX += x * alpha;\r\n\t\t\t\t\tbone.shearY += y * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ShearTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ShearTimeline = ShearTimeline;\r\n\tvar ColorTimeline = (function (_super) {\r\n\t\t__extends(ColorTimeline, _super);\r\n\t\tfunction ColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.color << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n\t\t\tframeIndex *= ColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.A] = a;\r\n\t\t};\r\n\t\tColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tvar color = slot.color, setup = slot.data.color;\r\n\t\t\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0;\r\n\t\t\tif (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + ColorTimeline.PREV_A];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + ColorTimeline.PREV_A];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + ColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + ColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + ColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + ColorTimeline.A] - a) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1)\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\telse {\r\n\t\t\t\tvar color = slot.color;\r\n\t\t\t\tif (blend == MixBlend.setup)\r\n\t\t\t\t\tcolor.setFromColor(slot.data.color);\r\n\t\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n\t\t\t}\r\n\t\t};\r\n\t\tColorTimeline.ENTRIES = 5;\r\n\t\tColorTimeline.PREV_TIME = -5;\r\n\t\tColorTimeline.PREV_R = -4;\r\n\t\tColorTimeline.PREV_G = -3;\r\n\t\tColorTimeline.PREV_B = -2;\r\n\t\tColorTimeline.PREV_A = -1;\r\n\t\tColorTimeline.R = 1;\r\n\t\tColorTimeline.G = 2;\r\n\t\tColorTimeline.B = 3;\r\n\t\tColorTimeline.A = 4;\r\n\t\treturn ColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.ColorTimeline = ColorTimeline;\r\n\tvar TwoColorTimeline = (function (_super) {\r\n\t\t__extends(TwoColorTimeline, _super);\r\n\t\tfunction TwoColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTwoColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.twoColor << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n\t\t\tframeIndex *= TwoColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.A] = a;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\tslot.darkColor.setFromColor(slot.data.darkColor);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tvar light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n\t\t\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n\t\t\t\t\t\tdark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n\t\t\tif (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[i + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[i + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[i + TwoColorTimeline.PREV_B2];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n\t\t\t\tr2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n\t\t\t\tg2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n\t\t\t\tb2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\t\tslot.darkColor.set(r2, g2, b2, 1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar light = slot.color, dark = slot.darkColor;\r\n\t\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\t\tlight.setFromColor(slot.data.color);\r\n\t\t\t\t\tdark.setFromColor(slot.data.darkColor);\r\n\t\t\t\t}\r\n\t\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n\t\t\t\tdark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTwoColorTimeline.ENTRIES = 8;\r\n\t\tTwoColorTimeline.PREV_TIME = -8;\r\n\t\tTwoColorTimeline.PREV_R = -7;\r\n\t\tTwoColorTimeline.PREV_G = -6;\r\n\t\tTwoColorTimeline.PREV_B = -5;\r\n\t\tTwoColorTimeline.PREV_A = -4;\r\n\t\tTwoColorTimeline.PREV_R2 = -3;\r\n\t\tTwoColorTimeline.PREV_G2 = -2;\r\n\t\tTwoColorTimeline.PREV_B2 = -1;\r\n\t\tTwoColorTimeline.R = 1;\r\n\t\tTwoColorTimeline.G = 2;\r\n\t\tTwoColorTimeline.B = 3;\r\n\t\tTwoColorTimeline.A = 4;\r\n\t\tTwoColorTimeline.R2 = 5;\r\n\t\tTwoColorTimeline.G2 = 6;\r\n\t\tTwoColorTimeline.B2 = 7;\r\n\t\treturn TwoColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TwoColorTimeline = TwoColorTimeline;\r\n\tvar AttachmentTimeline = (function () {\r\n\t\tfunction AttachmentTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.attachmentNames = new Array(frameCount);\r\n\t\t}\r\n\t\tAttachmentTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.attachment << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.attachmentNames[frameIndex] = attachmentName;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tif (direction == MixDirection.out && blend == MixBlend.setup) {\r\n\t\t\t\tvar attachmentName_1 = slot.data.attachmentName;\r\n\t\t\t\tslot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first) {\r\n\t\t\t\t\tvar attachmentName_2 = slot.data.attachmentName;\r\n\t\t\t\t\tslot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frameIndex = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframeIndex = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframeIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\t\t\tvar attachmentName = this.attachmentNames[frameIndex];\r\n\t\t\tskeleton.slots[this.slotIndex]\r\n\t\t\t\t.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n\t\t};\r\n\t\treturn AttachmentTimeline;\r\n\t}());\r\n\tspine.AttachmentTimeline = AttachmentTimeline;\r\n\tvar zeros = null;\r\n\tvar DeformTimeline = (function (_super) {\r\n\t\t__extends(DeformTimeline, _super);\r\n\t\tfunction DeformTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\t_this.frameVertices = new Array(frameCount);\r\n\t\t\tif (zeros == null)\r\n\t\t\t\tzeros = spine.Utils.newFloatArray(64);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tDeformTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frameVertices[frameIndex] = vertices;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\tif (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar verticesArray = slot.attachmentVertices;\r\n\t\t\tif (verticesArray.length == 0)\r\n\t\t\t\tblend = MixBlend.setup;\r\n\t\t\tvar frameVertices = this.frameVertices;\r\n\t\t\tvar vertexCount = frameVertices[0].length;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar vertices_1 = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\talpha = 1 - alpha;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] *= alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar vertices = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\tif (time >= frames[frames.length - 1]) {\r\n\t\t\t\tvar lastVertices = frameVertices[frames.length - 1];\r\n\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\tfor (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n\t\t\t\t\t\t\t\tvertices[i_1] += lastVertices[i_1] - setupVertices[i_1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tfor (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n\t\t\t\t\t\t\t\tvertices[i_2] += lastVertices[i_2];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tspine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tswitch (blend) {\r\n\t\t\t\t\t\tcase MixBlend.setup: {\r\n\t\t\t\t\t\t\tvar vertexAttachment_1 = slotAttachment;\r\n\t\t\t\t\t\t\tif (vertexAttachment_1.bones == null) {\r\n\t\t\t\t\t\t\t\tvar setupVertices = vertexAttachment_1.vertices;\r\n\t\t\t\t\t\t\t\tfor (var i_3 = 0; i_3 < vertexCount; i_3++) {\r\n\t\t\t\t\t\t\t\t\tvar setup = setupVertices[i_3];\r\n\t\t\t\t\t\t\t\t\tvertices[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tfor (var i_4 = 0; i_4 < vertexCount; i_4++)\r\n\t\t\t\t\t\t\t\t\tvertices[i_4] = lastVertices[i_4] * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\t\t\tfor (var i_5 = 0; i_5 < vertexCount; i_5++)\r\n\t\t\t\t\t\t\t\tvertices[i_5] += (lastVertices[i_5] - vertices[i_5]) * alpha;\r\n\t\t\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\t\tfor (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n\t\t\t\t\t\t\t\t\tvertices[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tfor (var i_7 = 0; i_7 < vertexCount; i_7++)\r\n\t\t\t\t\t\t\t\t\tvertices[i_7] += lastVertices[i_7] * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time);\r\n\t\t\tvar prevVertices = frameVertices[frame - 1];\r\n\t\t\tvar nextVertices = frameVertices[frame];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tif (blend == MixBlend.add) {\r\n\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (var i_8 = 0; i_8 < vertexCount; i_8++) {\r\n\t\t\t\t\t\t\tvar prev = prevVertices[i_8];\r\n\t\t\t\t\t\t\tvertices[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfor (var i_9 = 0; i_9 < vertexCount; i_9++) {\r\n\t\t\t\t\t\t\tvar prev = prevVertices[i_9];\r\n\t\t\t\t\t\t\tvertices[i_9] += prev + (nextVertices[i_9] - prev) * percent;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var i_10 = 0; i_10 < vertexCount; i_10++) {\r\n\t\t\t\t\t\tvar prev = prevVertices[i_10];\r\n\t\t\t\t\t\tvertices[i_10] = prev + (nextVertices[i_10] - prev) * percent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup: {\r\n\t\t\t\t\t\tvar vertexAttachment_2 = slotAttachment;\r\n\t\t\t\t\t\tif (vertexAttachment_2.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment_2.vertices;\r\n\t\t\t\t\t\t\tfor (var i_11 = 0; i_11 < vertexCount; i_11++) {\r\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_11], setup = setupVertices[i_11];\r\n\t\t\t\t\t\t\t\tvertices[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tfor (var i_12 = 0; i_12 < vertexCount; i_12++) {\r\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_12];\r\n\t\t\t\t\t\t\t\tvertices[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\tcase MixBlend.replace:\r\n\t\t\t\t\t\tfor (var i_13 = 0; i_13 < vertexCount; i_13++) {\r\n\t\t\t\t\t\t\tvar prev = prevVertices[i_13];\r\n\t\t\t\t\t\t\tvertices[i_13] += (prev + (nextVertices[i_13] - prev) * percent - vertices[i_13]) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase MixBlend.add:\r\n\t\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\tfor (var i_14 = 0; i_14 < vertexCount; i_14++) {\r\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_14];\r\n\t\t\t\t\t\t\t\tvertices[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tfor (var i_15 = 0; i_15 < vertexCount; i_15++) {\r\n\t\t\t\t\t\t\t\tvar prev = prevVertices[i_15];\r\n\t\t\t\t\t\t\t\tvertices[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DeformTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.DeformTimeline = DeformTimeline;\r\n\tvar EventTimeline = (function () {\r\n\t\tfunction EventTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.events = new Array(frameCount);\r\n\t\t}\r\n\t\tEventTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.event << 24;\r\n\t\t};\r\n\t\tEventTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tEventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n\t\t\tthis.frames[frameIndex] = event.time;\r\n\t\t\tthis.events[frameIndex] = event;\r\n\t\t};\r\n\t\tEventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tif (firedEvents == null)\r\n\t\t\t\treturn;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar frameCount = this.frames.length;\r\n\t\t\tif (lastTime > time) {\r\n\t\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n\t\t\t\tlastTime = -1;\r\n\t\t\t}\r\n\t\t\telse if (lastTime >= frames[frameCount - 1])\r\n\t\t\t\treturn;\r\n\t\t\tif (time < frames[0])\r\n\t\t\t\treturn;\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (lastTime < frames[0])\r\n\t\t\t\tframe = 0;\r\n\t\t\telse {\r\n\t\t\t\tframe = Animation.binarySearch(frames, lastTime);\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\twhile (frame > 0) {\r\n\t\t\t\t\tif (frames[frame - 1] != frameTime)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tframe--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (; frame < frameCount && time >= frames[frame]; frame++)\r\n\t\t\t\tfiredEvents.push(this.events[frame]);\r\n\t\t};\r\n\t\treturn EventTimeline;\r\n\t}());\r\n\tspine.EventTimeline = EventTimeline;\r\n\tvar DrawOrderTimeline = (function () {\r\n\t\tfunction DrawOrderTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.drawOrders = new Array(frameCount);\r\n\t\t}\r\n\t\tDrawOrderTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.drawOrder << 24;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.drawOrders[frameIndex] = drawOrder;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tif (direction == MixDirection.out && blend == MixBlend.setup) {\r\n\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (blend == MixBlend.setup || blend == MixBlend.first)\r\n\t\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframe = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframe = Animation.binarySearch(frames, time) - 1;\r\n\t\t\tvar drawOrderToSetupIndex = this.drawOrders[frame];\r\n\t\t\tif (drawOrderToSetupIndex == null)\r\n\t\t\t\tspine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n\t\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DrawOrderTimeline;\r\n\t}());\r\n\tspine.DrawOrderTimeline = DrawOrderTimeline;\r\n\tvar IkConstraintTimeline = (function (_super) {\r\n\t\t__extends(IkConstraintTimeline, _super);\r\n\t\tfunction IkConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tIkConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection, compress, stretch) {\r\n\t\t\tframeIndex *= IkConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\t\tconstraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n\t\t\t\t\tif (direction == MixDirection.out) {\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconstraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n\t\t\t\t\tif (direction == MixDirection[\"in\"]) {\r\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t\t\tconstraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\t\tconstraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n\t\t\tvar mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\tconstraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n\t\t\t\tif (direction == MixDirection.out) {\r\n\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n\t\t\t\tif (direction == MixDirection[\"in\"]) {\r\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t\tconstraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n\t\t\t\t\tconstraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraintTimeline.ENTRIES = 5;\r\n\t\tIkConstraintTimeline.PREV_TIME = -5;\r\n\t\tIkConstraintTimeline.PREV_MIX = -4;\r\n\t\tIkConstraintTimeline.PREV_BEND_DIRECTION = -3;\r\n\t\tIkConstraintTimeline.PREV_COMPRESS = -2;\r\n\t\tIkConstraintTimeline.PREV_STRETCH = -1;\r\n\t\tIkConstraintTimeline.MIX = 1;\r\n\t\tIkConstraintTimeline.BEND_DIRECTION = 2;\r\n\t\tIkConstraintTimeline.COMPRESS = 3;\r\n\t\tIkConstraintTimeline.STRETCH = 4;\r\n\t\treturn IkConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.IkConstraintTimeline = IkConstraintTimeline;\r\n\tvar TransformConstraintTimeline = (function (_super) {\r\n\t\t__extends(TransformConstraintTimeline, _super);\r\n\t\tfunction TransformConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTransformConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n\t\t\tframeIndex *= TransformConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tconstraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n\t\t\t\t\t\tconstraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0, scale = 0, shear = 0;\r\n\t\t\tif (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\trotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t\tscale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n\t\t\t\tshear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n\t\t\t}\r\n\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraintTimeline.ENTRIES = 5;\r\n\t\tTransformConstraintTimeline.PREV_TIME = -5;\r\n\t\tTransformConstraintTimeline.PREV_ROTATE = -4;\r\n\t\tTransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n\t\tTransformConstraintTimeline.PREV_SCALE = -2;\r\n\t\tTransformConstraintTimeline.PREV_SHEAR = -1;\r\n\t\tTransformConstraintTimeline.ROTATE = 1;\r\n\t\tTransformConstraintTimeline.TRANSLATE = 2;\r\n\t\tTransformConstraintTimeline.SCALE = 3;\r\n\t\tTransformConstraintTimeline.SHEAR = 4;\r\n\t\treturn TransformConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TransformConstraintTimeline = TransformConstraintTimeline;\r\n\tvar PathConstraintPositionTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintPositionTimeline, _super);\r\n\t\tfunction PathConstraintPositionTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n\t\t\tframeIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tconstraint.position = constraint.data.position;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tconstraint.position += (constraint.data.position - constraint.position) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar position = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n\t\t\t\tposition = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\t\tposition = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tposition += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n\t\t\t}\r\n\t\t\tif (blend == MixBlend.setup)\r\n\t\t\t\tconstraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.position += (position - constraint.position) * alpha;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.ENTRIES = 2;\r\n\t\tPathConstraintPositionTimeline.PREV_TIME = -2;\r\n\t\tPathConstraintPositionTimeline.PREV_VALUE = -1;\r\n\t\tPathConstraintPositionTimeline.VALUE = 1;\r\n\t\treturn PathConstraintPositionTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n\tvar PathConstraintSpacingTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintSpacingTimeline, _super);\r\n\t\tfunction PathConstraintSpacingTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tPathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tconstraint.spacing = constraint.data.spacing;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tconstraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar spacing = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n\t\t\t\tspacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\t\t\t\tspacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tspacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n\t\t\t}\r\n\t\t\tif (blend == MixBlend.setup)\r\n\t\t\t\tconstraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.spacing += (spacing - constraint.spacing) * alpha;\r\n\t\t};\r\n\t\treturn PathConstraintSpacingTimeline;\r\n\t}(PathConstraintPositionTimeline));\r\n\tspine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n\tvar PathConstraintMixTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintMixTimeline, _super);\r\n\t\tfunction PathConstraintMixTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n\t\t\tframeIndex *= PathConstraintMixTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase MixBlend.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = constraint.data.translateMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixBlend.first:\r\n\t\t\t\t\t\tconstraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n\t\t\t\trotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t}\r\n\t\t\tif (blend == MixBlend.setup) {\r\n\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.ENTRIES = 3;\r\n\t\tPathConstraintMixTimeline.PREV_TIME = -3;\r\n\t\tPathConstraintMixTimeline.PREV_ROTATE = -2;\r\n\t\tPathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n\t\tPathConstraintMixTimeline.ROTATE = 1;\r\n\t\tPathConstraintMixTimeline.TRANSLATE = 2;\r\n\t\treturn PathConstraintMixTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationState = (function () {\r\n\t\tfunction AnimationState(data) {\r\n\t\t\tthis.tracks = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.listeners = new Array();\r\n\t\t\tthis.queue = new EventQueue(this);\r\n\t\t\tthis.propertyIDs = new spine.IntSet();\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tthis.timeScale = 1;\r\n\t\t\tthis.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tAnimationState.prototype.update = function (delta) {\r\n\t\t\tdelta *= this.timeScale;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tcurrent.animationLast = current.nextAnimationLast;\r\n\t\t\t\tcurrent.trackLast = current.nextTrackLast;\r\n\t\t\t\tvar currentDelta = delta * current.timeScale;\r\n\t\t\t\tif (current.delay > 0) {\r\n\t\t\t\t\tcurrent.delay -= currentDelta;\r\n\t\t\t\t\tif (current.delay > 0)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tcurrentDelta = -current.delay;\r\n\t\t\t\t\tcurrent.delay = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvar next = current.next;\r\n\t\t\t\tif (next != null) {\r\n\t\t\t\t\tvar nextTime = current.trackLast - next.delay;\r\n\t\t\t\t\tif (nextTime >= 0) {\r\n\t\t\t\t\t\tnext.delay = 0;\r\n\t\t\t\t\t\tnext.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n\t\t\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t\t\t\tthis.setCurrent(i, next, true);\r\n\t\t\t\t\t\twhile (next.mixingFrom != null) {\r\n\t\t\t\t\t\t\tnext.mixTime += delta;\r\n\t\t\t\t\t\t\tnext = next.mixingFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n\t\t\t\t\ttracks[i] = null;\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n\t\t\t\t\tvar from = current.mixingFrom;\r\n\t\t\t\t\tcurrent.mixingFrom = null;\r\n\t\t\t\t\tif (from != null)\r\n\t\t\t\t\t\tfrom.mixingTo = null;\r\n\t\t\t\t\twhile (from != null) {\r\n\t\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t\t\tfrom = from.mixingFrom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from == null)\r\n\t\t\t\treturn true;\r\n\t\t\tvar finished = this.updateMixingFrom(from, delta);\r\n\t\t\tfrom.animationLast = from.nextAnimationLast;\r\n\t\t\tfrom.trackLast = from.nextTrackLast;\r\n\t\t\tif (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n\t\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n\t\t\t\t\tto.mixingFrom = from.mixingFrom;\r\n\t\t\t\t\tif (from.mixingFrom != null)\r\n\t\t\t\t\t\tfrom.mixingFrom.mixingTo = to;\r\n\t\t\t\t\tto.interruptAlpha = from.interruptAlpha;\r\n\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t}\r\n\t\t\t\treturn finished;\r\n\t\t\t}\r\n\t\t\tfrom.trackTime += delta * from.timeScale;\r\n\t\t\tto.mixTime += delta;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tAnimationState.prototype.apply = function (skeleton) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (this.animationsChanged)\r\n\t\t\t\tthis._animationsChanged();\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tvar applied = false;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null || current.delay > 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tapplied = true;\r\n\t\t\t\tvar blend = i == 0 ? spine.MixBlend.first : current.mixBlend;\r\n\t\t\t\tvar mix = current.alpha;\r\n\t\t\t\tif (current.mixingFrom != null)\r\n\t\t\t\t\tmix *= this.applyMixingFrom(current, skeleton, blend);\r\n\t\t\t\telse if (current.trackTime >= current.trackEnd && current.next == null)\r\n\t\t\t\t\tmix = 0;\r\n\t\t\t\tvar animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n\t\t\t\tvar timelineCount = current.animation.timelines.length;\r\n\t\t\t\tvar timelines = current.animation.timelines;\r\n\t\t\t\tif ((i == 0 && mix == 1) || blend == spine.MixBlend.add) {\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++)\r\n\t\t\t\t\t\ttimelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection[\"in\"]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar timelineMode = current.timelineMode;\r\n\t\t\t\t\tvar firstFrame = current.timelinesRotation.length == 0;\r\n\t\t\t\t\tif (firstFrame)\r\n\t\t\t\t\t\tspine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n\t\t\t\t\tvar timelinesRotation = current.timelinesRotation;\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++) {\r\n\t\t\t\t\t\tvar timeline = timelines[ii];\r\n\t\t\t\t\t\tvar timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;\r\n\t\t\t\t\t\tif (timeline instanceof spine.RotateTimeline) {\r\n\t\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(mix, blend);\r\n\t\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection[\"in\"]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.queueEvents(current, animationTime);\r\n\t\t\t\tevents.length = 0;\r\n\t\t\t\tcurrent.nextAnimationLast = animationTime;\r\n\t\t\t\tcurrent.nextTrackLast = current.trackTime;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn applied;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from.mixingFrom != null)\r\n\t\t\t\tthis.applyMixingFrom(from, skeleton, blend);\r\n\t\t\tvar mix = 0;\r\n\t\t\tif (to.mixDuration == 0) {\r\n\t\t\t\tmix = 1;\r\n\t\t\t\tif (blend == spine.MixBlend.first)\r\n\t\t\t\t\tblend = spine.MixBlend.setup;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmix = to.mixTime / to.mixDuration;\r\n\t\t\t\tif (mix > 1)\r\n\t\t\t\t\tmix = 1;\r\n\t\t\t\tif (blend != spine.MixBlend.first)\r\n\t\t\t\t\tblend = from.mixBlend;\r\n\t\t\t}\r\n\t\t\tvar events = mix < from.eventThreshold ? this.events : null;\r\n\t\t\tvar attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n\t\t\tvar animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n\t\t\tvar timelineCount = from.animation.timelines.length;\r\n\t\t\tvar timelines = from.animation.timelines;\r\n\t\t\tvar alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n\t\t\tif (blend == spine.MixBlend.add) {\r\n\t\t\t\tfor (var i = 0; i < timelineCount; i++)\r\n\t\t\t\t\ttimelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.out);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar timelineMode = from.timelineMode;\r\n\t\t\t\tvar timelineHoldMix = from.timelineHoldMix;\r\n\t\t\t\tvar firstFrame = from.timelinesRotation.length == 0;\r\n\t\t\t\tif (firstFrame)\r\n\t\t\t\t\tspine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n\t\t\t\tvar timelinesRotation = from.timelinesRotation;\r\n\t\t\t\tfrom.totalAlpha = 0;\r\n\t\t\t\tfor (var i = 0; i < timelineCount; i++) {\r\n\t\t\t\t\tvar timeline = timelines[i];\r\n\t\t\t\t\tvar direction = spine.MixDirection.out;\r\n\t\t\t\t\tvar timelineBlend = void 0;\r\n\t\t\t\t\tvar alpha = 0;\r\n\t\t\t\t\tswitch (timelineMode[i]) {\r\n\t\t\t\t\t\tcase AnimationState.SUBSEQUENT:\r\n\t\t\t\t\t\t\tif (!attachments && timeline instanceof spine.AttachmentTimeline)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\tif (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\ttimelineBlend = blend;\r\n\t\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase AnimationState.FIRST:\r\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\r\n\t\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase AnimationState.HOLD:\r\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\r\n\t\t\t\t\t\t\talpha = alphaHold;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\ttimelineBlend = spine.MixBlend.setup;\r\n\t\t\t\t\t\t\tvar holdMix = timelineHoldMix[i];\r\n\t\t\t\t\t\t\talpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfrom.totalAlpha += alpha;\r\n\t\t\t\t\tif (timeline instanceof spine.RotateTimeline)\r\n\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(alpha, blend);\r\n\t\t\t\t\t\tif (timelineBlend == spine.MixBlend.setup) {\r\n\t\t\t\t\t\t\tif (timeline instanceof spine.AttachmentTimeline) {\r\n\t\t\t\t\t\t\t\tif (attachments)\r\n\t\t\t\t\t\t\t\t\tdirection = spine.MixDirection.out;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (timeline instanceof spine.DrawOrderTimeline) {\r\n\t\t\t\t\t\t\t\tif (drawOrder)\r\n\t\t\t\t\t\t\t\t\tdirection = spine.MixDirection.out;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (to.mixDuration > 0)\r\n\t\t\t\tthis.queueEvents(from, animationTime);\r\n\t\t\tthis.events.length = 0;\r\n\t\t\tfrom.nextAnimationLast = animationTime;\r\n\t\t\tfrom.nextTrackLast = from.trackTime;\r\n\t\t\treturn mix;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\r\n\t\t\tif (firstFrame)\r\n\t\t\t\ttimelinesRotation[i] = 0;\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\ttimeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection[\"in\"]);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotateTimeline = timeline;\r\n\t\t\tvar frames = rotateTimeline.frames;\r\n\t\t\tvar bone = skeleton.bones[rotateTimeline.boneIndex];\r\n\t\t\tvar r1 = 0, r2 = 0;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (blend) {\r\n\t\t\t\t\tcase spine.MixBlend.setup:\r\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase spine.MixBlend.first:\r\n\t\t\t\t\t\tr1 = bone.rotation;\r\n\t\t\t\t\t\tr2 = bone.data.rotation;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tr1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n\t\t\t\tif (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\r\n\t\t\t\t\tr2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\r\n\t\t\t\t\tvar prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\t\tvar percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\t\tr2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t\t\tr2 = prevRotation + r2 * percent + bone.data.rotation;\r\n\t\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar total = 0, diff = r2 - r1;\r\n\t\t\tdiff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n\t\t\tif (diff == 0) {\r\n\t\t\t\ttotal = timelinesRotation[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar lastTotal = 0, lastDiff = 0;\r\n\t\t\t\tif (firstFrame) {\r\n\t\t\t\t\tlastTotal = 0;\r\n\t\t\t\t\tlastDiff = diff;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastTotal = timelinesRotation[i];\r\n\t\t\t\t\tlastDiff = timelinesRotation[i + 1];\r\n\t\t\t\t}\r\n\t\t\t\tvar current = diff > 0, dir = lastTotal >= 0;\r\n\t\t\t\tif (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n\t\t\t\t\tif (Math.abs(lastTotal) > 180)\r\n\t\t\t\t\t\tlastTotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\t\tdir = current;\r\n\t\t\t\t}\r\n\t\t\t\ttotal = diff + lastTotal - lastTotal % 360;\r\n\t\t\t\tif (dir != current)\r\n\t\t\t\t\ttotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\ttimelinesRotation[i] = total;\r\n\t\t\t}\r\n\t\t\ttimelinesRotation[i + 1] = diff;\r\n\t\t\tr1 += total * alpha;\r\n\t\t\tbone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n\t\t};\r\n\t\tAnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n\t\t\tvar animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n\t\t\tvar duration = animationEnd - animationStart;\r\n\t\t\tvar trackLastWrapped = entry.trackLast % duration;\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar i = 0, n = events.length;\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_1 = events[i];\r\n\t\t\t\tif (event_1.time < trackLastWrapped)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (event_1.time > animationEnd)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, event_1);\r\n\t\t\t}\r\n\t\t\tvar complete = false;\r\n\t\t\tif (entry.loop)\r\n\t\t\t\tcomplete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n\t\t\telse\r\n\t\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n\t\t\tif (complete)\r\n\t\t\t\tthis.queue.complete(entry);\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_2 = events[i];\r\n\t\t\t\tif (event_2.time < animationStart)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, events[i]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTracks = function () {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++)\r\n\t\t\t\tthis.clearTrack(i);\r\n\t\t\tthis.tracks.length = 0;\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTrack = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn;\r\n\t\t\tvar current = this.tracks[trackIndex];\r\n\t\t\tif (current == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.queue.end(current);\r\n\t\t\tthis.disposeNext(current);\r\n\t\t\tvar entry = current;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar from = entry.mixingFrom;\r\n\t\t\t\tif (from == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tthis.queue.end(from);\r\n\t\t\t\tentry.mixingFrom = null;\r\n\t\t\t\tentry.mixingTo = null;\r\n\t\t\t\tentry = from;\r\n\t\t\t}\r\n\t\t\tthis.tracks[current.trackIndex] = null;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n\t\t\tvar from = this.expandToIndex(index);\r\n\t\t\tthis.tracks[index] = current;\r\n\t\t\tif (from != null) {\r\n\t\t\t\tif (interrupt)\r\n\t\t\t\t\tthis.queue.interrupt(from);\r\n\t\t\t\tcurrent.mixingFrom = from;\r\n\t\t\t\tfrom.mixingTo = current;\r\n\t\t\t\tcurrent.mixTime = 0;\r\n\t\t\t\tif (from.mixingFrom != null && from.mixDuration > 0)\r\n\t\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\t\t\t\tfrom.timelinesRotation.length = 0;\r\n\t\t\t}\r\n\t\t\tthis.queue.start(current);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.setAnimationWith(trackIndex, animation, loop);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar interrupt = true;\r\n\t\t\tvar current = this.expandToIndex(trackIndex);\r\n\t\t\tif (current != null) {\r\n\t\t\t\tif (current.nextTrackLast == -1) {\r\n\t\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\r\n\t\t\t\t\tthis.queue.interrupt(current);\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcurrent = current.mixingFrom;\r\n\t\t\t\t\tinterrupt = false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\t\t\tthis.setCurrent(trackIndex, entry, interrupt);\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar last = this.expandToIndex(trackIndex);\r\n\t\t\tif (last != null) {\r\n\t\t\t\twhile (last.next != null)\r\n\t\t\t\t\tlast = last.next;\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\t\t\tif (last == null) {\r\n\t\t\t\tthis.setCurrent(trackIndex, entry, true);\r\n\t\t\t\tthis.queue.drain();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlast.next = entry;\r\n\t\t\t\tif (delay <= 0) {\r\n\t\t\t\t\tvar duration = last.animationEnd - last.animationStart;\r\n\t\t\t\t\tif (duration != 0) {\r\n\t\t\t\t\t\tif (last.loop)\r\n\t\t\t\t\t\t\tdelay += duration * (1 + ((last.trackTime / duration) | 0));\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdelay += Math.max(duration, last.trackTime);\r\n\t\t\t\t\t\tdelay -= this.data.getMix(last.animation, animation);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelay = last.trackTime;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tentry.delay = delay;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n\t\t\tvar entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n\t\t\tif (delay <= 0)\r\n\t\t\t\tdelay -= mixDuration;\r\n\t\t\tvar entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = this.tracks[i];\r\n\t\t\t\tif (current != null)\r\n\t\t\t\t\tthis.setEmptyAnimation(current.trackIndex, mixDuration);\r\n\t\t\t}\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.expandToIndex = function (index) {\r\n\t\t\tif (index < this.tracks.length)\r\n\t\t\t\treturn this.tracks[index];\r\n\t\t\tspine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n\t\t\tthis.tracks.length = index + 1;\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tAnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n\t\t\tvar entry = this.trackEntryPool.obtain();\r\n\t\t\tentry.trackIndex = trackIndex;\r\n\t\t\tentry.animation = animation;\r\n\t\t\tentry.loop = loop;\r\n\t\t\tentry.holdPrevious = false;\r\n\t\t\tentry.eventThreshold = 0;\r\n\t\t\tentry.attachmentThreshold = 0;\r\n\t\t\tentry.drawOrderThreshold = 0;\r\n\t\t\tentry.animationStart = 0;\r\n\t\t\tentry.animationEnd = animation.duration;\r\n\t\t\tentry.animationLast = -1;\r\n\t\t\tentry.nextAnimationLast = -1;\r\n\t\t\tentry.delay = 0;\r\n\t\t\tentry.trackTime = 0;\r\n\t\t\tentry.trackLast = -1;\r\n\t\t\tentry.nextTrackLast = -1;\r\n\t\t\tentry.trackEnd = Number.MAX_VALUE;\r\n\t\t\tentry.timeScale = 1;\r\n\t\t\tentry.alpha = 1;\r\n\t\t\tentry.interruptAlpha = 1;\r\n\t\t\tentry.mixTime = 0;\r\n\t\t\tentry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.disposeNext = function (entry) {\r\n\t\t\tvar next = entry.next;\r\n\t\t\twhile (next != null) {\r\n\t\t\t\tthis.queue.dispose(next);\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t\tentry.next = null;\r\n\t\t};\r\n\t\tAnimationState.prototype._animationsChanged = function () {\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tthis.propertyIDs.clear();\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar entry = this.tracks[i];\r\n\t\t\t\tif (entry == null)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\twhile (entry.mixingFrom != null)\r\n\t\t\t\t\tentry = entry.mixingFrom;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add)\r\n\t\t\t\t\t\tthis.setTimelineModes(entry);\r\n\t\t\t\t\tentry = entry.mixingTo;\r\n\t\t\t\t} while (entry != null);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.setTimelineModes = function (entry) {\r\n\t\t\tvar to = entry.mixingTo;\r\n\t\t\tvar timelines = entry.animation.timelines;\r\n\t\t\tvar timelinesCount = entry.animation.timelines.length;\r\n\t\t\tvar timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n\t\t\tentry.timelineHoldMix.length = 0;\r\n\t\t\tvar timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n\t\t\tvar propertyIDs = this.propertyIDs;\r\n\t\t\tif (to != null && to.holdPrevious) {\r\n\t\t\t\tfor (var i = 0; i < timelinesCount; i++) {\r\n\t\t\t\t\tpropertyIDs.add(timelines[i].getPropertyId());\r\n\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\touter: for (var i = 0; i < timelinesCount; i++) {\r\n\t\t\t\tvar id = timelines[i].getPropertyId();\r\n\t\t\t\tif (!propertyIDs.add(id))\r\n\t\t\t\t\ttimelineMode[i] = AnimationState.SUBSEQUENT;\r\n\t\t\t\telse if (to == null || !this.hasTimeline(to, id))\r\n\t\t\t\t\ttimelineMode[i] = AnimationState.FIRST;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var next = to.mixingTo; next != null; next = next.mixingTo) {\r\n\t\t\t\t\t\tif (this.hasTimeline(next, id))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (entry.mixDuration > 0) {\r\n\t\t\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD_MIX;\r\n\t\t\t\t\t\t\ttimelineDipMix[i] = next;\r\n\t\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelineMode[i] = AnimationState.HOLD;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.hasTimeline = function (entry, id) {\r\n\t\t\tvar timelines = entry.animation.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\tif (timelines[i].getPropertyId() == id)\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tAnimationState.prototype.getCurrent = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.tracks[trackIndex];\r\n\t\t};\r\n\t\tAnimationState.prototype.addListener = function (listener) {\r\n\t\t\tif (listener == null)\r\n\t\t\t\tthrow new Error(\"listener cannot be null.\");\r\n\t\t\tthis.listeners.push(listener);\r\n\t\t};\r\n\t\tAnimationState.prototype.removeListener = function (listener) {\r\n\t\t\tvar index = this.listeners.indexOf(listener);\r\n\t\t\tif (index >= 0)\r\n\t\t\t\tthis.listeners.splice(index, 1);\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListeners = function () {\r\n\t\t\tthis.listeners.length = 0;\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListenerNotifications = function () {\r\n\t\t\tthis.queue.clear();\r\n\t\t};\r\n\t\tAnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\r\n\t\tAnimationState.SUBSEQUENT = 0;\r\n\t\tAnimationState.FIRST = 1;\r\n\t\tAnimationState.HOLD = 2;\r\n\t\tAnimationState.HOLD_MIX = 3;\r\n\t\treturn AnimationState;\r\n\t}());\r\n\tspine.AnimationState = AnimationState;\r\n\tvar TrackEntry = (function () {\r\n\t\tfunction TrackEntry() {\r\n\t\t\tthis.mixBlend = spine.MixBlend.replace;\r\n\t\t\tthis.timelineMode = new Array();\r\n\t\t\tthis.timelineHoldMix = new Array();\r\n\t\t\tthis.timelinesRotation = new Array();\r\n\t\t}\r\n\t\tTrackEntry.prototype.reset = function () {\r\n\t\t\tthis.next = null;\r\n\t\t\tthis.mixingFrom = null;\r\n\t\t\tthis.mixingTo = null;\r\n\t\t\tthis.animation = null;\r\n\t\t\tthis.listener = null;\r\n\t\t\tthis.timelineMode.length = 0;\r\n\t\t\tthis.timelineHoldMix.length = 0;\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\tTrackEntry.prototype.getAnimationTime = function () {\r\n\t\t\tif (this.loop) {\r\n\t\t\t\tvar duration = this.animationEnd - this.animationStart;\r\n\t\t\t\tif (duration == 0)\r\n\t\t\t\t\treturn this.animationStart;\r\n\t\t\t\treturn (this.trackTime % duration) + this.animationStart;\r\n\t\t\t}\r\n\t\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n\t\t};\r\n\t\tTrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n\t\t\tthis.animationLast = animationLast;\r\n\t\t\tthis.nextAnimationLast = animationLast;\r\n\t\t};\r\n\t\tTrackEntry.prototype.isComplete = function () {\r\n\t\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\r\n\t\t};\r\n\t\tTrackEntry.prototype.resetRotationDirections = function () {\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\treturn TrackEntry;\r\n\t}());\r\n\tspine.TrackEntry = TrackEntry;\r\n\tvar EventQueue = (function () {\r\n\t\tfunction EventQueue(animState) {\r\n\t\t\tthis.objects = [];\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t\tthis.animState = animState;\r\n\t\t}\r\n\t\tEventQueue.prototype.start = function (entry) {\r\n\t\t\tthis.objects.push(EventType.start);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.interrupt = function (entry) {\r\n\t\t\tthis.objects.push(EventType.interrupt);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.end = function (entry) {\r\n\t\t\tthis.objects.push(EventType.end);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.dispose = function (entry) {\r\n\t\t\tthis.objects.push(EventType.dispose);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.complete = function (entry) {\r\n\t\t\tthis.objects.push(EventType.complete);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.event = function (entry, event) {\r\n\t\t\tthis.objects.push(EventType.event);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.objects.push(event);\r\n\t\t};\r\n\t\tEventQueue.prototype.drain = function () {\r\n\t\t\tif (this.drainDisabled)\r\n\t\t\t\treturn;\r\n\t\t\tthis.drainDisabled = true;\r\n\t\t\tvar objects = this.objects;\r\n\t\t\tvar listeners = this.animState.listeners;\r\n\t\t\tfor (var i = 0; i < objects.length; i += 2) {\r\n\t\t\t\tvar type = objects[i];\r\n\t\t\t\tvar entry = objects[i + 1];\r\n\t\t\t\tswitch (type) {\r\n\t\t\t\t\tcase EventType.start:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.start)\r\n\t\t\t\t\t\t\tentry.listener.start(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].start)\r\n\t\t\t\t\t\t\t\tlisteners[ii].start(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.interrupt:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.interrupt)\r\n\t\t\t\t\t\t\tentry.listener.interrupt(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].interrupt)\r\n\t\t\t\t\t\t\t\tlisteners[ii].interrupt(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.end:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.end)\r\n\t\t\t\t\t\t\tentry.listener.end(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].end)\r\n\t\t\t\t\t\t\t\tlisteners[ii].end(entry);\r\n\t\t\t\t\tcase EventType.dispose:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.dispose)\r\n\t\t\t\t\t\t\tentry.listener.dispose(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].dispose)\r\n\t\t\t\t\t\t\t\tlisteners[ii].dispose(entry);\r\n\t\t\t\t\t\tthis.animState.trackEntryPool.free(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.complete:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.complete)\r\n\t\t\t\t\t\t\tentry.listener.complete(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].complete)\r\n\t\t\t\t\t\t\t\tlisteners[ii].complete(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.event:\r\n\t\t\t\t\t\tvar event_3 = objects[i++ + 2];\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.event)\r\n\t\t\t\t\t\t\tentry.listener.event(entry, event_3);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].event)\r\n\t\t\t\t\t\t\t\tlisteners[ii].event(entry, event_3);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.clear();\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t};\r\n\t\tEventQueue.prototype.clear = function () {\r\n\t\t\tthis.objects.length = 0;\r\n\t\t};\r\n\t\treturn EventQueue;\r\n\t}());\r\n\tspine.EventQueue = EventQueue;\r\n\tvar EventType;\r\n\t(function (EventType) {\r\n\t\tEventType[EventType[\"start\"] = 0] = \"start\";\r\n\t\tEventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n\t\tEventType[EventType[\"end\"] = 2] = \"end\";\r\n\t\tEventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n\t\tEventType[EventType[\"complete\"] = 4] = \"complete\";\r\n\t\tEventType[EventType[\"event\"] = 5] = \"event\";\r\n\t})(EventType = spine.EventType || (spine.EventType = {}));\r\n\tvar AnimationStateAdapter2 = (function () {\r\n\t\tfunction AnimationStateAdapter2() {\r\n\t\t}\r\n\t\tAnimationStateAdapter2.prototype.start = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.interrupt = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.end = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.dispose = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.complete = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.event = function (entry, event) {\r\n\t\t};\r\n\t\treturn AnimationStateAdapter2;\r\n\t}());\r\n\tspine.AnimationStateAdapter2 = AnimationStateAdapter2;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationStateData = (function () {\r\n\t\tfunction AnimationStateData(skeletonData) {\r\n\t\t\tthis.animationToMixTime = {};\r\n\t\t\tthis.defaultMix = 0;\r\n\t\t\tif (skeletonData == null)\r\n\t\t\t\tthrow new Error(\"skeletonData cannot be null.\");\r\n\t\t\tthis.skeletonData = skeletonData;\r\n\t\t}\r\n\t\tAnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n\t\t\tvar from = this.skeletonData.findAnimation(fromName);\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + fromName);\r\n\t\t\tvar to = this.skeletonData.findAnimation(toName);\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + toName);\r\n\t\t\tthis.setMixWith(from, to, duration);\r\n\t\t};\r\n\t\tAnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"from cannot be null.\");\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"to cannot be null.\");\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tthis.animationToMixTime[key] = duration;\r\n\t\t};\r\n\t\tAnimationStateData.prototype.getMix = function (from, to) {\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tvar value = this.animationToMixTime[key];\r\n\t\t\treturn value === undefined ? this.defaultMix : value;\r\n\t\t};\r\n\t\treturn AnimationStateData;\r\n\t}());\r\n\tspine.AnimationStateData = AnimationStateData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AssetManager = (function () {\r\n\t\tfunction AssetManager(textureLoader, pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.toLoad = 0;\r\n\t\t\tthis.loaded = 0;\r\n\t\t\tthis.textureLoader = textureLoader;\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tAssetManager.downloadText = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(request.responseText);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.downloadBinary = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(new Uint8Array(request.response));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.prototype.loadText = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (data) {\r\n\t\t\t\t_this.assets[path] = data;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, data);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTexture = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = path;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureData = function (path, data, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = data;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureAtlas = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tvar parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (atlasData) {\r\n\t\t\t\tvar pagesLoaded = { count: 0 };\r\n\t\t\t\tvar atlasPages = new Array();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\tatlasPages.push(parent + \"/\" + path);\r\n\t\t\t\t\t\tvar image = document.createElement(\"img\");\r\n\t\t\t\t\t\timage.width = 16;\r\n\t\t\t\t\t\timage.height = 16;\r\n\t\t\t\t\t\treturn new spine.FakeTexture(image);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\tif (error)\r\n\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar _loop_1 = function (atlasPage) {\r\n\t\t\t\t\tvar pageLoadError = false;\r\n\t\t\t\t\t_this.loadTexture(atlasPage, function (imagePath, image) {\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\tif (!pageLoadError) {\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\t\t\t\t\treturn _this.get(parent + \"/\" + path);\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t_this.assets[path] = atlas;\r\n\t\t\t\t\t\t\t\t\tif (success)\r\n\t\t\t\t\t\t\t\t\t\tsuccess(path, atlas);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function (imagePath, errorMessage) {\r\n\t\t\t\t\t\tpageLoadError = true;\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tfor (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\r\n\t\t\t\t\tvar atlasPage = atlasPages_1[_i];\r\n\t\t\t\t\t_loop_1(atlasPage);\r\n\t\t\t\t}\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.get = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\treturn this.assets[path];\r\n\t\t};\r\n\t\tAssetManager.prototype.remove = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar asset = this.assets[path];\r\n\t\t\tif (asset.dispose)\r\n\t\t\t\tasset.dispose();\r\n\t\t\tthis.assets[path] = null;\r\n\t\t};\r\n\t\tAssetManager.prototype.removeAll = function () {\r\n\t\t\tfor (var key in this.assets) {\r\n\t\t\t\tvar asset = this.assets[key];\r\n\t\t\t\tif (asset.dispose)\r\n\t\t\t\t\tasset.dispose();\r\n\t\t\t}\r\n\t\t\tthis.assets = {};\r\n\t\t};\r\n\t\tAssetManager.prototype.isLoadingComplete = function () {\r\n\t\t\treturn this.toLoad == 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getToLoad = function () {\r\n\t\t\treturn this.toLoad;\r\n\t\t};\r\n\t\tAssetManager.prototype.getLoaded = function () {\r\n\t\t\treturn this.loaded;\r\n\t\t};\r\n\t\tAssetManager.prototype.dispose = function () {\r\n\t\t\tthis.removeAll();\r\n\t\t};\r\n\t\tAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn AssetManager;\r\n\t}());\r\n\tspine.AssetManager = AssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AtlasAttachmentLoader = (function () {\r\n\t\tfunction AtlasAttachmentLoader(atlas) {\r\n\t\t\tthis.atlas = atlas;\r\n\t\t}\r\n\t\tAtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.RegionAttachment(name);\r\n\t\t\tattachment.setRegion(region);\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.MeshAttachment(name);\r\n\t\t\tattachment.region = region;\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n\t\t\treturn new spine.BoundingBoxAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PathAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PointAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n\t\t\treturn new spine.ClippingAttachment(name);\r\n\t\t};\r\n\t\treturn AtlasAttachmentLoader;\r\n\t}());\r\n\tspine.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BlendMode;\r\n\t(function (BlendMode) {\r\n\t\tBlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tBlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n\t\tBlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n\t\tBlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n\t})(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Bone = (function () {\r\n\t\tfunction Bone(data, skeleton, parent) {\r\n\t\t\tthis.children = new Array();\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 0;\r\n\t\t\tthis.scaleY = 0;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.ax = 0;\r\n\t\t\tthis.ay = 0;\r\n\t\t\tthis.arotation = 0;\r\n\t\t\tthis.ascaleX = 0;\r\n\t\t\tthis.ascaleY = 0;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ashearY = 0;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t\tthis.a = 0;\r\n\t\t\tthis.b = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.c = 0;\r\n\t\t\tthis.d = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.sorted = false;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.skeleton = skeleton;\r\n\t\t\tthis.parent = parent;\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tBone.prototype.update = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransform = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n\t\t\tthis.ax = x;\r\n\t\t\tthis.ay = y;\r\n\t\t\tthis.arotation = rotation;\r\n\t\t\tthis.ascaleX = scaleX;\r\n\t\t\tthis.ascaleY = scaleY;\r\n\t\t\tthis.ashearX = shearX;\r\n\t\t\tthis.ashearY = shearY;\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tvar skeleton = this.skeleton;\r\n\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\tvar sx = skeleton.scaleX;\r\n\t\t\t\tvar sy = skeleton.scaleY;\r\n\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n\t\t\t\tthis.worldX = x * sx + skeleton.x;\r\n\t\t\t\tthis.worldY = y * sy + skeleton.y;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tthis.worldX = pa * x + pb * y + parent.worldX;\r\n\t\t\tthis.worldY = pc * x + pd * y + parent.worldY;\r\n\t\t\tswitch (this.data.transformMode) {\r\n\t\t\t\tcase spine.TransformMode.Normal: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la + pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb + pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.OnlyTranslation: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoRotationOrReflection: {\r\n\t\t\t\t\tvar s = pa * pa + pc * pc;\r\n\t\t\t\t\tvar prx = 0;\r\n\t\t\t\t\tif (s > 0.0001) {\r\n\t\t\t\t\t\ts = Math.abs(pa * pd - pb * pc) / s;\r\n\t\t\t\t\t\tpb = pc * s;\r\n\t\t\t\t\t\tpd = pa * s;\r\n\t\t\t\t\t\tprx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpa = 0;\r\n\t\t\t\t\t\tpc = 0;\r\n\t\t\t\t\t\tprx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar rx = rotation + shearX - prx;\r\n\t\t\t\t\tvar ry = rotation + shearY - prx + 90;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rx) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(ry) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rx) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(ry) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la - pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb - pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoScale:\r\n\t\t\t\tcase spine.TransformMode.NoScaleOrReflection: {\r\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(rotation);\r\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(rotation);\r\n\t\t\t\t\tvar za = (pa * cos + pb * sin) / this.skeleton.scaleX;\r\n\t\t\t\t\tvar zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\r\n\t\t\t\t\tvar s = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = 1 / s;\r\n\t\t\t\t\tza *= s;\r\n\t\t\t\t\tzc *= s;\r\n\t\t\t\t\ts = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tif (this.data.transformMode == spine.TransformMode.NoScale\r\n\t\t\t\t\t\t&& (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\r\n\t\t\t\t\t\ts = -s;\r\n\t\t\t\t\tvar r = Math.PI / 2 + Math.atan2(zc, za);\r\n\t\t\t\t\tvar zb = Math.cos(r) * s;\r\n\t\t\t\t\tvar zd = Math.sin(r) * s;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tthis.a = za * la + zb * lc;\r\n\t\t\t\t\tthis.b = za * lb + zb * ld;\r\n\t\t\t\t\tthis.c = zc * la + zd * lc;\r\n\t\t\t\t\tthis.d = zc * lb + zd * ld;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.a *= this.skeleton.scaleX;\r\n\t\t\tthis.b *= this.skeleton.scaleX;\r\n\t\t\tthis.c *= this.skeleton.scaleY;\r\n\t\t\tthis.d *= this.skeleton.scaleY;\r\n\t\t};\r\n\t\tBone.prototype.setToSetupPose = function () {\r\n\t\t\tvar data = this.data;\r\n\t\t\tthis.x = data.x;\r\n\t\t\tthis.y = data.y;\r\n\t\t\tthis.rotation = data.rotation;\r\n\t\t\tthis.scaleX = data.scaleX;\r\n\t\t\tthis.scaleY = data.scaleY;\r\n\t\t\tthis.shearX = data.shearX;\r\n\t\t\tthis.shearY = data.shearY;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationX = function () {\r\n\t\t\treturn Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationY = function () {\r\n\t\t\treturn Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleX = function () {\r\n\t\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleY = function () {\r\n\t\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t};\r\n\t\tBone.prototype.updateAppliedTransform = function () {\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tthis.ax = this.worldX;\r\n\t\t\t\tthis.ay = this.worldY;\r\n\t\t\t\tthis.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t\t\tthis.ashearX = 0;\r\n\t\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tvar pid = 1 / (pa * pd - pb * pc);\r\n\t\t\tvar dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\r\n\t\t\tthis.ax = (dx * pd * pid - dy * pb * pid);\r\n\t\t\tthis.ay = (dy * pa * pid - dx * pc * pid);\r\n\t\t\tvar ia = pid * pd;\r\n\t\t\tvar id = pid * pa;\r\n\t\t\tvar ib = pid * pb;\r\n\t\t\tvar ic = pid * pc;\r\n\t\t\tvar ra = ia * this.a - ib * this.c;\r\n\t\t\tvar rb = ia * this.b - ib * this.d;\r\n\t\t\tvar rc = id * this.c - ic * this.a;\r\n\t\t\tvar rd = id * this.d - ic * this.b;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n\t\t\tif (this.ascaleX > 0.0001) {\r\n\t\t\t\tvar det = ra * rd - rb * rc;\r\n\t\t\t\tthis.ascaleY = det / this.ascaleX;\r\n\t\t\t\tthis.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.ascaleX = 0;\r\n\t\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n\t\t\t\tthis.ashearY = 0;\r\n\t\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t};\r\n\t\tBone.prototype.worldToLocal = function (world) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar invDet = 1 / (a * d - b * c);\r\n\t\t\tvar x = world.x - this.worldX, y = world.y - this.worldY;\r\n\t\t\tworld.x = (x * d * invDet - y * b * invDet);\r\n\t\t\tworld.y = (y * a * invDet - x * c * invDet);\r\n\t\t\treturn world;\r\n\t\t};\r\n\t\tBone.prototype.localToWorld = function (local) {\r\n\t\t\tvar x = local.x, y = local.y;\r\n\t\t\tlocal.x = x * this.a + y * this.b + this.worldX;\r\n\t\t\tlocal.y = x * this.c + y * this.d + this.worldY;\r\n\t\t\treturn local;\r\n\t\t};\r\n\t\tBone.prototype.worldToLocalRotation = function (worldRotation) {\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\r\n\t\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;\r\n\t\t};\r\n\t\tBone.prototype.localToWorldRotation = function (localRotation) {\r\n\t\t\tlocalRotation -= this.rotation - this.shearX;\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\r\n\t\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.rotateWorld = function (degrees) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\r\n\t\t\tthis.a = cos * a - sin * c;\r\n\t\t\tthis.b = cos * b - sin * d;\r\n\t\t\tthis.c = sin * a + cos * c;\r\n\t\t\tthis.d = sin * b + cos * d;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t};\r\n\t\treturn Bone;\r\n\t}());\r\n\tspine.Bone = Bone;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoneData = (function () {\r\n\t\tfunction BoneData(index, name, parent) {\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 1;\r\n\t\t\tthis.scaleY = 1;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.transformMode = TransformMode.Normal;\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn BoneData;\r\n\t}());\r\n\tspine.BoneData = BoneData;\r\n\tvar TransformMode;\r\n\t(function (TransformMode) {\r\n\t\tTransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tTransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n\t\tTransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n\t\tTransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n\t\tTransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n\t})(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Event = (function () {\r\n\t\tfunction Event(time, data) {\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.time = time;\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\treturn Event;\r\n\t}());\r\n\tspine.Event = Event;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar EventData = (function () {\r\n\t\tfunction EventData(name) {\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn EventData;\r\n\t}());\r\n\tspine.EventData = EventData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraint = (function () {\r\n\t\tfunction IkConstraint(data, skeleton) {\r\n\t\t\tthis.bendDirection = 0;\r\n\t\t\tthis.compress = false;\r\n\t\t\tthis.stretch = false;\r\n\t\t\tthis.mix = 1;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.mix = data.mix;\r\n\t\t\tthis.bendDirection = data.bendDirection;\r\n\t\t\tthis.compress = data.compress;\r\n\t\t\tthis.stretch = data.stretch;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tIkConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tIkConstraint.prototype.update = function () {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tswitch (bones.length) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\r\n\t\t\tif (!bone.appliedValid)\r\n\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\tvar p = bone.parent;\r\n\t\t\tvar id = 1 / (p.a * p.d - p.b * p.c);\r\n\t\t\tvar x = targetX - p.worldX, y = targetY - p.worldY;\r\n\t\t\tvar tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;\r\n\t\t\tvar rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;\r\n\t\t\tif (bone.ascaleX < 0)\r\n\t\t\t\trotationIK += 180;\r\n\t\t\tif (rotationIK > 180)\r\n\t\t\t\trotationIK -= 360;\r\n\t\t\telse if (rotationIK < -180)\r\n\t\t\t\trotationIK += 360;\r\n\t\t\tvar sx = bone.ascaleX, sy = bone.ascaleY;\r\n\t\t\tif (compress || stretch) {\r\n\t\t\t\tvar b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n\t\t\t\tif ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n\t\t\t\t\tvar s = (dd / b - 1) * alpha + 1;\r\n\t\t\t\t\tsx *= s;\r\n\t\t\t\t\tif (uniform)\r\n\t\t\t\t\t\tsy *= s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, alpha) {\r\n\t\t\tif (alpha == 0) {\r\n\t\t\t\tchild.updateWorldTransform();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!parent.appliedValid)\r\n\t\t\t\tparent.updateAppliedTransform();\r\n\t\t\tif (!child.appliedValid)\r\n\t\t\t\tchild.updateAppliedTransform();\r\n\t\t\tvar px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n\t\t\tvar os1 = 0, os2 = 0, s2 = 0;\r\n\t\t\tif (psx < 0) {\r\n\t\t\t\tpsx = -psx;\r\n\t\t\t\tos1 = 180;\r\n\t\t\t\ts2 = -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tos1 = 0;\r\n\t\t\t\ts2 = 1;\r\n\t\t\t}\r\n\t\t\tif (psy < 0) {\r\n\t\t\t\tpsy = -psy;\r\n\t\t\t\ts2 = -s2;\r\n\t\t\t}\r\n\t\t\tif (csx < 0) {\r\n\t\t\t\tcsx = -csx;\r\n\t\t\t\tos2 = 180;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tos2 = 0;\r\n\t\t\tvar cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\r\n\t\t\tvar u = Math.abs(psx - psy) <= 0.0001;\r\n\t\t\tif (!u) {\r\n\t\t\t\tcy = 0;\r\n\t\t\t\tcwx = a * cx + parent.worldX;\r\n\t\t\t\tcwy = c * cx + parent.worldY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcy = child.ay;\r\n\t\t\t\tcwx = a * cx + b * cy + parent.worldX;\r\n\t\t\t\tcwy = c * cx + d * cy + parent.worldY;\r\n\t\t\t}\r\n\t\t\tvar pp = parent.parent;\r\n\t\t\ta = pp.a;\r\n\t\t\tb = pp.b;\r\n\t\t\tc = pp.c;\r\n\t\t\td = pp.d;\r\n\t\t\tvar id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n\t\t\tvar tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py, dd = tx * tx + ty * ty;\r\n\t\t\tx = cwx - pp.worldX;\r\n\t\t\ty = cwy - pp.worldY;\r\n\t\t\tvar dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n\t\t\tvar l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\r\n\t\t\touter: if (u) {\r\n\t\t\t\tl2 *= psx;\r\n\t\t\t\tvar cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\t\t\t\tif (cos < -1)\r\n\t\t\t\t\tcos = -1;\r\n\t\t\t\telse if (cos > 1) {\r\n\t\t\t\t\tcos = 1;\r\n\t\t\t\t\tif (stretch && l1 + l2 > 0.0001)\r\n\t\t\t\t\t\tsx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n\t\t\t\t}\r\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\r\n\t\t\t\ta = l1 + l2 * cos;\r\n\t\t\t\tb = l2 * Math.sin(a2);\r\n\t\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ta = psx * l2;\r\n\t\t\t\tb = psy * l2;\r\n\t\t\t\tvar aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n\t\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\r\n\t\t\t\tvar c1 = -2 * bb * l1, c2 = bb - aa;\r\n\t\t\t\td = c1 * c1 - 4 * c2 * c;\r\n\t\t\t\tif (d >= 0) {\r\n\t\t\t\t\tvar q = Math.sqrt(d);\r\n\t\t\t\t\tif (c1 < 0)\r\n\t\t\t\t\t\tq = -q;\r\n\t\t\t\t\tq = -(c1 + q) / 2;\r\n\t\t\t\t\tvar r0 = q / c2, r1 = c / q;\r\n\t\t\t\t\tvar r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\t\t\t\t\tif (r * r <= dd) {\r\n\t\t\t\t\t\ty = Math.sqrt(dd - r * r) * bendDir;\r\n\t\t\t\t\t\ta1 = ta - Math.atan2(y, r);\r\n\t\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\r\n\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n\t\t\t\tvar maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n\t\t\t\tc = -a * l1 / (aa - bb);\r\n\t\t\t\tif (c >= -1 && c <= 1) {\r\n\t\t\t\t\tc = Math.acos(c);\r\n\t\t\t\t\tx = a * Math.cos(c) + l1;\r\n\t\t\t\t\ty = b * Math.sin(c);\r\n\t\t\t\t\td = x * x + y * y;\r\n\t\t\t\t\tif (d < minDist) {\r\n\t\t\t\t\t\tminAngle = c;\r\n\t\t\t\t\t\tminDist = d;\r\n\t\t\t\t\t\tminX = x;\r\n\t\t\t\t\t\tminY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (d > maxDist) {\r\n\t\t\t\t\t\tmaxAngle = c;\r\n\t\t\t\t\t\tmaxDist = d;\r\n\t\t\t\t\t\tmaxX = x;\r\n\t\t\t\t\t\tmaxY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dd <= (minDist + maxDist) / 2) {\r\n\t\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\r\n\t\t\t\t\ta2 = minAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n\t\t\t\t\ta2 = maxAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar os = Math.atan2(cy, cx) * s2;\r\n\t\t\tvar rotation = parent.arotation;\r\n\t\t\ta1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\r\n\t\t\tif (a1 > 180)\r\n\t\t\t\ta1 -= 360;\r\n\t\t\telse if (a1 < -180)\r\n\t\t\t\ta1 += 360;\r\n\t\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n\t\t\trotation = child.arotation;\r\n\t\t\ta2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n\t\t\tif (a2 > 180)\r\n\t\t\t\ta2 -= 360;\r\n\t\t\telse if (a2 < -180)\r\n\t\t\t\ta2 += 360;\r\n\t\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\t\t};\r\n\t\treturn IkConstraint;\r\n\t}());\r\n\tspine.IkConstraint = IkConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraintData = (function () {\r\n\t\tfunction IkConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.bendDirection = 1;\r\n\t\t\tthis.compress = false;\r\n\t\t\tthis.stretch = false;\r\n\t\t\tthis.uniform = false;\r\n\t\t\tthis.mix = 1;\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn IkConstraintData;\r\n\t}());\r\n\tspine.IkConstraintData = IkConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraint = (function () {\r\n\t\tfunction PathConstraint(data, skeleton) {\r\n\t\t\tthis.position = 0;\r\n\t\t\tthis.spacing = 0;\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.spaces = new Array();\r\n\t\t\tthis.positions = new Array();\r\n\t\t\tthis.world = new Array();\r\n\t\t\tthis.curves = new Array();\r\n\t\t\tthis.lengths = new Array();\r\n\t\t\tthis.segments = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0, n = data.bones.length; i < n; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findSlot(data.target.name);\r\n\t\t\tthis.position = data.position;\r\n\t\t\tthis.spacing = data.spacing;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t}\r\n\t\tPathConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tPathConstraint.prototype.update = function () {\r\n\t\t\tvar attachment = this.target.getAttachment();\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n\t\t\tvar translate = translateMix > 0, rotate = rotateMix > 0;\r\n\t\t\tif (!translate && !rotate)\r\n\t\t\t\treturn;\r\n\t\t\tvar data = this.data;\r\n\t\t\tvar percentSpacing = data.spacingMode == spine.SpacingMode.Percent;\r\n\t\t\tvar rotateMode = data.rotateMode;\r\n\t\t\tvar tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\r\n\t\t\tvar boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tvar spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n\t\t\tvar spacing = this.spacing;\r\n\t\t\tif (scale || !percentSpacing) {\r\n\t\t\t\tif (scale)\r\n\t\t\t\t\tlengths = spine.Utils.setArraySize(this.lengths, boneCount);\r\n\t\t\t\tvar lengthSpacing = data.spacingMode == spine.SpacingMode.Length;\r\n\t\t\t\tfor (var i = 0, n = spacesCount - 1; i < n;) {\r\n\t\t\t\t\tvar bone = bones[i];\r\n\t\t\t\t\tvar setupLength = bone.data.length;\r\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = 0;\r\n\t\t\t\t\t\tspaces[++i] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (percentSpacing) {\r\n\t\t\t\t\t\tif (scale) {\r\n\t\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\t\t\tvar length_1 = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\t\t\tlengths[i] = length_1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tspaces[++i] = spacing;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\t\tvar length_2 = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = length_2;\r\n\t\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] = spacing;\r\n\t\t\t}\r\n\t\t\tvar positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);\r\n\t\t\tvar boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n\t\t\tvar tip = false;\r\n\t\t\tif (offsetRotation == 0)\r\n\t\t\t\ttip = rotateMode == spine.RotateMode.Chain;\r\n\t\t\telse {\r\n\t\t\t\ttip = false;\r\n\t\t\t\tvar p = this.target.bone;\r\n\t\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tbone.worldX += (boneX - bone.worldX) * translateMix;\r\n\t\t\t\tbone.worldY += (boneY - bone.worldY) * translateMix;\r\n\t\t\t\tvar x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n\t\t\t\tif (scale) {\r\n\t\t\t\t\tvar length_3 = lengths[i];\r\n\t\t\t\t\tif (length_3 != 0) {\r\n\t\t\t\t\t\tvar s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;\r\n\t\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tboneX = x;\r\n\t\t\t\tboneY = y;\r\n\t\t\t\tif (rotate) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\r\n\t\t\t\t\tif (tangents)\r\n\t\t\t\t\t\tr = positions[p - 1];\r\n\t\t\t\t\telse if (spaces[i + 1] == 0)\r\n\t\t\t\t\t\tr = positions[p + 2];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tr = Math.atan2(dy, dx);\r\n\t\t\t\t\tr -= Math.atan2(c, a);\r\n\t\t\t\t\tif (tip) {\r\n\t\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\t\tvar length_4 = bone.data.length;\r\n\t\t\t\t\t\tboneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;\r\n\t\t\t\t\t\tboneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tr += offsetRotation;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t}\r\n\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar position = this.position;\r\n\t\t\tvar spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n\t\t\tvar closed = path.closed;\r\n\t\t\tvar verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\t\t\tif (!path.constantSpeed) {\r\n\t\t\t\tvar lengths = path.lengths;\r\n\t\t\t\tcurveCount -= closed ? 1 : 2;\r\n\t\t\t\tvar pathLength_1 = lengths[curveCount];\r\n\t\t\t\tif (percentPosition)\r\n\t\t\t\t\tposition *= pathLength_1;\r\n\t\t\t\tif (percentSpacing) {\r\n\t\t\t\t\tfor (var i = 1; i < spacesCount; i++)\r\n\t\t\t\t\t\tspaces[i] *= pathLength_1;\r\n\t\t\t\t}\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, 8);\r\n\t\t\t\tfor (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\t\tvar space = spaces[i];\r\n\t\t\t\t\tposition += space;\r\n\t\t\t\t\tvar p = position;\r\n\t\t\t\t\tif (closed) {\r\n\t\t\t\t\t\tp %= pathLength_1;\r\n\t\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\t\tp += pathLength_1;\r\n\t\t\t\t\t\tcurve = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p > pathLength_1) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\t\tvar length_5 = lengths[curve];\r\n\t\t\t\t\t\tif (p > length_5)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\t\tp /= length_5;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvar prev = lengths[curve - 1];\r\n\t\t\t\t\t\t\tp = (p - prev) / (length_5 - prev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\t\tif (closed && curve == curveCount) {\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t\t}\r\n\t\t\t\treturn out;\r\n\t\t\t}\r\n\t\t\tif (closed) {\r\n\t\t\t\tverticesLength += 2;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n\t\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n\t\t\t\tworld[verticesLength - 2] = world[0];\r\n\t\t\t\tworld[verticesLength - 1] = world[1];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcurveCount--;\r\n\t\t\t\tverticesLength -= 4;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n\t\t\t}\r\n\t\t\tvar curves = spine.Utils.setArraySize(this.curves, curveCount);\r\n\t\t\tvar pathLength = 0;\r\n\t\t\tvar x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n\t\t\tvar tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n\t\t\tfor (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n\t\t\t\tcx1 = world[w];\r\n\t\t\t\tcy1 = world[w + 1];\r\n\t\t\t\tcx2 = world[w + 2];\r\n\t\t\t\tcy2 = world[w + 3];\r\n\t\t\t\tx2 = world[w + 4];\r\n\t\t\t\ty2 = world[w + 5];\r\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tcurves[i] = pathLength;\r\n\t\t\t\tx1 = x2;\r\n\t\t\t\ty1 = y2;\r\n\t\t\t}\r\n\t\t\tif (percentPosition)\r\n\t\t\t\tposition *= pathLength;\r\n\t\t\telse\r\n\t\t\t\tposition *= pathLength / path.lengths[curveCount - 1];\r\n\t\t\tif (percentSpacing) {\r\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] *= pathLength;\r\n\t\t\t}\r\n\t\t\tvar segments = this.segments;\r\n\t\t\tvar curveLength = 0;\r\n\t\t\tfor (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\tvar space = spaces[i];\r\n\t\t\t\tposition += space;\r\n\t\t\t\tvar p = position;\r\n\t\t\t\tif (closed) {\r\n\t\t\t\t\tp %= pathLength;\r\n\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\tp += pathLength;\r\n\t\t\t\t\tcurve = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p > pathLength) {\r\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\tvar length_6 = curves[curve];\r\n\t\t\t\t\tif (p > length_6)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\tp /= length_6;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = curves[curve - 1];\r\n\t\t\t\t\t\tp = (p - prev) / (length_6 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\tvar ii = curve * 6;\r\n\t\t\t\t\tx1 = world[ii];\r\n\t\t\t\t\ty1 = world[ii + 1];\r\n\t\t\t\t\tcx1 = world[ii + 2];\r\n\t\t\t\t\tcy1 = world[ii + 3];\r\n\t\t\t\t\tcx2 = world[ii + 4];\r\n\t\t\t\t\tcy2 = world[ii + 5];\r\n\t\t\t\t\tx2 = world[ii + 6];\r\n\t\t\t\t\ty2 = world[ii + 7];\r\n\t\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n\t\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n\t\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n\t\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n\t\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[0] = curveLength;\r\n\t\t\t\t\tfor (ii = 1; ii < 8; ii++) {\r\n\t\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\t\tddfx += dddfx;\r\n\t\t\t\t\t\tddfy += dddfy;\r\n\t\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\t\tsegments[ii] = curveLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[8] = curveLength;\r\n\t\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[9] = curveLength;\r\n\t\t\t\t\tsegment = 0;\r\n\t\t\t\t}\r\n\t\t\t\tp *= curveLength;\r\n\t\t\t\tfor (;; segment++) {\r\n\t\t\t\t\tvar length_7 = segments[segment];\r\n\t\t\t\t\tif (p > length_7)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (segment == 0)\r\n\t\t\t\t\t\tp /= length_7;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = segments[segment - 1];\r\n\t\t\t\t\t\tp = segment + (p - prev) / (length_7 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n\t\t\tif (p == 0 || isNaN(p)) {\r\n\t\t\t\tout[o] = x1;\r\n\t\t\t\tout[o + 1] = y1;\r\n\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n\t\t\tvar ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n\t\t\tvar x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\t\t\tout[o] = x;\r\n\t\t\tout[o + 1] = y;\r\n\t\t\tif (tangents) {\r\n\t\t\t\tif (p < 0.001)\r\n\t\t\t\t\tout[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n\t\t\t\telse\r\n\t\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tPathConstraint.NONE = -1;\r\n\t\tPathConstraint.BEFORE = -2;\r\n\t\tPathConstraint.AFTER = -3;\r\n\t\tPathConstraint.epsilon = 0.00001;\r\n\t\treturn PathConstraint;\r\n\t}());\r\n\tspine.PathConstraint = PathConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraintData = (function () {\r\n\t\tfunction PathConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn PathConstraintData;\r\n\t}());\r\n\tspine.PathConstraintData = PathConstraintData;\r\n\tvar PositionMode;\r\n\t(function (PositionMode) {\r\n\t\tPositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n\t\tPositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n\t})(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\r\n\tvar SpacingMode;\r\n\t(function (SpacingMode) {\r\n\t\tSpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n\t\tSpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n\t\tSpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n\t})(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\r\n\tvar RotateMode;\r\n\t(function (RotateMode) {\r\n\t\tRotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n\t\tRotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n\t\tRotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n\t})(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Assets = (function () {\r\n\t\tfunction Assets(clientId) {\r\n\t\t\tthis.toLoad = new Array();\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.clientId = clientId;\r\n\t\t}\r\n\t\tAssets.prototype.loaded = function () {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (var v in this.assets)\r\n\t\t\t\ti++;\r\n\t\t\treturn i;\r\n\t\t};\r\n\t\treturn Assets;\r\n\t}());\r\n\tvar SharedAssetManager = (function () {\r\n\t\tfunction SharedAssetManager(pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.clientAssets = {};\r\n\t\t\tthis.queuedAssets = {};\r\n\t\t\tthis.rawAssets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tSharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined) {\r\n\t\t\t\tclientAssets = new Assets(clientId);\r\n\t\t\t\tthis.clientAssets[clientId] = clientAssets;\r\n\t\t\t}\r\n\t\t\tif (textureLoader !== null)\r\n\t\t\t\tclientAssets.textureLoader = textureLoader;\r\n\t\t\tclientAssets.toLoad.push(path);\r\n\t\t\tif (this.queuedAssets[path] === path) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.queuedAssets[path] = path;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadText = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadJson = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = JSON.parse(request.responseText);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, textureLoader, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.src = path;\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\t_this.rawAssets[path] = img;\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t};\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.get = function (clientId, path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\treturn clientAssets.assets[path];\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\r\n\t\t\tfor (var i = 0; i < clientAssets.toLoad.length; i++) {\r\n\t\t\t\tvar path = clientAssets.toLoad[i];\r\n\t\t\t\tvar asset = clientAssets.assets[path];\r\n\t\t\t\tif (asset === null || asset === undefined) {\r\n\t\t\t\t\tvar rawAsset = this.rawAssets[path];\r\n\t\t\t\t\tif (rawAsset === null || rawAsset === undefined)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (rawAsset instanceof HTMLImageElement) {\r\n\t\t\t\t\t\tclientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tclientAssets.assets[path] = rawAsset;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.isLoadingComplete = function (clientId) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\tthis.updateClientAssets(clientAssets);\r\n\t\t\treturn clientAssets.toLoad.length == clientAssets.loaded();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.dispose = function () {\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn SharedAssetManager;\r\n\t}());\r\n\tspine.SharedAssetManager = SharedAssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skeleton = (function () {\r\n\t\tfunction Skeleton(data) {\r\n\t\t\tthis._updateCache = new Array();\r\n\t\t\tthis.updateCacheReset = new Array();\r\n\t\t\tthis.time = 0;\r\n\t\t\tthis.scaleX = 1;\r\n\t\t\tthis.scaleY = 1;\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++) {\r\n\t\t\t\tvar boneData = data.bones[i];\r\n\t\t\t\tvar bone = void 0;\r\n\t\t\t\tif (boneData.parent == null)\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, null);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar parent_1 = this.bones[boneData.parent.index];\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, parent_1);\r\n\t\t\t\t\tparent_1.children.push(bone);\r\n\t\t\t\t}\r\n\t\t\t\tthis.bones.push(bone);\r\n\t\t\t}\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.drawOrder = new Array();\r\n\t\t\tfor (var i = 0; i < data.slots.length; i++) {\r\n\t\t\t\tvar slotData = data.slots[i];\r\n\t\t\t\tvar bone = this.bones[slotData.boneData.index];\r\n\t\t\t\tvar slot = new spine.Slot(slotData, bone);\r\n\t\t\t\tthis.slots.push(slot);\r\n\t\t\t\tthis.drawOrder.push(slot);\r\n\t\t\t}\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.ikConstraints.length; i++) {\r\n\t\t\t\tvar ikConstraintData = data.ikConstraints[i];\r\n\t\t\t\tthis.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.transformConstraints.length; i++) {\r\n\t\t\t\tvar transformConstraintData = data.transformConstraints[i];\r\n\t\t\t\tthis.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.pathConstraints.length; i++) {\r\n\t\t\t\tvar pathConstraintData = data.pathConstraints[i];\r\n\t\t\t\tthis.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tthis.updateCache();\r\n\t\t}\r\n\t\tSkeleton.prototype.updateCache = function () {\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tupdateCache.length = 0;\r\n\t\t\tthis.updateCacheReset.length = 0;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].sorted = false;\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tvar ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n\t\t\tvar constraintCount = ikCount + transformCount + pathCount;\r\n\t\t\touter: for (var i = 0; i < constraintCount; i++) {\r\n\t\t\t\tfor (var ii = 0; ii < ikCount; ii++) {\r\n\t\t\t\t\tvar constraint = ikConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortIkConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < transformCount; ii++) {\r\n\t\t\t\t\tvar constraint = transformConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortTransformConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < pathCount; ii++) {\r\n\t\t\t\t\tvar constraint = pathConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortPathConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tthis.sortBone(bones[i]);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortIkConstraint = function (constraint) {\r\n\t\t\tvar target = constraint.target;\r\n\t\t\tthis.sortBone(target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar parent = constrained[0];\r\n\t\t\tthis.sortBone(parent);\r\n\t\t\tif (constrained.length > 1) {\r\n\t\t\t\tvar child = constrained[constrained.length - 1];\r\n\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tthis.sortReset(parent.children);\r\n\t\t\tconstrained[constrained.length - 1].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraint = function (constraint) {\r\n\t\t\tvar slot = constraint.target;\r\n\t\t\tvar slotIndex = slot.data.index;\r\n\t\t\tvar slotBone = slot.bone;\r\n\t\t\tif (this.skin != null)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n\t\t\tif (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n\t\t\tfor (var i = 0, n = this.data.skins.length; i < n; i++)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\tif (attachment instanceof spine.PathAttachment)\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortReset(constrained[i].children);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tconstrained[i].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortTransformConstraint = function (constraint) {\r\n\t\t\tthis.sortBone(constraint.target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tif (constraint.data.local) {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tvar child = constrained[i];\r\n\t\t\t\t\tthis.sortBone(child.parent);\r\n\t\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tthis.sortReset(constrained[ii].children);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tconstrained[ii].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n\t\t\tvar attachments = skin.attachments[slotIndex];\r\n\t\t\tif (!attachments)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var key in attachments) {\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar pathBones = attachment.bones;\r\n\t\t\tif (pathBones == null)\r\n\t\t\t\tthis.sortBone(slotBone);\r\n\t\t\telse {\r\n\t\t\t\tvar bones = this.bones;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile (i < pathBones.length) {\r\n\t\t\t\t\tvar boneCount = pathBones[i++];\r\n\t\t\t\t\tfor (var n = i + boneCount; i < n; i++) {\r\n\t\t\t\t\t\tvar boneIndex = pathBones[i];\r\n\t\t\t\t\t\tthis.sortBone(bones[boneIndex]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortBone = function (bone) {\r\n\t\t\tif (bone.sorted)\r\n\t\t\t\treturn;\r\n\t\t\tvar parent = bone.parent;\r\n\t\t\tif (parent != null)\r\n\t\t\t\tthis.sortBone(parent);\r\n\t\t\tbone.sorted = true;\r\n\t\t\tthis._updateCache.push(bone);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortReset = function (bones) {\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.sorted)\r\n\t\t\t\t\tthis.sortReset(bone.children);\r\n\t\t\t\tbone.sorted = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.updateWorldTransform = function () {\r\n\t\t\tvar updateCacheReset = this.updateCacheReset;\r\n\t\t\tfor (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n\t\t\t\tvar bone = updateCacheReset[i];\r\n\t\t\t\tbone.ax = bone.x;\r\n\t\t\t\tbone.ay = bone.y;\r\n\t\t\t\tbone.arotation = bone.rotation;\r\n\t\t\t\tbone.ascaleX = bone.scaleX;\r\n\t\t\t\tbone.ascaleY = bone.scaleY;\r\n\t\t\t\tbone.ashearX = bone.shearX;\r\n\t\t\t\tbone.ashearY = bone.shearY;\r\n\t\t\t\tbone.appliedValid = true;\r\n\t\t\t}\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tfor (var i = 0, n = updateCache.length; i < n; i++)\r\n\t\t\t\tupdateCache[i].update();\r\n\t\t};\r\n\t\tSkeleton.prototype.setToSetupPose = function () {\r\n\t\t\tthis.setBonesToSetupPose();\r\n\t\t\tthis.setSlotsToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.setBonesToSetupPose = function () {\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].setToSetupPose();\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.compress = constraint.data.compress;\r\n\t\t\t\tconstraint.stretch = constraint.data.stretch;\r\n\t\t\t}\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t}\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.position = data.position;\r\n\t\t\t\tconstraint.spacing = data.spacing;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.setSlotsToSetupPose = function () {\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tspine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tslots[i].setToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.getRootBone = function () {\r\n\t\t\tif (this.bones.length == 0)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.bones[0];\r\n\t\t};\r\n\t\tSkeleton.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.data.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].data.name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].data.name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkinByName = function (skinName) {\r\n\t\t\tvar skin = this.data.findSkin(skinName);\r\n\t\t\tif (skin == null)\r\n\t\t\t\tthrow new Error(\"Skin not found: \" + skinName);\r\n\t\t\tthis.setSkin(skin);\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkin = function (newSkin) {\r\n\t\t\tif (newSkin != null) {\r\n\t\t\t\tif (this.skin != null)\r\n\t\t\t\t\tnewSkin.attachAll(this, this.skin);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar slots = this.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar name_1 = slot.data.attachmentName;\r\n\t\t\t\t\t\tif (name_1 != null) {\r\n\t\t\t\t\t\t\tvar attachment = newSkin.getAttachment(i, name_1);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.skin = newSkin;\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n\t\t\treturn this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n\t\t\tif (attachmentName == null)\r\n\t\t\t\tthrow new Error(\"attachmentName cannot be null.\");\r\n\t\t\tif (this.skin != null) {\r\n\t\t\t\tvar attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\t\t\t\tif (attachment != null)\r\n\t\t\t\t\treturn attachment;\r\n\t\t\t}\r\n\t\t\tif (this.data.defaultSkin != null)\r\n\t\t\t\treturn this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName) {\r\n\t\t\t\t\tvar attachment = null;\r\n\t\t\t\t\tif (attachmentName != null) {\r\n\t\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\r\n\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t};\r\n\t\tSkeleton.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar ikConstraint = ikConstraints[i];\r\n\t\t\t\tif (ikConstraint.data.name == constraintName)\r\n\t\t\t\t\treturn ikConstraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.getBounds = function (offset, size, temp) {\r\n\t\t\tif (temp === void 0) { temp = new Array(2); }\r\n\t\t\tif (offset == null)\r\n\t\t\t\tthrow new Error(\"offset cannot be null.\");\r\n\t\t\tif (size == null)\r\n\t\t\t\tthrow new Error(\"size cannot be null.\");\r\n\t\t\tvar drawOrder = this.drawOrder;\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\tvar verticesLength = 0;\r\n\t\t\t\tvar vertices = null;\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\tverticesLength = 8;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tattachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\tverticesLength = mesh.worldVerticesLength;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\tif (vertices != null) {\r\n\t\t\t\t\tfor (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\r\n\t\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toffset.set(minX, minY);\r\n\t\t\tsize.set(maxX - minX, maxY - minY);\r\n\t\t};\r\n\t\tSkeleton.prototype.update = function (delta) {\r\n\t\t\tthis.time += delta;\r\n\t\t};\r\n\t\treturn Skeleton;\r\n\t}());\r\n\tspine.Skeleton = Skeleton;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonBounds = (function () {\r\n\t\tfunction SkeletonBounds() {\r\n\t\t\tthis.minX = 0;\r\n\t\t\tthis.minY = 0;\r\n\t\t\tthis.maxX = 0;\r\n\t\t\tthis.maxY = 0;\r\n\t\t\tthis.boundingBoxes = new Array();\r\n\t\t\tthis.polygons = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn spine.Utils.newFloatArray(16);\r\n\t\t\t});\r\n\t\t}\r\n\t\tSkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tvar boundingBoxes = this.boundingBoxes;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tvar polygonPool = this.polygonPool;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tvar slotCount = slots.length;\r\n\t\t\tboundingBoxes.length = 0;\r\n\t\t\tpolygonPool.freeAll(polygons);\r\n\t\t\tpolygons.length = 0;\r\n\t\t\tfor (var i = 0; i < slotCount; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.BoundingBoxAttachment) {\r\n\t\t\t\t\tvar boundingBox = attachment;\r\n\t\t\t\t\tboundingBoxes.push(boundingBox);\r\n\t\t\t\t\tvar polygon = polygonPool.obtain();\r\n\t\t\t\t\tif (polygon.length != boundingBox.worldVerticesLength) {\r\n\t\t\t\t\t\tpolygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygons.push(polygon);\r\n\t\t\t\t\tboundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateAabb) {\r\n\t\t\t\tthis.aabbCompute();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.minX = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.minY = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.maxX = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tthis.maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbCompute = function () {\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\r\n\t\t\t\tvar polygon = polygons[i];\r\n\t\t\t\tvar vertices = polygon;\r\n\t\t\t\tfor (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n\t\t\t\t\tvar x = vertices[ii];\r\n\t\t\t\t\tvar y = vertices[ii + 1];\r\n\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.minX = minX;\r\n\t\t\tthis.minY = minY;\r\n\t\t\tthis.maxX = maxX;\r\n\t\t\tthis.maxY = maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n\t\t\treturn x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar minX = this.minX;\r\n\t\t\tvar minY = this.minY;\r\n\t\t\tvar maxX = this.maxX;\r\n\t\t\tvar maxY = this.maxY;\r\n\t\t\tif ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n\t\t\t\treturn false;\r\n\t\t\tvar m = (y2 - y1) / (x2 - x1);\r\n\t\t\tvar y = m * (minX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\ty = m * (maxX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\tvar x = (minY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\tx = (maxY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n\t\t\treturn this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPoint = function (x, y) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.containsPointPolygon(polygons[i], x, y))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar prevIndex = nn - 2;\r\n\t\t\tvar inside = false;\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar vertexY = vertices[ii + 1];\r\n\t\t\t\tvar prevY = vertices[prevIndex + 1];\r\n\t\t\t\tif ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n\t\t\t\t\tvar vertexX = vertices[ii];\r\n\t\t\t\t\tif (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n\t\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex = ii;\r\n\t\t\t}\r\n\t\t\treturn inside;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar width12 = x1 - x2, height12 = y1 - y2;\r\n\t\t\tvar det1 = x1 * y2 - y1 * x2;\r\n\t\t\tvar x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar x4 = vertices[ii], y4 = vertices[ii + 1];\r\n\t\t\t\tvar det2 = x3 * y4 - y3 * x4;\r\n\t\t\t\tvar width34 = x3 - x4, height34 = y3 - y4;\r\n\t\t\t\tvar det3 = width12 * height34 - height12 * width34;\r\n\t\t\t\tvar x = (det1 * width34 - width12 * det2) / det3;\r\n\t\t\t\tif (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n\t\t\t\t\tvar y = (det1 * height34 - height12 * det2) / det3;\r\n\t\t\t\t\tif (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tx3 = x4;\r\n\t\t\t\ty3 = y4;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n\t\t\tif (boundingBox == null)\r\n\t\t\t\tthrow new Error(\"boundingBox cannot be null.\");\r\n\t\t\tvar index = this.boundingBoxes.indexOf(boundingBox);\r\n\t\t\treturn index == -1 ? null : this.polygons[index];\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getWidth = function () {\r\n\t\t\treturn this.maxX - this.minX;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getHeight = function () {\r\n\t\t\treturn this.maxY - this.minY;\r\n\t\t};\r\n\t\treturn SkeletonBounds;\r\n\t}());\r\n\tspine.SkeletonBounds = SkeletonBounds;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonClipping = (function () {\r\n\t\tfunction SkeletonClipping() {\r\n\t\t\tthis.triangulator = new spine.Triangulator();\r\n\t\t\tthis.clippingPolygon = new Array();\r\n\t\t\tthis.clipOutput = new Array();\r\n\t\t\tthis.clippedVertices = new Array();\r\n\t\t\tthis.clippedTriangles = new Array();\r\n\t\t\tthis.scratch = new Array();\r\n\t\t}\r\n\t\tSkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n\t\t\tif (this.clipAttachment != null)\r\n\t\t\t\treturn 0;\r\n\t\t\tthis.clipAttachment = clip;\r\n\t\t\tvar n = clip.worldVerticesLength;\r\n\t\t\tvar vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\r\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n\t\t\tvar clippingPolygon = this.clippingPolygon;\r\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\r\n\t\t\tvar clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n\t\t\tfor (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\r\n\t\t\t\tvar polygon = clippingPolygons[i];\r\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\r\n\t\t\t\tpolygon.push(polygon[0]);\r\n\t\t\t\tpolygon.push(polygon[1]);\r\n\t\t\t}\r\n\t\t\treturn clippingPolygons.length;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n\t\t\t\tthis.clipEnd();\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEnd = function () {\r\n\t\t\tif (this.clipAttachment == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.clipAttachment = null;\r\n\t\t\tthis.clippingPolygons = null;\r\n\t\t\tthis.clippedVertices.length = 0;\r\n\t\t\tthis.clippedTriangles.length = 0;\r\n\t\t\tthis.clippingPolygon.length = 0;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.isClipping = function () {\r\n\t\t\treturn this.clipAttachment != null;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n\t\t\tvar clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n\t\t\tvar clippedTriangles = this.clippedTriangles;\r\n\t\t\tvar polygons = this.clippingPolygons;\r\n\t\t\tvar polygonsCount = this.clippingPolygons.length;\r\n\t\t\tvar vertexSize = twoColor ? 12 : 8;\r\n\t\t\tvar index = 0;\r\n\t\t\tclippedVertices.length = 0;\r\n\t\t\tclippedTriangles.length = 0;\r\n\t\t\touter: for (var i = 0; i < trianglesLength; i += 3) {\r\n\t\t\t\tvar vertexOffset = triangles[i] << 1;\r\n\t\t\t\tvar x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\r\n\t\t\t\tvar x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\r\n\t\t\t\tvar x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n\t\t\t\tfor (var p = 0; p < polygonsCount; p++) {\r\n\t\t\t\t\tvar s = clippedVertices.length;\r\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n\t\t\t\t\t\tvar clipOutputLength = clipOutput.length;\r\n\t\t\t\t\t\tif (clipOutputLength == 0)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n\t\t\t\t\t\tvar d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n\t\t\t\t\t\tvar clipOutputCount = clipOutputLength >> 1;\r\n\t\t\t\t\t\tvar clipOutputItems = this.clipOutput;\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n\t\t\t\t\t\t\tvar x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\t\tvar c0 = x - x3, c1 = y - y3;\r\n\t\t\t\t\t\t\tvar a = (d0 * c0 + d1 * c1) * d;\r\n\t\t\t\t\t\t\tvar b = (d4 * c0 + d2 * c1) * d;\r\n\t\t\t\t\t\t\tvar c = 1 - a - b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n\t\t\t\t\t\t\tif (twoColor) {\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ts += vertexSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n\t\t\t\t\t\tclipOutputCount--;\r\n\t\t\t\t\t\tfor (var ii = 1; ii < clipOutputCount; ii++) {\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\r\n\t\t\t\t\t\t\ts += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tindex += clipOutputCount + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\tif (!twoColor) {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\r\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\r\n\t\t\t\t\t\tindex += 3;\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n\t\t\tvar originalOutput = output;\r\n\t\t\tvar clipped = false;\r\n\t\t\tvar input = null;\r\n\t\t\tif (clippingArea.length % 4 >= 2) {\r\n\t\t\t\tinput = output;\r\n\t\t\t\toutput = this.scratch;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tinput = this.scratch;\r\n\t\t\tinput.length = 0;\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\tinput.push(x2);\r\n\t\t\tinput.push(y2);\r\n\t\t\tinput.push(x3);\r\n\t\t\tinput.push(y3);\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\toutput.length = 0;\r\n\t\t\tvar clippingVertices = clippingArea;\r\n\t\t\tvar clippingVerticesLast = clippingArea.length - 4;\r\n\t\t\tfor (var i = 0;; i += 2) {\r\n\t\t\t\tvar edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n\t\t\t\tvar edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n\t\t\t\tvar deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n\t\t\t\tvar inputVertices = input;\r\n\t\t\t\tvar inputVerticesLength = input.length - 2, outputStart = output.length;\r\n\t\t\t\tfor (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n\t\t\t\t\tvar inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n\t\t\t\t\tvar inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n\t\t\t\t\tvar side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n\t\t\t\t\t\tif (side2) {\r\n\t\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\r\n\t\t\t\t\t\tif (Math.abs(s) > 0.000001) {\r\n\t\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\r\n\t\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\toutput.push(edgeX);\r\n\t\t\t\t\t\t\toutput.push(edgeY);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (side2) {\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\r\n\t\t\t\t\t\tif (Math.abs(s) > 0.000001) {\r\n\t\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\r\n\t\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\toutput.push(edgeX);\r\n\t\t\t\t\t\t\toutput.push(edgeY);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclipped = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (outputStart == output.length) {\r\n\t\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\toutput.push(output[0]);\r\n\t\t\t\toutput.push(output[1]);\r\n\t\t\t\tif (i == clippingVerticesLast)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tvar temp = output;\r\n\t\t\t\toutput = input;\r\n\t\t\t\toutput.length = 0;\r\n\t\t\t\tinput = temp;\r\n\t\t\t}\r\n\t\t\tif (originalOutput != output) {\r\n\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\tfor (var i = 0, n = output.length - 2; i < n; i++)\r\n\t\t\t\t\toriginalOutput[i] = output[i];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\r\n\t\t\treturn clipped;\r\n\t\t};\r\n\t\tSkeletonClipping.makeClockwise = function (polygon) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar verticeslength = polygon.length;\r\n\t\t\tvar area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n\t\t\tfor (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n\t\t\t\tp1x = vertices[i];\r\n\t\t\t\tp1y = vertices[i + 1];\r\n\t\t\t\tp2x = vertices[i + 2];\r\n\t\t\t\tp2y = vertices[i + 3];\r\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t\t}\r\n\t\t\tif (area < 0)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n\t\t\t\tvar x = vertices[i], y = vertices[i + 1];\r\n\t\t\t\tvar other = lastX - i;\r\n\t\t\t\tvertices[i] = vertices[other];\r\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\r\n\t\t\t\tvertices[other] = x;\r\n\t\t\t\tvertices[other + 1] = y;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn SkeletonClipping;\r\n\t}());\r\n\tspine.SkeletonClipping = SkeletonClipping;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonData = (function () {\r\n\t\tfunction SkeletonData() {\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.skins = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.animations = new Array();\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tthis.fps = 0;\r\n\t\t}\r\n\t\tSkeletonData.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSkin = function (skinName) {\r\n\t\t\tif (skinName == null)\r\n\t\t\t\tthrow new Error(\"skinName cannot be null.\");\r\n\t\t\tvar skins = this.skins;\r\n\t\t\tfor (var i = 0, n = skins.length; i < n; i++) {\r\n\t\t\t\tvar skin = skins[i];\r\n\t\t\t\tif (skin.name == skinName)\r\n\t\t\t\t\treturn skin;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findEvent = function (eventDataName) {\r\n\t\t\tif (eventDataName == null)\r\n\t\t\t\tthrow new Error(\"eventDataName cannot be null.\");\r\n\t\t\tvar events = this.events;\r\n\t\t\tfor (var i = 0, n = events.length; i < n; i++) {\r\n\t\t\t\tvar event_4 = events[i];\r\n\t\t\t\tif (event_4.name == eventDataName)\r\n\t\t\t\t\treturn event_4;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findAnimation = function (animationName) {\r\n\t\t\tif (animationName == null)\r\n\t\t\t\tthrow new Error(\"animationName cannot be null.\");\r\n\t\t\tvar animations = this.animations;\r\n\t\t\tfor (var i = 0, n = animations.length; i < n; i++) {\r\n\t\t\t\tvar animation = animations[i];\r\n\t\t\t\tif (animation.name == animationName)\r\n\t\t\t\t\treturn animation;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n\t\t\tif (pathConstraintName == null)\r\n\t\t\t\tthrow new Error(\"pathConstraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++)\r\n\t\t\t\tif (pathConstraints[i].name == pathConstraintName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn SkeletonData;\r\n\t}());\r\n\tspine.SkeletonData = SkeletonData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonJson = (function () {\r\n\t\tfunction SkeletonJson(attachmentLoader) {\r\n\t\t\tthis.scale = 1;\r\n\t\t\tthis.linkedMeshes = new Array();\r\n\t\t\tthis.attachmentLoader = attachmentLoader;\r\n\t\t}\r\n\t\tSkeletonJson.prototype.readSkeletonData = function (json) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar skeletonData = new spine.SkeletonData();\r\n\t\t\tvar root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n\t\t\tvar skeletonMap = root.skeleton;\r\n\t\t\tif (skeletonMap != null) {\r\n\t\t\t\tskeletonData.hash = skeletonMap.hash;\r\n\t\t\t\tskeletonData.version = skeletonMap.spine;\r\n\t\t\t\tskeletonData.width = skeletonMap.width;\r\n\t\t\t\tskeletonData.height = skeletonMap.height;\r\n\t\t\t\tskeletonData.fps = skeletonMap.fps;\r\n\t\t\t\tskeletonData.imagesPath = skeletonMap.images;\r\n\t\t\t}\r\n\t\t\tif (root.bones) {\r\n\t\t\t\tfor (var i = 0; i < root.bones.length; i++) {\r\n\t\t\t\t\tvar boneMap = root.bones[i];\r\n\t\t\t\t\tvar parent_2 = null;\r\n\t\t\t\t\tvar parentName = this.getValue(boneMap, \"parent\", null);\r\n\t\t\t\t\tif (parentName != null) {\r\n\t\t\t\t\t\tparent_2 = skeletonData.findBone(parentName);\r\n\t\t\t\t\t\tif (parent_2 == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Parent bone not found: \" + parentName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\r\n\t\t\t\t\tdata.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n\t\t\t\t\tdata.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n\t\t\t\t\tdata.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n\t\t\t\t\tdata.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n\t\t\t\t\tdata.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n\t\t\t\t\tskeletonData.bones.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.slots) {\r\n\t\t\t\tfor (var i = 0; i < root.slots.length; i++) {\r\n\t\t\t\t\tvar slotMap = root.slots[i];\r\n\t\t\t\t\tvar slotName = slotMap.name;\r\n\t\t\t\t\tvar boneName = slotMap.bone;\r\n\t\t\t\t\tvar boneData = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (boneData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Slot bone not found: \" + boneName);\r\n\t\t\t\t\tvar data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\r\n\t\t\t\t\tvar color = this.getValue(slotMap, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tdata.color.setFromString(color);\r\n\t\t\t\t\tvar dark = this.getValue(slotMap, \"dark\", null);\r\n\t\t\t\t\tif (dark != null) {\r\n\t\t\t\t\t\tdata.darkColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\t\t\t\tdata.darkColor.setFromString(dark);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n\t\t\t\t\tdata.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n\t\t\t\t\tskeletonData.slots.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.ik) {\r\n\t\t\t\tfor (var i = 0; i < root.ik.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.ik[i];\r\n\t\t\t\t\tvar data = new spine.IkConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"IK bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"IK target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\t\t\t\t\tdata.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n\t\t\t\t\tdata.compress = this.getValue(constraintMap, \"compress\", false);\r\n\t\t\t\t\tdata.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n\t\t\t\t\tdata.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n\t\t\t\t\tskeletonData.ikConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.transform) {\r\n\t\t\t\tfor (var i = 0; i < root.transform.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.transform[i];\r\n\t\t\t\t\tvar data = new spine.TransformConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.local = this.getValue(constraintMap, \"local\", false);\r\n\t\t\t\t\tdata.relative = this.getValue(constraintMap, \"relative\", false);\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n\t\t\t\t\tdata.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n\t\t\t\t\tdata.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tdata.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n\t\t\t\t\tdata.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\t\t\t\t\tskeletonData.transformConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.path) {\r\n\t\t\t\tfor (var i = 0; i < root.path.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.path[i];\r\n\t\t\t\t\tvar data = new spine.PathConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findSlot(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Path target slot not found: \" + targetName);\r\n\t\t\t\t\tdata.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n\t\t\t\t\tdata.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n\t\t\t\t\tdata.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.position = this.getValue(constraintMap, \"position\", 0);\r\n\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\tdata.position *= scale;\r\n\t\t\t\t\tdata.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\tdata.spacing *= scale;\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tskeletonData.pathConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.skins) {\r\n\t\t\t\tfor (var skinName in root.skins) {\r\n\t\t\t\t\tvar skinMap = root.skins[skinName];\r\n\t\t\t\t\tvar skin = new spine.Skin(skinName);\r\n\t\t\t\t\tfor (var slotName in skinMap) {\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\t\tvar slotMap = skinMap[slotName];\r\n\t\t\t\t\t\tfor (var entryName in slotMap) {\r\n\t\t\t\t\t\t\tvar attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tskin.addAttachment(slotIndex, entryName, attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tskeletonData.skins.push(skin);\r\n\t\t\t\t\tif (skin.name == \"default\")\r\n\t\t\t\t\t\tskeletonData.defaultSkin = skin;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n\t\t\t\tvar linkedMesh = this.linkedMeshes[i];\r\n\t\t\t\tvar skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\t\t\t\tif (skin == null)\r\n\t\t\t\t\tthrow new Error(\"Skin not found: \" + linkedMesh.skin);\r\n\t\t\t\tvar parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\t\t\t\tif (parent_3 == null)\r\n\t\t\t\t\tthrow new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent_3);\r\n\t\t\t\tlinkedMesh.mesh.updateUVs();\r\n\t\t\t}\r\n\t\t\tthis.linkedMeshes.length = 0;\r\n\t\t\tif (root.events) {\r\n\t\t\t\tfor (var eventName in root.events) {\r\n\t\t\t\t\tvar eventMap = root.events[eventName];\r\n\t\t\t\t\tvar data = new spine.EventData(eventName);\r\n\t\t\t\t\tdata.intValue = this.getValue(eventMap, \"int\", 0);\r\n\t\t\t\t\tdata.floatValue = this.getValue(eventMap, \"float\", 0);\r\n\t\t\t\t\tdata.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n\t\t\t\t\tdata.audioPath = this.getValue(eventMap, \"audio\", null);\r\n\t\t\t\t\tif (data.audioPath != null) {\r\n\t\t\t\t\t\tdata.volume = this.getValue(eventMap, \"volume\", 1);\r\n\t\t\t\t\t\tdata.balance = this.getValue(eventMap, \"balance\", 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tskeletonData.events.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.animations) {\r\n\t\t\t\tfor (var animationName in root.animations) {\r\n\t\t\t\t\tvar animationMap = root.animations[animationName];\r\n\t\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn skeletonData;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tname = this.getValue(map, \"name\", name);\r\n\t\t\tvar type = this.getValue(map, \"type\", \"region\");\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"region\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\t\t\t\t\tif (region == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tregion.path = path;\r\n\t\t\t\t\tregion.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tregion.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tregion.scaleX = this.getValue(map, \"scaleX\", 1);\r\n\t\t\t\t\tregion.scaleY = this.getValue(map, \"scaleY\", 1);\r\n\t\t\t\t\tregion.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tregion.width = map.width * scale;\r\n\t\t\t\t\tregion.height = map.height * scale;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tregion.color.setFromString(color);\r\n\t\t\t\t\tregion.updateOffset();\r\n\t\t\t\t\treturn region;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"boundingbox\": {\r\n\t\t\t\t\tvar box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\t\t\t\t\tif (box == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tbox.color.setFromString(color);\r\n\t\t\t\t\treturn box;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"mesh\":\r\n\t\t\t\tcase \"linkedmesh\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\t\tif (mesh == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tmesh.path = path;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tmesh.color.setFromString(color);\r\n\t\t\t\t\tvar parent_4 = this.getValue(map, \"parent\", null);\r\n\t\t\t\t\tif (parent_4 != null) {\r\n\t\t\t\t\t\tmesh.inheritDeform = this.getValue(map, \"deform\", true);\r\n\t\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\r\n\t\t\t\t\t\treturn mesh;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar uvs = map.uvs;\r\n\t\t\t\t\tthis.readVertices(map, mesh, uvs.length);\r\n\t\t\t\t\tmesh.triangles = map.triangles;\r\n\t\t\t\t\tmesh.regionUVs = uvs;\r\n\t\t\t\t\tmesh.updateUVs();\r\n\t\t\t\t\tmesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"path\": {\r\n\t\t\t\t\tvar path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\t\t\t\t\tif (path == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpath.closed = this.getValue(map, \"closed\", false);\r\n\t\t\t\t\tpath.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\r\n\t\t\t\t\tvar lengths = spine.Utils.newArray(vertexCount / 3, 0);\r\n\t\t\t\t\tfor (var i = 0; i < map.lengths.length; i++)\r\n\t\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\r\n\t\t\t\t\tpath.lengths = lengths;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpath.color.setFromString(color);\r\n\t\t\t\t\treturn path;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"point\": {\r\n\t\t\t\t\tvar point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\t\t\t\t\tif (point == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpoint.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tpoint.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tpoint.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpoint.color.setFromString(color);\r\n\t\t\t\t\treturn point;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"clipping\": {\r\n\t\t\t\t\tvar clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\t\t\t\t\tif (clip == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tvar end = this.getValue(map, \"end\", null);\r\n\t\t\t\t\tif (end != null) {\r\n\t\t\t\t\t\tvar slot = skeletonData.findSlot(end);\r\n\t\t\t\t\t\tif (slot == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Clipping end slot not found: \" + end);\r\n\t\t\t\t\t\tclip.endSlot = slot;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tclip.color.setFromString(color);\r\n\t\t\t\t\treturn clip;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tattachment.worldVerticesLength = verticesLength;\r\n\t\t\tvar vertices = map.vertices;\r\n\t\t\tif (verticesLength == vertices.length) {\r\n\t\t\t\tvar scaledVertices = spine.Utils.toFloatArray(vertices);\r\n\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\tfor (var i = 0, n = vertices.length; i < n; i++)\r\n\t\t\t\t\t\tscaledVertices[i] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\tattachment.vertices = scaledVertices;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar weights = new Array();\r\n\t\t\tvar bones = new Array();\r\n\t\t\tfor (var i = 0, n = vertices.length; i < n;) {\r\n\t\t\t\tvar boneCount = vertices[i++];\r\n\t\t\t\tbones.push(boneCount);\r\n\t\t\t\tfor (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n\t\t\t\t\tbones.push(vertices[i]);\r\n\t\t\t\t\tweights.push(vertices[i + 1] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 2] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 3]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tattachment.bones = bones;\r\n\t\t\tattachment.vertices = spine.Utils.toFloatArray(weights);\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar timelines = new Array();\r\n\t\t\tvar duration = 0;\r\n\t\t\tif (map.slots) {\r\n\t\t\t\tfor (var slotName in map.slots) {\r\n\t\t\t\t\tvar slotMap = map.slots[slotName];\r\n\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName == \"attachment\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"color\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.ColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar color = new spine.Color();\r\n\t\t\t\t\t\t\t\tcolor.setFromString(valueMap.color);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"twoColor\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.TwoColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar light = new spine.Color();\r\n\t\t\t\t\t\t\t\tvar dark = new spine.Color();\r\n\t\t\t\t\t\t\t\tlight.setFromString(valueMap.light);\r\n\t\t\t\t\t\t\t\tdark.setFromString(valueMap.dark);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.bones) {\r\n\t\t\t\tfor (var boneName in map.bones) {\r\n\t\t\t\t\tvar boneMap = map.bones[boneName];\r\n\t\t\t\t\tvar boneIndex = skeletonData.findBoneIndex(boneName);\r\n\t\t\t\t\tif (boneIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Bone not found: \" + boneName);\r\n\t\t\t\t\tfor (var timelineName in boneMap) {\r\n\t\t\t\t\t\tvar timelineMap = boneMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"rotate\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.RotateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"scale\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse if (timelineName === \"shear\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ShearTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.ik) {\r\n\t\t\t\tfor (var constraintName in map.ik) {\r\n\t\t\t\t\tvar constraintMap = map.ik[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findIkConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.IkConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.transform) {\r\n\t\t\t\tfor (var constraintName in map.transform) {\r\n\t\t\t\t\tvar constraintMap = map.transform[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findTransformConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.TransformConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.paths) {\r\n\t\t\t\tfor (var constraintName in map.paths) {\r\n\t\t\t\t\tvar constraintMap = map.paths[constraintName];\r\n\t\t\t\t\tvar index = skeletonData.findPathConstraintIndex(constraintName);\r\n\t\t\t\t\tif (index == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Path constraint not found: \" + constraintName);\r\n\t\t\t\t\tvar data = skeletonData.pathConstraints[index];\r\n\t\t\t\t\tfor (var timelineName in constraintMap) {\r\n\t\t\t\t\t\tvar timelineMap = constraintMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"position\" || timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"mix\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.deform) {\r\n\t\t\t\tfor (var deformName in map.deform) {\r\n\t\t\t\t\tvar deformMap = map.deform[deformName];\r\n\t\t\t\t\tvar skin = skeletonData.findSkin(deformName);\r\n\t\t\t\t\tif (skin == null)\r\n\t\t\t\t\t\tthrow new Error(\"Skin not found: \" + deformName);\r\n\t\t\t\t\tfor (var slotName in deformMap) {\r\n\t\t\t\t\t\tvar slotMap = deformMap[slotName];\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotMap.name);\r\n\t\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\t\tvar attachment = skin.getAttachment(slotIndex, timelineName);\r\n\t\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n\t\t\t\t\t\t\tvar weighted = attachment.bones != null;\r\n\t\t\t\t\t\t\tvar vertices = attachment.vertices;\r\n\t\t\t\t\t\t\tvar deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\t\t\t\t\t\t\tvar timeline = new spine.DeformTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\ttimeline.attachment = attachment;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var j = 0; j < timelineMap.length; j++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[j];\r\n\t\t\t\t\t\t\t\tvar deform = void 0;\r\n\t\t\t\t\t\t\t\tvar verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n\t\t\t\t\t\t\t\tif (verticesValue == null)\r\n\t\t\t\t\t\t\t\t\tdeform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tdeform = spine.Utils.newFloatArray(deformLength);\r\n\t\t\t\t\t\t\t\t\tvar start = this.getValue(valueMap, \"offset\", 0);\r\n\t\t\t\t\t\t\t\t\tspine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n\t\t\t\t\t\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = start, n = i + verticesValue.length; i < n; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!weighted) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < deformLength; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, deform);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar drawOrderNode = map.drawOrder;\r\n\t\t\tif (drawOrderNode == null)\r\n\t\t\t\tdrawOrderNode = map.draworder;\r\n\t\t\tif (drawOrderNode != null) {\r\n\t\t\t\tvar timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\r\n\t\t\t\tvar slotCount = skeletonData.slots.length;\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var j = 0; j < drawOrderNode.length; j++) {\r\n\t\t\t\t\tvar drawOrderMap = drawOrderNode[j];\r\n\t\t\t\t\tvar drawOrder = null;\r\n\t\t\t\t\tvar offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n\t\t\t\t\tif (offsets != null) {\r\n\t\t\t\t\t\tdrawOrder = spine.Utils.newArray(slotCount, -1);\r\n\t\t\t\t\t\tvar unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\r\n\t\t\t\t\t\tvar originalIndex = 0, unchangedIndex = 0;\r\n\t\t\t\t\t\tfor (var i = 0; i < offsets.length; i++) {\r\n\t\t\t\t\t\t\tvar offsetMap = offsets[i];\r\n\t\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\t\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + offsetMap.slot);\r\n\t\t\t\t\t\t\twhile (originalIndex != slotIndex)\r\n\t\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile (originalIndex < slotCount)\r\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\tfor (var i = slotCount - 1; i >= 0; i--)\r\n\t\t\t\t\t\t\tif (drawOrder[i] == -1)\r\n\t\t\t\t\t\t\t\tdrawOrder[i] = unchanged[--unchangedIndex];\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (map.events) {\r\n\t\t\t\tvar timeline = new spine.EventTimeline(map.events.length);\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var i = 0; i < map.events.length; i++) {\r\n\t\t\t\t\tvar eventMap = map.events[i];\r\n\t\t\t\t\tvar eventData = skeletonData.findEvent(eventMap.name);\r\n\t\t\t\t\tif (eventData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Event not found: \" + eventMap.name);\r\n\t\t\t\t\tvar event_5 = new spine.Event(spine.Utils.toSinglePrecision(eventMap.time), eventData);\r\n\t\t\t\t\tevent_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n\t\t\t\t\tevent_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n\t\t\t\t\tevent_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n\t\t\t\t\tif (event_5.data.audioPath != null) {\r\n\t\t\t\t\t\tevent_5.volume = this.getValue(eventMap, \"volume\", 1);\r\n\t\t\t\t\t\tevent_5.balance = this.getValue(eventMap, \"balance\", 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, event_5);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (isNaN(duration)) {\r\n\t\t\t\tthrow new Error(\"Error while parsing animation, duration is NaN\");\r\n\t\t\t}\r\n\t\t\tskeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n\t\t\tif (!map.curve)\r\n\t\t\t\treturn;\r\n\t\t\tif (map.curve === \"stepped\")\r\n\t\t\t\ttimeline.setStepped(frameIndex);\r\n\t\t\telse if (Object.prototype.toString.call(map.curve) === '[object Array]') {\r\n\t\t\t\tvar curve = map.curve;\r\n\t\t\t\ttimeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n\t\t\treturn map[prop] !== undefined ? map[prop] : defaultValue;\r\n\t\t};\r\n\t\tSkeletonJson.blendModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.BlendMode.Normal;\r\n\t\t\tif (str == \"additive\")\r\n\t\t\t\treturn spine.BlendMode.Additive;\r\n\t\t\tif (str == \"multiply\")\r\n\t\t\t\treturn spine.BlendMode.Multiply;\r\n\t\t\tif (str == \"screen\")\r\n\t\t\t\treturn spine.BlendMode.Screen;\r\n\t\t\tthrow new Error(\"Unknown blend mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.positionModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.PositionMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.PositionMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.spacingModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"length\")\r\n\t\t\t\treturn spine.SpacingMode.Length;\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.SpacingMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.SpacingMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.rotateModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"tangent\")\r\n\t\t\t\treturn spine.RotateMode.Tangent;\r\n\t\t\tif (str == \"chain\")\r\n\t\t\t\treturn spine.RotateMode.Chain;\r\n\t\t\tif (str == \"chainscale\")\r\n\t\t\t\treturn spine.RotateMode.ChainScale;\r\n\t\t\tthrow new Error(\"Unknown rotate mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.transformModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.TransformMode.Normal;\r\n\t\t\tif (str == \"onlytranslation\")\r\n\t\t\t\treturn spine.TransformMode.OnlyTranslation;\r\n\t\t\tif (str == \"norotationorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoRotationOrReflection;\r\n\t\t\tif (str == \"noscale\")\r\n\t\t\t\treturn spine.TransformMode.NoScale;\r\n\t\t\tif (str == \"noscaleorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoScaleOrReflection;\r\n\t\t\tthrow new Error(\"Unknown transform mode: \" + str);\r\n\t\t};\r\n\t\treturn SkeletonJson;\r\n\t}());\r\n\tspine.SkeletonJson = SkeletonJson;\r\n\tvar LinkedMesh = (function () {\r\n\t\tfunction LinkedMesh(mesh, skin, slotIndex, parent) {\r\n\t\t\tthis.mesh = mesh;\r\n\t\t\tthis.skin = skin;\r\n\t\t\tthis.slotIndex = slotIndex;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn LinkedMesh;\r\n\t}());\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skin = (function () {\r\n\t\tfunction Skin(name) {\r\n\t\t\tthis.attachments = new Array();\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\tSkin.prototype.addAttachment = function (slotIndex, name, attachment) {\r\n\t\t\tif (attachment == null)\r\n\t\t\t\tthrow new Error(\"attachment cannot be null.\");\r\n\t\t\tvar attachments = this.attachments;\r\n\t\t\tif (slotIndex >= attachments.length)\r\n\t\t\t\tattachments.length = slotIndex + 1;\r\n\t\t\tif (!attachments[slotIndex])\r\n\t\t\t\tattachments[slotIndex] = {};\r\n\t\t\tattachments[slotIndex][name] = attachment;\r\n\t\t};\r\n\t\tSkin.prototype.getAttachment = function (slotIndex, name) {\r\n\t\t\tvar dictionary = this.attachments[slotIndex];\r\n\t\t\treturn dictionary ? dictionary[name] : null;\r\n\t\t};\r\n\t\tSkin.prototype.attachAll = function (skeleton, oldSkin) {\r\n\t\t\tvar slotIndex = 0;\r\n\t\t\tfor (var i = 0; i < skeleton.slots.length; i++) {\r\n\t\t\t\tvar slot = skeleton.slots[i];\r\n\t\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n\t\t\t\t\tvar dictionary = oldSkin.attachments[slotIndex];\r\n\t\t\t\t\tfor (var key in dictionary) {\r\n\t\t\t\t\t\tvar skinAttachment = dictionary[key];\r\n\t\t\t\t\t\tif (slotAttachment == skinAttachment) {\r\n\t\t\t\t\t\t\tvar attachment = this.getAttachment(slotIndex, key);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tslotIndex++;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Skin;\r\n\t}());\r\n\tspine.Skin = Skin;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Slot = (function () {\r\n\t\tfunction Slot(data, bone) {\r\n\t\t\tthis.attachmentVertices = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (bone == null)\r\n\t\t\t\tthrow new Error(\"bone cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bone = bone;\r\n\t\t\tthis.color = new spine.Color();\r\n\t\t\tthis.darkColor = data.darkColor == null ? null : new spine.Color();\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tSlot.prototype.getAttachment = function () {\r\n\t\t\treturn this.attachment;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachment = function (attachment) {\r\n\t\t\tif (this.attachment == attachment)\r\n\t\t\t\treturn;\r\n\t\t\tthis.attachment = attachment;\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time;\r\n\t\t\tthis.attachmentVertices.length = 0;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachmentTime = function (time) {\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time - time;\r\n\t\t};\r\n\t\tSlot.prototype.getAttachmentTime = function () {\r\n\t\t\treturn this.bone.skeleton.time - this.attachmentTime;\r\n\t\t};\r\n\t\tSlot.prototype.setToSetupPose = function () {\r\n\t\t\tthis.color.setFromColor(this.data.color);\r\n\t\t\tif (this.darkColor != null)\r\n\t\t\t\tthis.darkColor.setFromColor(this.data.darkColor);\r\n\t\t\tif (this.data.attachmentName == null)\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\telse {\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Slot;\r\n\t}());\r\n\tspine.Slot = Slot;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SlotData = (function () {\r\n\t\tfunction SlotData(index, name, boneData) {\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (boneData == null)\r\n\t\t\t\tthrow new Error(\"boneData cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.boneData = boneData;\r\n\t\t}\r\n\t\treturn SlotData;\r\n\t}());\r\n\tspine.SlotData = SlotData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Texture = (function () {\r\n\t\tfunction Texture(image) {\r\n\t\t\tthis._image = image;\r\n\t\t}\r\n\t\tTexture.prototype.getImage = function () {\r\n\t\t\treturn this._image;\r\n\t\t};\r\n\t\tTexture.filterFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"nearest\": return TextureFilter.Nearest;\r\n\t\t\t\tcase \"linear\": return TextureFilter.Linear;\r\n\t\t\t\tcase \"mipmap\": return TextureFilter.MipMap;\r\n\t\t\t\tcase \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n\t\t\t\tcase \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n\t\t\t\tcase \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n\t\t\t\tcase \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture filter \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTexture.wrapFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n\t\t\t\tcase \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n\t\t\t\tcase \"repeat\": return TextureWrap.Repeat;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture wrap \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Texture;\r\n\t}());\r\n\tspine.Texture = Texture;\r\n\tvar TextureFilter;\r\n\t(function (TextureFilter) {\r\n\t\tTextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n\t\tTextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n\t})(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\r\n\tvar TextureWrap;\r\n\t(function (TextureWrap) {\r\n\t\tTextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n\t\tTextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n\t\tTextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n\t})(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\r\n\tvar TextureRegion = (function () {\r\n\t\tfunction TextureRegion() {\r\n\t\t\tthis.u = 0;\r\n\t\t\tthis.v = 0;\r\n\t\t\tthis.u2 = 0;\r\n\t\t\tthis.v2 = 0;\r\n\t\t\tthis.width = 0;\r\n\t\t\tthis.height = 0;\r\n\t\t\tthis.rotate = false;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.originalWidth = 0;\r\n\t\t\tthis.originalHeight = 0;\r\n\t\t}\r\n\t\treturn TextureRegion;\r\n\t}());\r\n\tspine.TextureRegion = TextureRegion;\r\n\tvar FakeTexture = (function (_super) {\r\n\t\t__extends(FakeTexture, _super);\r\n\t\tfunction FakeTexture() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\tFakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n\t\tFakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n\t\tFakeTexture.prototype.dispose = function () { };\r\n\t\treturn FakeTexture;\r\n\t}(Texture));\r\n\tspine.FakeTexture = FakeTexture;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TextureAtlas = (function () {\r\n\t\tfunction TextureAtlas(atlasText, textureLoader) {\r\n\t\t\tthis.pages = new Array();\r\n\t\t\tthis.regions = new Array();\r\n\t\t\tthis.load(atlasText, textureLoader);\r\n\t\t}\r\n\t\tTextureAtlas.prototype.load = function (atlasText, textureLoader) {\r\n\t\t\tif (textureLoader == null)\r\n\t\t\t\tthrow new Error(\"textureLoader cannot be null.\");\r\n\t\t\tvar reader = new TextureAtlasReader(atlasText);\r\n\t\t\tvar tuple = new Array(4);\r\n\t\t\tvar page = null;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar line = reader.readLine();\r\n\t\t\t\tif (line == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif (line.length == 0)\r\n\t\t\t\t\tpage = null;\r\n\t\t\t\telse if (!page) {\r\n\t\t\t\t\tpage = new TextureAtlasPage();\r\n\t\t\t\t\tpage.name = line;\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 2) {\r\n\t\t\t\t\t\tpage.width = parseInt(tuple[0]);\r\n\t\t\t\t\t\tpage.height = parseInt(tuple[1]);\r\n\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tpage.minFilter = spine.Texture.filterFromString(tuple[0]);\r\n\t\t\t\t\tpage.magFilter = spine.Texture.filterFromString(tuple[1]);\r\n\t\t\t\t\tvar direction = reader.readValue();\r\n\t\t\t\t\tpage.uWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tpage.vWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tif (direction == \"x\")\r\n\t\t\t\t\t\tpage.uWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"y\")\r\n\t\t\t\t\t\tpage.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"xy\")\r\n\t\t\t\t\t\tpage.uWrap = page.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\tpage.texture = textureLoader(line);\r\n\t\t\t\t\tpage.texture.setFilters(page.minFilter, page.magFilter);\r\n\t\t\t\t\tpage.texture.setWraps(page.uWrap, page.vWrap);\r\n\t\t\t\t\tpage.width = page.texture.getImage().width;\r\n\t\t\t\t\tpage.height = page.texture.getImage().height;\r\n\t\t\t\t\tthis.pages.push(page);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar region = new TextureAtlasRegion();\r\n\t\t\t\t\tregion.name = line;\r\n\t\t\t\t\tregion.page = page;\r\n\t\t\t\t\tregion.rotate = reader.readValue() == \"true\";\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar x = parseInt(tuple[0]);\r\n\t\t\t\t\tvar y = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar width = parseInt(tuple[0]);\r\n\t\t\t\t\tvar height = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.u = x / page.width;\r\n\t\t\t\t\tregion.v = y / page.height;\r\n\t\t\t\t\tif (region.rotate) {\r\n\t\t\t\t\t\tregion.u2 = (x + height) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + width) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tregion.u2 = (x + width) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + height) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.x = x;\r\n\t\t\t\t\tregion.y = y;\r\n\t\t\t\t\tregion.width = Math.abs(width);\r\n\t\t\t\t\tregion.height = Math.abs(height);\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.originalWidth = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.originalHeight = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tregion.offsetX = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.offsetY = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.index = parseInt(reader.readValue());\r\n\t\t\t\t\tregion.texture = page.texture;\r\n\t\t\t\t\tthis.regions.push(region);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tTextureAtlas.prototype.findRegion = function (name) {\r\n\t\t\tfor (var i = 0; i < this.regions.length; i++) {\r\n\t\t\t\tif (this.regions[i].name == name) {\r\n\t\t\t\t\treturn this.regions[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tTextureAtlas.prototype.dispose = function () {\r\n\t\t\tfor (var i = 0; i < this.pages.length; i++) {\r\n\t\t\t\tthis.pages[i].texture.dispose();\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TextureAtlas;\r\n\t}());\r\n\tspine.TextureAtlas = TextureAtlas;\r\n\tvar TextureAtlasReader = (function () {\r\n\t\tfunction TextureAtlasReader(text) {\r\n\t\t\tthis.index = 0;\r\n\t\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\r\n\t\t}\r\n\t\tTextureAtlasReader.prototype.readLine = function () {\r\n\t\t\tif (this.index >= this.lines.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.lines[this.index++];\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readValue = function () {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\treturn line.substring(colon + 1).trim();\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readTuple = function (tuple) {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\tvar i = 0, lastMatch = colon + 1;\r\n\t\t\tfor (; i < 3; i++) {\r\n\t\t\t\tvar comma = line.indexOf(\",\", lastMatch);\r\n\t\t\t\tif (comma == -1)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\ttuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n\t\t\t\tlastMatch = comma + 1;\r\n\t\t\t}\r\n\t\t\ttuple[i] = line.substring(lastMatch).trim();\r\n\t\t\treturn i + 1;\r\n\t\t};\r\n\t\treturn TextureAtlasReader;\r\n\t}());\r\n\tvar TextureAtlasPage = (function () {\r\n\t\tfunction TextureAtlasPage() {\r\n\t\t}\r\n\t\treturn TextureAtlasPage;\r\n\t}());\r\n\tspine.TextureAtlasPage = TextureAtlasPage;\r\n\tvar TextureAtlasRegion = (function (_super) {\r\n\t\t__extends(TextureAtlasRegion, _super);\r\n\t\tfunction TextureAtlasRegion() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\treturn TextureAtlasRegion;\r\n\t}(spine.TextureRegion));\r\n\tspine.TextureAtlasRegion = TextureAtlasRegion;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraint = (function () {\r\n\t\tfunction TransformConstraint(data, skeleton) {\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.temp = new spine.Vector2();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t\tthis.scaleMix = data.scaleMix;\r\n\t\t\tthis.shearMix = data.shearMix;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tTransformConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tTransformConstraint.prototype.update = function () {\r\n\t\t\tif (this.data.local) {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeLocal();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteLocal();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeWorld();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteWorld();\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect;\r\n\t\t\tvar offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += (temp.x - bone.worldX) * translateMix;\r\n\t\t\t\t\tbone.worldY += (temp.y - bone.worldY) * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\r\n\t\t\t\t\tvar ts = Math.sqrt(ta * ta + tc * tc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\r\n\t\t\t\t\tts = Math.sqrt(tb * tb + td * td);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tvar by = Math.atan2(d, b);\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr = by + (r + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += temp.x * translateMix;\r\n\t\t\t\t\tbone.worldY += temp.y * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tr = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar r = target.arotation - rotation + this.data.offsetRotation;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\trotation += r * rotateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax - x + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay - y + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix != 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix != 0) {\r\n\t\t\t\t\tvar r = target.ashearY - shearY + this.data.offsetShearY;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\tbone.shearY += r * shearMix;\r\n\t\t\t\t}\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0)\r\n\t\t\t\t\trotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix != 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix != 0)\r\n\t\t\t\t\tshearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\treturn TransformConstraint;\r\n\t}());\r\n\tspine.TransformConstraint = TransformConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraintData = (function () {\r\n\t\tfunction TransformConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.offsetRotation = 0;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.offsetScaleX = 0;\r\n\t\t\tthis.offsetScaleY = 0;\r\n\t\t\tthis.offsetShearY = 0;\r\n\t\t\tthis.relative = false;\r\n\t\t\tthis.local = false;\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn TransformConstraintData;\r\n\t}());\r\n\tspine.TransformConstraintData = TransformConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Triangulator = (function () {\r\n\t\tfunction Triangulator() {\r\n\t\t\tthis.convexPolygons = new Array();\r\n\t\t\tthis.convexPolygonsIndices = new Array();\r\n\t\t\tthis.indicesArray = new Array();\r\n\t\t\tthis.isConcaveArray = new Array();\r\n\t\t\tthis.triangles = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t\tthis.polygonIndicesPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t}\r\n\t\tTriangulator.prototype.triangulate = function (verticesArray) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar vertexCount = verticesArray.length >> 1;\r\n\t\t\tvar indices = this.indicesArray;\r\n\t\t\tindices.length = 0;\r\n\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\tindices[i] = i;\r\n\t\t\tvar isConcave = this.isConcaveArray;\r\n\t\t\tisConcave.length = 0;\r\n\t\t\tfor (var i = 0, n = vertexCount; i < n; ++i)\r\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n\t\t\tvar triangles = this.triangles;\r\n\t\t\ttriangles.length = 0;\r\n\t\t\twhile (vertexCount > 3) {\r\n\t\t\t\tvar previous = vertexCount - 1, i = 0, next = 1;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\touter: if (!isConcave[i]) {\r\n\t\t\t\t\t\tvar p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n\t\t\t\t\t\tvar p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n\t\t\t\t\t\tvar p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n\t\t\t\t\t\tvar p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n\t\t\t\t\t\tfor (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n\t\t\t\t\t\t\tif (!isConcave[ii])\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\tvar v = indices[ii] << 1;\r\n\t\t\t\t\t\t\tvar vx = vertices[v], vy = vertices[v + 1];\r\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n\t\t\t\t\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (next == 0) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tif (!isConcave[i])\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t} while (i > 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprevious = i;\r\n\t\t\t\t\ti = next;\r\n\t\t\t\t\tnext = (next + 1) % vertexCount;\r\n\t\t\t\t}\r\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n\t\t\t\ttriangles.push(indices[i]);\r\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\r\n\t\t\t\tindices.splice(i, 1);\r\n\t\t\t\tisConcave.splice(i, 1);\r\n\t\t\t\tvertexCount--;\r\n\t\t\t\tvar previousIndex = (vertexCount + i - 1) % vertexCount;\r\n\t\t\t\tvar nextIndex = i == vertexCount ? 0 : i;\r\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n\t\t\t}\r\n\t\t\tif (vertexCount == 3) {\r\n\t\t\t\ttriangles.push(indices[2]);\r\n\t\t\t\ttriangles.push(indices[0]);\r\n\t\t\t\ttriangles.push(indices[1]);\r\n\t\t\t}\r\n\t\t\treturn triangles;\r\n\t\t};\r\n\t\tTriangulator.prototype.decompose = function (verticesArray, triangles) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar convexPolygons = this.convexPolygons;\r\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\r\n\t\t\tconvexPolygons.length = 0;\r\n\t\t\tvar convexPolygonsIndices = this.convexPolygonsIndices;\r\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n\t\t\tconvexPolygonsIndices.length = 0;\r\n\t\t\tvar polygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\tpolygonIndices.length = 0;\r\n\t\t\tvar polygon = this.polygonPool.obtain();\r\n\t\t\tpolygon.length = 0;\r\n\t\t\tvar fanBaseIndex = -1, lastWinding = 0;\r\n\t\t\tfor (var i = 0, n = triangles.length; i < n; i += 3) {\r\n\t\t\t\tvar t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n\t\t\t\tvar x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n\t\t\t\tvar x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n\t\t\t\tvar x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n\t\t\t\tvar merged = false;\r\n\t\t\t\tif (fanBaseIndex == t1) {\r\n\t\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\t\tmerged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!merged) {\r\n\t\t\t\t\tif (polygon.length > 0) {\r\n\t\t\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\r\n\t\t\t\t\tpolygon.length = 0;\r\n\t\t\t\t\tpolygon.push(x1);\r\n\t\t\t\t\tpolygon.push(y1);\r\n\t\t\t\t\tpolygon.push(x2);\r\n\t\t\t\t\tpolygon.push(y2);\r\n\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\t\t\tpolygonIndices.length = 0;\r\n\t\t\t\t\tpolygonIndices.push(t1);\r\n\t\t\t\t\tpolygonIndices.push(t2);\r\n\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n\t\t\t\t\tfanBaseIndex = t1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (polygon.length > 0) {\r\n\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\tif (polygonIndices.length == 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar firstIndex = polygonIndices[0];\r\n\t\t\t\tvar lastIndex = polygonIndices[polygonIndices.length - 1];\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\tvar prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n\t\t\t\tvar prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n\t\t\t\tvar firstX = polygon[0], firstY = polygon[1];\r\n\t\t\t\tvar secondX = polygon[2], secondY = polygon[3];\r\n\t\t\t\tvar winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n\t\t\t\tfor (var ii = 0; ii < n; ii++) {\r\n\t\t\t\t\tif (ii == i)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherIndices = convexPolygonsIndices[ii];\r\n\t\t\t\t\tif (otherIndices.length != 3)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherFirstIndex = otherIndices[0];\r\n\t\t\t\t\tvar otherSecondIndex = otherIndices[1];\r\n\t\t\t\t\tvar otherLastIndex = otherIndices[2];\r\n\t\t\t\t\tvar otherPoly = convexPolygons[ii];\r\n\t\t\t\t\tvar x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\r\n\t\t\t\t\t\totherPoly.length = 0;\r\n\t\t\t\t\t\totherIndices.length = 0;\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\r\n\t\t\t\t\t\tprevPrevX = prevX;\r\n\t\t\t\t\t\tprevPrevY = prevY;\r\n\t\t\t\t\t\tprevX = x3;\r\n\t\t\t\t\t\tprevY = y3;\r\n\t\t\t\t\t\tii = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tif (polygon.length == 0) {\r\n\t\t\t\t\tconvexPolygons.splice(i, 1);\r\n\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1);\r\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn convexPolygons;\r\n\t\t};\r\n\t\tTriangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n\t\t\tvar previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n\t\t\tvar current = indices[index] << 1;\r\n\t\t\tvar next = indices[(index + 1) % vertexCount] << 1;\r\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n\t\t};\r\n\t\tTriangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n\t\t};\r\n\t\tTriangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\tvar px = p2x - p1x, py = p2y - p1y;\r\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n\t\t};\r\n\t\treturn Triangulator;\r\n\t}());\r\n\tspine.Triangulator = Triangulator;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IntSet = (function () {\r\n\t\tfunction IntSet() {\r\n\t\t\tthis.array = new Array();\r\n\t\t}\r\n\t\tIntSet.prototype.add = function (value) {\r\n\t\t\tvar contains = this.contains(value);\r\n\t\t\tthis.array[value | 0] = value | 0;\r\n\t\t\treturn !contains;\r\n\t\t};\r\n\t\tIntSet.prototype.contains = function (value) {\r\n\t\t\treturn this.array[value | 0] != undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.remove = function (value) {\r\n\t\t\tthis.array[value | 0] = undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.clear = function () {\r\n\t\t\tthis.array.length = 0;\r\n\t\t};\r\n\t\treturn IntSet;\r\n\t}());\r\n\tspine.IntSet = IntSet;\r\n\tvar Color = (function () {\r\n\t\tfunction Color(r, g, b, a) {\r\n\t\t\tif (r === void 0) { r = 0; }\r\n\t\t\tif (g === void 0) { g = 0; }\r\n\t\t\tif (b === void 0) { b = 0; }\r\n\t\t\tif (a === void 0) { a = 0; }\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t}\r\n\t\tColor.prototype.set = function (r, g, b, a) {\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromColor = function (c) {\r\n\t\t\tthis.r = c.r;\r\n\t\t\tthis.g = c.g;\r\n\t\t\tthis.b = c.b;\r\n\t\t\tthis.a = c.a;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromString = function (hex) {\r\n\t\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n\t\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n\t\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n\t\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n\t\t\tthis.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.add = function (r, g, b, a) {\r\n\t\t\tthis.r += r;\r\n\t\t\tthis.g += g;\r\n\t\t\tthis.b += b;\r\n\t\t\tthis.a += a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.clamp = function () {\r\n\t\t\tif (this.r < 0)\r\n\t\t\t\tthis.r = 0;\r\n\t\t\telse if (this.r > 1)\r\n\t\t\t\tthis.r = 1;\r\n\t\t\tif (this.g < 0)\r\n\t\t\t\tthis.g = 0;\r\n\t\t\telse if (this.g > 1)\r\n\t\t\t\tthis.g = 1;\r\n\t\t\tif (this.b < 0)\r\n\t\t\t\tthis.b = 0;\r\n\t\t\telse if (this.b > 1)\r\n\t\t\t\tthis.b = 1;\r\n\t\t\tif (this.a < 0)\r\n\t\t\t\tthis.a = 0;\r\n\t\t\telse if (this.a > 1)\r\n\t\t\t\tthis.a = 1;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.WHITE = new Color(1, 1, 1, 1);\r\n\t\tColor.RED = new Color(1, 0, 0, 1);\r\n\t\tColor.GREEN = new Color(0, 1, 0, 1);\r\n\t\tColor.BLUE = new Color(0, 0, 1, 1);\r\n\t\tColor.MAGENTA = new Color(1, 0, 1, 1);\r\n\t\treturn Color;\r\n\t}());\r\n\tspine.Color = Color;\r\n\tvar MathUtils = (function () {\r\n\t\tfunction MathUtils() {\r\n\t\t}\r\n\t\tMathUtils.clamp = function (value, min, max) {\r\n\t\t\tif (value < min)\r\n\t\t\t\treturn min;\r\n\t\t\tif (value > max)\r\n\t\t\t\treturn max;\r\n\t\t\treturn value;\r\n\t\t};\r\n\t\tMathUtils.cosDeg = function (degrees) {\r\n\t\t\treturn Math.cos(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.sinDeg = function (degrees) {\r\n\t\t\treturn Math.sin(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.signum = function (value) {\r\n\t\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\r\n\t\t};\r\n\t\tMathUtils.toInt = function (x) {\r\n\t\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\r\n\t\t};\r\n\t\tMathUtils.cbrt = function (x) {\r\n\t\t\tvar y = Math.pow(Math.abs(x), 1 / 3);\r\n\t\t\treturn x < 0 ? -y : y;\r\n\t\t};\r\n\t\tMathUtils.randomTriangular = function (min, max) {\r\n\t\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n\t\t};\r\n\t\tMathUtils.randomTriangularWith = function (min, max, mode) {\r\n\t\t\tvar u = Math.random();\r\n\t\t\tvar d = max - min;\r\n\t\t\tif (u <= (mode - min) / d)\r\n\t\t\t\treturn min + Math.sqrt(u * d * (mode - min));\r\n\t\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\r\n\t\t};\r\n\t\tMathUtils.PI = 3.1415927;\r\n\t\tMathUtils.PI2 = MathUtils.PI * 2;\r\n\t\tMathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n\t\tMathUtils.radDeg = MathUtils.radiansToDegrees;\r\n\t\tMathUtils.degreesToRadians = MathUtils.PI / 180;\r\n\t\tMathUtils.degRad = MathUtils.degreesToRadians;\r\n\t\treturn MathUtils;\r\n\t}());\r\n\tspine.MathUtils = MathUtils;\r\n\tvar Interpolation = (function () {\r\n\t\tfunction Interpolation() {\r\n\t\t}\r\n\t\tInterpolation.prototype.apply = function (start, end, a) {\r\n\t\t\treturn start + (end - start) * this.applyInternal(a);\r\n\t\t};\r\n\t\treturn Interpolation;\r\n\t}());\r\n\tspine.Interpolation = Interpolation;\r\n\tvar Pow = (function (_super) {\r\n\t\t__extends(Pow, _super);\r\n\t\tfunction Pow(power) {\r\n\t\t\tvar _this = _super.call(this) || this;\r\n\t\t\t_this.power = 2;\r\n\t\t\t_this.power = power;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPow.prototype.applyInternal = function (a) {\r\n\t\t\tif (a <= 0.5)\r\n\t\t\t\treturn Math.pow(a * 2, this.power) / 2;\r\n\t\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n\t\t};\r\n\t\treturn Pow;\r\n\t}(Interpolation));\r\n\tspine.Pow = Pow;\r\n\tvar PowOut = (function (_super) {\r\n\t\t__extends(PowOut, _super);\r\n\t\tfunction PowOut(power) {\r\n\t\t\treturn _super.call(this, power) || this;\r\n\t\t}\r\n\t\tPowOut.prototype.applyInternal = function (a) {\r\n\t\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n\t\t};\r\n\t\treturn PowOut;\r\n\t}(Pow));\r\n\tspine.PowOut = PowOut;\r\n\tvar Utils = (function () {\r\n\t\tfunction Utils() {\r\n\t\t}\r\n\t\tUtils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n\t\t\tfor (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n\t\t\t\tdest[j] = source[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.setArraySize = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tvar oldSize = array.length;\r\n\t\t\tif (oldSize == size)\r\n\t\t\t\treturn array;\r\n\t\t\tarray.length = size;\r\n\t\t\tif (oldSize < size) {\r\n\t\t\t\tfor (var i = oldSize; i < size; i++)\r\n\t\t\t\t\tarray[i] = value;\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.ensureArrayCapacity = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tif (array.length >= size)\r\n\t\t\t\treturn array;\r\n\t\t\treturn Utils.setArraySize(array, size, value);\r\n\t\t};\r\n\t\tUtils.newArray = function (size, defaultValue) {\r\n\t\t\tvar array = new Array(size);\r\n\t\t\tfor (var i = 0; i < size; i++)\r\n\t\t\t\tarray[i] = defaultValue;\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.newFloatArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Float32Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.newShortArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Int16Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.toFloatArray = function (array) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n\t\t};\r\n\t\tUtils.toSinglePrecision = function (value) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n\t\t};\r\n\t\tUtils.webkit602BugfixHelper = function (alpha, blend) {\r\n\t\t};\r\n\t\tUtils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n\t\treturn Utils;\r\n\t}());\r\n\tspine.Utils = Utils;\r\n\tvar DebugUtils = (function () {\r\n\t\tfunction DebugUtils() {\r\n\t\t}\r\n\t\tDebugUtils.logBones = function (skeleton) {\r\n\t\t\tfor (var i = 0; i < skeleton.bones.length; i++) {\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DebugUtils;\r\n\t}());\r\n\tspine.DebugUtils = DebugUtils;\r\n\tvar Pool = (function () {\r\n\t\tfunction Pool(instantiator) {\r\n\t\t\tthis.items = new Array();\r\n\t\t\tthis.instantiator = instantiator;\r\n\t\t}\r\n\t\tPool.prototype.obtain = function () {\r\n\t\t\treturn this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n\t\t};\r\n\t\tPool.prototype.free = function (item) {\r\n\t\t\tif (item.reset)\r\n\t\t\t\titem.reset();\r\n\t\t\tthis.items.push(item);\r\n\t\t};\r\n\t\tPool.prototype.freeAll = function (items) {\r\n\t\t\tfor (var i = 0; i < items.length; i++) {\r\n\t\t\t\tif (items[i].reset)\r\n\t\t\t\t\titems[i].reset();\r\n\t\t\t\tthis.items[i] = items[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tPool.prototype.clear = function () {\r\n\t\t\tthis.items.length = 0;\r\n\t\t};\r\n\t\treturn Pool;\r\n\t}());\r\n\tspine.Pool = Pool;\r\n\tvar Vector2 = (function () {\r\n\t\tfunction Vector2(x, y) {\r\n\t\t\tif (x === void 0) { x = 0; }\r\n\t\t\tif (y === void 0) { y = 0; }\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t\tVector2.prototype.set = function (x, y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tVector2.prototype.length = function () {\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\treturn Math.sqrt(x * x + y * y);\r\n\t\t};\r\n\t\tVector2.prototype.normalize = function () {\r\n\t\t\tvar len = this.length();\r\n\t\t\tif (len != 0) {\r\n\t\t\t\tthis.x /= len;\r\n\t\t\t\tthis.y /= len;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\treturn Vector2;\r\n\t}());\r\n\tspine.Vector2 = Vector2;\r\n\tvar TimeKeeper = (function () {\r\n\t\tfunction TimeKeeper() {\r\n\t\t\tthis.maxDelta = 0.064;\r\n\t\t\tthis.framesPerSecond = 0;\r\n\t\t\tthis.delta = 0;\r\n\t\t\tthis.totalTime = 0;\r\n\t\t\tthis.lastTime = Date.now() / 1000;\r\n\t\t\tthis.frameCount = 0;\r\n\t\t\tthis.frameTime = 0;\r\n\t\t}\r\n\t\tTimeKeeper.prototype.update = function () {\r\n\t\t\tvar now = Date.now() / 1000;\r\n\t\t\tthis.delta = now - this.lastTime;\r\n\t\t\tthis.frameTime += this.delta;\r\n\t\t\tthis.totalTime += this.delta;\r\n\t\t\tif (this.delta > this.maxDelta)\r\n\t\t\t\tthis.delta = this.maxDelta;\r\n\t\t\tthis.lastTime = now;\r\n\t\t\tthis.frameCount++;\r\n\t\t\tif (this.frameTime > 1) {\r\n\t\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\r\n\t\t\t\tthis.frameTime = 0;\r\n\t\t\t\tthis.frameCount = 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TimeKeeper;\r\n\t}());\r\n\tspine.TimeKeeper = TimeKeeper;\r\n\tvar WindowedMean = (function () {\r\n\t\tfunction WindowedMean(windowSize) {\r\n\t\t\tif (windowSize === void 0) { windowSize = 32; }\r\n\t\t\tthis.addedValues = 0;\r\n\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.mean = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t\tthis.values = new Array(windowSize);\r\n\t\t}\r\n\t\tWindowedMean.prototype.hasEnoughData = function () {\r\n\t\t\treturn this.addedValues >= this.values.length;\r\n\t\t};\r\n\t\tWindowedMean.prototype.addValue = function (value) {\r\n\t\t\tif (this.addedValues < this.values.length)\r\n\t\t\t\tthis.addedValues++;\r\n\t\t\tthis.values[this.lastValue++] = value;\r\n\t\t\tif (this.lastValue > this.values.length - 1)\r\n\t\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t};\r\n\t\tWindowedMean.prototype.getMean = function () {\r\n\t\t\tif (this.hasEnoughData()) {\r\n\t\t\t\tif (this.dirty) {\r\n\t\t\t\t\tvar mean = 0;\r\n\t\t\t\t\tfor (var i = 0; i < this.values.length; i++) {\r\n\t\t\t\t\t\tmean += this.values[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.mean = mean / this.values.length;\r\n\t\t\t\t\tthis.dirty = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn this.mean;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn WindowedMean;\r\n\t}());\r\n\tspine.WindowedMean = WindowedMean;\r\n})(spine || (spine = {}));\r\n(function () {\r\n\tif (!Math.fround) {\r\n\t\tMath.fround = (function (array) {\r\n\t\t\treturn function (x) {\r\n\t\t\t\treturn array[0] = x, array[0];\r\n\t\t\t};\r\n\t\t})(new Float32Array(1));\r\n\t}\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Attachment = (function () {\r\n\t\tfunction Attachment(name) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn Attachment;\r\n\t}());\r\n\tspine.Attachment = Attachment;\r\n\tvar VertexAttachment = (function (_super) {\r\n\t\t__extends(VertexAttachment, _super);\r\n\t\tfunction VertexAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n\t\t\t_this.worldVerticesLength = 0;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tVertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n\t\t\tcount = offset + (count >> 1) * stride;\r\n\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\tvar deformArray = slot.attachmentVertices;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tif (bones == null) {\r\n\t\t\t\tif (deformArray.length > 0)\r\n\t\t\t\t\tvertices = deformArray;\r\n\t\t\t\tvar bone = slot.bone;\r\n\t\t\t\tvar x = bone.worldX;\r\n\t\t\t\tvar y = bone.worldY;\r\n\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\tfor (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n\t\t\t\t\tvar vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n\t\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\r\n\t\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar v = 0, skip = 0;\r\n\t\t\tfor (var i = 0; i < start; i += 2) {\r\n\t\t\t\tvar n = bones[v];\r\n\t\t\t\tv += n + 1;\r\n\t\t\t\tskip += n;\r\n\t\t\t}\r\n\t\t\tvar skeletonBones = skeleton.bones;\r\n\t\t\tif (deformArray.length == 0) {\r\n\t\t\t\tfor (var w = offset, b = skip * 3; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar deform = deformArray;\r\n\t\t\t\tfor (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tVertexAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment;\r\n\t\t};\r\n\t\tVertexAttachment.nextID = 0;\r\n\t\treturn VertexAttachment;\r\n\t}(Attachment));\r\n\tspine.VertexAttachment = VertexAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AttachmentType;\r\n\t(function (AttachmentType) {\r\n\t\tAttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n\t\tAttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n\t\tAttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n\t\tAttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n\t\tAttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n\t\tAttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n\t})(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoundingBoxAttachment = (function (_super) {\r\n\t\t__extends(BoundingBoxAttachment, _super);\r\n\t\tfunction BoundingBoxAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn BoundingBoxAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.BoundingBoxAttachment = BoundingBoxAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar ClippingAttachment = (function (_super) {\r\n\t\t__extends(ClippingAttachment, _super);\r\n\t\tfunction ClippingAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn ClippingAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.ClippingAttachment = ClippingAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar MeshAttachment = (function (_super) {\r\n\t\t__extends(MeshAttachment, _super);\r\n\t\tfunction MeshAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.inheritDeform = false;\r\n\t\t\t_this.tempColor = new spine.Color(0, 0, 0, 0);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tMeshAttachment.prototype.updateUVs = function () {\r\n\t\t\tvar regionUVs = this.regionUVs;\r\n\t\t\tif (this.uvs == null || this.uvs.length != regionUVs.length)\r\n\t\t\t\tthis.uvs = spine.Utils.newFloatArray(regionUVs.length);\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tvar u = 0, v = 0, width = 0, height = 0;\r\n\t\t\tif (this.region instanceof spine.TextureAtlasRegion) {\r\n\t\t\t\tvar region = this.region;\r\n\t\t\t\tvar textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;\r\n\t\t\t\tif (region.rotate) {\r\n\t\t\t\t\tu = region.u - (region.originalHeight - region.offsetY - region.height) / textureWidth;\r\n\t\t\t\t\tv = region.v - (region.originalWidth - region.offsetX - region.width) / textureHeight;\r\n\t\t\t\t\twidth = region.originalHeight / textureWidth;\r\n\t\t\t\t\theight = region.originalWidth / textureHeight;\r\n\t\t\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\r\n\t\t\t\t\t\tuvs[i + 1] = v + height - regionUVs[i] * height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tu = region.u - region.offsetX / textureWidth;\r\n\t\t\t\tv = region.v - (region.originalHeight - region.offsetY - region.height) / textureHeight;\r\n\t\t\t\twidth = region.originalWidth / textureWidth;\r\n\t\t\t\theight = region.originalHeight / textureHeight;\r\n\t\t\t}\r\n\t\t\telse if (this.region == null) {\r\n\t\t\t\tu = v = 0;\r\n\t\t\t\twidth = height = 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tu = this.region.u;\r\n\t\t\t\tv = this.region.v;\r\n\t\t\t\twidth = this.region.u2 - u;\r\n\t\t\t\theight = this.region.v2 - v;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\tuvs[i] = u + regionUVs[i] * width;\r\n\t\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\r\n\t\t\t}\r\n\t\t};\r\n\t\tMeshAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\r\n\t\t};\r\n\t\tMeshAttachment.prototype.getParentMesh = function () {\r\n\t\t\treturn this.parentMesh;\r\n\t\t};\r\n\t\tMeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n\t\t\tthis.parentMesh = parentMesh;\r\n\t\t\tif (parentMesh != null) {\r\n\t\t\t\tthis.bones = parentMesh.bones;\r\n\t\t\t\tthis.vertices = parentMesh.vertices;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t\tthis.regionUVs = parentMesh.regionUVs;\r\n\t\t\t\tthis.triangles = parentMesh.triangles;\r\n\t\t\t\tthis.hullLength = parentMesh.hullLength;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn MeshAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.MeshAttachment = MeshAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathAttachment = (function (_super) {\r\n\t\t__extends(PathAttachment, _super);\r\n\t\tfunction PathAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.closed = false;\r\n\t\t\t_this.constantSpeed = false;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn PathAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PathAttachment = PathAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PointAttachment = (function (_super) {\r\n\t\t__extends(PointAttachment, _super);\r\n\t\tfunction PointAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.38, 0.94, 0, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n\t\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\r\n\t\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\r\n\t\t\treturn point;\r\n\t\t};\r\n\t\tPointAttachment.prototype.computeWorldRotation = function (bone) {\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\r\n\t\t\tvar x = cos * bone.a + sin * bone.b;\r\n\t\t\tvar y = cos * bone.c + sin * bone.d;\r\n\t\t\treturn Math.atan2(y, x) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\treturn PointAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PointAttachment = PointAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar RegionAttachment = (function (_super) {\r\n\t\t__extends(RegionAttachment, _super);\r\n\t\tfunction RegionAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.x = 0;\r\n\t\t\t_this.y = 0;\r\n\t\t\t_this.scaleX = 1;\r\n\t\t\t_this.scaleY = 1;\r\n\t\t\t_this.rotation = 0;\r\n\t\t\t_this.width = 0;\r\n\t\t\t_this.height = 0;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.offset = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.uvs = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.tempColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRegionAttachment.prototype.updateOffset = function () {\r\n\t\t\tvar regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n\t\t\tvar regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n\t\t\tvar localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n\t\t\tvar localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n\t\t\tvar localX2 = localX + this.region.width * regionScaleX;\r\n\t\t\tvar localY2 = localY + this.region.height * regionScaleY;\r\n\t\t\tvar radians = this.rotation * Math.PI / 180;\r\n\t\t\tvar cos = Math.cos(radians);\r\n\t\t\tvar sin = Math.sin(radians);\r\n\t\t\tvar localXCos = localX * cos + this.x;\r\n\t\t\tvar localXSin = localX * sin;\r\n\t\t\tvar localYCos = localY * cos + this.y;\r\n\t\t\tvar localYSin = localY * sin;\r\n\t\t\tvar localX2Cos = localX2 * cos + this.x;\r\n\t\t\tvar localX2Sin = localX2 * sin;\r\n\t\t\tvar localY2Cos = localY2 * cos + this.y;\r\n\t\t\tvar localY2Sin = localY2 * sin;\r\n\t\t\tvar offset = this.offset;\r\n\t\t\toffset[RegionAttachment.OX1] = localXCos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY1] = localYCos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n\t\t\toffset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n\t\t};\r\n\t\tRegionAttachment.prototype.setRegion = function (region) {\r\n\t\t\tthis.region = region;\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tif (region.rotate) {\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v2;\r\n\t\t\t\tuvs[4] = region.u;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v;\r\n\t\t\t\tuvs[0] = region.u2;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuvs[0] = region.u;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v;\r\n\t\t\t\tuvs[4] = region.u2;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v2;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n\t\t\tvar vertexOffset = this.offset;\r\n\t\t\tvar x = bone.worldX, y = bone.worldY;\r\n\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\tvar offsetX = 0, offsetY = 0;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX1];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY1];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX2];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY2];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX3];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY3];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX4];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY4];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t};\r\n\t\tRegionAttachment.OX1 = 0;\r\n\t\tRegionAttachment.OY1 = 1;\r\n\t\tRegionAttachment.OX2 = 2;\r\n\t\tRegionAttachment.OY2 = 3;\r\n\t\tRegionAttachment.OX3 = 4;\r\n\t\tRegionAttachment.OY3 = 5;\r\n\t\tRegionAttachment.OX4 = 6;\r\n\t\tRegionAttachment.OY4 = 7;\r\n\t\tRegionAttachment.X1 = 0;\r\n\t\tRegionAttachment.Y1 = 1;\r\n\t\tRegionAttachment.C1R = 2;\r\n\t\tRegionAttachment.C1G = 3;\r\n\t\tRegionAttachment.C1B = 4;\r\n\t\tRegionAttachment.C1A = 5;\r\n\t\tRegionAttachment.U1 = 6;\r\n\t\tRegionAttachment.V1 = 7;\r\n\t\tRegionAttachment.X2 = 8;\r\n\t\tRegionAttachment.Y2 = 9;\r\n\t\tRegionAttachment.C2R = 10;\r\n\t\tRegionAttachment.C2G = 11;\r\n\t\tRegionAttachment.C2B = 12;\r\n\t\tRegionAttachment.C2A = 13;\r\n\t\tRegionAttachment.U2 = 14;\r\n\t\tRegionAttachment.V2 = 15;\r\n\t\tRegionAttachment.X3 = 16;\r\n\t\tRegionAttachment.Y3 = 17;\r\n\t\tRegionAttachment.C3R = 18;\r\n\t\tRegionAttachment.C3G = 19;\r\n\t\tRegionAttachment.C3B = 20;\r\n\t\tRegionAttachment.C3A = 21;\r\n\t\tRegionAttachment.U3 = 22;\r\n\t\tRegionAttachment.V3 = 23;\r\n\t\tRegionAttachment.X4 = 24;\r\n\t\tRegionAttachment.Y4 = 25;\r\n\t\tRegionAttachment.C4R = 26;\r\n\t\tRegionAttachment.C4G = 27;\r\n\t\tRegionAttachment.C4B = 28;\r\n\t\tRegionAttachment.C4A = 29;\r\n\t\tRegionAttachment.U4 = 30;\r\n\t\tRegionAttachment.V4 = 31;\r\n\t\treturn RegionAttachment;\r\n\t}(spine.Attachment));\r\n\tspine.RegionAttachment = RegionAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar JitterEffect = (function () {\r\n\t\tfunction JitterEffect(jitterX, jitterY) {\r\n\t\t\tthis.jitterX = 0;\r\n\t\t\tthis.jitterY = 0;\r\n\t\t\tthis.jitterX = jitterX;\r\n\t\t\tthis.jitterY = jitterY;\r\n\t\t}\r\n\t\tJitterEffect.prototype.begin = function (skeleton) {\r\n\t\t};\r\n\t\tJitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tposition.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t\tposition.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t};\r\n\t\tJitterEffect.prototype.end = function () {\r\n\t\t};\r\n\t\treturn JitterEffect;\r\n\t}());\r\n\tspine.JitterEffect = JitterEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SwirlEffect = (function () {\r\n\t\tfunction SwirlEffect(radius) {\r\n\t\t\tthis.centerX = 0;\r\n\t\t\tthis.centerY = 0;\r\n\t\t\tthis.radius = 0;\r\n\t\t\tthis.angle = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.radius = radius;\r\n\t\t}\r\n\t\tSwirlEffect.prototype.begin = function (skeleton) {\r\n\t\t\tthis.worldX = skeleton.x + this.centerX;\r\n\t\t\tthis.worldY = skeleton.y + this.centerY;\r\n\t\t};\r\n\t\tSwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tvar radAngle = this.angle * spine.MathUtils.degreesToRadians;\r\n\t\t\tvar x = position.x - this.worldX;\r\n\t\t\tvar y = position.y - this.worldY;\r\n\t\t\tvar dist = Math.sqrt(x * x + y * y);\r\n\t\t\tif (dist < this.radius) {\r\n\t\t\t\tvar theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n\t\t\t\tvar cos = Math.cos(theta);\r\n\t\t\t\tvar sin = Math.sin(theta);\r\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\r\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSwirlEffect.prototype.end = function () {\r\n\t\t};\r\n\t\tSwirlEffect.interpolation = new spine.PowOut(2);\r\n\t\treturn SwirlEffect;\r\n\t}());\r\n\tspine.SwirlEffect = SwirlEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar AssetManager = (function (_super) {\r\n\t\t\t__extends(AssetManager, _super);\r\n\t\t\tfunction AssetManager(pathPrefix) {\r\n\t\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\t\treturn _super.call(this, function (image) { return new spine.canvas.CanvasTexture(image); }, pathPrefix) || this;\r\n\t\t\t}\r\n\t\t\treturn AssetManager;\r\n\t\t}(spine.AssetManager));\r\n\t\tcanvas.AssetManager = AssetManager;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar CanvasTexture = (function (_super) {\r\n\t\t\t__extends(CanvasTexture, _super);\r\n\t\t\tfunction CanvasTexture(image) {\r\n\t\t\t\treturn _super.call(this, image) || this;\r\n\t\t\t}\r\n\t\t\tCanvasTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n\t\t\tCanvasTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n\t\t\tCanvasTexture.prototype.dispose = function () { };\r\n\t\t\treturn CanvasTexture;\r\n\t\t}(spine.Texture));\r\n\t\tcanvas.CanvasTexture = CanvasTexture;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar SkeletonRenderer = (function () {\r\n\t\t\tfunction SkeletonRenderer(context) {\r\n\t\t\t\tthis.triangleRendering = false;\r\n\t\t\t\tthis.debugRendering = false;\r\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(8 * 1024);\r\n\t\t\t\tthis.tempColor = new spine.Color();\r\n\t\t\t\tthis.ctx = context;\r\n\t\t\t}\r\n\t\t\tSkeletonRenderer.prototype.draw = function (skeleton) {\r\n\t\t\t\tif (this.triangleRendering)\r\n\t\t\t\t\tthis.drawTriangles(skeleton);\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.drawImages(skeleton);\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawImages = function (skeleton) {\r\n\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\t\tif (this.debugRendering)\r\n\t\t\t\t\tctx.strokeStyle = \"green\";\r\n\t\t\t\tctx.save();\r\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\tvar regionAttachment = null;\r\n\t\t\t\t\tvar region = null;\r\n\t\t\t\t\tvar image = null;\r\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\tregionAttachment = attachment;\r\n\t\t\t\t\t\tregion = regionAttachment.region;\r\n\t\t\t\t\t\timage = region.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar skeleton_1 = slot.bone.skeleton;\r\n\t\t\t\t\tvar skeletonColor = skeleton_1.color;\r\n\t\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\t\tvar regionColor = regionAttachment.color;\r\n\t\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r, skeletonColor.g * slotColor.g * regionColor.g, skeletonColor.b * slotColor.b * regionColor.b, alpha);\r\n\t\t\t\t\tvar att = attachment;\r\n\t\t\t\t\tvar bone = slot.bone;\r\n\t\t\t\t\tvar w = region.width;\r\n\t\t\t\t\tvar h = region.height;\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tctx.transform(bone.a, bone.c, bone.b, bone.d, bone.worldX, bone.worldY);\r\n\t\t\t\t\tctx.translate(attachment.offset[0], attachment.offset[1]);\r\n\t\t\t\t\tctx.rotate(attachment.rotation * Math.PI / 180);\r\n\t\t\t\t\tvar atlasScale = att.width / w;\r\n\t\t\t\t\tctx.scale(atlasScale * attachment.scaleX, atlasScale * attachment.scaleY);\r\n\t\t\t\t\tctx.translate(w / 2, h / 2);\r\n\t\t\t\t\tif (attachment.region.rotate) {\r\n\t\t\t\t\t\tvar t = w;\r\n\t\t\t\t\t\tw = h;\r\n\t\t\t\t\t\th = t;\r\n\t\t\t\t\t\tctx.rotate(-Math.PI / 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.scale(1, -1);\r\n\t\t\t\t\tctx.translate(-w / 2, -h / 2);\r\n\t\t\t\t\tif (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n\t\t\t\t\t\tctx.globalAlpha = color.a;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.drawImage(image, region.x, region.y, w, h, 0, 0, w, h);\r\n\t\t\t\t\tif (this.debugRendering)\r\n\t\t\t\t\t\tctx.strokeRect(0, 0, w, h);\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t\tctx.restore();\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawTriangles = function (skeleton) {\r\n\t\t\t\tvar blendMode = null;\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tvar triangles = null;\r\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\tvar texture = null;\r\n\t\t\t\t\tvar region = null;\r\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\tvar regionAttachment = attachment;\r\n\t\t\t\t\t\tvertices = this.computeRegionVertices(slot, regionAttachment, false);\r\n\t\t\t\t\t\ttriangles = SkeletonRenderer.QUAD_TRIANGLES;\r\n\t\t\t\t\t\tregion = regionAttachment.region;\r\n\t\t\t\t\t\ttexture = region.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\t\tvertices = this.computeMeshVertices(slot, mesh, false);\r\n\t\t\t\t\t\ttriangles = mesh.triangles;\r\n\t\t\t\t\t\ttexture = mesh.region.renderObject.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (texture != null) {\r\n\t\t\t\t\t\tvar slotBlendMode = slot.data.blendMode;\r\n\t\t\t\t\t\tif (slotBlendMode != blendMode) {\r\n\t\t\t\t\t\t\tblendMode = slotBlendMode;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar skeleton_2 = slot.bone.skeleton;\r\n\t\t\t\t\t\tvar skeletonColor = skeleton_2.color;\r\n\t\t\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\t\t\tvar attachmentColor = attachment.color;\r\n\t\t\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n\t\t\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);\r\n\t\t\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\t\t\tif (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n\t\t\t\t\t\t\tctx.globalAlpha = color.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (var j = 0; j < triangles.length; j += 3) {\r\n\t\t\t\t\t\t\tvar t1 = triangles[j] * 8, t2 = triangles[j + 1] * 8, t3 = triangles[j + 2] * 8;\r\n\t\t\t\t\t\t\tvar x0 = vertices[t1], y0 = vertices[t1 + 1], u0 = vertices[t1 + 6], v0 = vertices[t1 + 7];\r\n\t\t\t\t\t\t\tvar x1 = vertices[t2], y1 = vertices[t2 + 1], u1 = vertices[t2 + 6], v1 = vertices[t2 + 7];\r\n\t\t\t\t\t\t\tvar x2 = vertices[t3], y2 = vertices[t3 + 1], u2 = vertices[t3 + 6], v2 = vertices[t3 + 7];\r\n\t\t\t\t\t\t\tthis.drawTriangle(texture, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2);\r\n\t\t\t\t\t\t\tif (this.debugRendering) {\r\n\t\t\t\t\t\t\t\tctx.strokeStyle = \"green\";\r\n\t\t\t\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\t\t\t\tctx.moveTo(x0, y0);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x1, y1);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x2, y2);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x0, y0);\r\n\t\t\t\t\t\t\t\tctx.stroke();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.ctx.globalAlpha = 1;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawTriangle = function (img, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2) {\r\n\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\tu0 *= img.width;\r\n\t\t\t\tv0 *= img.height;\r\n\t\t\t\tu1 *= img.width;\r\n\t\t\t\tv1 *= img.height;\r\n\t\t\t\tu2 *= img.width;\r\n\t\t\t\tv2 *= img.height;\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(x0, y0);\r\n\t\t\t\tctx.lineTo(x1, y1);\r\n\t\t\t\tctx.lineTo(x2, y2);\r\n\t\t\t\tctx.closePath();\r\n\t\t\t\tx1 -= x0;\r\n\t\t\t\ty1 -= y0;\r\n\t\t\t\tx2 -= x0;\r\n\t\t\t\ty2 -= y0;\r\n\t\t\t\tu1 -= u0;\r\n\t\t\t\tv1 -= v0;\r\n\t\t\t\tu2 -= u0;\r\n\t\t\t\tv2 -= v0;\r\n\t\t\t\tvar det = 1 / (u1 * v2 - u2 * v1), a = (v2 * x1 - v1 * x2) * det, b = (v2 * y1 - v1 * y2) * det, c = (u1 * x2 - u2 * x1) * det, d = (u1 * y2 - u2 * y1) * det, e = x0 - a * u0 - c * v0, f = y0 - b * u0 - d * v0;\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.transform(a, b, c, d, e, f);\r\n\t\t\t\tctx.clip();\r\n\t\t\t\tctx.drawImage(img, 0, 0);\r\n\t\t\t\tctx.restore();\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.computeRegionVertices = function (slot, region, pma) {\r\n\t\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\t\tvar skeletonColor = skeleton.color;\r\n\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\tvar regionColor = region.color;\r\n\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\tvar multiplier = pma ? alpha : 1;\r\n\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n\t\t\t\tregion.computeWorldVertices(slot.bone, this.vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tvar uvs = region.uvs;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U1] = uvs[0];\r\n\t\t\t\tvertices[spine.RegionAttachment.V1] = uvs[1];\r\n\t\t\t\tvertices[spine.RegionAttachment.C2R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U2] = uvs[2];\r\n\t\t\t\tvertices[spine.RegionAttachment.V2] = uvs[3];\r\n\t\t\t\tvertices[spine.RegionAttachment.C3R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U3] = uvs[4];\r\n\t\t\t\tvertices[spine.RegionAttachment.V3] = uvs[5];\r\n\t\t\t\tvertices[spine.RegionAttachment.C4R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U4] = uvs[6];\r\n\t\t\t\tvertices[spine.RegionAttachment.V4] = uvs[7];\r\n\t\t\t\treturn vertices;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.computeMeshVertices = function (slot, mesh, pma) {\r\n\t\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\t\tvar skeletonColor = skeleton.color;\r\n\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\tvar regionColor = mesh.color;\r\n\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\tvar multiplier = pma ? alpha : 1;\r\n\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n\t\t\t\tvar numVertices = mesh.worldVerticesLength / 2;\r\n\t\t\t\tif (this.vertices.length < mesh.worldVerticesLength) {\r\n\t\t\t\t\tthis.vertices = spine.Utils.newFloatArray(mesh.worldVerticesLength);\r\n\t\t\t\t}\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n\t\t\t\tvar uvs = mesh.uvs;\r\n\t\t\t\tfor (var i = 0, n = numVertices, u = 0, v = 2; i < n; i++) {\r\n\t\t\t\t\tvertices[v++] = color.r;\r\n\t\t\t\t\tvertices[v++] = color.g;\r\n\t\t\t\t\tvertices[v++] = color.b;\r\n\t\t\t\t\tvertices[v++] = color.a;\r\n\t\t\t\t\tvertices[v++] = uvs[u++];\r\n\t\t\t\t\tvertices[v++] = uvs[u++];\r\n\t\t\t\t\tv += 2;\r\n\t\t\t\t}\r\n\t\t\t\treturn vertices;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\t\t\tSkeletonRenderer.VERTEX_SIZE = 2 + 2 + 4;\r\n\t\t\treturn SkeletonRenderer;\r\n\t\t}());\r\n\t\tcanvas.SkeletonRenderer = SkeletonRenderer;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\n//# sourceMappingURL=spine-canvas.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = spine;\n}.call(window));"],"sourceRoot":""}