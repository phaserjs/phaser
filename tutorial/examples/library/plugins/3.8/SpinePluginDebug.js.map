{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///D:/wamp/www/phaser/node_modules/eventemitter3/index.js","webpack:///D:/wamp/www/phaser/src/data/DataManager.js","webpack:///D:/wamp/www/phaser/src/data/events/CHANGE_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/REMOVE_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/SET_DATA_EVENT.js","webpack:///D:/wamp/www/phaser/src/data/events/index.js","webpack:///D:/wamp/www/phaser/src/gameobjects/BuildGameObject.js","webpack:///D:/wamp/www/phaser/src/gameobjects/GameObject.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ComputedSize.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Depth.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Flip.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ScrollFactor.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/ToJSON.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Transform.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/TransformMatrix.js","webpack:///D:/wamp/www/phaser/src/gameobjects/components/Visible.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/DESTROY_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_CREATED_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_ERROR_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_LOOP_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_PLAY_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_SEEKED_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_SEEKING_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_STOP_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_TIMEOUT_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/VIDEO_UNLOCKED_EVENT.js","webpack:///D:/wamp/www/phaser/src/gameobjects/events/index.js","webpack:///D:/wamp/www/phaser/src/loader/File.js","webpack:///D:/wamp/www/phaser/src/loader/FileTypesManager.js","webpack:///D:/wamp/www/phaser/src/loader/GetURL.js","webpack:///D:/wamp/www/phaser/src/loader/MergeXHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/MultiFile.js","webpack:///D:/wamp/www/phaser/src/loader/XHRLoader.js","webpack:///D:/wamp/www/phaser/src/loader/XHRSettings.js","webpack:///D:/wamp/www/phaser/src/loader/const.js","webpack:///D:/wamp/www/phaser/src/loader/events/ADD_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_LOAD_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/FILE_PROGRESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/POST_PROCESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/PROGRESS_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/START_EVENT.js","webpack:///D:/wamp/www/phaser/src/loader/events/index.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/ImageFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/JSONFile.js","webpack:///D:/wamp/www/phaser/src/loader/filetypes/TextFile.js","webpack:///D:/wamp/www/phaser/src/math/Average.js","webpack:///D:/wamp/www/phaser/src/math/Bernstein.js","webpack:///D:/wamp/www/phaser/src/math/Between.js","webpack:///D:/wamp/www/phaser/src/math/CatmullRom.js","webpack:///D:/wamp/www/phaser/src/math/CeilTo.js","webpack:///D:/wamp/www/phaser/src/math/Clamp.js","webpack:///D:/wamp/www/phaser/src/math/DegToRad.js","webpack:///D:/wamp/www/phaser/src/math/Difference.js","webpack:///D:/wamp/www/phaser/src/math/Factorial.js","webpack:///D:/wamp/www/phaser/src/math/FloatBetween.js","webpack:///D:/wamp/www/phaser/src/math/FloorTo.js","webpack:///D:/wamp/www/phaser/src/math/FromPercent.js","webpack:///D:/wamp/www/phaser/src/math/GetSpeed.js","webpack:///D:/wamp/www/phaser/src/math/IsEven.js","webpack:///D:/wamp/www/phaser/src/math/IsEvenStrict.js","webpack:///D:/wamp/www/phaser/src/math/Linear.js","webpack:///D:/wamp/www/phaser/src/math/Matrix3.js","webpack:///D:/wamp/www/phaser/src/math/Matrix4.js","webpack:///D:/wamp/www/phaser/src/math/MaxAdd.js","webpack:///D:/wamp/www/phaser/src/math/MinSub.js","webpack:///D:/wamp/www/phaser/src/math/Percent.js","webpack:///D:/wamp/www/phaser/src/math/Quaternion.js","webpack:///D:/wamp/www/phaser/src/math/RadToDeg.js","webpack:///D:/wamp/www/phaser/src/math/RandomXY.js","webpack:///D:/wamp/www/phaser/src/math/RandomXYZ.js","webpack:///D:/wamp/www/phaser/src/math/RandomXYZW.js","webpack:///D:/wamp/www/phaser/src/math/Rotate.js","webpack:///D:/wamp/www/phaser/src/math/RotateAround.js","webpack:///D:/wamp/www/phaser/src/math/RotateAroundDistance.js","webpack:///D:/wamp/www/phaser/src/math/RotateVec3.js","webpack:///D:/wamp/www/phaser/src/math/RoundAwayFromZero.js","webpack:///D:/wamp/www/phaser/src/math/RoundTo.js","webpack:///D:/wamp/www/phaser/src/math/SinCosTableGenerator.js","webpack:///D:/wamp/www/phaser/src/math/SmoothStep.js","webpack:///D:/wamp/www/phaser/src/math/SmootherStep.js","webpack:///D:/wamp/www/phaser/src/math/ToXY.js","webpack:///D:/wamp/www/phaser/src/math/TransformXY.js","webpack:///D:/wamp/www/phaser/src/math/Vector2.js","webpack:///D:/wamp/www/phaser/src/math/Vector3.js","webpack:///D:/wamp/www/phaser/src/math/Vector4.js","webpack:///D:/wamp/www/phaser/src/math/Within.js","webpack:///D:/wamp/www/phaser/src/math/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/Between.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenPoints.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenPointsY.js","webpack:///D:/wamp/www/phaser/src/math/angle/BetweenY.js","webpack:///D:/wamp/www/phaser/src/math/angle/CounterClockwise.js","webpack:///D:/wamp/www/phaser/src/math/angle/Normalize.js","webpack:///D:/wamp/www/phaser/src/math/angle/Reverse.js","webpack:///D:/wamp/www/phaser/src/math/angle/RotateTo.js","webpack:///D:/wamp/www/phaser/src/math/angle/ShortestBetween.js","webpack:///D:/wamp/www/phaser/src/math/angle/Wrap.js","webpack:///D:/wamp/www/phaser/src/math/angle/WrapDegrees.js","webpack:///D:/wamp/www/phaser/src/math/angle/index.js","webpack:///D:/wamp/www/phaser/src/math/const.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistanceBetween.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistancePower.js","webpack:///D:/wamp/www/phaser/src/math/distance/DistanceSquared.js","webpack:///D:/wamp/www/phaser/src/math/distance/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/back/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/bounce/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/circular/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/cubic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/elastic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/expo/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/linear/Linear.js","webpack:///D:/wamp/www/phaser/src/math/easing/linear/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quadratic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quartic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/quintic/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/In.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/InOut.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/Out.js","webpack:///D:/wamp/www/phaser/src/math/easing/sine/index.js","webpack:///D:/wamp/www/phaser/src/math/easing/stepped/Stepped.js","webpack:///D:/wamp/www/phaser/src/math/easing/stepped/index.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Ceil.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Equal.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/Floor.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/GreaterThan.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/LessThan.js","webpack:///D:/wamp/www/phaser/src/math/fuzzy/index.js","webpack:///D:/wamp/www/phaser/src/math/index.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/BezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/CatmullRomInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/CubicBezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/LinearInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/QuadraticBezierInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/SmoothStepInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/SmootherStepInterpolation.js","webpack:///D:/wamp/www/phaser/src/math/interpolation/index.js","webpack:///D:/wamp/www/phaser/src/math/pow2/GetPowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/IsSizePowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/IsValuePowerOfTwo.js","webpack:///D:/wamp/www/phaser/src/math/pow2/index.js","webpack:///D:/wamp/www/phaser/src/math/random-data-generator/RandomDataGenerator.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapCeil.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapFloor.js","webpack:///D:/wamp/www/phaser/src/math/snap/SnapTo.js","webpack:///D:/wamp/www/phaser/src/math/snap/index.js","webpack:///D:/wamp/www/phaser/src/plugins/BasePlugin.js","webpack:///D:/wamp/www/phaser/src/plugins/ScenePlugin.js","webpack:///D:/wamp/www/phaser/src/renderer/BlendModes.js","webpack:///D:/wamp/www/phaser/src/scale/events/RESIZE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/BOOT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/CREATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/DESTROY_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/PAUSE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/POST_UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/PRE_UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/READY_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/RENDER_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/RESUME_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/SHUTDOWN_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/SLEEP_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/START_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_INIT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_OUT_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_START_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/UPDATE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/WAKE_EVENT.js","webpack:///D:/wamp/www/phaser/src/scene/events/index.js","webpack:///D:/wamp/www/phaser/src/utils/Class.js","webpack:///D:/wamp/www/phaser/src/utils/NOOP.js","webpack:///D:/wamp/www/phaser/src/utils/object/Extend.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetAdvancedValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetFastValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/GetValue.js","webpack:///D:/wamp/www/phaser/src/utils/object/IsPlainObject.js","webpack:///./SpineFile.js","webpack:///./SpinePlugin.js","webpack:///./events/COMPLETE_EVENT.js","webpack:///./events/DISPOSE_EVENT.js","webpack:///./events/END_EVENT.js","webpack:///./events/EVENT_EVENT.js","webpack:///./events/INTERRUPTED_EVENT.js","webpack:///./events/START_EVENT.js","webpack:///./events/index.js","webpack:///./gameobject/SpineGameObject.js","webpack:///./gameobject/SpineGameObjectCanvasRenderer.js","webpack:///./gameobject/SpineGameObjectRender.js","webpack:///./gameobject/SpineGameObjectWebGLRenderer.js","webpack:///./runtimes/spine-both.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,OAAO;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE,uEAAuE;AACvE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,aAAa,mBAAO,CAAC,mDAAU;;AAE/B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAA2D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,qBAAqB,mBAAO,CAAC,kFAAyB;AACtD,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,cAAc,mBAAO,CAAC,oEAAkB;;AAExC;;;;;;;;;;;;ACjBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,mEAAwB;AACjD,uBAAuB,mBAAO,CAAC,uFAAkC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,8BAA8B;AACzC,WAAW,0CAA0C;AACrD;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,WAAW,KAAK,SAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB,KAAK,gBAAgB;;AAExD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,cAAc,KAAK,UAAU;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzHA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,uBAAuB,mBAAO,CAAC,0EAAqB;AACpD,kBAAkB,mBAAO,CAAC,6DAAqB;AAC/C,mBAAmB,mBAAO,CAAC,mEAAe;AAC1C,aAAa,mBAAO,CAAC,0DAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAA2D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D,eAAe,mCAAmC;AAClD,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9IA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACtFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC7JA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,sBAAsB,mBAAO,CAAC,iFAAmB;AACjD,gBAAgB,mBAAO,CAAC,8DAAuB;AAC/C,uBAAuB,mBAAO,CAAC,4EAA8B;;AAE7D;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oCAAoC;AACtE,mCAAmC,sCAAsC;;AAEzE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;;AAE3E;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E,yCAAyC,sCAAsC;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/gBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,cAAc,mBAAO,CAAC,wDAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;;AAEvC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,+CAA+C;AAC9D;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA,kCAAkC,UAAU,cAAc;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,mCAAmC,wBAAwB;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACj8BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,MAAM;AACjB;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,yEAAiB;AACtC,oBAAoB,mBAAO,CAAC,uFAAwB;AACpD,mBAAmB,mBAAO,CAAC,qFAAuB;AAClD,iBAAiB,mBAAO,CAAC,iFAAqB;AAC9C,gBAAgB,mBAAO,CAAC,+EAAoB;AAC5C,gBAAgB,mBAAO,CAAC,+EAAoB;AAC5C,kBAAkB,mBAAO,CAAC,mFAAsB;AAChD,mBAAmB,mBAAO,CAAC,qFAAuB;AAClD,gBAAgB,mBAAO,CAAC,+EAAoB;AAC5C,mBAAmB,mBAAO,CAAC,qFAAuB;AAClD,oBAAoB,mBAAO,CAAC,uFAAwB;;AAEpD;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,YAAY,mBAAO,CAAC,6CAAS;AAC7B,aAAa,mBAAO,CAAC,qDAAU;AAC/B,mBAAmB,mBAAO,CAAC,+EAA8B;AACzD,aAAa,mBAAO,CAAC,+CAAU;AAC/B,uBAAuB,mBAAO,CAAC,mEAAoB;AACnD,gBAAgB,mBAAO,CAAC,qDAAa;AACrC,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,+BAA+B;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,4GAA4G;AAC5G;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACthBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,mEAAwB;AAC7C,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,sCAAsC;AACjD;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACnOA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,mEAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,sCAAsC;AACjD;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD,8BAA8B,cAAc;AAC5C,6BAA6B,WAAW;AACxC,iCAAiC,eAAe;AAChD,gCAAgC,aAAa;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjJA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,2BAA2B;AACtC,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,uDAAuD;AACjJ;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oFAAoF,mDAAmD;AACvI;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;AC/CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,4DAAa;AAC9B,cAAc,mBAAO,CAAC,sEAAkB;AACxC,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,uBAAuB,mBAAO,CAAC,wFAA2B;AAC1D,qBAAqB,mBAAO,CAAC,oFAAyB;AACtD,eAAe,mBAAO,CAAC,wEAAmB;AAC1C,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,8EAAsB;AAChD,cAAc,mBAAO,CAAC,sEAAkB;AACxC,WAAW,mBAAO,CAAC,gEAAe;;AAElC;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,uDAAuD;AAClE,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD,WAAW,+CAA+C;AAC1D;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uGAAuG;AAClH,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC3QA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,eAAe,mBAAO,CAAC,0EAA6B;AACpD,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC/NA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACxKA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,mDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1kBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;;;;;;;;;;;;AC/6CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,eAAe;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,cAAc,mBAAO,CAAC,+CAAW;AACjC,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC7vBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,+BAA+B,YAAY;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,qDAAiB;AACvC,cAAc,mBAAO,CAAC,qDAAiB;AACvC,iBAAiB,mBAAO,CAAC,2DAAoB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,+BAA+B,YAAY;AAC3C,kCAAkC,eAAe;;AAEjD;;AAEA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,4BAA4B,qBAAqB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,+CAA+C;AAC1D;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA,+BAA+B,wBAAwB;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;;AAEzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,6BAA6B,YAAY;;AAEzC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACxnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACnyBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1hBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,4CAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,yDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,4CAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AC1CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,eAAe,mBAAO,CAAC,0CAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,0CAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,qDAAW;AAChC,mBAAmB,mBAAO,CAAC,iEAAiB;AAC5C,oBAAoB,mBAAO,CAAC,mEAAkB;AAC9C,cAAc,mBAAO,CAAC,uDAAY;AAClC,sBAAsB,mBAAO,CAAC,uEAAoB;AAClD,eAAe,mBAAO,CAAC,yDAAa;AACpC,aAAa,mBAAO,CAAC,qDAAW;AAChC,cAAc,mBAAO,CAAC,uDAAY;AAClC,qBAAqB,mBAAO,CAAC,qEAAmB;AAChD,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,iBAAiB,mBAAO,CAAC,6DAAe;;AAExC;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,SAAS;;AAErC;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,wEAAmB;AACxC,WAAW,mBAAO,CAAC,oEAAiB;AACpC,aAAa,mBAAO,CAAC,wEAAmB;;AAExC;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,mDAAM;AACtB,SAAS,mBAAO,CAAC,qDAAO;AACxB,WAAW,mBAAO,CAAC,yDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,qDAAM;AACtB,SAAS,mBAAO,CAAC,uDAAO;AACxB,WAAW,mBAAO,CAAC,2DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,kDAAM;AACtB,SAAS,mBAAO,CAAC,oDAAO;AACxB,WAAW,mBAAO,CAAC,wDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,cAAc,mBAAO,CAAC,8DAAY;AAClC,WAAW,mBAAO,CAAC,wDAAS;AAC5B,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,eAAe,mBAAO,CAAC,gEAAa;AACpC,aAAa,mBAAO,CAAC,4DAAW;AAChC,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,aAAa,mBAAO,CAAC,4DAAW;;AAEhC;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2DAAU;;;;;;;;;;;;ACVnC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,sDAAM;AACtB,SAAS,mBAAO,CAAC,wDAAO;AACxB,WAAW,mBAAO,CAAC,4DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,8DAAW;;;;;;;;;;;;ACVpC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,iBAAiB,mBAAO,CAAC,6DAAe;AACxC,cAAc,mBAAO,CAAC,uDAAY;;AAElC;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;AAC7B,aAAa,mBAAO,CAAC,mEAAwB;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,kDAAU;AAC7B,cAAc,mBAAO,CAAC,wDAAa;AACnC,YAAY,mBAAO,CAAC,oDAAW;AAC/B,WAAW,mBAAO,CAAC,kDAAU;AAC7B,mBAAmB,mBAAO,CAAC,kEAAkB;AAC7C,UAAU,mBAAO,CAAC,gDAAS;AAC3B,UAAU,mBAAO,CAAC,gDAAS;;AAE3B;AACA,yBAAyB,mBAAO,CAAC,mHAA6C;;AAE9E;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,eAAe,mBAAO,CAAC,mDAAa;AACpC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,WAAW,mBAAO,CAAC,2CAAS;AAC5B,cAAc,mBAAO,CAAC,iDAAY;AAClC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,eAAe,mBAAO,CAAC,mDAAa;AACpC,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,aAAa,mBAAO,CAAC,+CAAW;AAChC,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,cAAc,mBAAO,CAAC,iDAAY;AAClC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,aAAa,mBAAO,CAAC,+CAAW;AAChC,cAAc,mBAAO,CAAC,iDAAY;AAClC,cAAc,mBAAO,CAAC,iDAAY;AAClC,eAAe,mBAAO,CAAC,mDAAa;AACpC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,uBAAuB,mBAAO,CAAC,mEAAqB;AACpD,aAAa,mBAAO,CAAC,+CAAW;AAChC,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,UAAU,mBAAO,CAAC,yCAAQ;AAC1B,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,UAAU,mBAAO,CAAC,yCAAQ;;AAE1B;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,gBAAgB,mBAAO,CAAC,qDAAc;;AAEtC;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,oDAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,8CAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,0DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,iBAAiB,mBAAO,CAAC,+FAA4B;AACrD,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,qBAAqB,mBAAO,CAAC,uGAAgC;AAC7D,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,kBAAkB,mBAAO,CAAC,iGAA6B;;AAEvD;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,gEAAiB;AACtC,YAAY,mBAAO,CAAC,sEAAoB;AACxC,aAAa,mBAAO,CAAC,wEAAqB;;AAE1C;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC,qDAAqD;;AAEvF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;AAEA,kDAAkD;AAClD,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC5eA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAY;AAC9B,WAAW,mBAAO,CAAC,wDAAa;AAChC,QAAQ,mBAAO,CAAC,kDAAU;;AAE1B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,4DAA4D,sCAAsC;AAClG;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC3HA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,iBAAiB,mBAAO,CAAC,wDAAc;AACvC,YAAY,mBAAO,CAAC,mDAAgB;AACpC,kBAAkB,mBAAO,CAAC,2DAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACzHA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4EAA4E;AACvF;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C;AACpF;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,sDAAsD;AAClI;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,6DAAc;AAChC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,aAAa,mBAAO,CAAC,mEAAiB;AACtC,WAAW,mBAAO,CAAC,+DAAe;AAClC,iBAAiB,mBAAO,CAAC,2EAAqB;AAC9C,gBAAgB,mBAAO,CAAC,yEAAoB;AAC5C,WAAW,mBAAO,CAAC,+DAAe;AAClC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,cAAc,mBAAO,CAAC,qEAAkB;AACxC,WAAW,mBAAO,CAAC,+DAAe;AAClC,WAAW,mBAAO,CAAC,+DAAe;AAClC,yBAAyB,mBAAO,CAAC,2FAA6B;AAC9D,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,oBAAoB,mBAAO,CAAC,iFAAwB;AACpD,sBAAsB,mBAAO,CAAC,qFAA0B;AACxD,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,YAAY,mBAAO,CAAC,iEAAgB;AACpC,UAAU,mBAAO,CAAC,6DAAc;;AAEhC;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,oBAAoB,mBAAO,CAAC,mEAAiB;;AAE7C,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5FA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,8CAAY;AAC/B,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,8CAA8C,aAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,mBAAmB,mBAAO,CAAC,yFAAwC;AACnE,gBAAgB,mBAAO,CAAC,8FAA4C;AACpE,oBAAoB,mBAAO,CAAC,2FAAyC;AACrE,eAAe,mBAAO,CAAC,4FAA2C;AAClE,gBAAgB,mBAAO,CAAC,0EAAkC;AAC1D,eAAe,mBAAO,CAAC,4FAA2C;;AAElE;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,kEAAkE;;AAExG;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACxPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,sBAAsB,mBAAO,CAAC,6FAA0C;AACxE,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,eAAe,mBAAO,CAAC,iFAAoC;AAC3D,kBAAkB,mBAAO,CAAC,yFAAwC;AAClE,kBAAkB,mBAAO,CAAC,6EAAkC;AAC5D,YAAY,mBAAO,CAAC,uCAAO;AAC3B,gBAAgB,mBAAO,CAAC,mCAAa;AACrC,sBAAsB,mBAAO,CAAC,qEAA8B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,aAAa;;AAEpD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qGAAqG;AACpH,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,eAAe,sCAAsC;AACrD,eAAe,sCAAsC;AACrD;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,WAAW;AAC1B;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,gBAAgB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB;AACA,YAAY,gBAAgB;AAC5B;;AAEA;;;;;;;;;;;;AC/lCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,mBAAO,CAAC,oDAAkB;AACxC,aAAa,mBAAO,CAAC,kDAAiB;AACtC,SAAS,mBAAO,CAAC,0CAAa;AAC9B,WAAW,mBAAO,CAAC,8CAAe;AAClC,iBAAiB,mBAAO,CAAC,0DAAqB;AAC9C,WAAW,mBAAO,CAAC,8CAAe;;AAElC;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,8EAAoC;AAC/D,YAAY,mBAAO,CAAC,8DAA4B;AAChD,YAAY,mBAAO,CAAC,gEAA6B;AACjD,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,sBAAsB,mBAAO,CAAC,kGAA8C;AAC5E,qBAAqB,mBAAO,CAAC,gGAA6C;AAC1E,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,0BAA0B,mBAAO,CAAC,0GAAkD;AACpF,wBAAwB,mBAAO,CAAC,sGAAgD;AAChF,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,iBAAiB,mBAAO,CAAC,sFAAwC;AACjE,eAAe,mBAAO,CAAC,oEAA+B;AACtD,kBAAkB,mBAAO,CAAC,qCAAY;AACtC,4BAA4B,mBAAO,CAAC,sEAAyB;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA,kCAAkC,6BAA6B;AAC/D,mCAAmC,+BAA+B;AAClE,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,uCAAuC,gBAAgB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,4CAA4C,yBAAyB;;AAErE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,qCAAqC,cAAc;AACnD,qCAAqC,gBAAgB;;AAErD;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACjjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,WAAW,mBAAO,CAAC,4DAA2B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5HA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,kBAAkB,mBAAO,CAAC,8DAA4B;AACtD,mBAAmB,mBAAO,CAAC,8DAA4B;;AAEvD,IAAI,IAAqB;AACzB;AACA,kBAAkB,mBAAO,CAAC,oFAAgC;AAC1D;;AAEA,IAAI,IAAsB;AAC1B;AACA,mBAAmB,mBAAO,CAAC,sFAAiC;AAC5D;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,WAAW,mBAAO,CAAC,4DAA2B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpKA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mDAAmD;AACxD;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAA6C;AAC/D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sDAAsD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,2DAA2D,0BAA0B;AACrF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sDAAsD;AAC3D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kEAAkE;AACvE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK,yDAAyD;AAC9D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA,wDAAwD,OAAO;AAC/D;AACA,wDAAwD,OAAO;AAC/D;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA,0DAA0D,SAAS;AACnE;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D,mCAAmC,WAAW;AAC9C,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,cAAc;AACjD,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kEAAkE;AACvE;AACA;AACA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,kEAAkE;AAClE,qDAAqD;AACrD;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qEAAqE;AAC1E,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,2DAA2D,8CAA8C,EAAE;AAC3G;AACA;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF,wEAAwE;AACxE,2DAA2D;AAC3D;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF,sDAAsD,sDAAsD;AAC5G,sDAAsD,qDAAqD;AAC3G;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;AAC5E,qDAAqD,4BAA4B;AACjF,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA,qDAAqD,qBAAqB;AAC1E;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS,oFAAoF;AAC7F,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,uBAAuB;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF,gDAAgD,qBAAqB;AACrE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yDAAyD;AAClE,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB;AAC5E,4DAA4D,0BAA0B;AACtF,8DAA8D,4BAA4B;AAC1F,kEAAkE,sBAAsB;AACxF,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,8CAA8C,kDAAkD,iDAAiD,+BAA+B,mCAAmC,0BAA0B,2CAA2C,mDAAmD,8EAA8E,WAAW;AAC/e,iHAAiH,2FAA2F,mCAAmC,sCAAsC,0BAA0B,uEAAuE,WAAW;AACjY;AACA;AACA;AACA,2EAA2E,8CAA8C,+CAA+C,kDAAkD,iDAAiD,+BAA+B,8BAA8B,mCAAmC,0BAA0B,2CAA2C,2CAA2C,mDAAmD,8EAA8E,WAAW;AACvmB,iHAAiH,2FAA2F,mCAAmC,mCAAmC,sCAAsC,0BAA0B,8DAA8D,oDAAoD,8HAA8H,WAAW;AAC7kB;AACA;AACA;AACA,2EAA2E,8CAA8C,iDAAiD,+BAA+B,0BAA0B,2CAA2C,8EAA8E,WAAW;AACvW,iHAAiH,2FAA2F,0BAA0B,mCAAmC,WAAW;AACpR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sDAAsD;AAC/D,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;;AAEA;AACA;AACA,CAAC,e","file":"SpinePluginDebug.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./SpinePlugin.js\");\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @callback DataEachCallback\r\n *\r\n * @param {*} parent - The parent object of the DataManager.\r\n * @param {string} key - The key of the value.\r\n * @param {*} value - The value.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The Data Manager Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManager\r\n * @memberof Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} parent - The object that this DataManager belongs to.\r\n * @param {Phaser.Events.EventEmitter} eventEmitter - The DataManager's event emitter.\r\n */\r\nvar DataManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function DataManager (parent, eventEmitter)\r\n    {\r\n        /**\r\n         * The object that this DataManager belongs to.\r\n         *\r\n         * @name Phaser.Data.DataManager#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * The DataManager's event emitter.\r\n         *\r\n         * @name Phaser.Data.DataManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = eventEmitter;\r\n\r\n        if (!eventEmitter)\r\n        {\r\n            this.events = (parent.events) ? parent.events : parent;\r\n        }\r\n\r\n        /**\r\n         * The data list.\r\n         *\r\n         * @name Phaser.Data.DataManager#list\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = {};\r\n\r\n        /**\r\n         * The public values list. You can use this to access anything you have stored\r\n         * in this Data Manager. For example, if you set a value called `gold` you can\r\n         * access it via:\r\n         *\r\n         * ```javascript\r\n         * this.data.values.gold;\r\n         * ```\r\n         *\r\n         * You can also modify it directly:\r\n         * \r\n         * ```javascript\r\n         * this.data.values.gold += 1000;\r\n         * ```\r\n         *\r\n         * Doing so will emit a `setdata` event from the parent of this Data Manager.\r\n         * \r\n         * Do not modify this object directly. Adding properties directly to this object will not\r\n         * emit any events. Always use `DataManager.set` to create new items the first time around.\r\n         *\r\n         * @name Phaser.Data.DataManager#values\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.10.0\r\n         */\r\n        this.values = {};\r\n\r\n        /**\r\n         * Whether setting data is frozen for this DataManager.\r\n         *\r\n         * @name Phaser.Data.DataManager#_frozen\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._frozen = false;\r\n\r\n        if (!parent.hasOwnProperty('sys') && this.events)\r\n        {\r\n            this.events.once('destroy', this.destroy, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     * \r\n     * ```javascript\r\n     * this.data.get('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     * \r\n     * ```javascript\r\n     * this.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     * \r\n     * ```javascript\r\n     * this.data.get([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.Data.DataManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    get: function (key)\r\n    {\r\n        var list = this.list;\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            var output = [];\r\n\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                output.push(list[key[i]]);\r\n            }\r\n\r\n            return output;\r\n        }\r\n        else\r\n        {\r\n            return list[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves all data values in a new object.\r\n     *\r\n     * @method Phaser.Data.DataManager#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Object.<string, *>} All data values.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Queries the DataManager for the values of keys matching the given regular expression.\r\n     *\r\n     * @method Phaser.Data.DataManager#query\r\n     * @since 3.0.0\r\n     *\r\n     * @param {RegExp} search - A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).\r\n     *\r\n     * @return {Object.<string, *>} The values of the keys matching the search string.\r\n     */\r\n    query: function (search)\r\n    {\r\n        var results = {};\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (this.list.hasOwnProperty(key) && key.match(search))\r\n            {\r\n                results[key] = this.list[key];\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.\r\n     * \r\n     * ```javascript\r\n     * data.set('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `get`:\r\n     * \r\n     * ```javascript\r\n     * data.get('gold');\r\n     * ```\r\n     * \r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     * \r\n     * ```javascript\r\n     * data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#set\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    set: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            return this.setValue(key, data);\r\n        }\r\n        else\r\n        {\r\n            for (var entry in key)\r\n            {\r\n                this.setValue(entry, key[entry]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value setter, called automatically by the `set` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#setValue\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     * @param {*} data - The value to set.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setValue: function (key, data)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.has(key))\r\n        {\r\n            //  Hit the key getter, which will in turn emit the events.\r\n            this.values[key] = data;\r\n        }\r\n        else\r\n        {\r\n            var _this = this;\r\n            var list = this.list;\r\n            var events = this.events;\r\n            var parent = this.parent;\r\n\r\n            Object.defineProperty(this.values, key, {\r\n\r\n                enumerable: true,\r\n                \r\n                configurable: true,\r\n\r\n                get: function ()\r\n                {\r\n                    return list[key];\r\n                },\r\n\r\n                set: function (value)\r\n                {\r\n                    if (!_this._frozen)\r\n                    {\r\n                        var previousValue = list[key];\r\n                        list[key] = value;\r\n\r\n                        events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);\r\n                        events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            list[key] = data;\r\n\r\n            events.emit(Events.SET_DATA, parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all data entries to the given callback.\r\n     *\r\n     * @method Phaser.Data.DataManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {DataEachCallback} callback - The function to call.\r\n     * @param {*} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ this.parent, null, undefined ];\r\n\r\n        for (var i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (var key in this.list)\r\n        {\r\n            args[1] = key;\r\n            args[2] = this.list[key];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Merge the given object of key value pairs into this DataManager.\r\n     *\r\n     * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)\r\n     * will emit a `changedata` event.\r\n     *\r\n     * @method Phaser.Data.DataManager#merge\r\n     * @fires Phaser.Data.Events#SET_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA\r\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Object.<string, *>} data - The data to merge.\r\n     * @param {boolean} [overwrite=true] - Whether to overwrite existing data. Defaults to true.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    merge: function (data, overwrite)\r\n    {\r\n        if (overwrite === undefined) { overwrite = true; }\r\n\r\n        //  Merge data from another component into this one\r\n        for (var key in data)\r\n        {\r\n            if (data.hasOwnProperty(key) && (overwrite || (!overwrite && !this.has(key))))\r\n            {\r\n                this.setValue(key, data[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Remove the value for the given key.\r\n     *\r\n     * If the key is found in this Data Manager it is removed from the internal lists and a\r\n     * `removedata` event is emitted.\r\n     * \r\n     * You can also pass in an array of keys, in which case all keys in the array will be removed:\r\n     * \r\n     * ```javascript\r\n     * this.data.remove([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * @method Phaser.Data.DataManager#remove\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key to remove, or an array of keys to remove.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this._frozen)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                this.removeValue(key[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return this.removeValue(key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal value remover, called automatically by the `remove` method.\r\n     *\r\n     * @method Phaser.Data.DataManager#removeValue\r\n     * @private\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The key to set the value for.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    removeValue: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            var data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.\r\n     *\r\n     * @method Phaser.Data.DataManager#pop\r\n     * @fires Phaser.Data.Events#REMOVE_DATA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the value to retrieve and delete.\r\n     *\r\n     * @return {*} The value of the given key.\r\n     */\r\n    pop: function (key)\r\n    {\r\n        var data = undefined;\r\n\r\n        if (!this._frozen && this.has(key))\r\n        {\r\n            data = this.list[key];\r\n\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n\r\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Determines whether the given key is set in this Data Manager.\r\n     * \r\n     * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check.\r\n     *\r\n     * @return {boolean} Returns `true` if the key exists, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return this.list.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts\r\n     * to create new values or update existing ones.\r\n     *\r\n     * @method Phaser.Data.DataManager#setFreeze\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Whether to freeze or unfreeze the Data Manager.\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    setFreeze: function (value)\r\n    {\r\n        this._frozen = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all data in this Data Manager and unfreeze it.\r\n     *\r\n     * @method Phaser.Data.DataManager#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Data.DataManager} This DataManager object.\r\n     */\r\n    reset: function ()\r\n    {\r\n        for (var key in this.list)\r\n        {\r\n            delete this.list[key];\r\n            delete this.values[key];\r\n        }\r\n\r\n        this._frozen = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy this data manager.\r\n     *\r\n     * @method Phaser.Data.DataManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.events.off(Events.CHANGE_DATA);\r\n        this.events.off(Events.SET_DATA);\r\n        this.events.off(Events.REMOVE_DATA);\r\n\r\n        this.parent = null;\r\n    },\r\n\r\n    /**\r\n     * Gets or sets the frozen state of this Data Manager.\r\n     * A frozen Data Manager will block all attempts to create new values or update existing ones.\r\n     *\r\n     * @name Phaser.Data.DataManager#freeze\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    freeze: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._frozen;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._frozen = (value) ? true : false;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Return the total number of entries in this Data Manager.\r\n     *\r\n     * @name Phaser.Data.DataManager#count\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    count: {\r\n\r\n        get: function ()\r\n        {\r\n            var i = 0;\r\n\r\n            for (var key in this.list)\r\n            {\r\n                if (this.list[key] !== undefined)\r\n                {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            return i;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DataManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Change Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item in the data store is changed.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * a change data event from a Game Object you would use: `sprite.data.on('changedata', listener)`.\r\n * \r\n * This event is dispatched for all items that change in the Data Manager.\r\n * To listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.\r\n *\r\n * @event Phaser.Data.Events#CHANGE_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that the Data Manager responsible for this event belongs to.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} value - The new value of the item in the Data Manager.\r\n * @param {any} previousValue - The previous value of the item in the Data Manager.\r\n */\r\nmodule.exports = 'changedata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Change Data Key Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item in the data store is changed.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the change of a specific data item from a Game Object you would use: `sprite.data.on('changedata-key', listener)`,\r\n * where `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`\r\n * then you can listen for `sprite.data.on('changedata-gold')`.\r\n *\r\n * @event Phaser.Data.Events#CHANGE_DATA_KEY\r\n * @since 3.16.1\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} value - The item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n * @param {any} previousValue - The previous item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'changedata-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Remove Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when an item is removed from it.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the removal of a data item on a Game Object you would use: `sprite.data.on('removedata', listener)`.\r\n *\r\n * @event Phaser.Data.Events#REMOVE_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} data - The item that was removed from the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'removedata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Set Data Event.\r\n * \r\n * This event is dispatched by a Data Manager when a new item is added to the data store.\r\n * \r\n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\r\n * the addition of a new data item on a Game Object you would use: `sprite.data.on('setdata', listener)`.\r\n *\r\n * @event Phaser.Data.Events#SET_DATA\r\n * @since 3.0.0\r\n * \r\n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\r\n * @param {string} key - The unique key of the data item within the Data Manager.\r\n * @param {any} data - The item that was added to the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\r\n */\r\nmodule.exports = 'setdata';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Data.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CHANGE_DATA: require('./CHANGE_DATA_EVENT'),\r\n    CHANGE_DATA_KEY: require('./CHANGE_DATA_KEY_EVENT'),\r\n    REMOVE_DATA: require('./REMOVE_DATA_EVENT'),\r\n    SET_DATA: require('./SET_DATA_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../renderer/BlendModes');\r\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Builds a Game Object using the provided configuration object.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The initial GameObject.\r\n * @param {Phaser.Types.GameObjects.GameObjectConfig} config - The config to build the GameObject with.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\r\n */\r\nvar BuildGameObject = function (scene, gameObject, config)\r\n{\r\n    //  Position\r\n\r\n    gameObject.x = GetAdvancedValue(config, 'x', 0);\r\n    gameObject.y = GetAdvancedValue(config, 'y', 0);\r\n    gameObject.depth = GetAdvancedValue(config, 'depth', 0);\r\n\r\n    //  Flip\r\n\r\n    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);\r\n    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);\r\n\r\n    //  Scale\r\n    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\r\n\r\n    var scale = GetAdvancedValue(config, 'scale', null);\r\n\r\n    if (typeof scale === 'number')\r\n    {\r\n        gameObject.setScale(scale);\r\n    }\r\n    else if (scale !== null)\r\n    {\r\n        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);\r\n        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);\r\n    }\r\n\r\n    //  ScrollFactor\r\n    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\r\n\r\n    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);\r\n\r\n    if (typeof scrollFactor === 'number')\r\n    {\r\n        gameObject.setScrollFactor(scrollFactor);\r\n    }\r\n    else if (scrollFactor !== null)\r\n    {\r\n        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);\r\n        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);\r\n    }\r\n\r\n    //  Rotation\r\n\r\n    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);\r\n\r\n    var angle = GetAdvancedValue(config, 'angle', null);\r\n\r\n    if (angle !== null)\r\n    {\r\n        gameObject.angle = angle;\r\n    }\r\n\r\n    //  Alpha\r\n\r\n    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);\r\n\r\n    //  Origin\r\n    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\r\n\r\n    var origin = GetAdvancedValue(config, 'origin', null);\r\n\r\n    if (typeof origin === 'number')\r\n    {\r\n        gameObject.setOrigin(origin);\r\n    }\r\n    else if (origin !== null)\r\n    {\r\n        var ox = GetAdvancedValue(origin, 'x', 0.5);\r\n        var oy = GetAdvancedValue(origin, 'y', 0.5);\r\n\r\n        gameObject.setOrigin(ox, oy);\r\n    }\r\n\r\n    //  BlendMode\r\n\r\n    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);\r\n\r\n    //  Visible\r\n\r\n    gameObject.visible = GetAdvancedValue(config, 'visible', true);\r\n\r\n    //  Add to Scene\r\n\r\n    var add = GetAdvancedValue(config, 'add', true);\r\n\r\n    if (add)\r\n    {\r\n        scene.sys.displayList.add(gameObject);\r\n    }\r\n\r\n    if (gameObject.preUpdate)\r\n    {\r\n        scene.sys.updateList.add(gameObject);\r\n    }\r\n\r\n    return gameObject;\r\n};\r\n\r\nmodule.exports = BuildGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ComponentsToJSON = require('./components/ToJSON');\r\nvar DataManager = require('../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\r\nvar GameObject = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GameObject (scene, type)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Game Object belongs.\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         * \r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         * \r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could move from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#state\r\n         * @type {(integer|string)}\r\n         * @since 3.16.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {integer}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     * \r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     * \r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(integer|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function (shape, callback, dropZone)\r\n    {\r\n        this.scene.sys.input.enable(this, shape, callback, dropZone);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will disable it.\r\n     *\r\n     * An object that is disabled for input stops processing or being considered for\r\n     * input events, but can be turned back on again at any time by simply calling\r\n     * `setInteractive()` with no arguments provided.\r\n     *\r\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#disableInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        if (this.input)\r\n        {\r\n            this.input.enabled = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will queue it\r\n     * for removal, causing it to no longer be interactive. The removal happens on\r\n     * the next game step, it is not immediate.\r\n     *\r\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n     * removed from the Input Manager and cleared from this Game Object.\r\n     *\r\n     * If you wish to re-enable this Game Object at a later date you will need to\r\n     * re-create its InteractiveObject by calling `setInteractive` again.\r\n     *\r\n     * If you wish to only temporarily stop an object from receiving input then use\r\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n     * this erases it completely.\r\n     * \r\n     * If you wish to resize a hit area, don't remove and then set it as being\r\n     * interactive. Instead, access the hitarea object directly and resize the shape\r\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n     * shape is a Rectangle, which it is by default.)\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        this.scene.sys.input.clear(this);\r\n\r\n        this.input = undefined;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            // indexes.unshift([parent.getIndex(child), parent.name]);\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\r\n        indexes.unshift(this.scene.sys.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\r\n     */\r\n    destroy: function (fromScene)\r\n    {\r\n        if (fromScene === undefined) { fromScene = false; }\r\n\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.preDestroy)\r\n        {\r\n            this.preDestroy.call(this);\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        var sys = this.scene.sys;\r\n\r\n        if (!fromScene)\r\n        {\r\n            sys.displayList.remove(this);\r\n            sys.updateList.remove(this);\r\n        }\r\n\r\n        if (this.input)\r\n        {\r\n            sys.input.clear(this);\r\n            this.input = undefined;\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        if (this.body)\r\n        {\r\n            this.body.destroy();\r\n            this.body = undefined;\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        if (!fromScene)\r\n        {\r\n            sys.queueDepthSort();\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.scene = undefined;\r\n\r\n        this.parentContainer = undefined;\r\n\r\n        this.removeAllListeners();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\r\nGameObject.RENDER_MASK = 15;\r\n\r\nmodule.exports = GameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for calculating and setting the size of a non-Frame based Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.ComputedSize\r\n * @since 3.0.0\r\n */\r\n\r\nvar ComputedSize = {\r\n\r\n    /**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayWidth` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    width: 0,\r\n\r\n    /**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayHeight` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    height: 0,\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     * \r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     * \r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setSize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Game Object.\r\n     * \r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ComputedSize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the depth of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Depth\r\n * @since 3.0.0\r\n */\r\n\r\nvar Depth = {\r\n\r\n    /**\r\n     * Private internal value. Holds the depth of the Game Object.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#_depth\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _depth: 0,\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Depth#depth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    depth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._depth;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scene.sys.queueDepthSort();\r\n            this._depth = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     * \r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Depth#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} value - The depth of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDepth: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.depth = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Depth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for visually flipping a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Flip\r\n * @since 3.0.0\r\n */\r\n\r\nvar Flip = {\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipX: false,\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipY: false,\r\n\r\n    /**\r\n     * Toggles the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipX: function ()\r\n    {\r\n        this.flipX = !this.flipX;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipY: function ()\r\n    {\r\n        this.flipY = !this.flipY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped will render inversed on the flipped axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Flip;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.ScrollFactor\r\n * @since 3.0.0\r\n */\r\n\r\nvar ScrollFactor = {\r\n\r\n    /**\r\n     * The horizontal scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorX: 1,\r\n\r\n    /**\r\n     * The vertical scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorY: 1,\r\n\r\n    /**\r\n     * Sets the scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ScrollFactor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Build a JSON representation of the given Game Object.\r\n *\r\n * This is typically extended further by Game Object specific implementations.\r\n *\r\n * @method Phaser.GameObjects.Components.ToJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to export as JSON.\r\n *\r\n * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n */\r\nvar ToJSON = function (gameObject)\r\n{\r\n    var out = {\r\n        name: gameObject.name,\r\n        type: gameObject.type,\r\n        x: gameObject.x,\r\n        y: gameObject.y,\r\n        depth: gameObject.depth,\r\n        scale: {\r\n            x: gameObject.scaleX,\r\n            y: gameObject.scaleY\r\n        },\r\n        origin: {\r\n            x: gameObject.originX,\r\n            y: gameObject.originY\r\n        },\r\n        flipX: gameObject.flipX,\r\n        flipY: gameObject.flipY,\r\n        rotation: gameObject.rotation,\r\n        alpha: gameObject.alpha,\r\n        visible: gameObject.visible,\r\n        blendMode: gameObject.blendMode,\r\n        textureKey: '',\r\n        frameKey: '',\r\n        data: {}\r\n    };\r\n\r\n    if (gameObject.texture)\r\n    {\r\n        out.textureKey = gameObject.texture.key;\r\n        out.frameKey = gameObject.frame.name;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToJSON;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar TransformMatrix = require('./TransformMatrix');\r\nvar WrapAngle = require('../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\r\n\r\nvar Transform = {\r\n\r\n    /**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleX: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the vertical scale value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleY: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _rotation: 0,\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    x: 0,\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    y: 0,\r\n\r\n    /**\r\n     * The z position of this Game Object.\r\n     * Note: Do not use this value to set the z-index, instead see the `depth` property.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    z: 0,\r\n\r\n    /**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    w: 0,\r\n\r\n    /**\r\n     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\r\n     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\r\n     * \r\n     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\r\n     * isn't the case, use the `scaleX` or `scaleY` properties instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.18.0\r\n     */\r\n    scale: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this._scaleX + this._scaleY) / 2;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     * \r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object in radians.\r\n     * \r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPosition: function (x, y, z, w)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n        if (z === undefined) { z = 0; }\r\n        if (w === undefined) { w = 0; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object to be a random position within the confines of\r\n     * the given area.\r\n     * \r\n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n     *\r\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n     * guaranteed to be within the area.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n     * @since 3.8.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the top-left of the random area.\r\n     * @param {number} [y=0] - The y position of the top-left of the random area.\r\n     * @param {number} [width] - The width of the random area.\r\n     * @param {number} [height] - The height of the random area.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRandomPosition: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n\r\n        this.x = x + (Math.random() * width);\r\n        this.y = y + (Math.random() * height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this.rotation = radians;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.z = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setW: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.w = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getLocalTransformMatrix: function (tempMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n\r\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n    },\r\n\r\n    /**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        if (!parent)\r\n        {\r\n            return this.getLocalTransformMatrix(tempMatrix);\r\n        }\r\n\r\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n\r\n        while (parent)\r\n        {\r\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\r\n\r\n            parentMatrix.multiply(tempMatrix, tempMatrix);\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return tempMatrix;\r\n    },\r\n\r\n    /**\r\n     * Gets the sum total rotation of all of this Game Objects parent Containers.\r\n     * \r\n     * The returned value is in radians and will be zero if this Game Object has no parent container.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getParentRotation\r\n     * @since 3.18.0\r\n     *\r\n     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\r\n     */\r\n    getParentRotation: function ()\r\n    {\r\n        var rotation = 0;\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        while (parent)\r\n        {\r\n            rotation += parent.rotation;\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return rotation;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Matrix used for display transformations for rendering.\r\n *\r\n * It is represented like so:\r\n *\r\n * ```\r\n * | a | c | tx |\r\n * | b | d | ty |\r\n * | 0 | 0 | 1  |\r\n * ```\r\n *\r\n * @class TransformMatrix\r\n * @memberof Phaser.GameObjects.Components\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [a=1] - The Scale X value.\r\n * @param {number} [b=0] - The Skew Y value.\r\n * @param {number} [c=0] - The Skew X value.\r\n * @param {number} [d=1] - The Scale Y value.\r\n * @param {number} [tx=0] - The Translate X value.\r\n * @param {number} [ty=0] - The Translate Y value.\r\n */\r\nvar TransformMatrix = new Class({\r\n\r\n    initialize:\r\n\r\n    function TransformMatrix (a, b, c, d, tx, ty)\r\n    {\r\n        if (a === undefined) { a = 1; }\r\n        if (b === undefined) { b = 0; }\r\n        if (c === undefined) { c = 0; }\r\n        if (d === undefined) { d = 1; }\r\n        if (tx === undefined) { tx = 0; }\r\n        if (ty === undefined) { ty = 0; }\r\n\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#matrix\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The decomposed matrix.\r\n         *\r\n         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.decomposedMatrix = {\r\n            translateX: 0,\r\n            translateY: 0,\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            rotation: 0\r\n        };\r\n    },\r\n\r\n    /**\r\n     * The Scale X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#a\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    a: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[0];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[0] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Skew Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#b\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    b: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[1];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[1] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Skew X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#c\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    c: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[2];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[2] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Scale Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#d\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    d: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[3];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[3] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#e\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    e: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#f\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    f: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate X value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#tx\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    tx: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[4];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[4] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Translate Y value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#ty\r\n     * @type {number}\r\n     * @since 3.4.0\r\n     */\r\n    ty: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.matrix[5];\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.matrix[5] = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Matrix. Value is in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotation\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.acos(this.a / this.scaleX) * ((Math.atan(-this.c / this.a) < 0) ? -1 : 1);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Matrix, normalized to be within the Phaser right-handed\r\n     * clockwise rotation space. Value is in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotationNormalized\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.19.0\r\n     */\r\n    rotationNormalized: {\r\n\r\n        get: function ()\r\n        {\r\n            var matrix = this.matrix;\r\n\r\n            var a = matrix[0];\r\n            var b = matrix[1];\r\n            var c = matrix[2];\r\n            var d = matrix[3];\r\n\r\n            if (a || b)\r\n            {\r\n                // var r = Math.sqrt(a * a + b * b);\r\n    \r\n                return (b > 0) ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);\r\n            }\r\n            else if (c || d)\r\n            {\r\n                // var s = Math.sqrt(c * c + d * d);\r\n    \r\n                return MATH_CONST.TAU - ((d > 0) ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The decomposed horizontal scale of the Matrix. This value is always positive.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.a * this.a) + (this.b * this.b));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The decomposed vertical scale of the Matrix. This value is always positive.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt((this.c * this.c) + (this.d * this.d));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Reset the Matrix to an identity matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    loadIdentity: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = 1;\r\n        matrix[1] = 0;\r\n        matrix[2] = 0;\r\n        matrix[3] = 1;\r\n        matrix[4] = 0;\r\n        matrix[5] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation value.\r\n     * @param {number} y - The vertical translation value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    translate: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\r\n        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale value.\r\n     * @param {number} y - The vertical scale value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    scale: function (x, y)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] *= x;\r\n        matrix[1] *= x;\r\n        matrix[2] *= y;\r\n        matrix[3] *= y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle of rotation in radians.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    rotate: function (angle)\r\n    {\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        matrix[0] = a * cos + c * sin;\r\n        matrix[1] = b * cos + d * sin;\r\n        matrix[2] = a * -sin + c * cos;\r\n        matrix[3] = b * -sin + d * cos;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     * \r\n     * If an `out` Matrix is given then the results will be stored in it.\r\n     * If it is not given, this matrix will be updated in place instead.\r\n     * Use an `out` Matrix if you do not wish to mutate this matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - The Matrix to multiply by.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [out] - An optional Matrix to store the results in.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} Either this TransformMatrix, or the `out` Matrix, if given in the arguments.\r\n     */\r\n    multiply: function (rhs, out)\r\n    {\r\n        var matrix = this.matrix;\r\n        var source = rhs.matrix;\r\n\r\n        var localA = matrix[0];\r\n        var localB = matrix[1];\r\n        var localC = matrix[2];\r\n        var localD = matrix[3];\r\n        var localE = matrix[4];\r\n        var localF = matrix[5];\r\n\r\n        var sourceA = source[0];\r\n        var sourceB = source[1];\r\n        var sourceC = source[2];\r\n        var sourceD = source[3];\r\n        var sourceE = source[4];\r\n        var sourceF = source[5];\r\n\r\n        var destinationMatrix = (out === undefined) ? this : out;\r\n\r\n        destinationMatrix.a = (sourceA * localA) + (sourceB * localC);\r\n        destinationMatrix.b = (sourceA * localB) + (sourceB * localD);\r\n        destinationMatrix.c = (sourceC * localA) + (sourceD * localC);\r\n        destinationMatrix.d = (sourceC * localB) + (sourceD * localD);\r\n        destinationMatrix.e = (sourceE * localA) + (sourceF * localC) + localE;\r\n        destinationMatrix.f = (sourceE * localB) + (sourceF * localD) + localF;\r\n\r\n        return destinationMatrix;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the matrix given, including the offset.\r\n     * \r\n     * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.\r\n     * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiplyWithOffset\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     * @param {number} offsetX - Horizontal offset to factor in to the multiplication.\r\n     * @param {number} offsetY - Vertical offset to factor in to the multiplication.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    multiplyWithOffset: function (src, offsetX, offsetY)\r\n    {\r\n        var matrix = this.matrix;\r\n        var otherMatrix = src.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        var pse = offsetX * a0 + offsetY * c0 + tx0;\r\n        var psf = offsetX * b0 + offsetY * d0 + ty0;\r\n\r\n        var a1 = otherMatrix[0];\r\n        var b1 = otherMatrix[1];\r\n        var c1 = otherMatrix[2];\r\n        var d1 = otherMatrix[3];\r\n        var tx1 = otherMatrix[4];\r\n        var ty1 = otherMatrix[5];\r\n\r\n        matrix[0] = a1 * a0 + b1 * c0;\r\n        matrix[1] = a1 * b0 + b1 * d0;\r\n        matrix[2] = c1 * a0 + d1 * c0;\r\n        matrix[3] = c1 * b0 + d1 * d0;\r\n        matrix[4] = tx1 * a0 + ty1 * c0 + pse;\r\n        matrix[5] = tx1 * b0 + ty1 * d0 + psf;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    transform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a0 = matrix[0];\r\n        var b0 = matrix[1];\r\n        var c0 = matrix[2];\r\n        var d0 = matrix[3];\r\n        var tx0 = matrix[4];\r\n        var ty0 = matrix[5];\r\n\r\n        matrix[0] = a * a0 + b * c0;\r\n        matrix[1] = a * b0 + b * d0;\r\n        matrix[2] = c * a0 + d * c0;\r\n        matrix[3] = c * b0 + d * d0;\r\n        matrix[4] = tx * a0 + ty * c0 + tx0;\r\n        matrix[5] = tx * b0 + ty * d0 + ty0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform a point using this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point to transform.\r\n     * @param {number} y - The y coordinate of the point to transform.\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The Point object to store the transformed coordinates.\r\n     *\r\n     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} The Point containing the transformed coordinates.\r\n     */\r\n    transformPoint: function (x, y, point)\r\n    {\r\n        if (point === undefined) { point = { x: 0, y: 0 }; }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        point.x = x * a + y * c + tx;\r\n        point.y = x * b + y * d + ty;\r\n\r\n        return point;\r\n    },\r\n\r\n    /**\r\n     * Invert the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var n = a * d - b * c;\r\n\r\n        matrix[0] = d / n;\r\n        matrix[1] = -b / n;\r\n        matrix[2] = -c / n;\r\n        matrix[3] = a / n;\r\n        matrix[4] = (c * ty - d * tx) / n;\r\n        matrix[5] = -(a * ty - b * tx) / n;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the matrix given.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFrom\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFrom: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src.a;\r\n        matrix[1] = src.b;\r\n        matrix[2] = src.c;\r\n        matrix[3] = src.d;\r\n        matrix[4] = src.e;\r\n        matrix[5] = src.f;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix to copy those of the array given.\r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFromArray\r\n     * @since 3.11.0\r\n     *\r\n     * @param {array} src - The array of values to set into this matrix.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    copyFromArray: function (src)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = src[0];\r\n        matrix[1] = src[1];\r\n        matrix[2] = src[2];\r\n        matrix[3] = src[3];\r\n        matrix[4] = src[4];\r\n        matrix[5] = src[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.transform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    copyToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\r\n     * This will use the Context.setTransform method.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setToContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\r\n     */\r\n    setToContext: function (ctx)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n        return ctx;\r\n    },\r\n\r\n    /**\r\n     * Copy the values in this Matrix to the array given.\r\n     * \r\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToArray\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} [out] - The array to copy the matrix values in to.\r\n     *\r\n     * @return {array} An array where elements 0 to 5 contain the values from this matrix.\r\n     */\r\n    copyToArray: function (out)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        if (out === undefined)\r\n        {\r\n            out = [ matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5] ];\r\n        }\r\n        else\r\n        {\r\n            out[0] = matrix[0];\r\n            out[1] = matrix[1];\r\n            out[2] = matrix[2];\r\n            out[3] = matrix[3];\r\n            out[4] = matrix[4];\r\n            out[5] = matrix[5];\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} a - The Scale X value.\r\n     * @param {number} b - The Shear Y value.\r\n     * @param {number} c - The Shear X value.\r\n     * @param {number} d - The Scale Y value.\r\n     * @param {number} tx - The Translate X value.\r\n     * @param {number} ty - The Translate Y value.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    setTransform: function (a, b, c, d, tx, ty)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        matrix[0] = a;\r\n        matrix[1] = b;\r\n        matrix[2] = c;\r\n        matrix[3] = d;\r\n        matrix[4] = tx;\r\n        matrix[5] = ty;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.\r\n     * \r\n     * The result must be applied in the following order to reproduce the current matrix:\r\n     * \r\n     * translate -> rotate -> scale\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The decomposed Matrix.\r\n     */\r\n    decomposeMatrix: function ()\r\n    {\r\n        var decomposedMatrix = this.decomposedMatrix;\r\n\r\n        var matrix = this.matrix;\r\n\r\n        //  a = scale X (1)\r\n        //  b = shear Y (0)\r\n        //  c = shear X (0)\r\n        //  d = scale Y (1)\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n\r\n        var determ = a * d - b * c;\r\n\r\n        decomposedMatrix.translateX = matrix[4];\r\n        decomposedMatrix.translateY = matrix[5];\r\n\r\n        if (a || b)\r\n        {\r\n            var r = Math.sqrt(a * a + b * b);\r\n\r\n            decomposedMatrix.rotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);\r\n            decomposedMatrix.scaleX = r;\r\n            decomposedMatrix.scaleY = determ / r;\r\n        }\r\n        else if (c || d)\r\n        {\r\n            var s = Math.sqrt(c * c + d * d);\r\n\r\n            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));\r\n            decomposedMatrix.scaleX = determ / s;\r\n            decomposedMatrix.scaleY = s;\r\n        }\r\n        else\r\n        {\r\n            decomposedMatrix.rotation = 0;\r\n            decomposedMatrix.scaleX = 0;\r\n            decomposedMatrix.scaleY = 0;\r\n        }\r\n\r\n        return decomposedMatrix;\r\n    },\r\n\r\n    /**\r\n     * Apply the identity, translate, rotate and scale operations on the Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation.\r\n     * @param {number} y - The vertical translation.\r\n     * @param {number} rotation - The angle of rotation in radians.\r\n     * @param {number} scaleX - The horizontal scale.\r\n     * @param {number} scaleY - The vertical scale.\r\n     *\r\n     * @return {this} This TransformMatrix.\r\n     */\r\n    applyITRS: function (x, y, rotation, scaleX, scaleY)\r\n    {\r\n        var matrix = this.matrix;\r\n\r\n        var radianSin = Math.sin(rotation);\r\n        var radianCos = Math.cos(rotation);\r\n\r\n        // Translate\r\n        matrix[4] = x;\r\n        matrix[5] = y;\r\n\r\n        // Rotate and Scale\r\n        matrix[0] = radianCos * scaleX;\r\n        matrix[1] = radianSin * scaleX;\r\n        matrix[2] = -radianSin * scaleY;\r\n        matrix[3] = radianCos * scaleY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of\r\n     * the current matrix with its transformation applied.\r\n     * \r\n     * Can be used to translate points from world to local space.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyInverse\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} x - The x position to translate.\r\n     * @param {number} y - The y position to translate.\r\n     * @param {Phaser.Math.Vector2} [output] - A Vector2, or point-like object, to store the results in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates, inverse-transformed through this matrix.\r\n     */\r\n    applyInverse: function (x, y, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        var matrix = this.matrix;\r\n\r\n        var a = matrix[0];\r\n        var b = matrix[1];\r\n        var c = matrix[2];\r\n        var d = matrix[3];\r\n        var tx = matrix[4];\r\n        var ty = matrix[5];\r\n\r\n        var id = 1 / ((a * d) + (c * -b));\r\n\r\n        output.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n        output.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the X component of this matrix multiplied by the given values.\r\n     * This is the same as `x * a + y * c + e`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getX\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated x value.\r\n     */\r\n    getX: function (x, y)\r\n    {\r\n        return x * this.a + y * this.c + this.e;\r\n    },\r\n\r\n    /**\r\n     * Returns the Y component of this matrix multiplied by the given values.\r\n     * This is the same as `x * b + y * d + f`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getY\r\n     * @since 3.12.0\r\n     * \r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     *\r\n     * @return {number} The calculated y value.\r\n     */\r\n    getY: function (x, y)\r\n    {\r\n        return x * this.b + y * this.d + this.f;\r\n    },\r\n\r\n    /**\r\n     * Returns a string that can be used in a CSS Transform call as a `matrix` property.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#getCSSMatrix\r\n     * @since 3.12.0\r\n     *\r\n     * @return {string} A string containing the CSS Transform matrix values.\r\n     */\r\n    getCSSMatrix: function ()\r\n    {\r\n        var m = this.matrix;\r\n\r\n        return 'matrix(' + m[0] + ',' + m[1] + ',' + m[2] + ',' + m[3] + ',' + m[4] + ',' + m[5] + ')';\r\n    },\r\n\r\n    /**\r\n     * Destroys this Transform Matrix.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TransformMatrix#destroy\r\n     * @since 3.4.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.matrix = null;\r\n        this.decomposedMatrix = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TransformMatrix;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 1; // 0001\r\n\r\n/**\r\n * Provides methods used for setting the visibility of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Visible\r\n * @since 3.0.0\r\n */\r\n\r\nvar Visible = {\r\n\r\n    /**\r\n     * Private internal value. Holds the visible value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#_visible\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    _visible: true,\r\n\r\n    /**\r\n     * The visible state of the Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value)\r\n            {\r\n                this._visible = true;\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n            else\r\n            {\r\n                this._visible = false;\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Visible#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = Visible;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Object Destroy Event.\r\n * \r\n * This event is dispatched when a Game Object instance is being destroyed.\r\n * \r\n * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#DESTROY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object which is being destroyed.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Complete Event.\r\n * \r\n * This event is dispatched when a Video finishes playback by reaching the end of its duration. It\r\n * is also dispatched if a video marker sequence is being played and reaches the end.\r\n * \r\n * Note that not all videos can fire this event. Live streams, for example, have no fixed duration,\r\n * so never technically 'complete'.\r\n * \r\n * If a video is stopped from playback, via the `Video.stop` method, it will emit the\r\n * `VIDEO_STOP` event instead of this one.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('complete', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed playback.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Created Event.\r\n * \r\n * This event is dispatched when the texture for a Video has been created. This happens\r\n * when enough of the video source has been loaded that the browser is able to render a\r\n * frame from it.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('created', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_CREATED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.\r\n * @param {integer} width - The width of the video.\r\n * @param {integer} height - The height of the video.\r\n */\r\nmodule.exports = 'created';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Error Event.\r\n * \r\n * This event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('error', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_ERROR\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which threw the error.\r\n * @param {Event} event - The native DOM event the browser raised during playback.\r\n */\r\nmodule.exports = 'error';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Loop Event.\r\n * \r\n * This event is dispatched when a Video that is currently playing has looped. This only\r\n * happens if the `loop` parameter was specified, or the `setLoop` method was called,\r\n * and if the video has a fixed duration. Video streams, for example, cannot loop, as\r\n * they have no duration.\r\n * \r\n * Looping is based on the result of the Video `timeupdate` event. This event is not\r\n * frame-accurate, due to the way browsers work, so please do not rely on this loop\r\n * event to be time or frame precise.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('loop', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_LOOP\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which has looped.\r\n */\r\nmodule.exports = 'loop';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Play Event.\r\n * \r\n * This event is dispatched when a Video begins playback. For videos that do not require\r\n * interaction unlocking, this is usually as soon as the `Video.play` method is called.\r\n * However, for videos that require unlocking, it is fired once playback begins after\r\n * they've been unlocked.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('play', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_PLAY\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which started playback.\r\n */\r\nmodule.exports = 'play';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Seeked Event.\r\n * \r\n * This event is dispatched when a Video completes seeking to a new point in its timeline.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('seeked', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_SEEKED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed seeking.\r\n */\r\nmodule.exports = 'seeked';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Seeking Event.\r\n * \r\n * This event is dispatched when a Video _begins_ seeking to a new point in its timeline.\r\n * When the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('seeking', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_SEEKING\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which started seeking.\r\n */\r\nmodule.exports = 'seeking';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Stopped Event.\r\n * \r\n * This event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,\r\n * either directly via game code, or indirectly as the result of changing a video source or destroying it.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('stop', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_STOP\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which stopped playback.\r\n */\r\nmodule.exports = 'stop';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Timeout Event.\r\n * \r\n * This event is dispatched when a Video has exhausted its allocated time while trying to connect to a video\r\n * source to start playback.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('timeout', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which timed out.\r\n */\r\nmodule.exports = 'timeout';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Unlocked Event.\r\n * \r\n * This event is dispatched when a Video that was prevented from playback due to the browsers\r\n * Media Engagement Interaction policy, is unlocked by a user gesture.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.\r\n */\r\nmodule.exports = 'unlocked';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    VIDEO_COMPLETE: require('./VIDEO_COMPLETE_EVENT'),\r\n    VIDEO_CREATED: require('./VIDEO_CREATED_EVENT'),\r\n    VIDEO_ERROR: require('./VIDEO_ERROR_EVENT'),\r\n    VIDEO_LOOP: require('./VIDEO_LOOP_EVENT'),\r\n    VIDEO_PLAY: require('./VIDEO_PLAY_EVENT'),\r\n    VIDEO_SEEKED: require('./VIDEO_SEEKED_EVENT'),\r\n    VIDEO_SEEKING: require('./VIDEO_SEEKING_EVENT'),\r\n    VIDEO_STOP: require('./VIDEO_STOP_EVENT'),\r\n    VIDEO_TIMEOUT: require('./VIDEO_TIMEOUT_EVENT'),\r\n    VIDEO_UNLOCKED: require('./VIDEO_UNLOCKED_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Error calling \\'Loader.' + this.type + '\\' invalid key provided.');\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         * Automatically has Loader.path prepended to it.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (this.url === undefined)\r\n        {\r\n            this.url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof(this.url) !== 'function')\r\n        {\r\n            this.url = loader.path + this.url;\r\n        }\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //  \r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        var localFileOk = ((xhr.responseURL && xhr.responseURL.indexOf('file://') === 0 && event.target.status === 0));\r\n\r\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\r\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\r\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @since 3.7.0\r\n * \r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @since 3.7.0\r\n * \r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar types = {};\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypesManager\r\n */\r\n\r\nvar FileTypesManager = {\r\n\r\n    /**\r\n     * Static method called when a LoaderPlugin is created.\r\n     * \r\n     * Loops through the local types object and injects all of them as\r\n     * properties into the LoaderPlugin instance.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.install\r\n     * @since 3.0.0\r\n     * \r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.\r\n     */\r\n    install: function (loader)\r\n    {\r\n        for (var key in types)\r\n        {\r\n            loader[key] = types[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Static method called directly by the File Types.\r\n     * \r\n     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.register\r\n     * @since 3.0.0\r\n     * \r\n     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.\r\n     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.\r\n     */\r\n    register: function (key, factoryFunction)\r\n    {\r\n        types[key] = factoryFunction;\r\n    },\r\n\r\n    /**\r\n     * Removed all associated file types.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        types = {};\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = FileTypesManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n * \r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#multiKeyIndex\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = loader.multiKeyIndex++;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = files;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = files.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        /**\r\n         * A reference to the Loaders baseURL at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#baseURL\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.baseURL = loader.baseURL;\r\n\r\n        /**\r\n         * A reference to the Loaders path at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#path\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.path = loader.path;\r\n\r\n        /**\r\n         * A reference to the Loaders prefix at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#prefix\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.prefix = loader.prefix;\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < files.length; i++)\r\n        {\r\n            files[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file, xhr);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {integer} [timeout=0] - Optional XHR timeout value.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Add File Event.\r\n * \r\n * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('addfile', listener)`.\r\n * \r\n * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.\r\n *\r\n * @event Phaser.Loader.Events#ADD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The unique key of the file that was added to the Loader.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.\r\n */\r\nmodule.exports = 'addfile';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Complete Event.\r\n * \r\n * This event is dispatched when the Loader has fully processed everything in the load queue.\r\n * By this point every loaded file will now be in its associated cache and ready for use.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('complete', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {integer} totalComplete - The total number of files that successfully loaded.\r\n * @param {integer} totalFailed - The total number of files that failed to load.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.\r\n * \r\n * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * It uses a special dynamic event name constructed from the key and type of the file.\r\n * \r\n * For example, if you have loaded an `image` with a key of `monster`, you can listen for it\r\n * using the following:\r\n *\r\n * ```javascript\r\n * this.load.on('filecomplete-image-monster', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n *\r\n * Or, if you have loaded a texture `atlas` with a key of `Level1`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Error Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file fails to load.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD_ERROR\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n */\r\nmodule.exports = 'loaderror';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file finishes loading,\r\n * but _before_ it is processed and added to the internal Phaser caches.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('load', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.\r\n */\r\nmodule.exports = 'load';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Progress Event.\r\n * \r\n * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\r\n * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.\r\n */\r\nmodule.exports = 'fileprogress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Post Process Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\r\n * It is dispatched before the internal lists are cleared and each File is destroyed.\r\n * \r\n * Use this hook to perform any last minute processing of files that can only happen once the\r\n * Loader has completed, but prior to it emitting the `complete` event.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#POST_PROCESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'postprocess';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Progress Event.\r\n * \r\n * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('progress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {number} progress - The current progress of the load. A value between 0 and 1.\r\n */\r\nmodule.exports = 'progress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Start Event.\r\n * \r\n * This event is dispatched when the Loader starts running. At this point load progress is zero.\r\n * \r\n * This event is dispatched even if there aren't any files in the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('start', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD: require('./ADD_EVENT'),\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    FILE_COMPLETE: require('./FILE_COMPLETE_EVENT'),\r\n    FILE_KEY_COMPLETE: require('./FILE_KEY_COMPLETE_EVENT'),\r\n    FILE_LOAD_ERROR: require('./FILE_LOAD_ERROR_EVENT'),\r\n    FILE_LOAD: require('./FILE_LOAD_EVENT'),\r\n    FILE_PROGRESS: require('./FILE_PROGRESS_EVENT'),\r\n    POST_PROCESS: require('./POST_PROCESS_EVENT'),\r\n    PROGRESS: require('./PROGRESS_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            var json = JSON.parse(this.xhrLoader.responseText);\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n * \r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'txt';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.text,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the mean average of the given values.\r\n *\r\n * @function Phaser.Math.Average\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} values - The values to average.\r\n *\r\n * @return {number} The average value.\r\n */\r\nvar Average = function (values)\r\n{\r\n    var sum = 0;\r\n\r\n    for (var i = 0; i < values.length; i++)\r\n    {\r\n        sum += (+values[i]);\r\n    }\r\n\r\n    return sum / values.length;\r\n};\r\n\r\nmodule.exports = Average;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Factorial = require('./Factorial');\r\n\r\n/**\r\n * [description]\r\n *\r\n * @function Phaser.Math.Bernstein\r\n * @since 3.0.0\r\n *\r\n * @param {number} n - [description]\r\n * @param {number} i - [description]\r\n *\r\n * @return {number} [description]\r\n */\r\nvar Bernstein = function (n, i)\r\n{\r\n    return Factorial(n) / Factorial(i) / Factorial(n - i);\r\n};\r\n\r\nmodule.exports = Bernstein;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random integer between the `min` and `max` values, inclusive.\r\n *\r\n * @function Phaser.Math.Between\r\n * @since 3.0.0\r\n *\r\n * @param {integer} min - The minimum value.\r\n * @param {integer} max - The maximum value.\r\n *\r\n * @return {integer} The random integer.\r\n */\r\nvar Between = function (min, max)\r\n{\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a Catmull-Rom value.\r\n *\r\n * @function Phaser.Math.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - [description]\r\n * @param {number} p0 - [description]\r\n * @param {number} p1 - [description]\r\n * @param {number} p2 - [description]\r\n * @param {number} p3 - [description]\r\n *\r\n * @return {number} The Catmull-Rom value.\r\n */\r\nvar CatmullRom = function (t, p0, p1, p2, p3)\r\n{\r\n    var v0 = (p2 - p0) * 0.5;\r\n    var v1 = (p3 - p1) * 0.5;\r\n    var t2 = t * t;\r\n    var t3 = t * t2;\r\n\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n};\r\n\r\nmodule.exports = CatmullRom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Ceils to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.CeilTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {number} [place=0] - The place to round to.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar CeilTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.ceil(value * p) / p;\r\n};\r\n\r\nmodule.exports = CeilTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {integer} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the positive difference of two given numbers.\r\n *\r\n * @function Phaser.Math.Difference\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first number in the calculation.\r\n * @param {number} b - The second number in the calculation.\r\n *\r\n * @return {number} The positive difference of the two given numbers.\r\n */\r\nvar Difference = function (a, b)\r\n{\r\n    return Math.abs(a - b);\r\n};\r\n\r\nmodule.exports = Difference;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the factorial of a given number for integer values greater than 0.\r\n *\r\n * @function Phaser.Math.Factorial\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - A positive integer to calculate the factorial of.\r\n *\r\n * @return {number} The factorial of the given number.\r\n */\r\nvar Factorial = function (value)\r\n{\r\n    if (value === 0)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    var res = value;\r\n\r\n    while (--value)\r\n    {\r\n        res *= value;\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\nmodule.exports = Factorial;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a random floating point number between the two given bounds, minimum inclusive, maximum exclusive.\r\n *\r\n * @function Phaser.Math.FloatBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} min - The lower bound for the float, inclusive.\r\n * @param {number} max - The upper bound for the float exclusive.\r\n *\r\n * @return {number} A random float within the given range.\r\n */\r\nvar FloatBetween = function (min, max)\r\n{\r\n    return Math.random() * (max - min) + min;\r\n};\r\n\r\nmodule.exports = FloatBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Floors to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.FloorTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {integer} [place=0] - The place to round to.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar FloorTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.floor(value * p) / p;\r\n};\r\n\r\nmodule.exports = FloorTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the speed required to cover a distance in the time given.\r\n *\r\n * @function Phaser.Math.GetSpeed\r\n * @since 3.0.0\r\n *\r\n * @param {number} distance - The distance to travel in pixels.\r\n * @param {integer} time - The time, in ms, to cover the distance in.\r\n *\r\n * @return {number} The amount you will need to increment the position by each step in order to cover the distance in the time given.\r\n */\r\nvar GetSpeed = function (distance, time)\r\n{\r\n    return (distance / time) / 1000;\r\n};\r\n\r\nmodule.exports = GetSpeed;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number.\r\n *\r\n * @function Phaser.Math.IsEven\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEven = function (value)\r\n{\r\n    // Use abstract equality == for \"is number\" test\r\n\r\n    // eslint-disable-next-line eqeqeq\r\n    return (value == parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEven;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number using a strict type check.\r\n *\r\n * @function Phaser.Math.IsEvenStrict\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEvenStrict = function (value)\r\n{\r\n    // Use strict equality === for \"is number\" test\r\n    return (value === parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEvenStrict;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a linear (interpolation) value over t.\r\n *\r\n * @function Phaser.Math.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} p0 - The first point.\r\n * @param {number} p1 - The second point.\r\n * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.\r\n *\r\n * @return {number} The step t% of the way between p0 and p1.\r\n */\r\nvar Linear = function (p0, p1, t)\r\n{\r\n    return (p1 - p0) * t + p0;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A three-dimensional matrix.\r\n *\r\n * Defaults to the identity matrix when instantiated.\r\n *\r\n * @class Matrix3\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix3} [m] - Optional Matrix3 to copy values from.\r\n */\r\nvar Matrix3 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Matrix3 (m)\r\n    {\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.Math.Matrix3#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.val = new Float32Array(9);\r\n\r\n        if (m)\r\n        {\r\n            //  Assume Matrix3 with val:\r\n            this.copy(m);\r\n        }\r\n        else\r\n        {\r\n            //  Default to identity\r\n            this.identity();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Matrix3.\r\n     *\r\n     * @method Phaser.Math.Matrix3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} A clone of this Matrix3.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Matrix3(this);\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Matrix3.copy`.\r\n     *\r\n     * @method Phaser.Math.Matrix3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to set the values of this Matrix's from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    set: function (src)\r\n    {\r\n        return this.copy(src);\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix into this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        var out = this.val;\r\n        var a = src.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix4 into this Matrix3.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - The Matrix4 to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromMat4: function (m)\r\n    {\r\n        var a = m.val;\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[4];\r\n        out[4] = a[5];\r\n        out[5] = a[6];\r\n        out[6] = a[8];\r\n        out[7] = a[9];\r\n        out[8] = a[10];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given array.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - The array to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromArray: function (a)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    identity: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 1;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 1;\r\n        out[5] = 0;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transpose this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    transpose: function ()\r\n    {\r\n        var a = this.val;\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a12 = a[5];\r\n\r\n        a[1] = a[3];\r\n        a[2] = a[6];\r\n        a[3] = a01;\r\n        a[5] = a[7];\r\n        a[6] = a02;\r\n        a[7] = a12;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        var b01 = a22 * a11 - a12 * a21;\r\n        var b11 = -a22 * a10 + a12 * a20;\r\n        var b21 = a21 * a10 - a11 * a20;\r\n\r\n        // Calculate the determinant\r\n        var det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        a[0] = b01 * det;\r\n        a[1] = (-a22 * a01 + a02 * a21) * det;\r\n        a[2] = (a12 * a01 - a02 * a11) * det;\r\n        a[3] = b11 * det;\r\n        a[4] = (a22 * a00 - a02 * a20) * det;\r\n        a[5] = (-a12 * a00 + a02 * a10) * det;\r\n        a[6] = b21 * det;\r\n        a[7] = (-a21 * a00 + a01 * a20) * det;\r\n        a[8] = (a11 * a00 - a01 * a10) * det;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the adjoint, or adjugate, of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    adjoint: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        a[0] = (a11 * a22 - a12 * a21);\r\n        a[1] = (a02 * a21 - a01 * a22);\r\n        a[2] = (a01 * a12 - a02 * a11);\r\n        a[3] = (a12 * a20 - a10 * a22);\r\n        a[4] = (a00 * a22 - a02 * a20);\r\n        a[5] = (a02 * a10 - a00 * a12);\r\n        a[6] = (a10 * a21 - a11 * a20);\r\n        a[7] = (a01 * a20 - a00 * a21);\r\n        a[8] = (a00 * a11 - a01 * a10);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the determinant of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The determinant of this Matrix.\r\n     */\r\n    determinant: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} src - The Matrix to multiply this Matrix by.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n        var a20 = a[6];\r\n        var a21 = a[7];\r\n        var a22 = a[8];\r\n\r\n        var b = src.val;\r\n\r\n        var b00 = b[0];\r\n        var b01 = b[1];\r\n        var b02 = b[2];\r\n        var b10 = b[3];\r\n        var b11 = b[4];\r\n        var b12 = b[5];\r\n        var b20 = b[6];\r\n        var b21 = b[7];\r\n        var b22 = b[8];\r\n\r\n        a[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n        a[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n        a[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n\r\n        a[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n        a[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n        a[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n\r\n        a[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n        a[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n        a[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix3#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    translate: function (v)\r\n    {\r\n        var a = this.val;\r\n        var x = v.x;\r\n        var y = v.y;\r\n\r\n        a[6] = x * a[0] + y * a[3] + a[6];\r\n        a[7] = x * a[1] + y * a[4] + a[7];\r\n        a[8] = x * a[2] + y * a[5] + a[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a rotation transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    rotate: function (rad)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a10 = a[3];\r\n        var a11 = a[4];\r\n        var a12 = a[5];\r\n\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        a[0] = c * a00 + s * a10;\r\n        a[1] = c * a01 + s * a11;\r\n        a[2] = c * a02 + s * a12;\r\n\r\n        a[3] = c * a10 - s * a00;\r\n        a[4] = c * a11 - s * a01;\r\n        a[5] = c * a12 - s * a02;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * Uses the `x` and `y` components of the given Vector to scale the Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    scale: function (v)\r\n    {\r\n        var a = this.val;\r\n        var x = v.x;\r\n        var y = v.y;\r\n\r\n        a[0] = x * a[0];\r\n        a[1] = x * a[1];\r\n        a[2] = x * a[2];\r\n\r\n        a[3] = y * a[3];\r\n        a[4] = y * a[4];\r\n        a[5] = y * a[5];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Matrix3#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    fromQuat: function (q)\r\n    {\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        var out = this.val;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[3] = xy + wz;\r\n        out[6] = xz - wy;\r\n\r\n        out[1] = xy - wz;\r\n        out[4] = 1 - (xx + zz);\r\n        out[7] = yz + wx;\r\n\r\n        out[2] = xz + wy;\r\n        out[5] = yz - wx;\r\n        out[8] = 1 - (xx + yy);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix3#normalFromMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} m - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix3} This Matrix3.\r\n     */\r\n    normalFromMat4: function (m)\r\n    {\r\n        var a = m.val;\r\n        var out = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n\r\n        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n\r\n        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Matrix3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\nvar EPSILON = 0.000001;\r\n\r\n/**\r\n * @classdesc\r\n * A four-dimensional matrix.\r\n *\r\n * @class Matrix4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Matrix4} [m] - Optional Matrix4 to copy values from.\r\n */\r\nvar Matrix4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Matrix4 (m)\r\n    {\r\n        /**\r\n         * The matrix values.\r\n         *\r\n         * @name Phaser.Math.Matrix4#val\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.val = new Float32Array(16);\r\n\r\n        if (m)\r\n        {\r\n            //  Assume Matrix4 with val:\r\n            this.copy(m);\r\n        }\r\n        else\r\n        {\r\n            //  Default to identity\r\n            this.identity();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Matrix4.\r\n     *\r\n     * @method Phaser.Math.Matrix4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} A clone of this Matrix4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Matrix4(this);\r\n    },\r\n\r\n    //  TODO - Should work with basic values\r\n\r\n    /**\r\n     * This method is an alias for `Matrix4.copy`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    set: function (src)\r\n    {\r\n        return this.copy(src);\r\n    },\r\n\r\n    /**\r\n     * Copy the values of a given Matrix into this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        var out = this.val;\r\n        var a = src.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given array.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromArray\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} a - The array to copy the values from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromArray: function (a)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        out[4] = a[4];\r\n        out[5] = a[5];\r\n        out[6] = a[6];\r\n        out[7] = a[7];\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n        out[12] = a[12];\r\n        out[13] = a[13];\r\n        out[14] = a[14];\r\n        out[15] = a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix.\r\n     *\r\n     * Sets all values to `0`.\r\n     *\r\n     * @method Phaser.Math.Matrix4#zero\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    zero: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 0;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 0;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 0;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y` and `z` values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#xyz\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value.\r\n     * @param {number} y - The y value.\r\n     * @param {number} z - The z value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    xyz: function (x, y, z)\r\n    {\r\n        this.identity();\r\n\r\n        var out = this.val;\r\n\r\n        out[12] = x;\r\n        out[13] = y;\r\n        out[14] = z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the scaling values of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaling\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x scaling value.\r\n     * @param {number} y - The y scaling value.\r\n     * @param {number} z - The z scaling value.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaling: function (x, y, z)\r\n    {\r\n        this.zero();\r\n\r\n        var out = this.val;\r\n\r\n        out[0] = x;\r\n        out[5] = y;\r\n        out[10] = z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    identity: function ()\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = 1;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n        out[4] = 0;\r\n        out[5] = 1;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 1;\r\n        out[11] = 0;\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transpose this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#transpose\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    transpose: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n        var a23 = a[11];\r\n\r\n        a[1] = a[4];\r\n        a[2] = a[8];\r\n        a[3] = a[12];\r\n        a[4] = a01;\r\n        a[6] = a[9];\r\n        a[7] = a[13];\r\n        a[8] = a02;\r\n        a[9] = a12;\r\n        a[11] = a[14];\r\n        a[12] = a03;\r\n        a[13] = a13;\r\n        a[14] = a23;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        det = 1 / det;\r\n\r\n        a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n        a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n        a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n        a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n        a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n        a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n        a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n        a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n        a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n        a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the adjoint, or adjugate, of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#adjoint\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    adjoint: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        a[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\r\n        a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n        a[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\r\n        a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n        a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n        a[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\r\n        a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n        a[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\r\n        a[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\r\n        a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n        a[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\r\n        a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n        a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n        a[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\r\n        a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n        a[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the determinant of this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#determinant\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The determinant of this Matrix.\r\n     */\r\n    determinant: function ()\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b00 = a00 * a11 - a01 * a10;\r\n        var b01 = a00 * a12 - a02 * a10;\r\n        var b02 = a00 * a13 - a03 * a10;\r\n        var b03 = a01 * a12 - a02 * a11;\r\n        var b04 = a01 * a13 - a03 * a11;\r\n        var b05 = a02 * a13 - a03 * a12;\r\n        var b06 = a20 * a31 - a21 * a30;\r\n        var b07 = a20 * a32 - a22 * a30;\r\n        var b08 = a20 * a33 - a23 * a30;\r\n        var b09 = a21 * a32 - a22 * a31;\r\n        var b10 = a21 * a33 - a23 * a31;\r\n        var b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Matrix by the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        var a = this.val;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        var a30 = a[12];\r\n        var a31 = a[13];\r\n        var a32 = a[14];\r\n        var a33 = a[15];\r\n\r\n        var b = src.val;\r\n\r\n        // Cache only the current line of the second matrix\r\n        var b0 = b[0];\r\n        var b1 = b[1];\r\n        var b2 = b[2];\r\n        var b3 = b[3];\r\n\r\n        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[4];\r\n        b1 = b[5];\r\n        b2 = b[6];\r\n        b3 = b[7];\r\n\r\n        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[8];\r\n        b1 = b[9];\r\n        b2 = b[10];\r\n        b3 = b[11];\r\n\r\n        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[12];\r\n        b1 = b[13];\r\n        b2 = b[14];\r\n        b3 = b[15];\r\n\r\n        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Matrix4#multiplyLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} src - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    multiplyLocal: function (src)\r\n    {\r\n        var a = [];\r\n        var m1 = this.val;\r\n        var m2 = src.val;\r\n\r\n        a[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];\r\n        a[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];\r\n        a[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];\r\n        a[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];\r\n\r\n        a[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];\r\n        a[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];\r\n        a[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];\r\n        a[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];\r\n\r\n        a[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];\r\n        a[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];\r\n        a[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];\r\n        a[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];\r\n\r\n        a[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];\r\n        a[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];\r\n        a[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];\r\n        a[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];\r\n\r\n        return this.fromArray(a);\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translate: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translate this Matrix using the given values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#translateXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    translateXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scale: function (v)\r\n    {\r\n        var x = v.x;\r\n        var y = v.y;\r\n        var z = v.z;\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a scale transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#scaleXYZ\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x component.\r\n     * @param {number} y - The y component.\r\n     * @param {number} z - The z component.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    scaleXYZ: function (x, y, z)\r\n    {\r\n        var a = this.val;\r\n\r\n        a[0] = a[0] * x;\r\n        a[1] = a[1] * x;\r\n        a[2] = a[2] * x;\r\n        a[3] = a[3] * x;\r\n\r\n        a[4] = a[4] * y;\r\n        a[5] = a[5] * y;\r\n        a[6] = a[6] * y;\r\n        a[7] = a[7] * y;\r\n\r\n        a[8] = a[8] * z;\r\n        a[9] = a[9] * z;\r\n        a[10] = a[10] * z;\r\n        a[11] = a[11] * z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Derive a rotation matrix around the given axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#makeRotationAxis\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.\r\n     * @param {number} angle - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    makeRotationAxis: function (axis, angle)\r\n    {\r\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n        var c = Math.cos(angle);\r\n        var s = Math.sin(angle);\r\n        var t = 1 - c;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var tx = t * x;\r\n        var ty = t * y;\r\n\r\n        this.fromArray([\r\n            tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n            tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n            0, 0, 0, 1\r\n        ]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a rotation transformation to this Matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotate: function (rad, axis)\r\n    {\r\n        var a = this.val;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var len = Math.sqrt(x * x + y * y + z * z);\r\n\r\n        if (Math.abs(len) < EPSILON)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        len = 1 / len;\r\n        x *= len;\r\n        y *= len;\r\n        z *= len;\r\n\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n        var t = 1 - c;\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Construct the elements of the rotation matrix\r\n        var b00 = x * x * t + c;\r\n        var b01 = y * x * t + z * s;\r\n        var b02 = z * x * t - y * s;\r\n\r\n        var b10 = x * y * t - z * s;\r\n        var b11 = y * y * t + c;\r\n        var b12 = z * y * t + x * s;\r\n\r\n        var b20 = x * z * t + y * s;\r\n        var b21 = y * z * t - x * s;\r\n        var b22 = z * z * t + c;\r\n\r\n        // Perform rotation-specific matrix multiplication\r\n        a[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n        a[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n        a[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n        a[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n        a[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n        a[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n        a[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n        a[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n        a[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n        a[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n        a[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n        a[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its X axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle in radians to rotate by.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateX: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[4] = a10 * c + a20 * s;\r\n        a[5] = a11 * c + a21 * s;\r\n        a[6] = a12 * c + a22 * s;\r\n        a[7] = a13 * c + a23 * s;\r\n        a[8] = a20 * c - a10 * s;\r\n        a[9] = a21 * c - a11 * s;\r\n        a[10] = a22 * c - a12 * s;\r\n        a[11] = a23 * c - a13 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Y axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateY: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a20 = a[8];\r\n        var a21 = a[9];\r\n        var a22 = a[10];\r\n        var a23 = a[11];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c - a20 * s;\r\n        a[1] = a01 * c - a21 * s;\r\n        a[2] = a02 * c - a22 * s;\r\n        a[3] = a03 * c - a23 * s;\r\n        a[8] = a00 * s + a20 * c;\r\n        a[9] = a01 * s + a21 * c;\r\n        a[10] = a02 * s + a22 * c;\r\n        a[11] = a03 * s + a23 * c;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this matrix on its Z axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    rotateZ: function (rad)\r\n    {\r\n        var a = this.val;\r\n        var s = Math.sin(rad);\r\n        var c = Math.cos(rad);\r\n\r\n        var a00 = a[0];\r\n        var a01 = a[1];\r\n        var a02 = a[2];\r\n        var a03 = a[3];\r\n\r\n        var a10 = a[4];\r\n        var a11 = a[5];\r\n        var a12 = a[6];\r\n        var a13 = a[7];\r\n\r\n        // Perform axis-specific matrix multiplication\r\n        a[0] = a00 * c + a10 * s;\r\n        a[1] = a01 * c + a11 * s;\r\n        a[2] = a02 * c + a12 * s;\r\n        a[3] = a03 * c + a13 * s;\r\n        a[4] = a10 * c - a00 * s;\r\n        a[5] = a11 * c - a01 * s;\r\n        a[6] = a12 * c - a02 * s;\r\n        a[7] = a13 * c - a03 * s;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given rotation Quaternion and translation Vector.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromRotationTranslation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.\r\n     * @param {Phaser.Math.Vector3} v - The Vector to set translation from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromRotationTranslation: function (q, v)\r\n    {\r\n        // Quaternion math\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = v.x;\r\n        out[13] = v.y;\r\n        out[14] = v.z;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this Matrix from the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Matrix4#fromQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    fromQuat: function (q)\r\n    {\r\n        var out = this.val;\r\n\r\n        var x = q.x;\r\n        var y = q.y;\r\n        var z = q.z;\r\n        var w = q.w;\r\n\r\n        var x2 = x + x;\r\n        var y2 = y + y;\r\n        var z2 = z + z;\r\n\r\n        var xx = x * x2;\r\n        var xy = x * y2;\r\n        var xz = x * z2;\r\n\r\n        var yy = y * y2;\r\n        var yz = y * z2;\r\n        var zz = z * z2;\r\n\r\n        var wx = w * x2;\r\n        var wy = w * y2;\r\n        var wz = w * z2;\r\n\r\n        out[0] = 1 - (yy + zz);\r\n        out[1] = xy + wz;\r\n        out[2] = xz - wy;\r\n        out[3] = 0;\r\n\r\n        out[4] = xy - wz;\r\n        out[5] = 1 - (xx + zz);\r\n        out[6] = yz + wx;\r\n        out[7] = 0;\r\n\r\n        out[8] = xz + wy;\r\n        out[9] = yz - wx;\r\n        out[10] = 1 - (xx + yy);\r\n        out[11] = 0;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a frustum matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#frustum\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    frustum: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        var rl = 1 / (right - left);\r\n        var tb = 1 / (top - bottom);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = (near * 2) * rl;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (near * 2) * tb;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = (right + left) * rl;\r\n        out[9] = (top + bottom) * tb;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (far * near * 2) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspective\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} fovy - Vertical field of view in radians\r\n     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspective: function (fovy, aspect, near, far)\r\n    {\r\n        var out = this.val;\r\n        var f = 1.0 / Math.tan(fovy / 2);\r\n        var nf = 1 / (near - far);\r\n\r\n        out[0] = f / aspect;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = f;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = (far + near) * nf;\r\n        out[11] = -1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (2 * far * near) * nf;\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a perspective projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#perspectiveLH\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the frustum.\r\n     * @param {number} height - The height of the frustum.\r\n     * @param {number} near - Near bound of the frustum.\r\n     * @param {number} far - Far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    perspectiveLH: function (width, height, near, far)\r\n    {\r\n        var out = this.val;\r\n\r\n        out[0] = (2 * near) / width;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = (2 * near) / height;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = -far / (near - far);\r\n        out[11] = 1;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = (near * far) / (near - far);\r\n        out[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate an orthogonal projection matrix with the given bounds.\r\n     *\r\n     * @method Phaser.Math.Matrix4#ortho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} left - The left bound of the frustum.\r\n     * @param {number} right - The right bound of the frustum.\r\n     * @param {number} bottom - The bottom bound of the frustum.\r\n     * @param {number} top - The top bound of the frustum.\r\n     * @param {number} near - The near bound of the frustum.\r\n     * @param {number} far - The far bound of the frustum.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    ortho: function (left, right, bottom, top, near, far)\r\n    {\r\n        var out = this.val;\r\n        var lr = left - right;\r\n        var bt = bottom - top;\r\n        var nf = near - far;\r\n\r\n        //  Avoid division by zero\r\n        lr = (lr === 0) ? lr : 1 / lr;\r\n        bt = (bt === 0) ? bt : 1 / bt;\r\n        nf = (nf === 0) ? nf : 1 / nf;\r\n\r\n        out[0] = -2 * lr;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 0;\r\n\r\n        out[4] = 0;\r\n        out[5] = -2 * bt;\r\n        out[6] = 0;\r\n        out[7] = 0;\r\n\r\n        out[8] = 0;\r\n        out[9] = 0;\r\n        out[10] = 2 * nf;\r\n        out[11] = 0;\r\n\r\n        out[12] = (left + right) * lr;\r\n        out[13] = (top + bottom) * bt;\r\n        out[14] = (far + near) * nf;\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a look-at matrix with the given eye position, focal point, and up axis.\r\n     *\r\n     * @method Phaser.Math.Matrix4#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} eye - Position of the viewer\r\n     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\r\n     * @param {Phaser.Math.Vector3} up - vec3 pointing up.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    lookAt: function (eye, center, up)\r\n    {\r\n        var out = this.val;\r\n\r\n        var eyex = eye.x;\r\n        var eyey = eye.y;\r\n        var eyez = eye.z;\r\n\r\n        var upx = up.x;\r\n        var upy = up.y;\r\n        var upz = up.z;\r\n\r\n        var centerx = center.x;\r\n        var centery = center.y;\r\n        var centerz = center.z;\r\n\r\n        if (Math.abs(eyex - centerx) < EPSILON &&\r\n            Math.abs(eyey - centery) < EPSILON &&\r\n            Math.abs(eyez - centerz) < EPSILON)\r\n        {\r\n            return this.identity();\r\n        }\r\n\r\n        var z0 = eyex - centerx;\r\n        var z1 = eyey - centery;\r\n        var z2 = eyez - centerz;\r\n\r\n        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n\r\n        z0 *= len;\r\n        z1 *= len;\r\n        z2 *= len;\r\n\r\n        var x0 = upy * z2 - upz * z1;\r\n        var x1 = upz * z0 - upx * z2;\r\n        var x2 = upx * z1 - upy * z0;\r\n\r\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n\r\n        if (!len)\r\n        {\r\n            x0 = 0;\r\n            x1 = 0;\r\n            x2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            x0 *= len;\r\n            x1 *= len;\r\n            x2 *= len;\r\n        }\r\n\r\n        var y0 = z1 * x2 - z2 * x1;\r\n        var y1 = z2 * x0 - z0 * x2;\r\n        var y2 = z0 * x1 - z1 * x0;\r\n\r\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n\r\n        if (!len)\r\n        {\r\n            y0 = 0;\r\n            y1 = 0;\r\n            y2 = 0;\r\n        }\r\n        else\r\n        {\r\n            len = 1 / len;\r\n            y0 *= len;\r\n            y1 *= len;\r\n            y2 *= len;\r\n        }\r\n\r\n        out[0] = x0;\r\n        out[1] = y0;\r\n        out[2] = z0;\r\n        out[3] = 0;\r\n\r\n        out[4] = x1;\r\n        out[5] = y1;\r\n        out[6] = z1;\r\n        out[7] = 0;\r\n\r\n        out[8] = x2;\r\n        out[9] = y2;\r\n        out[10] = z2;\r\n        out[11] = 0;\r\n\r\n        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n        out[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.\r\n     *\r\n     * @method Phaser.Math.Matrix4#yawPitchRoll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yaw - [description]\r\n     * @param {number} pitch - [description]\r\n     * @param {number} roll - [description]\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    yawPitchRoll: function (yaw, pitch, roll)\r\n    {\r\n        this.zero();\r\n        _tempMat1.zero();\r\n        _tempMat2.zero();\r\n\r\n        var m0 = this.val;\r\n        var m1 = _tempMat1.val;\r\n        var m2 = _tempMat2.val;\r\n\r\n        //  Rotate Z\r\n        var s = Math.sin(roll);\r\n        var c = Math.cos(roll);\r\n\r\n        m0[10] = 1;\r\n        m0[15] = 1;\r\n        m0[0] = c;\r\n        m0[1] = s;\r\n        m0[4] = -s;\r\n        m0[5] = c;\r\n\r\n        //  Rotate X\r\n        s = Math.sin(pitch);\r\n        c = Math.cos(pitch);\r\n\r\n        m1[0] = 1;\r\n        m1[15] = 1;\r\n        m1[5] = c;\r\n        m1[10] = c;\r\n        m1[9] = -s;\r\n        m1[6] = s;\r\n\r\n        //  Rotate Y\r\n        s = Math.sin(yaw);\r\n        c = Math.cos(yaw);\r\n\r\n        m2[5] = 1;\r\n        m2[15] = 1;\r\n        m2[0] = c;\r\n        m2[2] = -s;\r\n        m2[8] = s;\r\n        m2[10] = c;\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.\r\n     *\r\n     * @method Phaser.Math.Matrix4#setWorldMatrix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.\r\n     * @param {Phaser.Math.Vector3} position - The position of the world matrix.\r\n     * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.\r\n     * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.\r\n     * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.\r\n     *\r\n     * @return {Phaser.Math.Matrix4} This Matrix4.\r\n     */\r\n    setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix)\r\n    {\r\n        this.yawPitchRoll(rotation.y, rotation.x, rotation.z);\r\n\r\n        _tempMat1.scaling(scale.x, scale.y, scale.z);\r\n        _tempMat2.xyz(position.x, position.y, position.z);\r\n\r\n        this.multiplyLocal(_tempMat1);\r\n        this.multiplyLocal(_tempMat2);\r\n\r\n        if (viewMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(viewMatrix);\r\n        }\r\n\r\n        if (projectionMatrix !== undefined)\r\n        {\r\n            this.multiplyLocal(projectionMatrix);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nvar _tempMat1 = new Matrix4();\r\nvar _tempMat2 = new Matrix4();\r\n\r\nmodule.exports = Matrix4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Add an `amount` to a `value`, limiting the maximum result to `max`.\r\n *\r\n * @function Phaser.Math.MaxAdd\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to add to.\r\n * @param {number} amount - The amount to add.\r\n * @param {number} max - The maximum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MaxAdd = function (value, amount, max)\r\n{\r\n    return Math.min(value + amount, max);\r\n};\r\n\r\nmodule.exports = MaxAdd;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Subtract an `amount` from `value`, limiting the minimum result to `min`.\r\n *\r\n * @function Phaser.Math.MinSub\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to subtract from.\r\n * @param {number} amount - The amount to subtract.\r\n * @param {number} min - The minimum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MinSub = function (value, amount, min)\r\n{\r\n    return Math.max(value - amount, min);\r\n};\r\n\r\nmodule.exports = MinSub;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Work out what percentage `value` is of the range between `min` and `max`.\r\n * If `max` isn't given then it will return the percentage of `value` to `min`.\r\n *\r\n * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.\r\n *\r\n * @function Phaser.Math.Percent\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to determine the percentage of.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n * @param {number} [upperMax] - The mid-way point in the range that represents 100%.\r\n *\r\n * @return {number} A value between 0 and 1 representing the percentage.\r\n */\r\nvar Percent = function (value, min, max, upperMax)\r\n{\r\n    if (max === undefined) { max = min + 1; }\r\n\r\n    var percentage = (value - min) / (max - min);\r\n\r\n    if (percentage > 1)\r\n    {\r\n        if (upperMax !== undefined)\r\n        {\r\n            percentage = ((upperMax - value)) / (upperMax - max);\r\n\r\n            if (percentage < 0)\r\n            {\r\n                percentage = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            percentage = 1;\r\n        }\r\n    }\r\n    else if (percentage < 0)\r\n    {\r\n        percentage = 0;\r\n    }\r\n\r\n    return percentage;\r\n};\r\n\r\nmodule.exports = Percent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\nvar Vector3 = require('./Vector3');\r\nvar Matrix3 = require('./Matrix3');\r\n\r\nvar EPSILON = 0.000001;\r\n\r\n//  Some shared 'private' arrays\r\nvar siNext = new Int8Array([ 1, 2, 0 ]);\r\nvar tmp = new Float32Array([ 0, 0, 0 ]);\r\n\r\nvar xUnitVec3 = new Vector3(1, 0, 0);\r\nvar yUnitVec3 = new Vector3(0, 1, 0);\r\n\r\nvar tmpvec = new Vector3();\r\nvar tmpMat3 = new Matrix3();\r\n\r\n/**\r\n * @classdesc\r\n * A quaternion.\r\n *\r\n * @class Quaternion\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Quaternion = new Class({\r\n\r\n    initialize:\r\n\r\n    function Quaternion (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The y component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The z component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        /**\r\n         * The w component of this Quaternion.\r\n         *\r\n         * @name Phaser.Math.Quaternion#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Quaternion or Vector into this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z;\r\n        this.w = src.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the components of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.\r\n     * @param {number} [y=0] - The y component.\r\n     * @param {number} [z=0] - The z component.\r\n     * @param {number} [w=0] - The w component.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Quaternion#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        this.w += v.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Quaternion#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z;\r\n        this.w -= v.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Quaternion by the given value.\r\n     *\r\n     * @method Phaser.Math.Quaternion#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Quaternion by.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Quaternion.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Quaternion squared.\r\n     *\r\n     * @method Phaser.Math.Quaternion#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Quaternion, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Quaternion and the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.\r\n     *\r\n     * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.\r\n     * @param {number} [t=0] - The percentage of interpolation.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotationTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - [description]\r\n     * @param {Phaser.Math.Vector3} b - [description]\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotationTo: function (a, b)\r\n    {\r\n        var dot = a.x * b.x + a.y * b.y + a.z * b.z;\r\n\r\n        if (dot < -0.999999)\r\n        {\r\n            if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON)\r\n            {\r\n                tmpvec.copy(yUnitVec3).cross(a);\r\n            }\r\n\r\n            tmpvec.normalize();\r\n\r\n            return this.setAxisAngle(tmpvec, Math.PI);\r\n\r\n        }\r\n        else if (dot > 0.999999)\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.z = 0;\r\n            this.w = 1;\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            tmpvec.copy(a).cross(b);\r\n\r\n            this.x = tmpvec.x;\r\n            this.y = tmpvec.y;\r\n            this.z = tmpvec.z;\r\n            this.w = 1 + dot;\r\n\r\n            return this.normalize();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Set the axes of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxes\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} view - The view axis.\r\n     * @param {Phaser.Math.Vector3} right - The right axis.\r\n     * @param {Phaser.Math.Vector3} up - The upwards axis.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    setAxes: function (view, right, up)\r\n    {\r\n        var m = tmpMat3.val;\r\n\r\n        m[0] = right.x;\r\n        m[3] = right.y;\r\n        m[6] = right.z;\r\n\r\n        m[1] = up.x;\r\n        m[4] = up.y;\r\n        m[7] = up.z;\r\n\r\n        m[2] = -view.x;\r\n        m[5] = -view.y;\r\n        m[8] = -view.z;\r\n\r\n        return this.fromMat3(tmpMat3).normalize();\r\n    },\r\n\r\n    /**\r\n     * Reset this Matrix to an identity (default) Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#identity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    identity: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the axis angle of this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#setAxisAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} axis - The axis.\r\n     * @param {number} rad - The angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    setAxisAngle: function (axis, rad)\r\n    {\r\n        rad = rad * 0.5;\r\n\r\n        var s = Math.sin(rad);\r\n\r\n        this.x = s * axis.x;\r\n        this.y = s * axis.y;\r\n        this.z = s * axis.z;\r\n        this.w = Math.cos(rad);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiply this Quaternion by the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    multiply: function (b)\r\n    {\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n        var bw = b.w;\r\n\r\n        this.x = ax * bw + aw * bx + ay * bz - az * by;\r\n        this.y = ay * bw + aw * by + az * bx - ax * bz;\r\n        this.z = az * bw + aw * bz + ax * by - ay * bx;\r\n        this.w = aw * bw - ax * bx - ay * by - az * bz;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.\r\n     *\r\n     * @method Phaser.Math.Quaternion#slerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.\r\n     * @param {number} t - The percentage of interpolation.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    slerp: function (b, t)\r\n    {\r\n        // benchmarks: http://jsperf.com/quaternion-slerp-implementations\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n        var bw = b.w;\r\n\r\n        // calc cosine\r\n        var cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n\r\n        // adjust signs (if necessary)\r\n        if (cosom < 0)\r\n        {\r\n            cosom = -cosom;\r\n            bx = - bx;\r\n            by = - by;\r\n            bz = - bz;\r\n            bw = - bw;\r\n        }\r\n\r\n        // \"from\" and \"to\" quaternions are very close\r\n        //  ... so we can do a linear interpolation\r\n        var scale0 = 1 - t;\r\n        var scale1 = t;\r\n\r\n        // calculate coefficients\r\n        if ((1 - cosom) > EPSILON)\r\n        {\r\n            // standard case (slerp)\r\n            var omega = Math.acos(cosom);\r\n            var sinom = Math.sin(omega);\r\n\r\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n            scale1 = Math.sin(t * omega) / sinom;\r\n        }\r\n\r\n        // calculate final values\r\n        this.x = scale0 * ax + scale1 * bx;\r\n        this.y = scale0 * ay + scale1 * by;\r\n        this.z = scale0 * az + scale1 * bz;\r\n        this.w = scale0 * aw + scale1 * bw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Invert this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#invert\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    invert: function ()\r\n    {\r\n        var a0 = this.x;\r\n        var a1 = this.y;\r\n        var a2 = this.z;\r\n        var a3 = this.w;\r\n\r\n        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n        var invDot = (dot) ? 1 / dot : 0;\r\n\r\n        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n\r\n        this.x = -a0 * invDot;\r\n        this.y = -a1 * invDot;\r\n        this.z = -a2 * invDot;\r\n        this.w = a3 * invDot;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Convert this Quaternion into its conjugate.\r\n     *\r\n     * Sets the x, y and z components.\r\n     *\r\n     * @method Phaser.Math.Quaternion#conjugate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    conjugate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the X axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateX: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bx = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw + aw * bx;\r\n        this.y = ay * bw + az * bx;\r\n        this.z = az * bw - ay * bx;\r\n        this.w = aw * bw - ax * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the Y axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateY: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var by = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw - az * by;\r\n        this.y = ay * bw + aw * by;\r\n        this.z = az * bw + ax * by;\r\n        this.w = aw * bw - ay * by;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Quaternion on the Z axis.\r\n     *\r\n     * @method Phaser.Math.Quaternion#rotateZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rad - The rotation angle in radians.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    rotateZ: function (rad)\r\n    {\r\n        rad *= 0.5;\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        var bz = Math.sin(rad);\r\n        var bw = Math.cos(rad);\r\n\r\n        this.x = ax * bw + ay * bz;\r\n        this.y = ay * bw - ax * bz;\r\n        this.z = az * bw + aw * bz;\r\n        this.w = aw * bw - az * bz;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Create a unit (or rotation) Quaternion from its x, y, and z components.\r\n     *\r\n     * Sets the w component.\r\n     *\r\n     * @method Phaser.Math.Quaternion#calculateW\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    calculateW: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        this.w = -Math.sqrt(1.0 - x * x - y * y - z * z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Convert the given Matrix into this Quaternion.\r\n     *\r\n     * @method Phaser.Math.Quaternion#fromMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.\r\n     *\r\n     * @return {Phaser.Math.Quaternion} This Quaternion.\r\n     */\r\n    fromMat3: function (mat)\r\n    {\r\n        // benchmarks:\r\n        //    http://jsperf.com/typed-array-access-speed\r\n        //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion\r\n\r\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n        // article \"Quaternion Calculus and Fast Animation\".\r\n        var m = mat.val;\r\n        var fTrace = m[0] + m[4] + m[8];\r\n        var fRoot;\r\n\r\n        if (fTrace > 0)\r\n        {\r\n            // |w| > 1/2, may as well choose w > 1/2\r\n            fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n\r\n            this.w = 0.5 * fRoot;\r\n\r\n            fRoot = 0.5 / fRoot; // 1/(4w)\r\n\r\n            this.x = (m[7] - m[5]) * fRoot;\r\n            this.y = (m[2] - m[6]) * fRoot;\r\n            this.z = (m[3] - m[1]) * fRoot;\r\n        }\r\n        else\r\n        {\r\n            // |w| <= 1/2\r\n            var i = 0;\r\n\r\n            if (m[4] > m[0])\r\n            {\r\n                i = 1;\r\n            }\r\n\r\n            if (m[8] > m[i * 3 + i])\r\n            {\r\n                i = 2;\r\n            }\r\n\r\n            var j = siNext[i];\r\n            var k = siNext[j];\r\n\r\n            //  This isn't quite as clean without array access\r\n            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);\r\n            tmp[i] = 0.5 * fRoot;\r\n\r\n            fRoot = 0.5 / fRoot;\r\n\r\n            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n\r\n            this.x = tmp[0];\r\n            this.y = tmp[1];\r\n            this.z = tmp[2];\r\n            this.w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Quaternion;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle in radians, to the equivalent angle in degrees.\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {number} radians - The angle in radians to convert ot degrees.\r\n *\r\n * @return {integer} The given angle converted to degrees.\r\n */\r\nvar RadToDeg = function (radians)\r\n{\r\n    return radians * CONST.RAD_TO_DEG;\r\n};\r\n\r\nmodule.exports = RadToDeg;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random unit vector.\r\n *\r\n * Computes random values for the given vector between -1 and 1 that can be used to represent a direction.\r\n *\r\n * Optionally accepts a scale value to scale the resulting vector by.\r\n *\r\n * @function Phaser.Math.RandomXY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2} vector - The Vector to compute random values for.\r\n * @param {number} [scale=1] - The scale of the random values.\r\n *\r\n * @return {Phaser.Math.Vector2} The given Vector.\r\n */\r\nvar RandomXY = function (vector, scale)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n\r\n    var r = Math.random() * 2 * Math.PI;\r\n\r\n    vector.x = Math.cos(r) * scale;\r\n    vector.y = Math.sin(r) * scale;\r\n\r\n    return vector;\r\n};\r\n\r\nmodule.exports = RandomXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random position vector in a spherical area, optionally defined by the given radius.\r\n *\r\n * @function Phaser.Math.RandomXYZ\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec3 - The Vector to compute random values for.\r\n * @param {number} [radius=1] - The radius.\r\n *\r\n * @return {Phaser.Math.Vector3} The given Vector.\r\n */\r\nvar RandomXYZ = function (vec3, radius)\r\n{\r\n    if (radius === undefined) { radius = 1; }\r\n\r\n    var r = Math.random() * 2 * Math.PI;\r\n    var z = (Math.random() * 2) - 1;\r\n    var zScale = Math.sqrt(1 - z * z) * radius;\r\n\r\n    vec3.x = Math.cos(r) * zScale;\r\n    vec3.y = Math.sin(r) * zScale;\r\n    vec3.z = z * radius;\r\n\r\n    return vec3;\r\n};\r\n\r\nmodule.exports = RandomXYZ;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random four-dimensional vector.\r\n *\r\n * @function Phaser.Math.RandomXYZW\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector4} vec4 - The Vector to compute random values for.\r\n * @param {number} [scale=1] - The scale of the random values.\r\n *\r\n * @return {Phaser.Math.Vector4} The given Vector.\r\n */\r\nvar RandomXYZW = function (vec4, scale)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n\r\n    // TODO: Not spherical; should fix this for more uniform distribution\r\n    vec4.x = (Math.random() * 2 - 1) * scale;\r\n    vec4.y = (Math.random() * 2 - 1) * scale;\r\n    vec4.z = (Math.random() * 2 - 1) * scale;\r\n    vec4.w = (Math.random() * 2 - 1) * scale;\r\n\r\n    return vec4;\r\n};\r\n\r\nmodule.exports = RandomXYZW;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a given point by a given angle around the origin (0, 0), in an anti-clockwise direction.\r\n *\r\n * @function Phaser.Math.Rotate\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} angle - The angle to be rotated by in an anticlockwise direction.\r\n *\r\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle in an anticlockwise direction.\r\n */\r\nvar Rotate = function (point, angle)\r\n{\r\n    var x = point.x;\r\n    var y = point.y;\r\n\r\n    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));\r\n    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle`.\r\n *\r\n * @function Phaser.Math.RotateAround\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle around the given coordinates.\r\n */\r\nvar RotateAround = function (point, x, y, angle)\r\n{\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var tx = point.x - x;\r\n    var ty = point.y - y;\r\n\r\n    point.x = tx * c - ty * s + x;\r\n    point.y = tx * s + ty * c + y;\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAround;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.\r\n *\r\n * @function Phaser.Math.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n * @param {number} distance - The distance from (x, y) to place the point at.\r\n *\r\n * @return {Phaser.Geom.Point} The given point.\r\n */\r\nvar RotateAroundDistance = function (point, x, y, angle, distance)\r\n{\r\n    var t = angle + Math.atan2(point.y - y, point.x - x);\r\n\r\n    point.x = x + (distance * Math.cos(t));\r\n    point.y = y + (distance * Math.sin(t));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAroundDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector3 = require('../math/Vector3');\r\nvar Matrix4 = require('../math/Matrix4');\r\nvar Quaternion = require('../math/Quaternion');\r\n\r\nvar tmpMat4 = new Matrix4();\r\nvar tmpQuat = new Quaternion();\r\nvar tmpVec3 = new Vector3();\r\n\r\n/**\r\n * Rotates a vector in place by axis angle.\r\n *\r\n * This is the same as transforming a point by an\r\n * axis-angle quaternion, but it has higher precision.\r\n *\r\n * @function Phaser.Math.RotateVec3\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector3} vec - The vector to be rotated.\r\n * @param {Phaser.Math.Vector3} axis - The axis to rotate around.\r\n * @param {number} radians - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Math.Vector3} The given vector.\r\n */\r\nvar RotateVec3 = function (vec, axis, radians)\r\n{\r\n    //  Set the quaternion to our axis angle\r\n    tmpQuat.setAxisAngle(axis, radians);\r\n\r\n    //  Create a rotation matrix from the axis angle\r\n    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));\r\n\r\n    //  Multiply our vector by the rotation matrix\r\n    return vec.transformMat4(tmpMat4);\r\n};\r\n\r\nmodule.exports = RotateVec3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.\r\n *\r\n * @function Phaser.Math.RoundAwayFromZero\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to round.\r\n *\r\n * @return {number} The rounded number, rounded away from zero.\r\n */\r\nvar RoundAwayFromZero = function (value)\r\n{\r\n    // \"Opposite\" of truncate.\r\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\r\n};\r\n\r\nmodule.exports = RoundAwayFromZero;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a value to the given precision.\r\n * \r\n * For example:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456, 0) = 123\r\n * RoundTo(123.456, 1) = 120\r\n * RoundTo(123.456, 2) = 100\r\n * ```\r\n * \r\n * To round the decimal, i.e. to round to precision, pass in a negative `place`:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456789, 0) = 123\r\n * RoundTo(123.456789, -1) = 123.5\r\n * RoundTo(123.456789, -2) = 123.46\r\n * RoundTo(123.456789, -3) = 123.457\r\n * ```\r\n *\r\n * @function Phaser.Math.RoundTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {integer} [place=0] - The place to round to. Positive to round the units, negative to round the decimal.\r\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar RoundTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.round(value * p) / p;\r\n};\r\n\r\nmodule.exports = RoundTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a series of sine and cosine values.\r\n *\r\n * @function Phaser.Math.SinCosTableGenerator\r\n * @since 3.0.0\r\n *\r\n * @param {number} length - The number of values to generate.\r\n * @param {number} [sinAmp=1] - The sine value amplitude.\r\n * @param {number} [cosAmp=1] - The cosine value amplitude.\r\n * @param {number} [frequency=1] - The frequency of the values.\r\n *\r\n * @return {Phaser.Types.Math.SinCosTable} The generated values.\r\n */\r\nvar SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)\r\n{\r\n    if (sinAmp === undefined) { sinAmp = 1; }\r\n    if (cosAmp === undefined) { cosAmp = 1; }\r\n    if (frequency === undefined) { frequency = 1; }\r\n\r\n    frequency *= Math.PI / length;\r\n\r\n    var cos = [];\r\n    var sin = [];\r\n\r\n    for (var c = 0; c < length; c++)\r\n    {\r\n        cosAmp -= sinAmp * frequency;\r\n        sinAmp += cosAmp * frequency;\r\n\r\n        cos[c] = cosAmp;\r\n        sin[c] = sinAmp;\r\n    }\r\n\r\n    return {\r\n        sin: sin,\r\n        cos: cos,\r\n        length: length\r\n    };\r\n};\r\n\r\nmodule.exports = SinCosTableGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmoothStep = function (x, min, max)\r\n{\r\n    if (x <= min)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (x >= max)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    x = (x - min) / (max - min);\r\n\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smoother interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.\r\n *\r\n * @function Phaser.Math.SmootherStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmootherStep = function (x, min, max)\r\n{\r\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\r\n\r\n    return x * x * x * (x * (x * 6 - 15) + 10);\r\n};\r\n\r\nmodule.exports = SmootherStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Returns a Vec2 containing the x and y position of the given index in a `width` x `height` sized grid.\r\n * \r\n * For example, in a 6 x 4 grid, index 16 would equal x: 4 y: 2.\r\n * \r\n * If the given index is out of range an empty Vec2 is returned.\r\n *\r\n * @function Phaser.Math.ToXY\r\n * @since 3.19.0\r\n *\r\n * @param {integer} index - The position within the grid to get the x/y value for.\r\n * @param {integer} width - The width of the grid.\r\n * @param {integer} height - The height of the grid.\r\n * @param {Phaser.Math.Vector2} [out] - An optional Vector2 to store the result in. If not given, a new Vector2 instance will be created.\r\n *\r\n * @return {Phaser.Math.Vector2} A Vector2 where the x and y properties contain the given grid index.\r\n */\r\nvar ToXY = function (index, width, height, out)\r\n{\r\n    if (out === undefined) { out = new Vector2(); }\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n    var total = width * height;\r\n\r\n    if (index > 0 && index <= total)\r\n    {\r\n        if (index > width - 1)\r\n        {\r\n            y = Math.floor(index / width);\r\n            x = index - (y * width);\r\n        }\r\n        else\r\n        {\r\n            x = index;\r\n        }\r\n\r\n        out.set(x, y);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Takes the `x` and `y` coordinates and transforms them into the same space as\r\n * defined by the position, rotation and scale values.\r\n *\r\n * @function Phaser.Math.TransformXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x coordinate to be transformed.\r\n * @param {number} y - The y coordinate to be transformed.\r\n * @param {number} positionX - Horizontal position of the transform point.\r\n * @param {number} positionY - Vertical position of the transform point.\r\n * @param {number} rotation - Rotation of the transform point, in radians.\r\n * @param {number} scaleX - Horizontal scale of the transform point.\r\n * @param {number} scaleY - Vertical scale of the transform point.\r\n * @param {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} [output] - The output vector, point or object for the translated coordinates.\r\n *\r\n * @return {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} The translated point.\r\n */\r\nvar TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output)\r\n{\r\n    if (output === undefined) { output = new Vector2(); }\r\n\r\n    var radianSin = Math.sin(rotation);\r\n    var radianCos = Math.cos(rotation);\r\n\r\n    // Rotate and Scale\r\n    var a = radianCos * scaleX;\r\n    var b = radianSin * scaleX;\r\n    var c = -radianSin * scaleY;\r\n    var d = radianCos * scaleY;\r\n\r\n    //  Invert\r\n    var id = 1 / ((a * d) + (c * -b));\r\n\r\n    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);\r\n    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = TransformXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\r\nvar Vector2 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector2 (x, y)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n        }\r\n        else\r\n        {\r\n            if (y === undefined) { y = x; }\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector2.\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x || 0;\r\n        this.y = src.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the component values of this Vector from a given Vector2Like object.\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setFromObject: function (obj)\r\n    {\r\n        this.x = obj.x || 0;\r\n        this.y = obj.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    set: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setTo: function (x, y)\r\n    {\r\n        return this.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} azimuth - The angular coordinate, in radians.\r\n     * @param {number} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setToPolar: function (azimuth, radius)\r\n    {\r\n        if (radius == null) { radius = 1; }\r\n\r\n        this.x = Math.cos(azimuth) * radius;\r\n        this.y = Math.sin(azimuth) * radius;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n     *\r\n     * @return {boolean} Whether the given Vector is equal to this Vector.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y));\r\n    },\r\n\r\n    /**\r\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n     */\r\n    angle: function ()\r\n    {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n\r\n        var angle = Math.atan2(this.y, this.x);\r\n\r\n        if (angle < 0)\r\n        {\r\n            angle += 2 * Math.PI;\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    add: function (src)\r\n    {\r\n        this.x += src.x;\r\n        this.y += src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    subtract: function (src)\r\n    {\r\n        this.x -= src.x;\r\n        this.y -= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        this.x *= src.x;\r\n        this.y *= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    scale: function (value)\r\n    {\r\n        if (isFinite(value))\r\n        {\r\n            this.x *= value;\r\n            this.y *= value;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    divide: function (src)\r\n    {\r\n        this.x /= src.x;\r\n        this.y /= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x` and `y` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return x * x + y * y;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var len = x * x + y * y;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Right-hand normalize (make unit length) this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeRightHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y * -1;\r\n        this.y = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (src)\r\n    {\r\n        return this.x * src.x + this.y * src.y;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n     *\r\n     * @return {number} The cross product of this Vector and the given Vector.\r\n     */\r\n    cross: function (src)\r\n    {\r\n        return this.x * src.y - this.y * src.x;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    lerp: function (src, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n\r\n        this.x = ax + t * (src.x - ax);\r\n        this.y = ay + t * (src.y - ay);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[3] * y + m[6];\r\n        this.y = m[1] * x + m[4] * y + m[7];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[13];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\r\nVector2.ZERO = new Vector2();\r\n\r\n/**\r\n * A static right Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.RIGHT = new Vector2(1, 0);\r\n\r\n/**\r\n * A static left Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.LEFT = new Vector2(-1, 0);\r\n\r\n/**\r\n * A static up Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.UP = new Vector2(0, -1);\r\n\r\n/**\r\n * A static down Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.DOWN = new Vector2(0, 1);\r\n\r\n/**\r\n * A static one Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.ONE = new Vector2(1, 1);\r\n\r\nmodule.exports = Vector2;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 3D space.\r\n *\r\n * A three-component vector.\r\n *\r\n * @class Vector3\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n */\r\nvar Vector3 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector3 (x, y, z)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector3#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Set this Vector to point up.\r\n     *\r\n     * Sets the y component of the vector to 1, and the others to 0.\r\n     *\r\n     * @method Phaser.Math.Vector3#up\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    up: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 1;\r\n        this.z = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector3.\r\n     *\r\n     * @method Phaser.Math.Vector3#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross (vector) product of two given Vectors.\r\n     *\r\n     * @method Phaser.Math.Vector3#crossVectors\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} a - The first Vector to multiply.\r\n     * @param {Phaser.Math.Vector3} b - The second Vector to multiply.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    crossVectors: function (a, b)\r\n    {\r\n        var ax = a.x;\r\n        var ay = a.y;\r\n        var az = a.z;\r\n        var bx = b.x;\r\n        var by = b.y;\r\n        var bz = b.z;\r\n\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector3#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.\r\n     *\r\n     * @return {boolean} True if the two vectors strictly match, otherwise false.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z));\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.\r\n     *\r\n     * @method Phaser.Math.Vector3#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y and z components.\r\n     * @param {number} [y] - The y value to set for this Vector.\r\n     * @param {number} [z] - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    set: function (x, y, z)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector3#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector3#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector3#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        if (isFinite(scale))\r\n        {\r\n            this.x *= scale;\r\n            this.y *= scale;\r\n            this.z *= scale;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.z = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y` and `z` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector3#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector3#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n\r\n        return x * x + y * y + z * z;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector3#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var len = x * x + y * y + z * z;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to dot product with this Vector3.\r\n     *\r\n     * @return {number} The dot product of this Vector and `v`.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector to cross product with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    cross: function (v)\r\n    {\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var bx = v.x;\r\n        var by = v.y;\r\n        var bz = v.z;\r\n\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector3#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} v - The Vector3 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        this.x = x * m[0] + y * m[3] + z * m[6];\r\n        this.y = x * m[1] + y * m[4] + z * m[7];\r\n        this.z = x * m[2] + y * m[5] + z * m[8];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13];\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms the coordinates of this Vector3 with the given Matrix4.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformCoordinates: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];\r\n        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];\r\n        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];\r\n        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];\r\n\r\n        this.x = tx / tw;\r\n        this.y = ty / tw;\r\n        this.z = tz / tw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector3#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,\r\n     * e.g. unprojecting a 2D point into 3D space.\r\n     *\r\n     * @method Phaser.Math.Vector3#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to multiply this Vector3 with.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    project: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var m = mat.val;\r\n\r\n        var a00 = m[0];\r\n        var a01 = m[1];\r\n        var a02 = m[2];\r\n        var a03 = m[3];\r\n        var a10 = m[4];\r\n        var a11 = m[5];\r\n        var a12 = m[6];\r\n        var a13 = m[7];\r\n        var a20 = m[8];\r\n        var a21 = m[9];\r\n        var a22 = m[10];\r\n        var a23 = m[11];\r\n        var a30 = m[12];\r\n        var a31 = m[13];\r\n        var a32 = m[14];\r\n        var a33 = m[15];\r\n\r\n        var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);\r\n\r\n        this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;\r\n        this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;\r\n        this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Unproject this point from 2D space to 3D space.\r\n     * The point should have its x and y properties set to\r\n     * 2D screen space, and the z either at 0 (near plane)\r\n     * or 1 (far plane). The provided matrix is assumed to already\r\n     * be combined, i.e. projection * view * model.\r\n     *\r\n     * After this operation, this vector's (x, y, z) components will\r\n     * represent the unprojected 3D coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector3#unproject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.\r\n     * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    unproject: function (viewport, invProjectionView)\r\n    {\r\n        var viewX = viewport.x;\r\n        var viewY = viewport.y;\r\n        var viewWidth = viewport.z;\r\n        var viewHeight = viewport.w;\r\n\r\n        var x = this.x - viewX;\r\n        var y = (viewHeight - this.y - 1) - viewY;\r\n        var z = this.z;\r\n\r\n        this.x = (2 * x) / viewWidth - 1;\r\n        this.y = (2 * y) / viewHeight - 1;\r\n        this.z = 2 * z - 1;\r\n\r\n        return this.project(invProjectionView);\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector3#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector3} This Vector3.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.ZERO\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.ZERO = new Vector3();\r\n\r\n/**\r\n * A static right Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.RIGHT\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.RIGHT = new Vector3(1, 0, 0);\r\n\r\n/**\r\n * A static left Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.LEFT\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.LEFT = new Vector3(-1, 0, 0);\r\n\r\n/**\r\n * A static up Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.UP\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.UP = new Vector3(0, -1, 0);\r\n\r\n/**\r\n * A static down Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.DOWN\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.DOWN = new Vector3(0, 1, 0);\r\n\r\n/**\r\n * A static forward Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.FORWARD\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.FORWARD = new Vector3(0, 0, 1);\r\n\r\n/**\r\n * A static back Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.BACK\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.BACK = new Vector3(0, 0, -1);\r\n\r\n/**\r\n * A static one Vector3 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector3.ONE\r\n * @type {Phaser.Math.Vector3}\r\n * @since 3.16.0\r\n */\r\nVector3.ONE = new Vector3(1, 1, 1);\r\n\r\nmodule.exports = Vector3;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 4D space.\r\n *\r\n * A four-component vector.\r\n *\r\n * @class Vector4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Vector4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector4 (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        /**\r\n         * The w component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.w = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector4.\r\n     *\r\n     * @method Phaser.Math.Vector4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} A clone of this Vector4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n        this.w = src.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict quality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector4#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The vector to check equality with.\r\n     *\r\n     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.\r\n     *\r\n     * @method Phaser.Math.Vector4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.\r\n     * @param {number} y - The y value to set for this Vector.\r\n     * @param {number} z - The z value to set for this Vector.\r\n     * @param {number} w - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n        this.w += v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n        this.w -= v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector4#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n        this.w *= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n        this.w /= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz + dw * dw;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y`, `z` and `w` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        this.w = -this.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        // TODO: is this really the same as Vector3?\r\n        // Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\r\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector4#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n//  TODO: Check if these are required internally, if not, remove.\r\nVector4.prototype.sub = Vector4.prototype.subtract;\r\nVector4.prototype.mul = Vector4.prototype.multiply;\r\nVector4.prototype.div = Vector4.prototype.divide;\r\nVector4.prototype.dist = Vector4.prototype.distance;\r\nVector4.prototype.distSq = Vector4.prototype.distanceSq;\r\nVector4.prototype.len = Vector4.prototype.length;\r\nVector4.prototype.lenSq = Vector4.prototype.lengthSq;\r\n\r\nmodule.exports = Vector4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the two values are within the given `tolerance` of each other.\r\n *\r\n * @function Phaser.Math.Within\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value to use in the calculation.\r\n * @param {number} b - The second value to use in the calculation.\r\n * @param {number} tolerance - The tolerance. Anything equal to or less than this value is considered as being within range.\r\n *\r\n * @return {boolean} Returns `true` if `a` is less than or equal to the tolerance of `b`.\r\n */\r\nvar Within = function (a, b, tolerance)\r\n{\r\n    return (Math.abs(a - b) <= tolerance);\r\n};\r\n\r\nmodule.exports = Within;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * @function Phaser.Math.Angle.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar Between = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * Calculates the angle of the vector from the first point to the second point.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPoints\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\r\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPoints = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\r\n};\r\n\r\nmodule.exports = BetweenPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.BetweenPoints} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPointsY\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\r\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPointsY = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.x - point1.x, point2.y - point1.y);\r\n};\r\n\r\nmodule.exports = BetweenPointsY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.Between} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenY = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(x2 - x1, y2 - y1);\r\n};\r\n\r\nmodule.exports = BetweenY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const');\r\n\r\n/**\r\n * Takes an angle in Phasers default clockwise format and converts it so that\r\n * 0 is North, 90 is West, 180 is South and 270 is East,\r\n * therefore running counter-clockwise instead of clockwise.\r\n * \r\n * You can pass in the angle from a Game Object using:\r\n * \r\n * ```javascript\r\n * var converted = CounterClockwise(gameobject.rotation);\r\n * ```\r\n * \r\n * All values for this function are in radians.\r\n *\r\n * @function Phaser.Math.Angle.CounterClockwise\r\n * @since 3.16.0\r\n *\r\n * @param {number} angle - The angle to convert, in radians.\r\n *\r\n * @return {number} The converted angle, in radians.\r\n */\r\nvar CounterClockwise = function (angle)\r\n{\r\n    if (angle > Math.PI)\r\n    {\r\n        angle -= CONST.PI2;\r\n    }\r\n\r\n    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);\r\n};\r\n\r\nmodule.exports = CounterClockwise;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Normalize an angle to the [0, 2pi] range.\r\n *\r\n * @function Phaser.Math.Angle.Normalize\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to normalize, in radians.\r\n *\r\n * @return {number} The normalized angle, in radians.\r\n */\r\nvar Normalize = function (angle)\r\n{\r\n    angle = angle % (2 * Math.PI);\r\n\r\n    if (angle >= 0)\r\n    {\r\n        return angle;\r\n    }\r\n    else\r\n    {\r\n        return angle + 2 * Math.PI;\r\n    }\r\n};\r\n\r\nmodule.exports = Normalize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Normalize = require('./Normalize');\r\n\r\n/**\r\n * Reverse the given angle.\r\n *\r\n * @function Phaser.Math.Angle.Reverse\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to reverse, in radians.\r\n *\r\n * @return {number} The reversed angle, in radians.\r\n */\r\nvar Reverse = function (angle)\r\n{\r\n    return Normalize(angle + Math.PI);\r\n};\r\n\r\nmodule.exports = Reverse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../const');\r\n\r\n/**\r\n * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.\r\n *\r\n * @function Phaser.Math.Angle.RotateTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} currentAngle - The current angle, in radians.\r\n * @param {number} targetAngle - The target angle to rotate to, in radians.\r\n * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\r\n *\r\n * @return {number} The adjusted angle.\r\n */\r\nvar RotateTo = function (currentAngle, targetAngle, lerp)\r\n{\r\n    if (lerp === undefined) { lerp = 0.05; }\r\n\r\n    if (currentAngle === targetAngle)\r\n    {\r\n        return currentAngle;\r\n    }\r\n\r\n    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))\r\n    {\r\n        currentAngle = targetAngle;\r\n    }\r\n    else\r\n    {\r\n        if (Math.abs(targetAngle - currentAngle) > Math.PI)\r\n        {\r\n            if (targetAngle < currentAngle)\r\n            {\r\n                targetAngle += MATH_CONST.PI2;\r\n            }\r\n            else\r\n            {\r\n                targetAngle -= MATH_CONST.PI2;\r\n            }\r\n        }\r\n\r\n        if (targetAngle > currentAngle)\r\n        {\r\n            currentAngle += lerp;\r\n        }\r\n        else if (targetAngle < currentAngle)\r\n        {\r\n            currentAngle -= lerp;\r\n        }\r\n    }\r\n\r\n    return currentAngle;\r\n};\r\n\r\nmodule.exports = RotateTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Gets the shortest angle between `angle1` and `angle2`.\r\n *\r\n * Both angles must be in the range -180 to 180, which is the same clamped\r\n * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n * this method and get the shortest angle back between the two of them.\r\n *\r\n * The angle returned will be in the same range. If the returned angle is\r\n * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n * a clockwise rotation.\r\n *\r\n * TODO: Wrap the angles in this function?\r\n *\r\n * @function Phaser.Math.Angle.ShortestBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle1 - The first angle in the range -180 to 180.\r\n * @param {number} angle2 - The second angle in the range -180 to 180.\r\n *\r\n * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\r\n */\r\nvar ShortestBetween = function (angle1, angle2)\r\n{\r\n    var difference = angle2 - angle1;\r\n\r\n    if (difference === 0)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    var times = Math.floor((difference - (-180)) / 360);\r\n\r\n    return difference - (times * 360);\r\n\r\n};\r\n\r\nmodule.exports = ShortestBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathWrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle.\r\n *\r\n * Wraps the angle to a value in the range of -PI to PI.\r\n *\r\n * @function Phaser.Math.Angle.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in radians.\r\n *\r\n * @return {number} The wrapped angle, in radians.\r\n */\r\nvar Wrap = function (angle)\r\n{\r\n    return MathWrap(angle, -Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Wrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle in degrees.\r\n *\r\n * Wraps the angle to a value in the range of -180 to 180.\r\n *\r\n * @function Phaser.Math.Angle.WrapDegrees\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in degrees.\r\n *\r\n * @return {number} The wrapped angle, in degrees.\r\n */\r\nvar WrapDegrees = function (angle)\r\n{\r\n    return Wrap(angle, -180, 180);\r\n};\r\n\r\nmodule.exports = WrapDegrees;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Angle\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./Between'),\r\n    BetweenPoints: require('./BetweenPoints'),\r\n    BetweenPointsY: require('./BetweenPointsY'),\r\n    BetweenY: require('./BetweenY'),\r\n    CounterClockwise: require('./CounterClockwise'),\r\n    Normalize: require('./Normalize'),\r\n    Reverse: require('./Reverse'),\r\n    RotateTo: require('./RotateTo'),\r\n    ShortestBetween: require('./ShortestBetween'),\r\n    Wrap: require('./Wrap'),\r\n    WrapDegrees: require('./WrapDegrees')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = {\r\n\r\n    /**\r\n     * The value of PI * 2.\r\n     * \r\n     * @name Phaser.Math.PI2\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PI2: Math.PI * 2,\r\n\r\n    /**\r\n     * The value of PI * 0.5.\r\n     * \r\n     * @name Phaser.Math.TAU\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TAU: Math.PI * 0.5,\r\n\r\n    /**\r\n     * An epsilon value (1.0e-6)\r\n     * \r\n     * @name Phaser.Math.EPSILON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    EPSILON: 1.0e-6,\r\n\r\n    /**\r\n     * For converting degrees to radians (PI / 180)\r\n     * \r\n     * @name Phaser.Math.DEG_TO_RAD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    DEG_TO_RAD: Math.PI / 180,\r\n\r\n    /**\r\n     * For converting radians to degrees (180 / PI)\r\n     * \r\n     * @name Phaser.Math.RAD_TO_DEG\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    RAD_TO_DEG: 180 / Math.PI,\r\n\r\n    /**\r\n     * An instance of the Random Number Generator.\r\n     * This is not set until the Game boots.\r\n     * \r\n     * @name Phaser.Math.RND\r\n     * @type {Phaser.Math.RandomDataGenerator}\r\n     * @since 3.0.0\r\n     */\r\n    RND: null\r\n\r\n};\r\n\r\nmodule.exports = MATH_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points) to the power of `pow`.\r\n *\r\n * @function Phaser.Math.Distance.Power\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n * @param {number} pow - The exponent.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistancePower = function (x1, y1, x2, y2, pow)\r\n{\r\n    if (pow === undefined) { pow = 2; }\r\n\r\n    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\r\n};\r\n\r\nmodule.exports = DistancePower;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points), squared.\r\n *\r\n * @function Phaser.Math.Distance.Squared\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point, squared.\r\n */\r\nvar DistanceSquared = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return dx * dx + dy * dy;\r\n};\r\n\r\nmodule.exports = DistanceSquared;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Distance\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./DistanceBetween'),\r\n    Power: require('./DistancePower'),\r\n    Squared: require('./DistanceSquared')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Back.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    return v * v * ((overshoot + 1) * v - overshoot);\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Back.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    var s = overshoot * 1.525;\r\n\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * (v * v * ((s + 1) * v - s));\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Back ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Back.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [overshoot=1.70158] - The overshoot amount.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v, overshoot)\r\n{\r\n    if (overshoot === undefined) { overshoot = 1.70158; }\r\n\r\n    return --v * v * ((overshoot + 1) * v + overshoot) + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Back\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    v = 1 - v;\r\n\r\n    if (v < 1 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * v * v);\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);\r\n    }\r\n    else\r\n    {\r\n        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    var reverse = false;\r\n\r\n    if (v < 0.5)\r\n    {\r\n        v = 1 - (v * 2);\r\n        reverse = true;\r\n    }\r\n    else\r\n    {\r\n        v = (v * 2) - 1;\r\n    }\r\n\r\n    if (v < 1 / 2.75)\r\n    {\r\n        v = 7.5625 * v * v;\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\r\n    }\r\n    else\r\n    {\r\n        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\r\n    }\r\n\r\n    if (reverse)\r\n    {\r\n        return (1 - v) * 0.5;\r\n    }\r\n    else\r\n    {\r\n        return v * 0.5 + 0.5;\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Bounce ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Bounce.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    if (v < 1 / 2.75)\r\n    {\r\n        return 7.5625 * v * v;\r\n    }\r\n    else if (v < 2 / 2.75)\r\n    {\r\n        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\r\n    }\r\n    else if (v < 2.5 / 2.75)\r\n    {\r\n        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\r\n    }\r\n    else\r\n    {\r\n        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Bounce\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Circular.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return 1 - Math.sqrt(1 - v * v);\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Circular.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return -0.5 * (Math.sqrt(1 - v * v) - 1);\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Circular ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Circular.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return Math.sqrt(1 - (--v * v));\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Circular\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * v + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Cubic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Cubic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return --v * v * v + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Cubic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        if ((v *= 2) < 1)\r\n        {\r\n            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\r\n        }\r\n        else\r\n        {\r\n            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Elastic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Elastic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\r\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v, amplitude, period)\r\n{\r\n    if (amplitude === undefined) { amplitude = 0.1; }\r\n    if (period === undefined) { period = 0.1; }\r\n\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        var s = period / 4;\r\n\r\n        if (amplitude < 1)\r\n        {\r\n            amplitude = 1;\r\n        }\r\n        else\r\n        {\r\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\r\n        }\r\n\r\n        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Elastic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Expo.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return Math.pow(2, 10 * (v - 1)) - 0.001;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Expo.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * Math.pow(2, 10 * (v - 1));\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Exponential ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Expo.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return 1 - Math.pow(2, -10 * v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Expo\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Back: require('./back'),\r\n    Bounce: require('./bounce'),\r\n    Circular: require('./circular'),\r\n    Cubic: require('./cubic'),\r\n    Elastic: require('./elastic'),\r\n    Expo: require('./expo'),\r\n    Linear: require('./linear'),\r\n    Quadratic: require('./quadratic'),\r\n    Quartic: require('./quartic'),\r\n    Quintic: require('./quintic'),\r\n    Sine: require('./sine'),\r\n    Stepped: require('./stepped')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Linear easing (no variation).\r\n *\r\n * @function Phaser.Math.Easing.Linear.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Linear = function (v)\r\n{\r\n    return v;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Linear\r\n */\r\n\r\nmodule.exports = require('./Linear');\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v;\r\n    }\r\n    else\r\n    {\r\n        return -0.5 * (--v * (v - 2) - 1);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quadratic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quadratic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return v * (2 - v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quadratic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return -0.5 * ((v -= 2) * v * v * v - 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quartic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quartic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return 1 - (--v * v * v * v);\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quartic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    return v * v * v * v * v;\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if ((v *= 2) < 1)\r\n    {\r\n        return 0.5 * v * v * v * v * v;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * ((v -= 2) * v * v * v * v + 2);\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Quintic ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Quintic.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    return --v * v * v * v * v + 1;\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Quintic\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-in.\r\n *\r\n * @function Phaser.Math.Easing.Sine.In\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar In = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return 1 - Math.cos(v * Math.PI / 2);\r\n    }\r\n};\r\n\r\nmodule.exports = In;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-in/out.\r\n *\r\n * @function Phaser.Math.Easing.Sine.InOut\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar InOut = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return 0.5 * (1 - Math.cos(Math.PI * v));\r\n    }\r\n};\r\n\r\nmodule.exports = InOut;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sinusoidal ease-out.\r\n *\r\n * @function Phaser.Math.Easing.Sine.Out\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Out = function (v)\r\n{\r\n    if (v === 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v === 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return Math.sin(v * Math.PI / 2);\r\n    }\r\n};\r\n\r\nmodule.exports = Out;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Sine\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    In: require('./In'),\r\n    Out: require('./Out'),\r\n    InOut: require('./InOut')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Stepped easing.\r\n *\r\n * @function Phaser.Math.Easing.Stepped.Stepped\r\n * @since 3.0.0\r\n *\r\n * @param {number} v - The value to be tweened.\r\n * @param {number} [steps=1] - The number of steps in the ease.\r\n *\r\n * @return {number} The tweened value.\r\n */\r\nvar Stepped = function (v, steps)\r\n{\r\n    if (steps === undefined) { steps = 1; }\r\n\r\n    if (v <= 0)\r\n    {\r\n        return 0;\r\n    }\r\n    else if (v >= 1)\r\n    {\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        return (((steps * v) | 0) + 1) * (1 / steps);\r\n    }\r\n};\r\n\r\nmodule.exports = Stepped;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing.Stepped\r\n */\r\n\r\nmodule.exports = require('./Stepped');\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy ceiling of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The fuzzy ceiling of the value.\r\n */\r\nvar Ceil = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.ceil(value - epsilon);\r\n};\r\n\r\nmodule.exports = Ceil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether the given values are fuzzily equal.\r\n *\r\n * Two numbers are fuzzily equal if their difference is less than `epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.Equal\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if the values are fuzzily equal, otherwise `false`.\r\n */\r\nvar Equal = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.abs(a - b) < epsilon;\r\n};\r\n\r\nmodule.exports = Equal;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy floor of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The floor of the value.\r\n */\r\nvar Floor = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.floor(value + epsilon);\r\n};\r\n\r\nmodule.exports = Floor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily greater than `b`.\r\n *\r\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.GreaterThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\r\n */\r\nvar GreaterThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a > b - epsilon;\r\n};\r\n\r\nmodule.exports = GreaterThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily less than `b`.\r\n *\r\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.LessThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\r\n */\r\nvar LessThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a < b + epsilon;\r\n};\r\n\r\nmodule.exports = LessThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Fuzzy\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./Ceil'),\r\n    Equal: require('./Equal'),\r\n    Floor: require('./Floor'),\r\n    GreaterThan: require('./GreaterThan'),\r\n    LessThan: require('./LessThan')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Math\r\n */\r\n\r\nvar PhaserMath = {\r\n\r\n    //  Collections of functions\r\n    Angle: require('./angle/'),\r\n    Distance: require('./distance/'),\r\n    Easing: require('./easing/'),\r\n    Fuzzy: require('./fuzzy/'),\r\n    Interpolation: require('./interpolation/'),\r\n    Pow2: require('./pow2/'),\r\n    Snap: require('./snap/'),\r\n\r\n    //  Expose the RNG Class\r\n    RandomDataGenerator: require('./random-data-generator/RandomDataGenerator'),\r\n\r\n    //  Single functions\r\n    Average: require('./Average'),\r\n    Bernstein: require('./Bernstein'),\r\n    Between: require('./Between'),\r\n    CatmullRom: require('./CatmullRom'),\r\n    CeilTo: require('./CeilTo'),\r\n    Clamp: require('./Clamp'),\r\n    DegToRad: require('./DegToRad'),\r\n    Difference: require('./Difference'),\r\n    Factorial: require('./Factorial'),\r\n    FloatBetween: require('./FloatBetween'),\r\n    FloorTo: require('./FloorTo'),\r\n    FromPercent: require('./FromPercent'),\r\n    GetSpeed: require('./GetSpeed'),\r\n    IsEven: require('./IsEven'),\r\n    IsEvenStrict: require('./IsEvenStrict'),\r\n    Linear: require('./Linear'),\r\n    MaxAdd: require('./MaxAdd'),\r\n    MinSub: require('./MinSub'),\r\n    Percent: require('./Percent'),\r\n    RadToDeg: require('./RadToDeg'),\r\n    RandomXY: require('./RandomXY'),\r\n    RandomXYZ: require('./RandomXYZ'),\r\n    RandomXYZW: require('./RandomXYZW'),\r\n    Rotate: require('./Rotate'),\r\n    RotateAround: require('./RotateAround'),\r\n    RotateAroundDistance: require('./RotateAroundDistance'),\r\n    RoundAwayFromZero: require('./RoundAwayFromZero'),\r\n    RoundTo: require('./RoundTo'),\r\n    SinCosTableGenerator: require('./SinCosTableGenerator'),\r\n    SmootherStep: require('./SmootherStep'),\r\n    SmoothStep: require('./SmoothStep'),\r\n    ToXY: require('./ToXY'),\r\n    TransformXY: require('./TransformXY'),\r\n    Within: require('./Within'),\r\n    Wrap: require('./Wrap'),\r\n\r\n    //  Vector classes\r\n    Vector2: require('./Vector2'),\r\n    Vector3: require('./Vector3'),\r\n    Vector4: require('./Vector4'),\r\n    Matrix3: require('./Matrix3'),\r\n    Matrix4: require('./Matrix4'),\r\n    Quaternion: require('./Quaternion'),\r\n    RotateVec3: require('./RotateVec3')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\n\r\nPhaserMath = Extend(false, PhaserMath, CONST);\r\n\r\n//  Export it\r\n\r\nmodule.exports = PhaserMath;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bernstein = require('../Bernstein');\r\n\r\n/**\r\n * A bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Bezier\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar BezierInterpolation = function (v, k)\r\n{\r\n    var b = 0;\r\n    var n = v.length - 1;\r\n\r\n    for (var i = 0; i <= n; i++)\r\n    {\r\n        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);\r\n    }\r\n\r\n    return b;\r\n};\r\n\r\nmodule.exports = BezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CatmullRom = require('../CatmullRom');\r\n\r\n/**\r\n * A Catmull-Rom interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CatmullRomInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (v[0] === v[m])\r\n    {\r\n        if (k < 0)\r\n        {\r\n            i = Math.floor(f = m * (1 + k));\r\n        }\r\n\r\n        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);\r\n    }\r\n    else\r\n    {\r\n        if (k < 0)\r\n        {\r\n            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);\r\n        }\r\n\r\n        if (k > 1)\r\n        {\r\n            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);\r\n        }\r\n\r\n        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);\r\n    }\r\n};\r\n\r\nmodule.exports = CatmullRomInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return 3 * k * k * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P3 (t, p)\r\n{\r\n    return t * t * t * p;\r\n}\r\n\r\n/**\r\n * A cubic bezier interpolation method.\r\n *\r\n * https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\r\n *\r\n * @function Phaser.Math.Interpolation.CubicBezier\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The first control point.\r\n * @param {number} p2 - The second control point.\r\n * @param {number} p3 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CubicBezierInterpolation = function (t, p0, p1, p2, p3)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\r\n};\r\n\r\nmodule.exports = CubicBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Linear = require('../Linear');\r\n\r\n/**\r\n * A linear interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Linear\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Linear_interpolation}\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {!number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {!number} The interpolated value.\r\n */\r\nvar LinearInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (k < 0)\r\n    {\r\n        return Linear(v[0], v[1], f);\r\n    }\r\n    else if (k > 1)\r\n    {\r\n        return Linear(v[m], v[m - 1], m - f);\r\n    }\r\n    else\r\n    {\r\n        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);\r\n    }\r\n};\r\n\r\nmodule.exports = LinearInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    return 2 * (1 - t) * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return t * t * p;\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\r\n\r\n/**\r\n * A quadratic bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.QuadraticBezier\r\n * @since 3.2.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The control point.\r\n * @param {number} p2 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar QuadraticBezierInterpolation = function (t, p0, p1, p2)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2);\r\n};\r\n\r\nmodule.exports = QuadraticBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmoothStep = require('../SmoothStep');\r\n\r\n/**\r\n * A Smooth Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmoothStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmoothStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmoothStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmoothStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmootherStep = require('../SmootherStep');\r\n\r\n/**\r\n * A Smoother Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmootherStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmootherStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmootherStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmootherStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Interpolation\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Bezier: require('./BezierInterpolation'),\r\n    CatmullRom: require('./CatmullRomInterpolation'),\r\n    CubicBezier: require('./CubicBezierInterpolation'),\r\n    Linear: require('./LinearInterpolation'),\r\n    QuadraticBezier: require('./QuadraticBezierInterpolation'),\r\n    SmoothStep: require('./SmoothStepInterpolation'),\r\n    SmootherStep: require('./SmootherStepInterpolation')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the nearest power of 2 to the given `value`.\r\n *\r\n * @function Phaser.Math.Pow2.GetPowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n *\r\n * @return {integer} The nearest power of 2 to `value`.\r\n */\r\nvar GetPowerOfTwo = function (value)\r\n{\r\n    var index = Math.log(value) / 0.6931471805599453;\r\n\r\n    return (1 << Math.ceil(index));\r\n};\r\n\r\nmodule.exports = GetPowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given `width` and `height` are a power of two.\r\n * Useful for checking texture dimensions.\r\n *\r\n * @function Phaser.Math.Pow2.IsSizePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} width - The width.\r\n * @param {number} height - The height.\r\n *\r\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\r\n */\r\nvar IsSizePowerOfTwo = function (width, height)\r\n{\r\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsSizePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tests the value and returns `true` if it is a power of two.\r\n *\r\n * @function Phaser.Math.Pow2.IsValuePowerOfTwo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to check if it's a power of two.\r\n *\r\n * @return {boolean} Returns `true` if `value` is a power of two, otherwise `false`.\r\n */\r\nvar IsValuePowerOfTwo = function (value)\r\n{\r\n    return (value > 0 && (value & (value - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsValuePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Pow2\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    GetNext: require('./GetPowerOfTwo'),\r\n    IsSize: require('./IsSizePowerOfTwo'),\r\n    IsValue: require('./IsValuePowerOfTwo')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A seeded Random Data Generator.\r\n * \r\n * Access via `Phaser.Math.RND` which is an instance of this class pre-defined\r\n * by Phaser. Or, create your own instance to use as you require.\r\n * \r\n * The `Math.RND` generator is seeded by the Game Config property value `seed`.\r\n * If no such config property exists, a random number is used.\r\n * \r\n * If you create your own instance of this class you should provide a seed for it.\r\n * If no seed is given it will use a 'random' one based on Date.now.\r\n *\r\n * @class RandomDataGenerator\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|string[])} [seeds] - The seeds to use for the random number generator.\r\n */\r\nvar RandomDataGenerator = new Class({\r\n\r\n    initialize:\r\n\r\n    function RandomDataGenerator (seeds)\r\n    {\r\n        if (seeds === undefined) { seeds = [ (Date.now() * Math.random()).toString() ]; }\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#c\r\n         * @type {number}\r\n         * @default 1\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.c = 1;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s0\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s0 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s1\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s1 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s2\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s2 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#n\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.2.0\r\n         */\r\n        this.n = 0;\r\n\r\n        /**\r\n         * Signs to choose from.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#signs\r\n         * @type {number[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.signs = [ -1, 1 ];\r\n\r\n        if (seeds)\r\n        {\r\n            this.init(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Private random helper.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rnd\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @return {number} A random number.\r\n     */\r\n    rnd: function ()\r\n    {\r\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n\r\n        this.c = t | 0;\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        this.s2 = t - this.c;\r\n\r\n        return this.s2;\r\n    },\r\n\r\n    /**\r\n     * Internal method that creates a seed hash.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#hash\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @param {string} data - The value to hash.\r\n     *\r\n     * @return {number} The hashed value.\r\n     */\r\n    hash: function (data)\r\n    {\r\n        var h;\r\n        var n = this.n;\r\n\r\n        data = data.toString();\r\n\r\n        for (var i = 0; i < data.length; i++)\r\n        {\r\n            n += data.charCodeAt(i);\r\n            h = 0.02519603282416938 * n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            h *= n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            n += h * 0x100000000;// 2^32\r\n        }\r\n\r\n        this.n = n;\r\n\r\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\r\n    },\r\n\r\n    /**\r\n     * Initialize the state of the random data generator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.\r\n     */\r\n    init: function (seeds)\r\n    {\r\n        if (typeof seeds === 'string')\r\n        {\r\n            this.state(seeds);\r\n        }\r\n        else\r\n        {\r\n            this.sow(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reset the seed of the random data generator.\r\n     *\r\n     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.\r\n     */\r\n    sow: function (seeds)\r\n    {\r\n        // Always reset to default seed\r\n        this.n = 0xefc8249d;\r\n        this.s0 = this.hash(' ');\r\n        this.s1 = this.hash(' ');\r\n        this.s2 = this.hash(' ');\r\n        this.c = 1;\r\n\r\n        if (!seeds)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Apply any seeds\r\n        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)\r\n        {\r\n            var seed = seeds[i];\r\n\r\n            this.s0 -= this.hash(seed);\r\n            this.s0 += ~~(this.s0 < 0);\r\n            this.s1 -= this.hash(seed);\r\n            this.s1 += ~~(this.s1 < 0);\r\n            this.s2 -= this.hash(seed);\r\n            this.s2 += ~~(this.s2 < 0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integer\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random integer between 0 and 2^32.\r\n     */\r\n    integer: function ()\r\n    {\r\n        // 2^32\r\n        return this.rnd() * 0x100000000;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#frac\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 1.\r\n     */\r\n    frac: function ()\r\n    {\r\n        // 2^-53\r\n        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#real\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 2^32.\r\n     */\r\n    real: function ()\r\n    {\r\n        return this.integer() + this.frac();\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integerInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    integerInRange: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     * This method is an alias for RandomDataGenerator.integerInRange.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#between\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    between: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#realInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    realInRange: function (min, max)\r\n    {\r\n        return this.frac() * (max - min) + min;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between -1 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#normal\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between -1 and 1.\r\n     */\r\n    normal: function ()\r\n    {\r\n        return 1 - (2 * this.frac());\r\n    },\r\n\r\n    /**\r\n     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#uuid\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} A valid RFC4122 version4 ID hex string\r\n     */\r\n    uuid: function ()\r\n    {\r\n        var a = '';\r\n        var b = '';\r\n\r\n        for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')\r\n        {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n\r\n        return b;\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#pick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */\r\n    pick: function (array)\r\n    {\r\n        return array[this.integerInRange(0, array.length - 1)];\r\n    },\r\n\r\n    /**\r\n     * Returns a sign to be used with multiplication operator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sign\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} -1 or +1.\r\n     */\r\n    sign: function ()\r\n    {\r\n        return this.pick(this.signs);\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array, favoring the earlier entries.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#weightedPick\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} array - The array to pick a random element from.\r\n     *\r\n     * @return {*} A random member of the array.\r\n     */\r\n    weightedPick: function (array)\r\n    {\r\n        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];\r\n    },\r\n\r\n    /**\r\n     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#timestamp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random timestamp between min and max.\r\n     */\r\n    timestamp: function (min, max)\r\n    {\r\n        return this.realInRange(min || 946684800000, max || 1577862000000);\r\n    },\r\n\r\n    /**\r\n     * Returns a random angle between -180 and 180.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -180 and 180.\r\n     */\r\n    angle: function ()\r\n    {\r\n        return this.integerInRange(-180, 180);\r\n    },\r\n\r\n    /**\r\n     * Returns a random rotation in radians, between -3.141 and 3.141\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -3.141 and 3.141\r\n     */\r\n    rotation: function ()\r\n    {\r\n        return this.realInRange(-3.1415926, 3.1415926);\r\n    },\r\n\r\n    /**\r\n     * Gets or Sets the state of the generator. This allows you to retain the values\r\n     * that the generator is using between games, i.e. in a game save file.\r\n     *\r\n     * To seed this generator with a previously saved state you can pass it as the\r\n     * `seed` value in your game config, or call this method directly after Phaser has booted.\r\n     *\r\n     * Call this method with no parameters to return the current state.\r\n     *\r\n     * If providing a state it should match the same format that this method\r\n     * returns, which is a string with a header `!rnd` followed by the `c`,\r\n     * `s0`, `s1` and `s2` values respectively, each comma-delimited.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#state\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [state] - Generator state to be set.\r\n     *\r\n     * @return {string} The current state of the generator.\r\n     */\r\n    state: function (state)\r\n    {\r\n        if (typeof state === 'string' && state.match(/^!rnd/))\r\n        {\r\n            state = state.split(',');\r\n\r\n            this.c = parseFloat(state[1]);\r\n            this.s0 = parseFloat(state[2]);\r\n            this.s1 = parseFloat(state[3]);\r\n            this.s2 = parseFloat(state[4]);\r\n        }\r\n\r\n        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');\r\n    },\r\n\r\n    /**\r\n     * Shuffles the given array, using the current seed.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#shuffle\r\n     * @since 3.7.0\r\n     *\r\n     * @param {array} [array] - The array to be shuffled.\r\n     *\r\n     * @return {array} The shuffled array.\r\n     */\r\n    shuffle: function (array)\r\n    {\r\n        var len = array.length - 1;\r\n\r\n        for (var i = len; i > 0; i--)\r\n        {\r\n            var randomIndex = Math.floor(this.frac() * (i + 1));\r\n            var itemAtIndex = array[randomIndex];\r\n\r\n            array[randomIndex] = array[i];\r\n            array[i] = itemAtIndex;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RandomDataGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using ceil.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `15`.\r\n * As will `14` snap to `15`... but `16` will snap to `20`.\r\n *\r\n * @function Phaser.Math.Snap.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapCeil = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.ceil(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapCeil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using floor.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\r\n * As will `14` snap to `10`... but `16` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapFloor = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapFloor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using rounding.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10` whereas `14` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.To\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapTo = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.round(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Snap\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./SnapCeil'),\r\n    Floor: require('./SnapFloor'),\r\n    To: require('./SnapTo')\r\n\r\n};\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Global Plugin is installed just once into the Game owned Plugin Manager.\r\n * It can listen for Game events and respond to them.\r\n *\r\n * @class BasePlugin\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar BasePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function BasePlugin (pluginManager)\r\n    {\r\n        /**\r\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\r\n         * Can be used as a route to gain access to game systems and  events.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#pluginManager\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.pluginManager = pluginManager;\r\n\r\n        /**\r\n         * A reference to the Game instance this plugin is running under.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.game = pluginManager.game;\r\n    },\r\n\r\n    /**\r\n     * The PluginManager calls this method on a Global Plugin when the plugin is first instantiated.\r\n     * It will never be called again on this instance.\r\n     * In here you can set-up whatever you need for this plugin to run.\r\n     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.\r\n     * On a Scene Plugin, this method is never called. Use {@link Phaser.Plugins.ScenePlugin#boot} instead.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#init\r\n     * @since 3.8.0\r\n     *\r\n     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).\r\n     */\r\n    init: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * The PluginManager calls this method on a Global Plugin when the plugin is started.\r\n     * If a plugin is stopped, and then started again, this will get called again.\r\n     * Typically called immediately after `BasePlugin.init`.\r\n     * On a Scene Plugin, this method is never called.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#start\r\n     * @since 3.8.0\r\n     */\r\n    start: function ()\r\n    {\r\n        //  Here are the game-level events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the game closes down.\r\n\r\n        // var eventEmitter = this.game.events;\r\n\r\n        // eventEmitter.once('destroy', this.gameDestroy, this);\r\n        // eventEmitter.on('pause', this.gamePause, this);\r\n        // eventEmitter.on('resume', this.gameResume, this);\r\n        // eventEmitter.on('resize', this.gameResize, this);\r\n        // eventEmitter.on('prestep', this.gamePreStep, this);\r\n        // eventEmitter.on('step', this.gameStep, this);\r\n        // eventEmitter.on('poststep', this.gamePostStep, this);\r\n        // eventEmitter.on('prerender', this.gamePreRender, this);\r\n        // eventEmitter.on('postrender', this.gamePostRender, this);\r\n    },\r\n\r\n    /**\r\n     * The PluginManager calls this method on a Global Plugin when the plugin is stopped.\r\n     * The game code has requested that your plugin stop doing whatever it does.\r\n     * It is now considered as 'inactive' by the PluginManager.\r\n     * Handle that process here (i.e. stop listening for events, etc)\r\n     * If the plugin is started again then `BasePlugin.start` will be called again.\r\n     * On a Scene Plugin, this method is never called.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#stop\r\n     * @since 3.8.0\r\n     */\r\n    stop: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Game instance has been destroyed.\r\n     * You must release everything in here, all references, all objects, free it all up.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BasePlugin;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar BasePlugin = require('./BasePlugin');\r\nvar Class = require('../utils/Class');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * A Scene Level Plugin is installed into every Scene and belongs to that Scene.\r\n * It can listen for Scene events and respond to them.\r\n * It can map itself to a Scene property, or into the Scene Systems, or both.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Plugins\r\n * @extends Phaser.Plugins.BasePlugin\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    Extends: BasePlugin,\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene, pluginManager)\r\n    {\r\n        BasePlugin.call(this, pluginManager);\r\n\r\n        /**\r\n         * A reference to the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You can use it during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.ScenePlugin#scene\r\n         * @type {?Phaser.Scene}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You can use it during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.ScenePlugin#systems\r\n         * @type {?Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called when the Scene boots. It is only ever called once.\r\n     *\r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     *\r\n     * In here you can listen for {@link Phaser.Scenes.Events Scene events} and set-up whatever you need for this plugin to run.\r\n     * Here are the Scene events you can listen to:\r\n     *\r\n     * - start\r\n     * - ready\r\n     * - preupdate\r\n     * - update\r\n     * - postupdate\r\n     * - resize\r\n     * - pause\r\n     * - resume\r\n     * - sleep\r\n     * - wake\r\n     * - transitioninit\r\n     * - transitionstart\r\n     * - transitioncomplete\r\n     * - transitionout\r\n     * - shutdown\r\n     * - destroy\r\n     *\r\n     * At the very least you should offer a destroy handler for when the Scene closes down, i.e:\r\n     *\r\n     * ```javascript\r\n     * var eventEmitter = this.systems.events;\r\n     * eventEmitter.once('destroy', this.sceneDestroy, this);\r\n     * ```\r\n     *\r\n     * @method Phaser.Plugins.ScenePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Game instance has been destroyed.\r\n     * \r\n     * You must release everything in here, all references, all objects, free it all up.\r\n     *\r\n     * @method Phaser.Plugins.ScenePlugin#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScenePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Blend Modes.\r\n * \r\n * @namespace Phaser.BlendModes\r\n * @since 3.0.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Skips the Blend Mode check in the renderer.\r\n     * \r\n     * @name Phaser.BlendModes.SKIP_CHECK\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SKIP_CHECK: -1,\r\n\r\n    /**\r\n     * Normal blend mode. For Canvas and WebGL.\r\n     * This is the default setting and draws new shapes on top of the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.NORMAL\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    NORMAL: 0,\r\n\r\n    /**\r\n     * Add blend mode. For Canvas and WebGL.\r\n     * Where both shapes overlap the color is determined by adding color values.\r\n     * \r\n     * @name Phaser.BlendModes.ADD\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    ADD: 1,\r\n\r\n    /**\r\n     * Multiply blend mode. For Canvas and WebGL.\r\n     * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.\r\n     * \r\n     * @name Phaser.BlendModes.MULTIPLY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    MULTIPLY: 2,\r\n\r\n    /**\r\n     * Screen blend mode. For Canvas and WebGL.\r\n     * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)\r\n     * \r\n     * @name Phaser.BlendModes.SCREEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SCREEN: 3,\r\n\r\n    /**\r\n     * Overlay blend mode. For Canvas only.\r\n     * A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.\r\n     * \r\n     * @name Phaser.BlendModes.OVERLAY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    OVERLAY: 4,\r\n\r\n    /**\r\n     * Darken blend mode. For Canvas only.\r\n     * Retains the darkest pixels of both layers.\r\n     * \r\n     * @name Phaser.BlendModes.DARKEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DARKEN: 5,\r\n\r\n    /**\r\n     * Lighten blend mode. For Canvas only.\r\n     * Retains the lightest pixels of both layers.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTEN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LIGHTEN: 6,\r\n\r\n    /**\r\n     * Color Dodge blend mode. For Canvas only.\r\n     * Divides the bottom layer by the inverted top layer.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_DODGE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR_DODGE: 7,\r\n\r\n    /**\r\n     * Color Burn blend mode. For Canvas only.\r\n     * Divides the inverted bottom layer by the top layer, and then inverts the result.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR_BURN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR_BURN: 8,\r\n\r\n    /**\r\n     * Hard Light blend mode. For Canvas only.\r\n     * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\r\n     * \r\n     * @name Phaser.BlendModes.HARD_LIGHT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    HARD_LIGHT: 9,\r\n\r\n    /**\r\n     * Soft Light blend mode. For Canvas only.\r\n     * A softer version of hard-light. Pure black or white does not result in pure black or white.\r\n     * \r\n     * @name Phaser.BlendModes.SOFT_LIGHT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOFT_LIGHT: 10,\r\n\r\n    /**\r\n     * Difference blend mode. For Canvas only.\r\n     * Subtracts the bottom layer from the top layer or the other way round to always get a positive value.\r\n     * \r\n     * @name Phaser.BlendModes.DIFFERENCE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DIFFERENCE: 11,\r\n\r\n    /**\r\n     * Exclusion blend mode. For Canvas only.\r\n     * Like difference, but with lower contrast.\r\n     * \r\n     * @name Phaser.BlendModes.EXCLUSION\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    EXCLUSION: 12,\r\n\r\n    /**\r\n     * Hue blend mode. For Canvas only.\r\n     * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.HUE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    HUE: 13,\r\n\r\n    /**\r\n     * Saturation blend mode. For Canvas only.\r\n     * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.SATURATION\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SATURATION: 14,\r\n\r\n    /**\r\n     * Color blend mode. For Canvas only.\r\n     * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.COLOR\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COLOR: 15,\r\n\r\n    /**\r\n     * Luminosity blend mode. For Canvas only.\r\n     * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\r\n     * \r\n     * @name Phaser.BlendModes.LUMINOSITY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LUMINOSITY: 16,\r\n\r\n    /**\r\n     * Alpha erase blend mode. For Canvas and WebGL.\r\n     * \r\n     * @name Phaser.BlendModes.ERASE\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    ERASE: 17,\r\n\r\n    /**\r\n     * Source-in blend mode. For Canvas only.\r\n     * The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_IN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_IN: 18,\r\n\r\n    /**\r\n     * Source-out blend mode. For Canvas only.\r\n     * The new shape is drawn where it doesn't overlap the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_OUT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_OUT: 19,\r\n\r\n    /**\r\n     * Source-out blend mode. For Canvas only.\r\n     * The new shape is only drawn where it overlaps the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.SOURCE_ATOP\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    SOURCE_ATOP: 20,\r\n\r\n    /**\r\n     * Destination-over blend mode. For Canvas only.\r\n     * New shapes are drawn behind the existing canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_OVER\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_OVER: 21,\r\n\r\n    /**\r\n     * Destination-in blend mode. For Canvas only.\r\n     * The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_IN\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_IN: 22,\r\n\r\n    /**\r\n     * Destination-out blend mode. For Canvas only.\r\n     * The existing content is kept where it doesn't overlap the new shape.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_OUT\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_OUT: 23,\r\n\r\n    /**\r\n     * Destination-out blend mode. For Canvas only.\r\n     * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.\r\n     * \r\n     * @name Phaser.BlendModes.DESTINATION_ATOP\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    DESTINATION_ATOP: 24,\r\n\r\n    /**\r\n     * Lighten blend mode. For Canvas only.\r\n     * Where both shapes overlap the color is determined by adding color values.\r\n     * \r\n     * @name Phaser.BlendModes.LIGHTER\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    LIGHTER: 25,\r\n\r\n    /**\r\n     * Copy blend mode. For Canvas only.\r\n     * Only the new shape is shown.\r\n     * \r\n     * @name Phaser.BlendModes.COPY\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    COPY: 26,\r\n\r\n    /**\r\n     * Xor blend mode. For Canvas only.\r\n     * Shapes are made transparent where both overlap and drawn normal everywhere else.\r\n     * \r\n     * @name Phaser.BlendModes.XOR\r\n     * @type {integer}\r\n     * @const\r\n     * @since 3.0.0\r\n     */\r\n    XOR: 27\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Resize Event.\r\n * \r\n * This event is dispatched whenever the Scale Manager detects a resize event from the browser.\r\n * It sends three parameters to the callback, each of them being Size components. You can read\r\n * the `width`, `height`, `aspectRatio` and other properties of these components to help with\r\n * scaling your own game content.\r\n *\r\n * @event Phaser.Scale.Events#RESIZE\r\n * @since 3.16.1\r\n * \r\n * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.\r\n * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size multiplied by resolution.\r\n * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.\r\n * @param {number} resolution - The current resolution. Defaults to 1 at the moment.\r\n * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.\r\n * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Boot Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('boot', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#BOOT\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'boot';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Create Event.\r\n * \r\n * This event is dispatched by a Scene after it has been created by the Scene Manager.\r\n * \r\n * If a Scene has a `create` method then this event is emitted _after_ that has run.\r\n * \r\n * If there is a transition, this event will be fired after the `TRANSITION_START` event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('create', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#CREATE\r\n * @since 3.17.0\r\n * \r\n * @param {Phaser.Scene} scene - A reference to the Scene that emitted this event.\r\n */\r\nmodule.exports = 'create';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Destroy Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems destroy process.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('destroy', listener)`.\r\n * \r\n * You should destroy any resources that may be in use by your Scene in this event handler.\r\n * \r\n * @event Phaser.Scenes.Events#DESTROY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pause Event.\r\n * \r\n * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\r\n * action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('pause', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#PAUSE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was paused.\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Post Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('postupdate', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#POST_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'postupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pre Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('preupdate', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#PRE_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'preupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Ready Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems start process.\r\n * By this point in the process the Scene is now fully active and rendering.\r\n * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('ready', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#READY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was started.\r\n */\r\nmodule.exports = 'ready';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Render Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('render', listener)`.\r\n * \r\n * A Scene will only render if it is visible and active.\r\n * By the time this event is dispatched, the Scene will have already been rendered.\r\n * \r\n * @event Phaser.Scenes.Events#RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.\r\n */\r\nmodule.exports = 'render';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Resume Event.\r\n * \r\n * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('resume', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#RESUME\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was resumed.\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Shutdown Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems shutdown process.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('shutdown', listener)`.\r\n * \r\n * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding\r\n * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\r\n * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.\r\n * \r\n * @event Phaser.Scenes.Events#SHUTDOWN\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was shutdown.\r\n */\r\nmodule.exports = 'shutdown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Sleep Event.\r\n * \r\n * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('sleep', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#SLEEP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was sent to sleep.\r\n */\r\nmodule.exports = 'sleep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Start Event.\r\n * \r\n * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('start', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Complete Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition.\r\n * \r\n * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\r\n * of the transition.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitioncomplete', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} scene -The Scene on which the transitioned completed.\r\n */\r\nmodule.exports = 'transitioncomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Init Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition.\r\n * \r\n * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\r\n * this event is not dispatched.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitioninit', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_INIT\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitioninit';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Out Event.\r\n * \r\n * This event is dispatched by a Scene when it initiates a transition to another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionout', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_OUT\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} target - A reference to the Scene that is being transitioned to.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionout';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Start Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\r\n * \r\n * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\r\n * this event is dispatched anyway.\r\n * \r\n * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\r\n * dispatched instead of this event.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionstart', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_START\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Wake Event.\r\n * \r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\r\n * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('transitionwake', listener)`.\r\n * \r\n * The Scene Transition event flow is as follows:\r\n * \r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n * \r\n * @event Phaser.Scenes.Events#TRANSITION_WAKE\r\n * @since 3.5.0\r\n * \r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionwake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Update Event.\r\n * \r\n * This event is dispatched by a Scene during the main game loop step.\r\n * \r\n * The event flow for a single step of a Scene is as follows:\r\n * \r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('update', listener)`.\r\n * \r\n * A Scene will only run its step if it is active.\r\n * \r\n * @event Phaser.Scenes.Events#UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'update';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Wake Event.\r\n * \r\n * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\r\n * or as an action from another Scene.\r\n * \r\n * Listen to it from a Scene using `this.scene.events.on('wake', listener)`.\r\n * \r\n * @event Phaser.Scenes.Events#WAKE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was woken up.\r\n */\r\nmodule.exports = 'wake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Scenes.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BOOT: require('./BOOT_EVENT'),\r\n    CREATE: require('./CREATE_EVENT'),\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    POST_UPDATE: require('./POST_UPDATE_EVENT'),\r\n    PRE_UPDATE: require('./PRE_UPDATE_EVENT'),\r\n    READY: require('./READY_EVENT'),\r\n    RENDER: require('./RENDER_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    SHUTDOWN: require('./SHUTDOWN_EVENT'),\r\n    SLEEP: require('./SLEEP_EVENT'),\r\n    START: require('./START_EVENT'),\r\n    TRANSITION_COMPLETE: require('./TRANSITION_COMPLETE_EVENT'),\r\n    TRANSITION_INIT: require('./TRANSITION_INIT_EVENT'),\r\n    TRANSITION_OUT: require('./TRANSITION_OUT_EVENT'),\r\n    TRANSITION_START: require('./TRANSITION_START_EVENT'),\r\n    TRANSITION_WAKE: require('./TRANSITION_WAKE_EVENT'),\r\n    UPDATE: require('./UPDATE_EVENT'),\r\n    WAKE: require('./WAKE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsPlainObject = require('./IsPlainObject');\r\n\r\n// @param {boolean} deep - Perform a deep copy?\r\n// @param {object} target - The target object to copy to.\r\n// @return {object} The extended object.\r\n\r\n/**\r\n * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\r\n *\r\n * @function Phaser.Utils.Objects.Extend\r\n * @since 3.0.0\r\n *\r\n * @return {object} The extended object.\r\n */\r\nvar Extend = function ()\r\n{\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean')\r\n    {\r\n        deep = target;\r\n        target = arguments[1] || {};\r\n\r\n        // skip the boolean and the target\r\n        i = 2;\r\n    }\r\n\r\n    // extend Phaser if only one argument is passed\r\n    if (length === i)\r\n    {\r\n        target = this;\r\n        --i;\r\n    }\r\n\r\n    for (; i < length; i++)\r\n    {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null)\r\n        {\r\n            // Extend the base object\r\n            for (name in options)\r\n            {\r\n                src = target[name];\r\n                copy = options[name];\r\n\r\n                // Prevent never-ending loop\r\n                if (target === copy)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\r\n                {\r\n                    if (copyIsArray)\r\n                    {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n                    }\r\n                    else\r\n                    {\r\n                        clone = src && IsPlainObject(src) ? src : {};\r\n                    }\r\n\r\n                    // Never move original objects, clone them\r\n                    target[name] = Extend(deep, clone, copy);\r\n\r\n                // Don't bring in undefined values\r\n                }\r\n                else if (copy !== undefined)\r\n                {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};\r\n\r\nmodule.exports = Extend;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH = require('../../math');\r\nvar GetValue = require('./GetValue');\r\n\r\n/**\r\n * Retrieves a value from an object. Allows for more advanced selection options, including:\r\n *\r\n * Allowed types:\r\n * \r\n * Implicit\r\n * {\r\n *     x: 4\r\n * }\r\n *\r\n * From function\r\n * {\r\n *     x: function ()\r\n * }\r\n *\r\n * Randomly pick one element from the array\r\n * {\r\n *     x: [a, b, c, d, e, f]\r\n * }\r\n *\r\n * Random integer between min and max:\r\n * {\r\n *     x: { randInt: [min, max] }\r\n * }\r\n *\r\n * Random float between min and max:\r\n * {\r\n *     x: { randFloat: [min, max] }\r\n * }\r\n * \r\n *\r\n * @function Phaser.Utils.Objects.GetAdvancedValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetAdvancedValue = function (source, key, defaultValue)\r\n{\r\n    var value = GetValue(source, key, null);\r\n\r\n    if (value === null)\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (Array.isArray(value))\r\n    {\r\n        return MATH.RND.pick(value);\r\n    }\r\n    else if (typeof value === 'object')\r\n    {\r\n        if (value.hasOwnProperty('randInt'))\r\n        {\r\n            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);\r\n        }\r\n        else if (value.hasOwnProperty('randFloat'))\r\n        {\r\n            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);\r\n        }\r\n    }\r\n    else if (typeof value === 'function')\r\n    {\r\n        return value(key);\r\n    }\r\n\r\n    return value;\r\n};\r\n\r\nmodule.exports = GetAdvancedValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a slightly modified version of jQuery.isPlainObject.\r\n * A plain object is an object whose internal class property is [object Object].\r\n *\r\n * @function Phaser.Utils.Objects.IsPlainObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - The object to inspect.\r\n *\r\n * @return {boolean} `true` if the object is plain, otherwise `false`.\r\n */\r\nvar IsPlainObject = function (obj)\r\n{\r\n    // Not plain objects:\r\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n    // - DOM nodes\r\n    // - window\r\n    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // Support: Firefox <20\r\n    // The try/catch suppresses exceptions thrown when attempting to access\r\n    // the \"constructor\" property of certain host objects, ie. |window.location|\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n    try\r\n    {\r\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n\r\nmodule.exports = IsPlainObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar GetFastValue = require('../../../src/utils/object/GetFastValue');\r\nvar ImageFile = require('../../../src/loader/filetypes/ImageFile.js');\r\nvar IsPlainObject = require('../../../src/utils/object/IsPlainObject');\r\nvar JSONFile = require('../../../src/loader/filetypes/JSONFile.js');\r\nvar MultiFile = require('../../../src/loader/MultiFile.js');\r\nvar TextFile = require('../../../src/loader/filetypes/TextFile.js');\r\n\r\n/**\r\n * @typedef {object} Phaser.Loader.FileTypes.SpineFileConfig\r\n *\r\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Texture Manager.\r\n * @property {string} [textureURL] - The absolute or relative URL to load the texture image file from.\r\n * @property {string} [textureExtension='png'] - The default file extension to use for the image texture if no url is provided.\r\n * @property {XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture image file.\r\n * @property {string} [normalMap] - The filename of an associated normal map. It uses the same path and url to load as the texture image.\r\n * @property {string} [atlasURL] - The absolute or relative URL to load the atlas data file from.\r\n * @property {string} [atlasExtension='txt'] - The default file extension to use for the atlas data if no url is provided.\r\n * @property {XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas data file.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Spine File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spine method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spine.\r\n *\r\n * @class SpineFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Loader.FileTypes.SpineFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [jsonURL] - The absolute or relative URL to load the JSON file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {boolean} [preMultipliedAlpha=false] - Do the textures contain pre-multiplied alpha or not?\r\n * @param {XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar SpineFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function SpineFile (loader, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var i;\r\n        var json;\r\n        var atlas;\r\n        var files = [];\r\n        var cache = loader.cacheManager.custom.spine;\r\n\r\n        //  atlas can be an array of atlas files, not just a single one\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            json = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'jsonURL'),\r\n                extension: GetFastValue(config, 'jsonExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'jsonXhrSettings')\r\n            });\r\n\r\n            atlasURL = GetFastValue(config, 'atlasURL');\r\n            preMultipliedAlpha = GetFastValue(config, 'preMultipliedAlpha');\r\n\r\n            if (!Array.isArray(atlasURL))\r\n            {\r\n                atlasURL = [ atlasURL ];\r\n            }\r\n\r\n            for (i = 0; i < atlasURL.length; i++)\r\n            {\r\n                atlas = new TextFile(loader, {\r\n                    key: key,\r\n                    url: atlasURL[i],\r\n                    extension: GetFastValue(config, 'atlasExtension', 'atlas'),\r\n                    xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n                });\r\n\r\n                atlas.cache = cache;\r\n\r\n                files.push(atlas);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            json = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n            if (!Array.isArray(atlasURL))\r\n            {\r\n                atlasURL = [ atlasURL ];\r\n            }\r\n\r\n            for (i = 0; i < atlasURL.length; i++)\r\n            {\r\n                atlas = new TextFile(loader, key + '_' + i, atlasURL[i], atlasXhrSettings);\r\n                atlas.cache = cache;\r\n\r\n                files.push(atlas);\r\n            }\r\n        }\r\n\r\n        files.unshift(json);\r\n\r\n        MultiFile.call(this, loader, 'spine', key, files);\r\n\r\n        this.config.preMultipliedAlpha = preMultipliedAlpha;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpineFile#onFileComplete\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'text')\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var content = file.data.split('\\n');\r\n\r\n                //  Extract the textures\r\n                var textures = [];\r\n\r\n                for (var t = 0; t < content.length; t++)\r\n                {\r\n                    var line = content[t];\r\n\r\n                    if (line.trim() === '' && t < content.length - 1)\r\n                    {\r\n                        line = content[t + 1];\r\n\r\n                        textures.push(line);\r\n                    }\r\n                }\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', this.baseURL);\r\n                var path = GetFastValue(config, 'path', this.path);\r\n                var prefix = GetFastValue(config, 'prefix', this.prefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    var textureURL = textures[i];\r\n\r\n                    var key = 'SP' + this.multiKeyIndex + '_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpineFile#addToCache\r\n     * @since 3.19.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            fileJSON.addToCache();\r\n\r\n            var atlasCache;\r\n            var atlasKey = '';\r\n            var combinedAtlasData = '';\r\n            var preMultipliedAlpha = (this.config.preMultipliedAlpha) ? true : false;\r\n\r\n            for (var i = 1; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                if (file.type === 'text')\r\n                {\r\n                    atlasKey = file.key.substr(0, file.key.length - 2);\r\n\r\n                    atlasCache = file.cache;\r\n\r\n                    combinedAtlasData = combinedAtlasData.concat(file.data);\r\n                }\r\n                else\r\n                {\r\n                    var src = file.key.trim();\r\n                    var pos = src.indexOf('_');\r\n                    var key = src.substr(pos + 1);\r\n       \r\n                    this.loader.textureManager.addImage(key, file.data);\r\n                }\r\n\r\n                file.pendingDestroy();\r\n            }\r\n\r\n            atlasCache.add(atlasKey, { preMultipliedAlpha: preMultipliedAlpha, data: combinedAtlasData });\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../../../src/gameobjects/BuildGameObject');\r\nvar Class = require('../../../src/utils/Class');\r\nvar GetValue = require('../../../src/utils/object/GetValue');\r\nvar ResizeEvent = require('../../../src/scale/events/RESIZE_EVENT');\r\nvar ScenePlugin = require('../../../src/plugins/ScenePlugin');\r\nvar Spine = require('Spine');\r\nvar SpineFile = require('./SpineFile');\r\nvar SpineGameObject = require('./gameobject/SpineGameObject');\r\n\r\n/**\r\n * @classdesc\r\n * The Spine Plugin is a Scene based plugin that handles the creation and rendering of Spine Game Objects.\r\n * \r\n * All rendering and object creation is handled via the official Spine Runtimes. This version of the plugin\r\n * uses the Spine 3.8 runtimes. Files created in a different version of Spine may not work as a result.\r\n * \r\n * You can find more details about Spine at http://esotericsoftware.com/.\r\n * \r\n * Please note that you require a Spine license in order to use Spine Runtimes in your games.\r\n * \r\n * You can install this plugin into your Phaser game by either importing it, if you're using ES6:\r\n * \r\n * ```javascript\r\n * import * as SpinePlugin from './SpinePlugin.js';\r\n * ```\r\n * \r\n * and then adding it to your Phaser Game configuration:\r\n * \r\n * ```javascript\r\n * plugins: {\r\n *     scene: [\r\n *         { key: 'SpinePlugin', plugin: window.SpinePlugin, mapping: 'spine' }\r\n *     ]\r\n * }\r\n * ```\r\n * \r\n * If you're using ES5 then you can load the Spine Plugin in a Scene files payload, _within_ your\r\n * Game Configuration object, like this:\r\n * \r\n * ```javascript\r\n * scene: {\r\n *     preload: preload,\r\n *     create: create,\r\n *     pack: {\r\n *         files: [\r\n *             { type: 'scenePlugin', key: 'SpinePlugin', url: 'plugins/SpinePlugin.js', sceneKey: 'spine' }\r\n *         ]\r\n *     }\r\n * }\r\n * ```\r\n * \r\n * Loading it like this allows you to then use commands such as `this.load.spine` from within the\r\n * same Scene. Alternatively, you can use the method `this.load.plugin` to load the plugin via the normal\r\n * Phaser Loader. However, doing so will not add it to the current Scene. It will be available from any\r\n * subsequent Scenes.\r\n * \r\n * Assuming a default environment you access it from within a Scene by using the `this.spine` reference.\r\n * \r\n * When this plugin is installed into a Scene it will add a Loader File Type, allowing you to load\r\n * Spine files directly, i.e.:\r\n * \r\n * ```javascript\r\n * this.load.spine('stretchyman', 'stretchyman-pro.json', [ 'stretchyman-pma.atlas' ], true);\r\n * ```\r\n * \r\n * It also installs a Game Object Factory method, allowin you to create Spine Game Objects:\r\n * \r\n * ```javascript\r\n * this.add.spine(512, 650, 'stretchyman')\r\n * ```\r\n * \r\n * The first argument is the key which you used when importing the Spine data. There are lots of\r\n * things you can specify, such as the animation name, skeleton, slot attachments and more. Please\r\n * see the respective documentation and examples for further details.\r\n * \r\n * Phaser expects the Spine data to be exported from the Spine application in a JSON format, not binary.\r\n * The associated atlas files are scanned for any texture files present in them, which are then loaded.\r\n * If you have exported your Spine data with preMultipiedAlpha set, then you should enable this in the\r\n * load arguments, or you may see black outlines around skeleton textures.\r\n * \r\n * The Spine plugin is local to the Scene in which it is installed. This means a change to something,\r\n * such as the Skeleton Debug Renderer, in this Scene, will not impact the renderer in any other Scene.\r\n * The only exception to this is with the caches this plugin creates. Spine atlas and texture data are\r\n * stored in their own caches, which are global, meaning they're accessible from any Scene in your\r\n * game, regardless if the Scene loaded the Spine data or not.\r\n * \r\n * For details about the Spine Runtime API see http://esotericsoftware.com/spine-api-reference\r\n *\r\n * @class SpinePlugin\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 3.19.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpinePlugin = new Class({\r\n\r\n    Extends: ScenePlugin,\r\n\r\n    initialize:\r\n\r\n    function SpinePlugin (scene, pluginManager)\r\n    {\r\n        ScenePlugin.call(this, scene, pluginManager);\r\n\r\n        var game = pluginManager.game;\r\n\r\n        /**\r\n         * A read-only flag that indicates if the game is running under WebGL or Canvas.\r\n         *\r\n         * @name SpinePlugin#isWebGL\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.isWebGL = (game.config.renderType === 2);\r\n\r\n        /**\r\n         * A custom cache that stores the Spine atlas data.\r\n         * \r\n         * This cache is global across your game, allowing you to access Spine data loaded from other Scenes,\r\n         * no matter which Scene you are in.\r\n         *\r\n         * @name SpinePlugin#cache\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.cache = game.cache.addCustom('spine');\r\n\r\n        /**\r\n         * A custom cache that stores the Spine Textures.\r\n         * \r\n         * This cache is global across your game, allowing you to access Spine data loaded from other Scenes,\r\n         * no matter which Scene you are in.\r\n         *\r\n         * @name SpinePlugin#spineTextures\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.spineTextures = game.cache.addCustom('spineTextures');\r\n\r\n        /**\r\n         * A reference to the global JSON Cache.\r\n         *\r\n         * @name SpinePlugin#json\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.19.0\r\n         */\r\n        this.json = game.cache.json;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         *\r\n         * @name SpinePlugin#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.19.0\r\n         */\r\n        this.textures = game.textures;\r\n\r\n        /**\r\n         * A flag that sets if the Skeleton Renderers will render debug information over the top\r\n         * of the skeleton or not.\r\n         *\r\n         * @name SpinePlugin#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.drawDebug = false;\r\n\r\n        /**\r\n         * The underlying WebGL context of the Phaser renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.19.0\r\n         */\r\n        this.gl;\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that this Game is using.\r\n         *\r\n         * @name SpinePlugin#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.19.0\r\n         */\r\n        this.renderer;\r\n\r\n        /**\r\n         * An instance of the Spine WebGL Scene Renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#sceneRenderer\r\n         * @type {spine.webgl.SceneRenderer}\r\n         * @since 3.19.0\r\n         */\r\n        this.sceneRenderer;\r\n\r\n        /**\r\n         * An instance of the Spine Skeleton Renderer.\r\n         *\r\n         * @name SpinePlugin#skeletonRenderer\r\n         * @type {(spine.canvas.SkeletonRenderer|spine.webgl.SkeletonRenderer)}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonRenderer;\r\n\r\n        /**\r\n         * An instance of the Spine Skeleton Debug Renderer.\r\n         * \r\n         * Only set if running in WebGL mode.\r\n         *\r\n         * @name SpinePlugin#skeletonDebugRenderer\r\n         * @type {spine.webgl.skeletonDebugRenderer}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonDebugRenderer;\r\n\r\n        /**\r\n         * A reference to the Spine runtime.\r\n         * This is the runtime created by Esoteric Software\r\n         *\r\n         * @name SpinePlugin#plugin\r\n         * @type {spine}\r\n         * @since 3.19.0\r\n         */\r\n        this.plugin = Spine;\r\n\r\n        /**\r\n         * An internal vector3 used by the screen to world method.\r\n         *\r\n         * @name SpinePlugin#temp1\r\n         * @private\r\n         * @type {spine.webgl.Vector3}\r\n         * @since 3.19.0\r\n         */\r\n        this.temp1;\r\n\r\n        /**\r\n         * An internal vector3 used by the screen to world method.\r\n         *\r\n         * @name SpinePlugin#temp2\r\n         * @private\r\n         * @type {spine.webgl.Vector3}\r\n         * @since 3.19.0\r\n         */\r\n        this.temp2;\r\n\r\n        if (this.isWebGL)\r\n        {\r\n            this.runtime = Spine.webgl;\r\n\r\n            this.renderer = game.renderer;\r\n            this.gl = game.renderer.gl;\r\n\r\n            this.getAtlas = this.getAtlasWebGL;\r\n        }\r\n        else\r\n        {\r\n            this.runtime = Spine.canvas;\r\n\r\n            this.renderer = game.renderer;\r\n\r\n            this.getAtlas = this.getAtlasCanvas;\r\n        }\r\n\r\n        var _this = this;\r\n\r\n        var add = function (x, y, key, animationName, loop)\r\n        {\r\n            var spineGO = new SpineGameObject(this.scene, _this, x, y, key, animationName, loop);\r\n    \r\n            this.displayList.add(spineGO);\r\n            this.updateList.add(spineGO);\r\n        \r\n            return spineGO;\r\n        };\r\n\r\n        var make = function (config, addToScene)\r\n        {\r\n            if (config === undefined) { config = {}; }\r\n    \r\n            var key = GetValue(config, 'key', null);\r\n            var animationName = GetValue(config, 'animationName', null);\r\n            var loop = GetValue(config, 'loop', false);\r\n    \r\n            var spineGO = new SpineGameObject(this.scene, _this, 0, 0, key, animationName, loop);\r\n    \r\n            if (addToScene !== undefined)\r\n            {\r\n                config.add = addToScene;\r\n            }\r\n    \r\n            BuildGameObject(this.scene, spineGO, config);\r\n    \r\n            //  Spine specific\r\n            var skinName = GetValue(config, 'skinName', false);\r\n    \r\n            if (skinName)\r\n            {\r\n                spineGO.setSkinByName(skinName);\r\n            }\r\n    \r\n            var slotName = GetValue(config, 'slotName', false);\r\n            var attachmentName = GetValue(config, 'attachmentName', null);\r\n    \r\n            if (slotName)\r\n            {\r\n                spineGO.setAttachment(slotName, attachmentName);\r\n            }\r\n    \r\n            return spineGO.refresh();\r\n        };\r\n\r\n        pluginManager.registerFileType('spine', this.spineFileCallback, scene);\r\n        pluginManager.registerGameObject('spine', add, make);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler.\r\n     *\r\n     * @method SpinePlugin#boot\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        if (this.isWebGL)\r\n        {\r\n            this.bootWebGL();\r\n            this.onResize();\r\n            this.game.scale.on(ResizeEvent, this.onResize, this);\r\n        }\r\n        else\r\n        {\r\n            this.bootCanvas();\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.once('shutdown', this.shutdown, this);\r\n        eventEmitter.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler for the Canvas Renderer.\r\n     *\r\n     * @method SpinePlugin#bootCanvas\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    bootCanvas: function ()\r\n    {\r\n        this.skeletonRenderer = new Spine.canvas.SkeletonRenderer(this.scene.sys.context);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler for the WebGL Renderer.\r\n     *\r\n     * @method SpinePlugin#bootWebGL\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    bootWebGL: function ()\r\n    {\r\n        this.sceneRenderer = new Spine.webgl.SceneRenderer(this.renderer.canvas, this.gl, true);\r\n\r\n        //  Monkeypatch the Spine setBlendMode functions, or batching is destroyed\r\n\r\n        var setBlendMode = function (srcBlend, dstBlend)\r\n        {\r\n            if (srcBlend !== this.srcBlend || dstBlend !== this.dstBlend)\r\n            {\r\n                var gl = this.context.gl;\r\n\r\n                this.srcBlend = srcBlend;\r\n                this.dstBlend = dstBlend;\r\n\r\n                if (this.isDrawing)\r\n                {\r\n                    this.flush();\r\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\r\n                }\r\n            }\r\n        };\r\n\r\n        this.sceneRenderer.batcher.setBlendMode = setBlendMode;\r\n        this.sceneRenderer.shapes.setBlendMode = setBlendMode;\r\n\r\n        this.skeletonRenderer = this.sceneRenderer.skeletonRenderer;\r\n        this.skeletonDebugRenderer = this.sceneRenderer.skeletonDebugRenderer;\r\n\r\n        this.temp1 = new Spine.webgl.Vector3(0, 0, 0);\r\n        this.temp2 = new Spine.webgl.Vector3(0, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Gets a loaded Spine Atlas from the cache and creates a new Spine Texture Atlas,\r\n     * then returns it. You do not normally need to invoke this method directly.\r\n     *\r\n     * @method SpinePlugin#getAtlasCanvas\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine Atlas to create.\r\n     * \r\n     * @return {spine.TextureAtlas} The Spine Texture Atlas, or undefined if the given key wasn't found.\r\n     */\r\n    getAtlasCanvas: function (key)\r\n    {\r\n        var atlasEntry = this.cache.get(key);\r\n\r\n        if (!atlasEntry)\r\n        {\r\n            console.warn('No atlas data for: ' + key);\r\n            return;\r\n        }\r\n\r\n        var atlas;\r\n        var spineTextures = this.spineTextures;\r\n\r\n        if (spineTextures.has(key))\r\n        {\r\n            atlas = spineTextures.get(key);\r\n        }\r\n        else\r\n        {\r\n            var textures = this.textures;\r\n\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function (path)\r\n            {\r\n                return new Spine.canvas.CanvasTexture(textures.get(path).getSourceImage());\r\n            });\r\n        }\r\n\r\n        return atlas;\r\n    },\r\n\r\n    /**\r\n     * Gets a loaded Spine Atlas from the cache and creates a new Spine Texture Atlas,\r\n     * then returns it. You do not normally need to invoke this method directly.\r\n     *\r\n     * @method SpinePlugin#getAtlasWebGL\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine Atlas to create.\r\n     * \r\n     * @return {spine.TextureAtlas} The Spine Texture Atlas, or undefined if the given key wasn't found.\r\n     */\r\n    getAtlasWebGL: function (key)\r\n    {\r\n        var atlasEntry = this.cache.get(key);\r\n\r\n        if (!atlasEntry)\r\n        {\r\n            console.warn('No atlas data for: ' + key);\r\n            return;\r\n        }\r\n\r\n        var atlas;\r\n        var spineTextures = this.spineTextures;\r\n\r\n        if (spineTextures.has(key))\r\n        {\r\n            atlas = spineTextures.get(key);\r\n        }\r\n        else\r\n        {\r\n            var textures = this.textures;\r\n\r\n            var gl = this.sceneRenderer.context.gl;\r\n\r\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n\r\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function (path)\r\n            {\r\n                return new Spine.webgl.GLTexture(gl, textures.get(path).getSourceImage(), false);\r\n            });\r\n        }\r\n\r\n        return atlas;\r\n    },\r\n\r\n    /**\r\n     * Adds a Spine Skeleton and Atlas file, or array of files, to the current load queue.\r\n     *\r\n     * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n     * \r\n     * ```javascript\r\n     * function preload ()\r\n     * {\r\n     *     this.load.spine('spineBoy', 'boy.json', 'boy.atlas', true);\r\n     * }\r\n     * ```\r\n     *\r\n     * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n     * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n     * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n     * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n     * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n     * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n     * loaded.\r\n     * \r\n     * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n     * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n     * \r\n     * Phaser expects the Spine data to be exported from the Spine application in a JSON format, not binary. The associated\r\n     * atlas files are scanned for any texture files present in them, which are then loaded. If you have exported\r\n     * your Spine data with preMultipiedAlpha set, then you should enable this in the arguments, or you may see black\r\n     * outlines around skeleton textures.\r\n     * \r\n     * The key must be a unique String. It is used to add the file to the global Spine cache upon a successful load.\r\n     * The key should be unique both in terms of files being loaded and files already present in the Spine cache.\r\n     * Loading a file using a key that is already taken will result in a warning.\r\n     *\r\n     * Instead of passing arguments you can pass a configuration object, such as:\r\n     * \r\n     * ```javascript\r\n     * this.load.spine({\r\n     *     key: 'mainmenu',\r\n     *     jsonURL: 'boy.json',\r\n     *     atlasURL: 'boy.atlas',\r\n     *     preMultipliedAlpha: true\r\n     * });\r\n     * ```\r\n     * \r\n     * If you need to load multiple Spine atlas files, provide them as an array:\r\n     * \r\n     * ```javascript\r\n     * function preload ()\r\n     * {\r\n     *     this.load.spine('demos', 'demos.json', [ 'atlas1.atlas', 'atlas2.atlas' ], true);\r\n     * }\r\n     * ```\r\n     *\r\n     * See the documentation for `Phaser.Types.Loader.FileTypes.SpineFileConfig` for more details.\r\n     *\r\n     * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n     * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n     * this is what you would use to retrieve the data from the Spine plugin.\r\n     *\r\n     * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n     *\r\n     * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n     * and no URL is given then the Loader will set the URL to be \"alien.json\". It will always add `.json` as the extension, although\r\n     * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n     *\r\n     * Note: The ability to load this type of file will only be available if the Spine Plugin has been built or loaded into Phaser.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#spine\r\n     * @fires Phaser.Loader.LoaderPlugin#addFileEvent\r\n     * @since 3.19.0\r\n     *\r\n     * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n     * @param {string} jsonURL - The absolute or relative URL to load the Spine json file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n     * @param {string|string[]} atlasURL - The absolute or relative URL to load the Spine atlas file from. If undefined or `null` it will be set to `<key>.atlas`, i.e. if `key` was \"alien\" then the URL will be \"alien.atlas\".\r\n     * @param {boolean} [preMultipiedAlpha=false] - Do the texture files include pre-multiplied alpha or not?\r\n     * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the Spine json file. Used in replacement of the Loaders default XHR Settings.\r\n     * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the Spine atlas file. Used in replacement of the Loaders default XHR Settings.\r\n     *\r\n     * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\r\n     */\r\n    spineFileCallback: function (key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\r\n    {\r\n        var multifile;\r\n   \r\n        if (Array.isArray(key))\r\n        {\r\n            for (var i = 0; i < key.length; i++)\r\n            {\r\n                multifile = new SpineFile(this, key[i]);\r\n    \r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            multifile = new SpineFile(this, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n        \r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts the given x and y screen coordinates into the world space of the given Skeleton.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#worldToLocal\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The screen space x coordinate to convert.\r\n     * @param {number} y - The screen space y coordinate to convert.\r\n     * @param {spine.Skeleton} skeleton - The Spine Skeleton to convert into.\r\n     * @param {spine.Bone} [bone] - Optional bone of the Skeleton to convert into.\r\n     * \r\n     * @return {spine.Vector2} A Vector2 containing the translated point.\r\n     */\r\n    worldToLocal: function (x, y, skeleton, bone)\r\n    {\r\n        var temp1 = this.temp1;\r\n        var temp2 = this.temp2;\r\n        var camera = this.sceneRenderer.camera;\r\n\r\n        temp1.set(x + skeleton.x, y - skeleton.y, 0);\r\n\r\n        var width = camera.viewportWidth;\r\n        var height = camera.viewportHeight;\r\n\r\n        camera.screenToWorld(temp1, width, height);\r\n\r\n        if (bone && bone.parent !== null)\r\n        {\r\n            bone.parent.worldToLocal(temp2.set(temp1.x - skeleton.x, temp1.y - skeleton.y, 0));\r\n\r\n            return new Spine.Vector2(temp2.x, temp2.y);\r\n        }\r\n        else if (bone)\r\n        {\r\n            return new Spine.Vector2(temp1.x - skeleton.x, temp1.y - skeleton.y);\r\n        }\r\n        else\r\n        {\r\n            return new Spine.Vector2(temp1.x, temp1.y);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a Spine Vector2 based on the given x and y values.\r\n     *\r\n     * @method SpinePlugin#getVector2\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The Vector x value.\r\n     * @param {number} y - The Vector y value.\r\n     * \r\n     * @return {spine.Vector2} A Spine Vector2 based on the given values.\r\n     */\r\n    getVector2: function (x, y)\r\n    {\r\n        return new Spine.Vector2(x, y);\r\n    },\r\n\r\n    /**\r\n     * Returns a Spine Vector2 based on the given x, y and z values.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#getVector3\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} x - The Vector x value.\r\n     * @param {number} y - The Vector y value.\r\n     * @param {number} z - The Vector z value.\r\n     * \r\n     * @return {spine.Vector2} A Spine Vector2 based on the given values.\r\n     */\r\n    getVector3: function (x, y, z)\r\n    {\r\n        return new Spine.webgl.Vector3(x, y, z);\r\n    },\r\n\r\n    /**\r\n     * Sets `drawBones` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugBones\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugBones: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawBones = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawRegionAttachments` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugRegionAttachments\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugRegionAttachments: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawRegionAttachments = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawBoundingBoxes` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugBoundingBoxes\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugBoundingBoxes: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawBoundingBoxes = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawMeshHull` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugMeshHull\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugMeshHull: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawMeshHull = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawMeshTriangles` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugMeshTriangles\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugMeshTriangles: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawMeshTriangles = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawPaths` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugPaths\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugPaths: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawPaths = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawSkeletonXY` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugSkeletonXY\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugSkeletonXY: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawSkeletonXY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets `drawClipping` in the Spine Skeleton Debug Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setDebugClipping\r\n     * @since 3.19.0\r\n     * \r\n     * @param {boolean} [value=true] - The value to set in the debug property.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setDebugClipping: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skeletonDebugRenderer.drawClipping = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given vertex effect on the Spine Skeleton Renderer.\r\n     * \r\n     * Only works in WebGL.\r\n     *\r\n     * @method SpinePlugin#setEffect\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.VertexEffect} [effect] - The vertex effect to set on the Skeleton Renderer.\r\n     * \r\n     * @return {this} This Spine Plugin.\r\n     */\r\n    setEffect: function (effect)\r\n    {\r\n        this.sceneRenderer.skeletonRenderer.vertexEffect = effect;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a Spine Skeleton based on the given key and optional Skeleton JSON data.\r\n     * \r\n     * The Skeleton data should have already been loaded before calling this method.\r\n     *\r\n     * @method SpinePlugin#createSkeleton\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} key - The key of the Spine skeleton data, as loaded by the plugin. If the Spine JSON contains multiple skeletons, reference them with a period, i.e. `set.spineBoy`.\r\n     * @param {object} [skeletonJSON] - Optional Skeleton JSON data to use, instead of getting it from the cache.\r\n     * \r\n     * @return {(any|null)} This Spine Skeleton data object, or `null` if the key was invalid.\r\n     */\r\n    createSkeleton: function (key, skeletonJSON)\r\n    {\r\n        var atlasKey = key;\r\n        var jsonKey = key;\r\n        var split = (key.indexOf('.') !== -1);\r\n\r\n        if (split)\r\n        {\r\n            var parts = key.split('.');\r\n\r\n            atlasKey = parts.shift();\r\n            jsonKey = parts.join('.');\r\n        }\r\n\r\n        var atlasData = this.cache.get(atlasKey);\r\n        var atlas = this.getAtlas(atlasKey);\r\n\r\n        if (!atlas)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        if (!this.spineTextures.has(atlasKey))\r\n        {\r\n            this.spineTextures.add(atlasKey, atlas);\r\n        }\r\n\r\n        var preMultipliedAlpha = atlasData.preMultipliedAlpha;\r\n\r\n        var atlasLoader = new Spine.AtlasAttachmentLoader(atlas);\r\n        \r\n        var skeletonJson = new Spine.SkeletonJson(atlasLoader);\r\n\r\n        var data;\r\n\r\n        if (skeletonJSON)\r\n        {\r\n            data = skeletonJSON;\r\n        }\r\n        else\r\n        {\r\n            var json = this.json.get(atlasKey);\r\n\r\n            data = (split) ? GetValue(json, jsonKey) : json;\r\n        }\r\n\r\n        if (data)\r\n        {\r\n            var skeletonData = skeletonJson.readSkeletonData(data);\r\n\r\n            var skeleton = new Spine.Skeleton(skeletonData);\r\n        \r\n            return { skeletonData: skeletonData, skeleton: skeleton, preMultipliedAlpha: preMultipliedAlpha };\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Animation State and Animation State Data for the given skeleton.\r\n     * \r\n     * The returned object contains two properties: `state` and `stateData` respectively.\r\n     *\r\n     * @method SpinePlugin#createAnimationState\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Skeleton} skeleton - The Skeleton to create the Animation State for.\r\n     * \r\n     * @return {any} An object containing the Animation State and Animation State Data instances.\r\n     */\r\n    createAnimationState: function (skeleton)\r\n    {\r\n        var stateData = new Spine.AnimationStateData(skeleton.data);\r\n\r\n        var state = new Spine.AnimationState(stateData);\r\n\r\n        return { stateData: stateData, state: state };\r\n    },\r\n\r\n    /**\r\n     * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * \r\n     * The returned object contains two properties: `offset` and `size`:\r\n     * \r\n     * `offset` - The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * `size` - The width and height of the AABB.\r\n     *\r\n     * @method SpinePlugin#getBounds\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Skeleton} skeleton - The Skeleton to get the bounds from.\r\n     * \r\n     * @return {any} The bounds object.\r\n     */\r\n    getBounds: function (skeleton)\r\n    {\r\n        var offset = new Spine.Vector2();\r\n        var size = new Spine.Vector2();\r\n\r\n        skeleton.getBounds(offset, size, []);\r\n\r\n        return { offset: offset, size: size };\r\n    },\r\n\r\n    /**\r\n     * Internal handler for when the renderer resizes.\r\n     * \r\n     * Only called if running in WebGL.\r\n     *\r\n     * @method SpinePlugin#onResize\r\n     * @since 3.19.0\r\n     */\r\n    onResize: function ()\r\n    {\r\n        var renderer = this.renderer;\r\n        var sceneRenderer = this.sceneRenderer;\r\n\r\n        var viewportWidth = renderer.width;\r\n        var viewportHeight = renderer.height;\r\n\r\n        sceneRenderer.camera.position.x = viewportWidth / 2;\r\n        sceneRenderer.camera.position.y = viewportHeight / 2;\r\n    \r\n        sceneRenderer.camera.viewportWidth = viewportWidth;\r\n        sceneRenderer.camera.viewportHeight = viewportHeight;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * \r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method SpinePlugin#shutdown\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * \r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method SpinePlugin#destroy\r\n     * @private\r\n     * @since 3.19.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        if (this.sceneRenderer)\r\n        {\r\n            this.sceneRenderer.dispose();\r\n        }\r\n\r\n        this.pluginManager.removeGameObject('spine', true, true);\r\n\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n\r\n        this.cache = null;\r\n        this.spineTextures = null;\r\n        this.json = null;\r\n        this.textures = null;\r\n        this.sceneRenderer = null;\r\n        this.skeletonRenderer = null;\r\n        this.gl = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a new Spine Game Object and adds it to the Scene.\r\n * \r\n * The x and y coordinate given is used to set the placement of the root Spine bone, which can vary from\r\n * skeleton to skeleton. All rotation and scaling happens from the root bone placement. Spine Game Objects\r\n * do not have a Phaser origin.\r\n * \r\n * If the Spine JSON file exported multiple Skeletons within it, then you can specify them by using a period\r\n * character in the key. For example, if you loaded a Spine JSON using the key `monsters` and it contains\r\n * multiple Skeletons, including one called `goblin` then you would use the key `monsters.goblin` to reference\r\n * that.\r\n * \r\n * ```javascript\r\n * let jelly = this.add.spine(512, 550, 'jelly', 'jelly-think', true);\r\n * ```\r\n * \r\n * The key is optional. If not passed here, you need to call `SpineGameObject.setSkeleton()` to use it.\r\n * \r\n * The animation name is also optional and can be set later via `SpineGameObject.setAnimation`.\r\n * \r\n * Should you wish for more control over the object creation, such as setting a slot attachment or skin\r\n * name, then use `SpinePlugin.make` instead.\r\n *\r\n * @method SpinePlugin#add\r\n * @since 3.19.0\r\n * \r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - The key of the Spine Skeleton this Game Object will use, as stored in the Spine Plugin.\r\n * @param {string} [animationName] - The name of the animation to set on this Skeleton.\r\n * @param {boolean} [loop=false] - Should the animation playback be looped or not?\r\n *\r\n * @return {SpineGameObject} The Game Object that was created.\r\n */\r\n\r\n/**\r\n * Creates a new Spine Game Object from the given configuration file and optionally adds it to the Scene.\r\n * \r\n * The x and y coordinate given is used to set the placement of the root Spine bone, which can vary from\r\n * skeleton to skeleton. All rotation and scaling happens from the root bone placement. Spine Game Objects\r\n * do not have a Phaser origin.\r\n * \r\n * If the Spine JSON file exported multiple Skeletons within it, then you can specify them by using a period\r\n * character in the key. For example, if you loaded a Spine JSON using the key `monsters` and it contains\r\n * multiple Skeletons, including one called `goblin` then you would use the key `monsters.goblin` to reference\r\n * that.\r\n * \r\n * ```javascript\r\n * let jelly = this.make.spine({\r\n *     x: 500, y: 500, key: 'jelly',\r\n *     scale: 1.5,\r\n *     skinName: 'square_Green',\r\n *     animationName: 'jelly-idle', loop: true,\r\n *     slotName: 'hat', attachmentName: 'images/La_14'\r\n * });\r\n * ```\r\n *\r\n * @method SpinePlugin#make\r\n * @since 3.19.0\r\n *\r\n * @param {any} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {SpineGameObject} The Game Object that was created.\r\n */\r\n\r\nmodule.exports = SpinePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Complete Event.\r\n *\r\n * @event SpinePluginEvents#COMPLETE\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Dispose Event.\r\n *\r\n * @event SpinePluginEvents#DISPOSE\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'dispose';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The End Event.\r\n *\r\n * @event SpinePluginEvents#END\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'end';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Custom Event Event.\r\n *\r\n * @event SpinePluginEvents#EVENT\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'event';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Interrupted Event.\r\n *\r\n * @event SpinePluginEvents#INTERRUPTED\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'interrupted';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Start Event.\r\n *\r\n * @event SpinePluginEvents#START\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace SpinePluginEvents\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    DISPOSE: require('./DISPOSE_EVENT'),\r\n    END: require('./END_EVENT'),\r\n    EVENT: require('./EVENT_EVENT'),\r\n    INTERRUPTED: require('./INTERRUPTED_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar AngleBetween = require('../../../../src/math/angle/Between');\r\nvar Clamp = require('../../../../src/math/Clamp');\r\nvar Class = require('../../../../src/utils/Class');\r\nvar ComponentsComputedSize = require('../../../../src/gameobjects/components/ComputedSize');\r\nvar ComponentsDepth = require('../../../../src/gameobjects/components/Depth');\r\nvar ComponentsFlip = require('../../../../src/gameobjects/components/Flip');\r\nvar ComponentsScrollFactor = require('../../../../src/gameobjects/components/ScrollFactor');\r\nvar ComponentsTransform = require('../../../../src/gameobjects/components/Transform');\r\nvar ComponentsVisible = require('../../../../src/gameobjects/components/Visible');\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\nvar DegToRad = require('../../../../src/math/DegToRad');\r\nvar GameObject = require('../../../../src/gameobjects/GameObject');\r\nvar RadToDeg = require('../../../../src/math/RadToDeg');\r\nvar SpineEvents = require('../events/');\r\nvar SpineGameObjectRender = require('./SpineGameObjectRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Spine Game Object is a Phaser level object that can be added to your Phaser Scenes. It encapsulates\r\n * a Spine Skeleton with Spine Animation Data and Animation State, with helper methods to allow you to\r\n * easily change the skin, slot attachment, bone positions and more.\r\n * \r\n * Spine Game Objects can be created via the Game Object Factory, Game Object Creator, or directly.\r\n * You can only create them if the Spine plugin has been loaded into Phaser.\r\n * \r\n * The quickest way is the Game Object Factory:\r\n * \r\n * ```javascript\r\n * let jelly = this.add.spine(512, 550, 'jelly', 'jelly-think', true);\r\n * ```\r\n * \r\n * Here we are creating a new Spine Game Object positioned at 512 x 550. It's using the `jelly`\r\n * Spine data, which has previously been loaded into your Scene. The `jelly-think` argument is\r\n * an optional animation to start playing on the skeleton. The final argument `true` sets the\r\n * animation to loop. Look at the documentation for further details on each of these options.\r\n * \r\n * For more control, you can use the Game Object Creator, passing in a Spine Game Object\r\n * Configuration object:\r\n * \r\n * ```javascript\r\n * let jelly = this.make.spine({\r\n *     x: 512, y: 550, key: 'jelly',\r\n *     scale: 1.5,\r\n *     skinName: 'square_Green',\r\n *     animationName: 'jelly-think', loop: true,\r\n *     slotName: 'hat', attachmentName: 'images/La_14'\r\n * });\r\n * ```\r\n * \r\n * Here, you've got the ability to specify extra details, such as the slot name, attachments or\r\n * overall scale.\r\n * \r\n * If you wish to instantiate a Spine Game Object directly you can do so, but in order for it to\r\n * update and render, it must be added to the display and update lists of your Scene:\r\n * \r\n * ```javascript\r\n * let jelly = new SpineGameObject(this, this.spine, 512, 550, 'jelly', 'jelly-think', true);\r\n * this.sys.displayList.add(jelly);\r\n * this.sys.updateList.add(jelly);\r\n * ```\r\n * \r\n * It's possible to enable Spine Game Objects for input, but you should be aware that it will use\r\n * the bounds of the skeletons current pose to create the hit area from. Sometimes this is ok, but\r\n * often not. Make use of the `InputPlugin.enableDebug` method to view the input shape being created.\r\n * If it's not suitable, provide your own shape to the `setInteractive` method.\r\n * \r\n * Due to the way Spine handles scaling, it's not recommended to enable a Spine Game Object for\r\n * physics directly. Instead, you should look at creating a proxy body and syncing the Spine Game\r\n * Object position with it. See the examples for further details.\r\n * \r\n * If your Spine Game Object has black outlines around the different parts of the texture when it\r\n * renders then you have exported the files from Spine with pre-multiplied alpha enabled, but have\r\n * forgotten to set that flag when loading the Spine data. Please see the loader docs for more details.\r\n *\r\n * @class SpineGameObject\r\n * @constructor\r\n * @since 3.19.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Game Object belongs to.\r\n * @param {SpinePlugin} pluginManager - A reference to the Phaser Spine Plugin.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - The key of the Spine Skeleton this Game Object will use, as stored in the Spine Plugin.\r\n * @param {string} [animationName] - The name of the animation to set on this Skeleton.\r\n * @param {boolean} [loop=false] - Should the animation playback be looped or not?\r\n */\r\nvar SpineGameObject = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        ComponentsComputedSize,\r\n        ComponentsDepth,\r\n        ComponentsFlip,\r\n        ComponentsScrollFactor,\r\n        ComponentsTransform,\r\n        ComponentsVisible,\r\n        SpineGameObjectRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function SpineGameObject (scene, plugin, x, y, key, animationName, loop)\r\n    {\r\n        GameObject.call(this, scene, 'Spine');\r\n\r\n        /**\r\n         * A reference to the Spine Plugin.\r\n         *\r\n         * @name SpineGameObject#plugin\r\n         * @type {SpinePlugin}\r\n         * @since 3.19.0\r\n         */\r\n        this.plugin = plugin;\r\n\r\n        /**\r\n         * The Spine Skeleton this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#skeleton\r\n         * @type {spine.Skeleton}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeleton = null;\r\n\r\n        /**\r\n         * The Spine Skeleton Data associated with the Skeleton this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#skeletonData\r\n         * @type {spine.SkeletonData}\r\n         * @since 3.19.0\r\n         */\r\n        this.skeletonData = null;\r\n\r\n        /**\r\n         * The Spine Animation State this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#state\r\n         * @type {spine.AnimationState}\r\n         * @since 3.19.0\r\n         */\r\n        this.state = null;\r\n\r\n        /**\r\n         * The Spine Animation State Data associated with the Animation State this Game Object is using.\r\n         *\r\n         * @name SpineGameObject#stateData\r\n         * @type {spine.AnimationStateData}\r\n         * @since 3.19.0\r\n         */\r\n        this.stateData = null;\r\n\r\n        /**\r\n         * A reference to the root bone of the Skeleton.\r\n         *\r\n         * @name SpineGameObject#root\r\n         * @type {spine.Bone}\r\n         * @since 3.19.0\r\n         */\r\n        this.root = null;\r\n\r\n        /**\r\n         * This object holds the calculated bounds of the current\r\n         * pose, as set when a new Skeleton is applied.\r\n         *\r\n         * @name SpineGameObject#bounds\r\n         * @type {any}\r\n         * @since 3.19.0\r\n         */\r\n        this.bounds = null;\r\n        \r\n        /**\r\n         * A Game Object level flag that allows you to enable debug drawing\r\n         * to the Skeleton Debug Renderer by toggling it.\r\n         *\r\n         * @name SpineGameObject#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.drawDebug = false;\r\n\r\n        /**\r\n         * The factor to scale the Animation update time by.\r\n         *\r\n         * @name SpineGameObject#timeScale\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * The calculated Display Origin of this Game Object.\r\n         *\r\n         * @name SpineGameObject#displayOriginX\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.displayOriginX = 0;\r\n\r\n        /**\r\n         * The calculated Display Origin of this Game Object.\r\n         *\r\n         * @name SpineGameObject#displayOriginY\r\n         * @type {number}\r\n         * @since 3.19.0\r\n         */\r\n        this.displayOriginY = 0;\r\n\r\n        /**\r\n         * A flag that stores if the texture associated with the current\r\n         * Skin being used by this Game Object, has its alpha pre-multiplied\r\n         * into it, or not.\r\n         *\r\n         * @name SpineGameObject#preMultipliedAlpha\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.preMultipliedAlpha = false;\r\n\r\n        /**\r\n         * A default Blend Mode. You cannot change the blend mode of a\r\n         * Spine Game Object.\r\n         *\r\n         * @name SpineGameObject#blendMode\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.blendMode = 0;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key)\r\n        {\r\n            this.setSkeleton(key, animationName, loop);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Overrides the default Game Object method and always returns true.\r\n     * Rendering is decided in the renderer functions.\r\n     *\r\n     * @method SpineGameObject#willRender\r\n     * @since 3.19.0\r\n     *\r\n     * @return {boolean} Always returns `true`.\r\n     */\r\n    willRender: function ()\r\n    {\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level for the whole Skeleton of this Game Object.\r\n     * \r\n     * The alpha controls the opacity of the Game Object as it renders.\r\n     * \r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * @method SpineGameObject#setAlpha\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} [value=1] - The alpha value used for the whole Skeleton.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlpha: function (value, slotName)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (slotName)\r\n        {\r\n            var slot = this.findSlot(slotName);\r\n\r\n            if (slot)\r\n            {\r\n                slot.color.a = Clamp(value, 0, 1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.alpha = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#alpha\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.a;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.a = v;\r\n            }\r\n\r\n            if (v === 0)\r\n            {\r\n                this.renderFlags &= ~2;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= 2;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of red used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#red\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    red: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.r;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.r = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of green used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#green\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    green: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.g;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.g = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The amount of blue used when rendering the Skeleton.\r\n     * \r\n     * A value between 0 and 1.\r\n     *\r\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\r\n     *\r\n     * @name SpineGameObject#blue\r\n     * @type {number}\r\n     * @since 3.19.0\r\n     */\r\n    blue: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.skeleton.color.b;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            if (this.skeleton)\r\n            {\r\n                this.skeleton.color.b = v;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the color on the given attachment slot. Or, if no slot is given, on the whole skeleton.\r\n     *\r\n     * @method SpineGameObject#setColor\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} [color=0xffffff] - The color being applied to the Skeleton or named Slot. Set to white to disable any previously set color.\r\n     * @param {string} [slotName] - The name of the slot to set the color on. If not give, will be set on the whole skeleton.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setColor: function (color, slotName)\r\n    {\r\n        if (color === undefined) { color = 0xffffff; }\r\n\r\n        var red = (color >> 16 & 0xFF) / 255;\r\n        var green = (color >> 8 & 0xFF) / 255;\r\n        var blue = (color & 0xFF) / 255;\r\n        var alpha = (color > 16777215) ? (color >>> 24) / 255 : null;\r\n\r\n        var target = this.skeleton;\r\n\r\n        if (slotName)\r\n        {\r\n            var slot = this.findSlot(slotName);\r\n\r\n            if (slot)\r\n            {\r\n                target = slot;\r\n            }\r\n        }\r\n\r\n        target.color.r = red;\r\n        target.color.g = green;\r\n        target.color.b = blue;\r\n\r\n        if (alpha !== null)\r\n        {\r\n            target.color.a = alpha;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Game Object to use the given Skeleton based on the Atlas Data Key and a provided JSON object\r\n     * that contains the Skeleton data.\r\n     *\r\n     * @method SpineGameObject#setSkeletonFromJSON\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} atlasDataKey - The key of the Spine data to use for this Skeleton.\r\n     * @param {object} skeletonJSON - The JSON data for the Skeleton.\r\n     * @param {string} [animationName] - Optional name of the animation to set on the Skeleton.\r\n     * @param {boolean} [loop=false] - Should the animation, if set, loop or not?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkeletonFromJSON: function (atlasDataKey, skeletonJSON, animationName, loop)\r\n    {\r\n        return this.setSkeleton(atlasDataKey, skeletonJSON, animationName, loop);\r\n    },\r\n\r\n    /**\r\n     * Sets this Game Object to use the given Skeleton based on its cache key.\r\n     * \r\n     * Typically, once set, the Skeleton doesn't change. Instead, you change the skin,\r\n     * or slot attachment, or any other property to adjust it.\r\n     *\r\n     * @method SpineGameObject#setSkeleton\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} atlasDataKey - The key of the Spine data to use for this Skeleton.\r\n     * @param {object} skeletonJSON - The JSON data for the Skeleton.\r\n     * @param {string} [animationName] - Optional name of the animation to set on the Skeleton.\r\n     * @param {boolean} [loop=false] - Should the animation, if set, loop or not?\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkeleton: function (atlasDataKey, animationName, loop, skeletonJSON)\r\n    {\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        var data = this.plugin.createSkeleton(atlasDataKey, skeletonJSON);\r\n\r\n        this.skeletonData = data.skeletonData;\r\n\r\n        this.preMultipliedAlpha = data.preMultipliedAlpha;\r\n\r\n        var skeleton = data.skeleton;\r\n\r\n        skeleton.setSkin();\r\n        skeleton.setToSetupPose();\r\n\r\n        this.skeleton = skeleton;\r\n\r\n        //  AnimationState\r\n        data = this.plugin.createAnimationState(skeleton);\r\n\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.state = data.state;\r\n        this.stateData = data.stateData;\r\n\r\n        this.state.addListener({\r\n            event: this.onEvent.bind(this),\r\n            complete: this.onComplete.bind(this),\r\n            start: this.onStart.bind(this),\r\n            end: this.onEnd.bind(this),\r\n            dispose: this.onDispose.bind(this),\r\n            interrupted: this.onInterrupted.bind(this)\r\n        });\r\n\r\n        if (animationName)\r\n        {\r\n            this.setAnimation(0, animationName, loop);\r\n        }\r\n\r\n        this.root = this.getRootBone();\r\n\r\n        if (this.root)\r\n        {\r\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\r\n        }\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        skeleton.updateCache();\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onComplete event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onComplete\r\n     * @fires SpinePluginEvents#COMPLETE\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onComplete: function (entry)\r\n    {\r\n        this.emit(SpineEvents.COMPLETE, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onDispose event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onDispose\r\n     * @fires SpinePluginEvents#DISPOSE\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onDispose: function (entry)\r\n    {\r\n        this.emit(SpineEvents.DISPOSE, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onEnd event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onEnd\r\n     * @fires SpinePluginEvents#END\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onEnd: function (entry)\r\n    {\r\n        this.emit(SpineEvents.END, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine Event event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onEvent\r\n     * @fires SpinePluginEvents#EVENT\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     * @param {spine.Event} event - The Spine event.\r\n     */\r\n    onEvent: function (entry, event)\r\n    {\r\n        this.emit(SpineEvents.EVENT, entry, event);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onInterrupted event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onInterrupted\r\n     * @fires SpinePluginEvents#INTERRUPTED\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onInterrupted: function (entry)\r\n    {\r\n        this.emit(SpineEvents.INTERRUPTED, entry);\r\n    },\r\n\r\n    /**\r\n     * Internal event handler that emits the Spine onStart event via this Game Object.\r\n     *\r\n     * @method SpineGameObject#onStart\r\n     * @fires SpinePluginEvents#START\r\n     * @private\r\n     * @since 3.19.0\r\n     * \r\n     * @param {any} entry - The event data from Spine.\r\n     */\r\n    onStart: function (entry)\r\n    {\r\n        this.emit(SpineEvents.START, entry);\r\n    },\r\n\r\n    /**\r\n     * Refreshes the data about the current Skeleton.\r\n     * \r\n     * This will reset the rotation, position and size of the Skeleton to match this Game Object.\r\n     * \r\n     * Call this method if you need to access the Skeleton data directly, and it may have changed\r\n     * recently.\r\n     *\r\n     * @method SpineGameObject#refresh\r\n     * @since 3.19.0\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        if (this.root)\r\n        {\r\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\r\n        }\r\n\r\n        this.updateSize();\r\n\r\n        this.skeleton.updateCache();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * If no arguments are given it uses the current skeleton data dimensions.\r\n     * \r\n     * You can use this method to set a fixed size of this Game Object, such as for input detection,\r\n     * when the skeleton data doesn't match what is required in-game.\r\n     *\r\n     * @method SpineGameObject#setSize\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} [width] - The width of the Skeleton. If not given it defaults to the Skeleton Data width.\r\n     * @param {number} [height] - The height of the Skeleton. If not given it defaults to the Skeleton Data height.\r\n     * @param {number} [offsetX=0] - The horizontal offset of the Skeleton from its x and y coordinate.\r\n     * @param {number} [offsetY=0] - The vertical offset of the Skeleton from its x and y coordinate.\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    setSize: function (width, height, offsetX, offsetY)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        if (width === undefined) { width = skeleton.data.width; }\r\n        if (height === undefined) { height = skeleton.data.height; }\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.displayOriginX = skeleton.x - offsetX;\r\n        this.displayOriginY = skeleton.y - offsetY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of this Game Object from the Skeleton position.\r\n     * \r\n     * You can use this method to adjust how the position of this Game Object relates to the Skeleton it is using.\r\n     *\r\n     * @method SpineGameObject#setOffset\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} [offsetX=0] - The horizontal offset of the Skeleton from its x and y coordinate.\r\n     * @param {number} [offsetY=0] - The vertical offset of the Skeleton from its x and y coordinate.\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    setOffset: function (offsetX, offsetY)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n\r\n        this.displayOriginX = skeleton.x - offsetX;\r\n        this.displayOriginY = skeleton.y - offsetY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that syncs all of the Game Object position and scale data to the Skeleton.\r\n     * It then syncs the skeleton bounds back to this Game Object.\r\n     * \r\n     * This method is called automatically as needed internally, however, it's also exposed should\r\n     * you require overriding the size settings.\r\n     *\r\n     * @method SpineGameObject#updateSize\r\n     * @since 3.19.0\r\n     * \r\n     * @return {this} This Game Object.\r\n     */\r\n    updateSize: function ()\r\n    {\r\n        var skeleton = this.skeleton;\r\n        var renderer = this.plugin.renderer;\r\n\r\n        var height = renderer.height;\r\n\r\n        var oldScaleX = this.scaleX;\r\n        var oldScaleY = this.scaleY;\r\n\r\n        skeleton.x = this.x;\r\n        skeleton.y = height - this.y;\r\n        skeleton.scaleX = 1;\r\n        skeleton.scaleY = 1;\r\n\r\n        skeleton.updateWorldTransform();\r\n\r\n        var bounds = this.getBounds();\r\n\r\n        this.width = bounds.size.x;\r\n        this.height = bounds.size.y;\r\n\r\n        this.displayOriginX = this.x - bounds.offset.x;\r\n        this.displayOriginY = this.y - (height - (this.height + bounds.offset.y));\r\n\r\n        skeleton.scaleX = oldScaleX;\r\n        skeleton.scaleY = oldScaleY;\r\n\r\n        skeleton.updateWorldTransform();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object, as applied to the Skeleton it is using.\r\n     *\r\n     * @name SpineGameObject#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.19.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            this.refresh();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object, as applied to the Skeleton it is using.\r\n     *\r\n     * @name SpineGameObject#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.19.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            this.refresh();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the bones in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getBoneList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the bones in the Skeleton Data.\r\n     */\r\n    getBoneList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.bones.length; i++)\r\n            {\r\n                output.push(skeletonData.bones[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the skins in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getSkinList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the skins in the Skeleton Data.\r\n     */\r\n    getSkinList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.skins.length; i++)\r\n            {\r\n                output.push(skeletonData.skins[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the slots in the Skeleton.\r\n     *\r\n     * @method SpineGameObject#getSlotList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the slots in the Skeleton.\r\n     */\r\n    getSlotList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeleton = this.skeleton;\r\n\r\n        for (var i = 0; i < skeleton.slots.length; i++)\r\n        {\r\n            output.push(skeleton.slots[i].data.name);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the names of all the animations in the Skeleton Data.\r\n     *\r\n     * @method SpineGameObject#getAnimationList\r\n     * @since 3.19.0\r\n     * \r\n     * @return {string[]} An array containing the names of all the animations in the Skeleton Data.\r\n     */\r\n    getAnimationList: function ()\r\n    {\r\n        var output = [];\r\n\r\n        var skeletonData = this.skeletonData;\r\n\r\n        if (skeletonData)\r\n        {\r\n            for (var i = 0; i < skeletonData.animations.length; i++)\r\n            {\r\n                output.push(skeletonData.animations[i].name);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the current animation being played on the given track, if any.\r\n     *\r\n     * @method SpineGameObject#getCurrentAnimation\r\n     * @since 3.19.0\r\n     * \r\n     * @param {integer} [trackIndex=0] - The track to return the current animation on.\r\n     * \r\n     * @return {?spine.Animation} The current Animation on the given track, or `undefined` if there is no current animation.\r\n     */\r\n    getCurrentAnimation: function (trackIndex)\r\n    {\r\n        if (trackIndex === undefined) { trackIndex = 0; }\r\n\r\n        var current = this.state.getCurrent(trackIndex);\r\n\r\n        if (current)\r\n        {\r\n            return current.animation;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current animation for a track, discarding any queued animations.\r\n     * If the formerly current track entry was never applied to a skeleton, it is replaced (not mixed from).\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     *\r\n     * @method SpineGameObject#play\r\n     * @fires SpinePluginEvents#START\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} animationName - The string-based key of the animation to play.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n     *\r\n     * @return {this} This Game Object. If you need the TrackEntry, see `setAnimation` instead.\r\n     */\r\n    play: function (animationName, loop, ignoreIfPlaying)\r\n    {\r\n        this.setAnimation(0, animationName, loop, ignoreIfPlaying);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current animation for a track, discarding any queued animations.\r\n     * If the formerly current track entry was never applied to a skeleton, it is replaced (not mixed from).\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     *\r\n     * @method SpineGameObject#setAnimation\r\n     * @fires SpinePluginEvents#START\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to play the animation on.\r\n     * @param {string} animationName - The string-based key of the animation to play.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n     *\r\n     * @return {spine.TrackEntry} A track entry to allow further customization of animation playback.\r\n     */\r\n    setAnimation: function (trackIndex, animationName, loop, ignoreIfPlaying)\r\n    {\r\n        if (loop === undefined) { loop = false; }\r\n        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }\r\n\r\n        if (ignoreIfPlaying && this.state)\r\n        {\r\n            var currentTrack = this.state.getCurrent(0);\r\n \r\n            if (currentTrack && currentTrack.animation.name === animationName && !currentTrack.isComplete())\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this.findAnimation(animationName))\r\n        {\r\n            return this.state.setAnimation(trackIndex, animationName, loop);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an animation to be played after the current or last queued animation for a track.\r\n     * If the track is empty, it is equivalent to calling setAnimation.\r\n     * \r\n     * Animations are referenced by a unique string-based key, as defined in the Spine software.\r\n     * \r\n     * The delay is a float. If > 0, sets delay. If <= 0, the delay set is the duration of the previous\r\n     * track entry minus any mix duration (from the AnimationStateData) plus the specified delay\r\n     * (ie the mix ends at (delay = 0) or before (delay < 0) the previous track entry duration).\r\n     * If the previous entry is looping, its next loop completion is used instead of its duration.\r\n     *\r\n     * @method SpineGameObject#addAnimation\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     * @param {string} animationName - The string-based key of the animation to add.\r\n     * @param {boolean} [loop=false] - Should the animation be looped when played?\r\n     * @param {integer} [delay=0] - A delay, in ms, before which this animation will start when played.\r\n     *\r\n     * @return {spine.TrackEntry} A track entry to allow further customization of animation playback.\r\n     */\r\n    addAnimation: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        return this.state.addAnimation(trackIndex, animationName, loop, delay);\r\n    },\r\n\r\n    /**\r\n     * Sets an empty animation for a track, discarding any queued animations, and sets the track\r\n     * entry's mixDuration. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     * \r\n     * Mixing out is done by setting an empty animation with a mix duration using either setEmptyAnimation,\r\n     * setEmptyAnimations, or addEmptyAnimation. Mixing to an empty animation causes the previous animation to be\r\n     * applied less and less over the mix duration. Properties keyed in the previous animation transition to\r\n     * the value from lower tracks or to the setup pose value if no lower tracks key the property.\r\n     * A mix duration of 0 still mixes out over one frame.\r\n     * \r\n     * Mixing in is done by first setting an empty animation, then adding an animation using addAnimation\r\n     * and on the returned track entry, set the mixDuration. Mixing from an empty animation causes the new\r\n     * animation to be applied more and more over the mix duration. Properties keyed in the new animation\r\n     * transition from the value from lower tracks or from the setup pose value if no lower tracks key the\r\n     * property to the value keyed in the new animation.\r\n     *\r\n     * @method SpineGameObject#setEmptyAnimation\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     * @param {integer} [mixDuration] - Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData getMix based on the animation before this animation (if any).\r\n     *\r\n     * @return {spine.TrackEntry} The returned Track Entry.\r\n     */\r\n    setEmptyAnimation: function (trackIndex, mixDuration)\r\n    {\r\n        return this.state.setEmptyAnimation(trackIndex, mixDuration);\r\n    },\r\n\r\n    /**\r\n     * Removes all animations from the track, leaving skeletons in their current pose.\r\n     * \r\n     * It may be desired to use setEmptyAnimation to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose.\r\n     *\r\n     * @method SpineGameObject#clearTrack\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} trackIndex - The track index to add the animation to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        this.state.clearTrack(trackIndex);\r\n\r\n        return this;\r\n    },\r\n     \r\n    /**\r\n     * Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     * \r\n     * It may be desired to use setEmptyAnimation to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose.\r\n     *\r\n     * @method SpineGameObject#clearTracks\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clearTracks: function ()\r\n    {\r\n        this.state.clearTracks();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the skin used to look up attachments before looking in the defaultSkin.\r\n     * \r\n     * Attachments from the new skin are attached if the corresponding attachment from the\r\n     * old skin was attached. If there was no old skin, each slot's setup mode attachment is\r\n     * attached from the new skin.\r\n     * \r\n     * After changing the skin, the visible attachments can be reset to those attached in the\r\n     * setup pose by calling setSlotsToSetupPose. Also, often apply is called before the next time\r\n     * the skeleton is rendered to allow any attachment keys in the current animation(s) to hide\r\n     * or show attachments from the new skin.\r\n     *\r\n     * @method SpineGameObject#setSkinByName\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} skinName - The name of the skin to set.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.setSkinByName(skinName);\r\n\r\n        skeleton.setSlotsToSetupPose();\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the skin used to look up attachments before looking in the defaultSkin.\r\n     * \r\n     * Attachments from the new skin are attached if the corresponding attachment from the\r\n     * old skin was attached. If there was no old skin, each slot's setup mode attachment is\r\n     * attached from the new skin.\r\n     * \r\n     * After changing the skin, the visible attachments can be reset to those attached in the\r\n     * setup pose by calling setSlotsToSetupPose. Also, often apply is called before the next time\r\n     * the skeleton is rendered to allow any attachment keys in the current animation(s) to hide\r\n     * or show attachments from the new skin.\r\n     *\r\n     * @method SpineGameObject#setSkin\r\n     * @since 3.19.0\r\n     * \r\n     * @param {?spine.Skin} newSkin - The Skin to set. May be `null`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSkin: function (newSkin)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        skeleton.setSkin(newSkin);\r\n\r\n        skeleton.setSlotsToSetupPose();\r\n\r\n        this.state.apply(skeleton);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the mix duration when changing from the specified animation to the other.\r\n     *\r\n     * @method SpineGameObject#setMix\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} fromName - The animation to mix from.\r\n     * @param {string} toName - The animation to mix to.\r\n     * @param {number} [duration] - Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData getMix based on the animation before this animation (if any).\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setMix: function (fromName, toName, duration)\r\n    {\r\n        this.stateData.setMix(fromName, toName, duration);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Finds an attachment by looking in the skin and defaultSkin using the slot\r\n     * index and attachment name. First the skin is checked and if the attachment was not found,\r\n     * the default skin is checked.\r\n     *\r\n     * @method SpineGameObject#getAttachment\r\n     * @since 3.19.0\r\n     * \r\n     * @param {integer} slotIndex - The slot index to search.\r\n     * @param {string} attachmentName - The attachment name to look for.\r\n     *\r\n     * @return {?spine.Attachment} The Attachment, if found. May be null.\r\n     */\r\n    getAttachment: function (slotIndex, attachmentName)\r\n    {\r\n        return this.skeleton.getAttachment(slotIndex, attachmentName);\r\n    },\r\n\r\n    /**\r\n     * Finds an attachment by looking in the skin and defaultSkin using the slot name and attachment name.\r\n     *\r\n     * @method SpineGameObject#getAttachmentByName\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The slot name to search.\r\n     * @param {string} attachmentName - The attachment name to look for.\r\n     *\r\n     * @return {?spine.Attachment} The Attachment, if found. May be null.\r\n     */\r\n    getAttachmentByName: function (slotName, attachmentName)\r\n    {\r\n        return this.skeleton.getAttachmentByName(slotName, attachmentName);\r\n    },\r\n\r\n    /**\r\n     * A convenience method to set an attachment by finding the slot with findSlot,\r\n     * finding the attachment with getAttachment, then setting the slot's attachment.\r\n     *\r\n     * @method SpineGameObject#setAttachment\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The slot name to add the attachment to.\r\n     * @param {string} attachmentName - The attachment name to add.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        if (Array.isArray(slotName) && Array.isArray(attachmentName) && slotName.length === attachmentName.length)\r\n        {\r\n            for (var i = 0; i < slotName.length; i++)\r\n            {\r\n                this.skeleton.setAttachment(slotName[i], attachmentName[i]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.skeleton.setAttachment(slotName, attachmentName);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the bones, constraints, slots, and draw order to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.skeleton.setToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the slots and draw order to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setSlotsToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        this.skeleton.setSlotsToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the bones and constraints to their setup pose values.\r\n     *\r\n     * @method SpineGameObject#setBonesToSetupPose\r\n     * @since 3.19.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        this.skeleton.setBonesToSetupPose();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the root bone, or null.\r\n     *\r\n     * @method SpineGameObject#getRootBone\r\n     * @since 3.19.0\r\n     *\r\n     * @return {spine.Bone} The root bone, or null.\r\n     */\r\n    getRootBone: function ()\r\n    {\r\n        return this.skeleton.getRootBone();\r\n    },\r\n\r\n    /**\r\n     * Takes a Bone object and a position in world space and rotates the Bone so it is angled\r\n     * towards the given position. You can set an optional angle offset, should the bone be\r\n     * designed at a specific angle already. You can also set a minimum and maximum range for the angle.\r\n     *\r\n     * @method SpineGameObject#angleBoneToXY\r\n     * @since 3.19.0\r\n     * \r\n     * @param {spine.Bone} bone - The bone to rotate towards the world position.\r\n     * @param {number} worldX - The world x coordinate to rotate the bone towards.\r\n     * @param {number} worldY - The world y coordinate to rotate the bone towards.\r\n     * @param {number} [offset=0] - An offset to add to the rotation angle.\r\n     * @param {number} [minAngle=0] - The minimum range of the rotation angle.\r\n     * @param {number} [maxAngle=360] - The maximum range of the rotation angle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    angleBoneToXY: function (bone, worldX, worldY, offset, minAngle, maxAngle)\r\n    {\r\n        if (offset === undefined) { offset = 0; }\r\n        if (minAngle === undefined) { minAngle = 0; }\r\n        if (maxAngle === undefined) { maxAngle = 360; }\r\n\r\n        var renderer = this.plugin.renderer;\r\n        var height = renderer.height;\r\n\r\n        var angle = CounterClockwise(AngleBetween(bone.worldX, height - bone.worldY, worldX, worldY) + DegToRad(offset));\r\n\r\n        bone.rotation = Clamp(RadToDeg(angle), minAngle, maxAngle);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Finds a bone by comparing each bone's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findBone\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} boneName - The name of the bone to find.\r\n     *\r\n     * @return {spine.Bone} The bone, or null.\r\n     */\r\n    findBone: function (boneName)\r\n    {\r\n        return this.skeleton.findBone(boneName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a bone by comparing each bone's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findBoneIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} boneName - The name of the bone to find.\r\n     *\r\n     * @return {integer} The bone index. Or -1 if the bone was not found.\r\n     */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        return this.skeleton.findBoneIndex(boneName);\r\n    },\r\n\r\n    /**\r\n     * Finds a slot by comparing each slot's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSlot\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The name of the slot to find.\r\n     *\r\n     * @return {spine.Slot} The Slot. May be null.\r\n     */\r\n    findSlot: function (slotName)\r\n    {\r\n        return this.skeleton.findSlot(slotName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a slot by comparing each slot's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSlotIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} slotName - The name of the slot to find.\r\n     *\r\n     * @return {integer} The slot index. Or -1 if the Slot was not found.\r\n     */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        return this.skeleton.findSlotIndex(slotName);\r\n    },\r\n\r\n    /**\r\n     * Finds a skin by comparing each skin's name. It is more efficient to cache the results of\r\n     * this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findSkin\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} skinName - The name of the skin to find.\r\n     *\r\n     * @return {spine.Skin} The Skin. May be null.\r\n     */\r\n    findSkin: function (skinName)\r\n    {\r\n        return this.skeletonData.findSkin(skinName);\r\n    },\r\n\r\n    /**\r\n     * Finds an event by comparing each events's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findEvent\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} eventDataName - The name of the event to find.\r\n     *\r\n     * @return {spine.EventData} The Event Data. May be null.\r\n     */\r\n    findEvent: function (eventDataName)\r\n    {\r\n        return this.skeletonData.findEvent(eventDataName);\r\n    },\r\n\r\n    /**\r\n     * Finds an animation by comparing each animation's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findAnimation\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} animationName - The name of the animation to find.\r\n     *\r\n     * @return {spine.Animation} The Animation. May be null.\r\n     */\r\n    findAnimation: function (animationName)\r\n    {\r\n        return this.skeletonData.findAnimation(animationName);\r\n    },\r\n\r\n    /**\r\n     * Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results\r\n     * of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findIkConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.IkConstraintData} The IK constraint. May be null.\r\n     */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findIkConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds an transform constraint by comparing each transform constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findTransformConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.TransformConstraintData} The transform constraint. May be null.\r\n     */\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findTransformConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds a path constraint by comparing each path constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findPathConstraint\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {spine.PathConstraintData} The path constraint. May be null.\r\n     */\r\n    findPathConstraint: function (constraintName)\r\n    {\r\n        return this.skeletonData.findPathConstraint(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Finds the index of a path constraint by comparing each path constraint's name.\r\n     * It is more efficient to cache the results of this method than to call it multiple times.\r\n     *\r\n     * @method SpineGameObject#findPathConstraintIndex\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} constraintName - The name of the constraint to find.\r\n     *\r\n     * @return {integer} The constraint index. Or -1 if the constraint was not found.\r\n     */\r\n    findPathConstraintIndex: function (constraintName)\r\n    {\r\n        return this.skeletonData.findPathConstraintIndex(constraintName);\r\n    },\r\n\r\n    /**\r\n     * Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * \r\n     * The returned object contains two properties: `offset` and `size`:\r\n     * \r\n     * `offset` - The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * `size` - The width and height of the AABB.\r\n     *\r\n     * @method SpineGameObject#getBounds\r\n     * @since 3.19.0\r\n     * \r\n     * @return {any} The bounds object.\r\n     */\r\n    getBounds: function ()\r\n    {\r\n        return this.plugin.getBounds(this.skeleton);\r\n    },\r\n\r\n    /**\r\n     * Internal update handler.\r\n     *\r\n     * @method SpineGameObject#preUpdate\r\n     * @protected\r\n     * @since 3.19.0\r\n     * \r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        var skeleton = this.skeleton;\r\n\r\n        this.state.update((delta / 1000) * this.timeScale);\r\n\r\n        this.state.apply(skeleton);\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method SpineGameObject#preDestroy\r\n     * @protected\r\n     * @since 3.19.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.state)\r\n        {\r\n            this.state.clearListeners();\r\n            this.state.clearListenerNotifications();\r\n        }\r\n\r\n        this.plugin = null;\r\n\r\n        this.skeleton = null;\r\n        this.skeletonData = null;\r\n\r\n        this.state = null;\r\n        this.stateData = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpineGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\nvar RadToDeg = require('../../../../src/math/RadToDeg');\r\nvar Wrap = require('../../../../src/math/Wrap');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method SpineGameObject#renderCanvas\r\n * @since 3.19.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {SpineGameObject} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpineGameObjectCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var context = renderer.currentContext;\r\n\r\n    var plugin = src.plugin;\r\n    var skeleton = src.skeleton;\r\n    var skeletonRenderer = plugin.skeletonRenderer;\r\n\r\n    var GameObjectRenderMask = 15;\r\n\r\n    var willRender = !(GameObjectRenderMask !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)));\r\n\r\n    if (!skeleton || !willRender)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = renderer._tempMatrix1;\r\n    var spriteMatrix = renderer._tempMatrix2;\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, Math.abs(src.scaleX), Math.abs(src.scaleY));\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    skeleton.x = calcMatrix.tx;\r\n    skeleton.y = calcMatrix.ty;\r\n\r\n    skeleton.scaleX = calcMatrix.scaleX;\r\n\r\n    //  Inverse or we get upside-down skeletons\r\n    skeleton.scaleY = calcMatrix.scaleY * -1;\r\n\r\n    if (src.scaleX < 0)\r\n    {\r\n        skeleton.scaleX *= -1;\r\n\r\n        src.root.rotation = RadToDeg(calcMatrix.rotationNormalized);\r\n    }\r\n    else\r\n    {\r\n        //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n        src.root.rotation = Wrap(RadToDeg(CounterClockwise(calcMatrix.rotationNormalized)) + 90, 0, 360);\r\n    }\r\n\r\n    if (src.scaleY < 0)\r\n    {\r\n        skeleton.scaleY *= -1;\r\n\r\n        if (src.scaleX < 0)\r\n        {\r\n            src.root.rotation -= (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n        else\r\n        {\r\n            src.root.rotation += (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n    }\r\n\r\n    if (camera.renderToTexture)\r\n    {\r\n        skeleton.y = calcMatrix.ty;\r\n        skeleton.scaleY *= -1;\r\n    }\r\n\r\n    //  Add autoUpdate option\r\n    skeleton.updateWorldTransform();\r\n\r\n    skeletonRenderer.ctx = context;\r\n    skeletonRenderer.debugRendering = (plugin.drawDebug || src.drawDebug);\r\n\r\n    context.save();\r\n\r\n    skeletonRenderer.draw(skeleton);\r\n\r\n    context.restore();\r\n};\r\n\r\nmodule.exports = SpineGameObjectCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../../src/utils/NOOP');\r\nvar renderCanvas = require('../../../../src/utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpineGameObjectWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpineGameObjectCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\r\nvar RadToDeg = require('../../../../src/math/RadToDeg');\r\nvar Wrap = require('../../../../src/math/Wrap');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method SpineGameObject#renderWebGL\r\n * @since 3.19.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {SpineGameObject} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpineGameObjectWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var plugin = src.plugin;\r\n    var skeleton = src.skeleton;\r\n    var sceneRenderer = plugin.sceneRenderer;\r\n\r\n    var GameObjectRenderMask = 15;\r\n\r\n    var willRender = !(GameObjectRenderMask !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)));\r\n\r\n    if (!skeleton || !willRender)\r\n    {\r\n        //  Reset the current type\r\n        renderer.currentType = '';\r\n\r\n        //  If there is already a batch running, we need to close it\r\n        if (!renderer.nextTypeMatch)\r\n        {\r\n            //  The next object in the display list is not a Spine object, so we end the batch\r\n            sceneRenderer.end();\r\n    \r\n            renderer.rebindPipeline(renderer.pipelines.TextureTintPipeline);\r\n        }\r\n    \r\n        return;\r\n    }\r\n\r\n    if (renderer.newType)\r\n    {\r\n        renderer.clearPipeline();\r\n    }\r\n\r\n    var camMatrix = renderer._tempMatrix1;\r\n    var spriteMatrix = renderer._tempMatrix2;\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, Math.abs(src.scaleX), Math.abs(src.scaleY));\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    var viewportHeight = renderer.height;\r\n\r\n    skeleton.x = calcMatrix.tx;\r\n    skeleton.y = viewportHeight - calcMatrix.ty;\r\n\r\n    skeleton.scaleX = calcMatrix.scaleX;\r\n    skeleton.scaleY = calcMatrix.scaleY;\r\n\r\n    if (src.scaleX < 0)\r\n    {\r\n        skeleton.scaleX *= -1;\r\n\r\n        src.root.rotation = RadToDeg(calcMatrix.rotationNormalized);\r\n    }\r\n    else\r\n    {\r\n        //  +90 degrees to account for the difference in Spine vs. Phaser rotation\r\n        src.root.rotation = Wrap(RadToDeg(CounterClockwise(calcMatrix.rotationNormalized)) + 90, 0, 360);\r\n    }\r\n\r\n    if (src.scaleY < 0)\r\n    {\r\n        skeleton.scaleY *= -1;\r\n\r\n        if (src.scaleX < 0)\r\n        {\r\n            src.root.rotation -= (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n        else\r\n        {\r\n            src.root.rotation += (RadToDeg(calcMatrix.rotationNormalized) * 2);\r\n        }\r\n    }\r\n\r\n    if (camera.renderToTexture)\r\n    {\r\n        skeleton.y = calcMatrix.ty;\r\n        skeleton.scaleY *= -1;\r\n    }\r\n\r\n    //  Add autoUpdate option\r\n    skeleton.updateWorldTransform();\r\n\r\n    if (renderer.newType)\r\n    {\r\n        sceneRenderer.begin();\r\n    }\r\n\r\n    //  Draw the current skeleton\r\n\r\n    // console.log('draw', src.name);\r\n\r\n    sceneRenderer.drawSkeleton(skeleton, src.preMultipliedAlpha);\r\n\r\n    if (plugin.drawDebug || src.drawDebug)\r\n    {\r\n        //  Because if we don't, the bones render positions are completely wrong (*sigh*)\r\n        var oldX = skeleton.x;\r\n        var oldY = skeleton.y;\r\n\r\n        skeleton.x = 0;\r\n        skeleton.y = 0;\r\n\r\n        sceneRenderer.drawSkeletonDebug(skeleton, src.preMultipliedAlpha);\r\n\r\n        skeleton.x = oldX;\r\n        skeleton.y = oldY;\r\n    }\r\n\r\n    if (!renderer.nextTypeMatch)\r\n    {\r\n        //  The next object in the display list is not a Spine object, so we end the batch\r\n        sceneRenderer.end();\r\n\r\n        renderer.rebindPipeline(renderer.pipelines.TextureTintPipeline);\r\n    }\r\n};\r\n\r\nmodule.exports = SpineGameObjectWebGLRenderer;\r\n","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n    var Animation = (function () {\r\n        function Animation(name, timelines, duration) {\r\n            if (name == null)\r\n                throw new Error(\"name cannot be null.\");\r\n            if (timelines == null)\r\n                throw new Error(\"timelines cannot be null.\");\r\n            this.name = name;\r\n            this.timelines = timelines;\r\n            this.timelineIds = [];\r\n            for (var i = 0; i < timelines.length; i++)\r\n                this.timelineIds[timelines[i].getPropertyId()] = true;\r\n            this.duration = duration;\r\n        }\r\n        Animation.prototype.hasTimeline = function (id) {\r\n            return this.timelineIds[id] == true;\r\n        };\r\n        Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            if (loop && this.duration != 0) {\r\n                time %= this.duration;\r\n                if (lastTime > 0)\r\n                    lastTime %= this.duration;\r\n            }\r\n            var timelines = this.timelines;\r\n            for (var i = 0, n = timelines.length; i < n; i++)\r\n                timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n        };\r\n        Animation.binarySearch = function (values, target, step) {\r\n            if (step === void 0) { step = 1; }\r\n            var low = 0;\r\n            var high = values.length / step - 2;\r\n            if (high == 0)\r\n                return step;\r\n            var current = high >>> 1;\r\n            while (true) {\r\n                if (values[(current + 1) * step] <= target)\r\n                    low = current + 1;\r\n                else\r\n                    high = current;\r\n                if (low == high)\r\n                    return (low + 1) * step;\r\n                current = (low + high) >>> 1;\r\n            }\r\n        };\r\n        Animation.linearSearch = function (values, target, step) {\r\n            for (var i = 0, last = values.length - step; i <= last; i += step)\r\n                if (values[i] > target)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        return Animation;\r\n    }());\r\n    spine.Animation = Animation;\r\n    var MixBlend;\r\n    (function (MixBlend) {\r\n        MixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\r\n        MixBlend[MixBlend[\"first\"] = 1] = \"first\";\r\n        MixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\r\n        MixBlend[MixBlend[\"add\"] = 3] = \"add\";\r\n    })(MixBlend = spine.MixBlend || (spine.MixBlend = {}));\r\n    var MixDirection;\r\n    (function (MixDirection) {\r\n        MixDirection[MixDirection[\"mixIn\"] = 0] = \"mixIn\";\r\n        MixDirection[MixDirection[\"mixOut\"] = 1] = \"mixOut\";\r\n    })(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\r\n    var TimelineType;\r\n    (function (TimelineType) {\r\n        TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n        TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n        TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n        TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n        TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n        TimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n        TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n        TimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n        TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n        TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n        TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n        TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n        TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n        TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n        TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n    })(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\r\n    var CurveTimeline = (function () {\r\n        function CurveTimeline(frameCount) {\r\n            if (frameCount <= 0)\r\n                throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n            this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n        }\r\n        CurveTimeline.prototype.getFrameCount = function () {\r\n            return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n        };\r\n        CurveTimeline.prototype.setLinear = function (frameIndex) {\r\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n        };\r\n        CurveTimeline.prototype.setStepped = function (frameIndex) {\r\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n        };\r\n        CurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n            var index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n            if (index == this.curves.length)\r\n                return CurveTimeline.LINEAR;\r\n            var type = this.curves[index];\r\n            if (type == CurveTimeline.LINEAR)\r\n                return CurveTimeline.LINEAR;\r\n            if (type == CurveTimeline.STEPPED)\r\n                return CurveTimeline.STEPPED;\r\n            return CurveTimeline.BEZIER;\r\n        };\r\n        CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n            var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n            var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n            var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n            var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n            var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n            var curves = this.curves;\r\n            curves[i++] = CurveTimeline.BEZIER;\r\n            var x = dfx, y = dfy;\r\n            for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                curves[i] = x;\r\n                curves[i + 1] = y;\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                ddfx += dddfx;\r\n                ddfy += dddfy;\r\n                x += dfx;\r\n                y += dfy;\r\n            }\r\n        };\r\n        CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n            percent = spine.MathUtils.clamp(percent, 0, 1);\r\n            var curves = this.curves;\r\n            var i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n            var type = curves[i];\r\n            if (type == CurveTimeline.LINEAR)\r\n                return percent;\r\n            if (type == CurveTimeline.STEPPED)\r\n                return 0;\r\n            i++;\r\n            var x = 0;\r\n            for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n                x = curves[i];\r\n                if (x >= percent) {\r\n                    var prevX = void 0, prevY = void 0;\r\n                    if (i == start) {\r\n                        prevX = 0;\r\n                        prevY = 0;\r\n                    }\r\n                    else {\r\n                        prevX = curves[i - 2];\r\n                        prevY = curves[i - 1];\r\n                    }\r\n                    return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n                }\r\n            }\r\n            var y = curves[i - 1];\r\n            return y + (1 - y) * (percent - x) / (1 - x);\r\n        };\r\n        CurveTimeline.LINEAR = 0;\r\n        CurveTimeline.STEPPED = 1;\r\n        CurveTimeline.BEZIER = 2;\r\n        CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n        return CurveTimeline;\r\n    }());\r\n    spine.CurveTimeline = CurveTimeline;\r\n    var RotateTimeline = (function (_super) {\r\n        __extends(RotateTimeline, _super);\r\n        function RotateTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount << 1);\r\n            return _this;\r\n        }\r\n        RotateTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.rotate << 24) + this.boneIndex;\r\n        };\r\n        RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n            frameIndex <<= 1;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n        };\r\n        RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var bone = skeleton.bones[this.boneIndex];\r\n            if (!bone.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.rotation = bone.data.rotation;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        var r_1 = bone.data.rotation - bone.rotation;\r\n                        bone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n                var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.rotation = bone.data.rotation + r_2 * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        r_2 += bone.data.rotation - bone.rotation;\r\n                        r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n                    case MixBlend.add:\r\n                        bone.rotation += r_2 * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n            var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n            var frameTime = frames[frame];\r\n            var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n            var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n            r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    r += bone.data.rotation - bone.rotation;\r\n                case MixBlend.add:\r\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\r\n            }\r\n        };\r\n        RotateTimeline.ENTRIES = 2;\r\n        RotateTimeline.PREV_TIME = -2;\r\n        RotateTimeline.PREV_ROTATION = -1;\r\n        RotateTimeline.ROTATION = 1;\r\n        return RotateTimeline;\r\n    }(CurveTimeline));\r\n    spine.RotateTimeline = RotateTimeline;\r\n    var TranslateTimeline = (function (_super) {\r\n        __extends(TranslateTimeline, _super);\r\n        function TranslateTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        TranslateTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.translate << 24) + this.boneIndex;\r\n        };\r\n        TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n            frameIndex *= TranslateTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + TranslateTimeline.X] = x;\r\n            this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n        };\r\n        TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var bone = skeleton.bones[this.boneIndex];\r\n            if (!bone.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.x = bone.data.x;\r\n                        bone.y = bone.data.y;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        bone.x += (bone.data.x - bone.x) * alpha;\r\n                        bone.y += (bone.data.y - bone.y) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var x = 0, y = 0;\r\n            if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n                x = frames[frames.length + TranslateTimeline.PREV_X];\r\n                y = frames[frames.length + TranslateTimeline.PREV_Y];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n                x = frames[frame + TranslateTimeline.PREV_X];\r\n                y = frames[frame + TranslateTimeline.PREV_Y];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n                x += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n                y += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n            }\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x + x * alpha;\r\n                    bone.y = bone.data.y + y * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                    break;\r\n                case MixBlend.add:\r\n                    bone.x += x * alpha;\r\n                    bone.y += y * alpha;\r\n            }\r\n        };\r\n        TranslateTimeline.ENTRIES = 3;\r\n        TranslateTimeline.PREV_TIME = -3;\r\n        TranslateTimeline.PREV_X = -2;\r\n        TranslateTimeline.PREV_Y = -1;\r\n        TranslateTimeline.X = 1;\r\n        TranslateTimeline.Y = 2;\r\n        return TranslateTimeline;\r\n    }(CurveTimeline));\r\n    spine.TranslateTimeline = TranslateTimeline;\r\n    var ScaleTimeline = (function (_super) {\r\n        __extends(ScaleTimeline, _super);\r\n        function ScaleTimeline(frameCount) {\r\n            return _super.call(this, frameCount) || this;\r\n        }\r\n        ScaleTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.scale << 24) + this.boneIndex;\r\n        };\r\n        ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var bone = skeleton.bones[this.boneIndex];\r\n            if (!bone.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.scaleX = bone.data.scaleX;\r\n                        bone.scaleY = bone.data.scaleY;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var x = 0, y = 0;\r\n            if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n                x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n                y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n                x = frames[frame + ScaleTimeline.PREV_X];\r\n                y = frames[frame + ScaleTimeline.PREV_Y];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n                x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n                y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n            }\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    bone.scaleX += x - bone.data.scaleX;\r\n                    bone.scaleY += y - bone.data.scaleY;\r\n                }\r\n                else {\r\n                    bone.scaleX = x;\r\n                    bone.scaleY = y;\r\n                }\r\n            }\r\n            else {\r\n                var bx = 0, by = 0;\r\n                if (direction == MixDirection.mixOut) {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bx = bone.data.scaleX;\r\n                            by = bone.data.scaleY;\r\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\r\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\r\n                            break;\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            bx = bone.scaleX;\r\n                            by = bone.scaleY;\r\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\r\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\r\n                            break;\r\n                        case MixBlend.add:\r\n                            bx = bone.scaleX;\r\n                            by = bone.scaleY;\r\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                    }\r\n                }\r\n                else {\r\n                    switch (blend) {\r\n                        case MixBlend.setup:\r\n                            bx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);\r\n                            by = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);\r\n                            bone.scaleX = bx + (x - bx) * alpha;\r\n                            bone.scaleY = by + (y - by) * alpha;\r\n                            break;\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            bx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);\r\n                            by = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);\r\n                            bone.scaleX = bx + (x - bx) * alpha;\r\n                            bone.scaleY = by + (y - by) * alpha;\r\n                            break;\r\n                        case MixBlend.add:\r\n                            bx = spine.MathUtils.signum(x);\r\n                            by = spine.MathUtils.signum(y);\r\n                            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return ScaleTimeline;\r\n    }(TranslateTimeline));\r\n    spine.ScaleTimeline = ScaleTimeline;\r\n    var ShearTimeline = (function (_super) {\r\n        __extends(ShearTimeline, _super);\r\n        function ShearTimeline(frameCount) {\r\n            return _super.call(this, frameCount) || this;\r\n        }\r\n        ShearTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.shear << 24) + this.boneIndex;\r\n        };\r\n        ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var bone = skeleton.bones[this.boneIndex];\r\n            if (!bone.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bone.shearX = bone.data.shearX;\r\n                        bone.shearY = bone.data.shearY;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var x = 0, y = 0;\r\n            if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n                x = frames[frames.length + ShearTimeline.PREV_X];\r\n                y = frames[frames.length + ShearTimeline.PREV_Y];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n                x = frames[frame + ShearTimeline.PREV_X];\r\n                y = frames[frame + ShearTimeline.PREV_Y];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n                x = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n                y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n            }\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX + x * alpha;\r\n                    bone.shearY = bone.data.shearY + y * alpha;\r\n                    break;\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                    break;\r\n                case MixBlend.add:\r\n                    bone.shearX += x * alpha;\r\n                    bone.shearY += y * alpha;\r\n            }\r\n        };\r\n        return ShearTimeline;\r\n    }(TranslateTimeline));\r\n    spine.ShearTimeline = ShearTimeline;\r\n    var ColorTimeline = (function (_super) {\r\n        __extends(ColorTimeline, _super);\r\n        function ColorTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        ColorTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.color << 24) + this.slotIndex;\r\n        };\r\n        ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n            frameIndex *= ColorTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + ColorTimeline.R] = r;\r\n            this.frames[frameIndex + ColorTimeline.G] = g;\r\n            this.frames[frameIndex + ColorTimeline.B] = b;\r\n            this.frames[frameIndex + ColorTimeline.A] = a;\r\n        };\r\n        ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var slot = skeleton.slots[this.slotIndex];\r\n            if (!slot.bone.active)\r\n                return;\r\n            var frames = this.frames;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        slot.color.setFromColor(slot.data.color);\r\n                        return;\r\n                    case MixBlend.first:\r\n                        var color = slot.color, setup = slot.data.color;\r\n                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n                }\r\n                return;\r\n            }\r\n            var r = 0, g = 0, b = 0, a = 0;\r\n            if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n                var i = frames.length;\r\n                r = frames[i + ColorTimeline.PREV_R];\r\n                g = frames[i + ColorTimeline.PREV_G];\r\n                b = frames[i + ColorTimeline.PREV_B];\r\n                a = frames[i + ColorTimeline.PREV_A];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n                r = frames[frame + ColorTimeline.PREV_R];\r\n                g = frames[frame + ColorTimeline.PREV_G];\r\n                b = frames[frame + ColorTimeline.PREV_B];\r\n                a = frames[frame + ColorTimeline.PREV_A];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n                r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n                g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n                b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n                a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n            }\r\n            if (alpha == 1)\r\n                slot.color.set(r, g, b, a);\r\n            else {\r\n                var color = slot.color;\r\n                if (blend == MixBlend.setup)\r\n                    color.setFromColor(slot.data.color);\r\n                color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n            }\r\n        };\r\n        ColorTimeline.ENTRIES = 5;\r\n        ColorTimeline.PREV_TIME = -5;\r\n        ColorTimeline.PREV_R = -4;\r\n        ColorTimeline.PREV_G = -3;\r\n        ColorTimeline.PREV_B = -2;\r\n        ColorTimeline.PREV_A = -1;\r\n        ColorTimeline.R = 1;\r\n        ColorTimeline.G = 2;\r\n        ColorTimeline.B = 3;\r\n        ColorTimeline.A = 4;\r\n        return ColorTimeline;\r\n    }(CurveTimeline));\r\n    spine.ColorTimeline = ColorTimeline;\r\n    var TwoColorTimeline = (function (_super) {\r\n        __extends(TwoColorTimeline, _super);\r\n        function TwoColorTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        TwoColorTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.twoColor << 24) + this.slotIndex;\r\n        };\r\n        TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n            frameIndex *= TwoColorTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + TwoColorTimeline.R] = r;\r\n            this.frames[frameIndex + TwoColorTimeline.G] = g;\r\n            this.frames[frameIndex + TwoColorTimeline.B] = b;\r\n            this.frames[frameIndex + TwoColorTimeline.A] = a;\r\n            this.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n            this.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n            this.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n        };\r\n        TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var slot = skeleton.slots[this.slotIndex];\r\n            if (!slot.bone.active)\r\n                return;\r\n            var frames = this.frames;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        slot.color.setFromColor(slot.data.color);\r\n                        slot.darkColor.setFromColor(slot.data.darkColor);\r\n                        return;\r\n                    case MixBlend.first:\r\n                        var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n                }\r\n                return;\r\n            }\r\n            var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n            if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n                var i = frames.length;\r\n                r = frames[i + TwoColorTimeline.PREV_R];\r\n                g = frames[i + TwoColorTimeline.PREV_G];\r\n                b = frames[i + TwoColorTimeline.PREV_B];\r\n                a = frames[i + TwoColorTimeline.PREV_A];\r\n                r2 = frames[i + TwoColorTimeline.PREV_R2];\r\n                g2 = frames[i + TwoColorTimeline.PREV_G2];\r\n                b2 = frames[i + TwoColorTimeline.PREV_B2];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n                r = frames[frame + TwoColorTimeline.PREV_R];\r\n                g = frames[frame + TwoColorTimeline.PREV_G];\r\n                b = frames[frame + TwoColorTimeline.PREV_B];\r\n                a = frames[frame + TwoColorTimeline.PREV_A];\r\n                r2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n                g2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n                b2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n                r += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n                g += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n                b += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n                a += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n                r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n                g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n                b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n            }\r\n            if (alpha == 1) {\r\n                slot.color.set(r, g, b, a);\r\n                slot.darkColor.set(r2, g2, b2, 1);\r\n            }\r\n            else {\r\n                var light = slot.color, dark = slot.darkColor;\r\n                if (blend == MixBlend.setup) {\r\n                    light.setFromColor(slot.data.color);\r\n                    dark.setFromColor(slot.data.darkColor);\r\n                }\r\n                light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n                dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n            }\r\n        };\r\n        TwoColorTimeline.ENTRIES = 8;\r\n        TwoColorTimeline.PREV_TIME = -8;\r\n        TwoColorTimeline.PREV_R = -7;\r\n        TwoColorTimeline.PREV_G = -6;\r\n        TwoColorTimeline.PREV_B = -5;\r\n        TwoColorTimeline.PREV_A = -4;\r\n        TwoColorTimeline.PREV_R2 = -3;\r\n        TwoColorTimeline.PREV_G2 = -2;\r\n        TwoColorTimeline.PREV_B2 = -1;\r\n        TwoColorTimeline.R = 1;\r\n        TwoColorTimeline.G = 2;\r\n        TwoColorTimeline.B = 3;\r\n        TwoColorTimeline.A = 4;\r\n        TwoColorTimeline.R2 = 5;\r\n        TwoColorTimeline.G2 = 6;\r\n        TwoColorTimeline.B2 = 7;\r\n        return TwoColorTimeline;\r\n    }(CurveTimeline));\r\n    spine.TwoColorTimeline = TwoColorTimeline;\r\n    var AttachmentTimeline = (function () {\r\n        function AttachmentTimeline(frameCount) {\r\n            this.frames = spine.Utils.newFloatArray(frameCount);\r\n            this.attachmentNames = new Array(frameCount);\r\n        }\r\n        AttachmentTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.attachment << 24) + this.slotIndex;\r\n        };\r\n        AttachmentTimeline.prototype.getFrameCount = function () {\r\n            return this.frames.length;\r\n        };\r\n        AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n            this.frames[frameIndex] = time;\r\n            this.attachmentNames[frameIndex] = attachmentName;\r\n        };\r\n        AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\r\n            var slot = skeleton.slots[this.slotIndex];\r\n            if (!slot.bone.active)\r\n                return;\r\n            if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n                var attachmentName_1 = slot.data.attachmentName;\r\n                slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\r\n                return;\r\n            }\r\n            var frames = this.frames;\r\n            if (time < frames[0]) {\r\n                if (blend == MixBlend.setup || blend == MixBlend.first) {\r\n                    var attachmentName_2 = slot.data.attachmentName;\r\n                    slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\r\n                }\r\n                return;\r\n            }\r\n            var frameIndex = 0;\r\n            if (time >= frames[frames.length - 1])\r\n                frameIndex = frames.length - 1;\r\n            else\r\n                frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n            var attachmentName = this.attachmentNames[frameIndex];\r\n            skeleton.slots[this.slotIndex]\r\n                .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n        };\r\n        return AttachmentTimeline;\r\n    }());\r\n    spine.AttachmentTimeline = AttachmentTimeline;\r\n    var zeros = null;\r\n    var DeformTimeline = (function (_super) {\r\n        __extends(DeformTimeline, _super);\r\n        function DeformTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount);\r\n            _this.frameVertices = new Array(frameCount);\r\n            if (zeros == null)\r\n                zeros = spine.Utils.newFloatArray(64);\r\n            return _this;\r\n        }\r\n        DeformTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n        };\r\n        DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n            this.frames[frameIndex] = time;\r\n            this.frameVertices[frameIndex] = vertices;\r\n        };\r\n        DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var slot = skeleton.slots[this.slotIndex];\r\n            if (!slot.bone.active)\r\n                return;\r\n            var slotAttachment = slot.getAttachment();\r\n            if (!(slotAttachment instanceof spine.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))\r\n                return;\r\n            var deformArray = slot.deform;\r\n            if (deformArray.length == 0)\r\n                blend = MixBlend.setup;\r\n            var frameVertices = this.frameVertices;\r\n            var vertexCount = frameVertices[0].length;\r\n            var frames = this.frames;\r\n            if (time < frames[0]) {\r\n                var vertexAttachment = slotAttachment;\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        deformArray.length = 0;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        if (alpha == 1) {\r\n                            deformArray.length = 0;\r\n                            break;\r\n                        }\r\n                        var deform_1 = spine.Utils.setArraySize(deformArray, vertexCount);\r\n                        if (vertexAttachment.bones == null) {\r\n                            var setupVertices = vertexAttachment.vertices;\r\n                            for (var i = 0; i < vertexCount; i++)\r\n                                deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;\r\n                        }\r\n                        else {\r\n                            alpha = 1 - alpha;\r\n                            for (var i = 0; i < vertexCount; i++)\r\n                                deform_1[i] *= alpha;\r\n                        }\r\n                }\r\n                return;\r\n            }\r\n            var deform = spine.Utils.setArraySize(deformArray, vertexCount);\r\n            if (time >= frames[frames.length - 1]) {\r\n                var lastVertices = frameVertices[frames.length - 1];\r\n                if (alpha == 1) {\r\n                    if (blend == MixBlend.add) {\r\n                        var vertexAttachment = slotAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            var setupVertices = vertexAttachment.vertices;\r\n                            for (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n                                deform[i_1] += lastVertices[i_1] - setupVertices[i_1];\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n                                deform[i_2] += lastVertices[i_2];\r\n                        }\r\n                    }\r\n                    else {\r\n                        spine.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n                    }\r\n                }\r\n                else {\r\n                    switch (blend) {\r\n                        case MixBlend.setup: {\r\n                            var vertexAttachment_1 = slotAttachment;\r\n                            if (vertexAttachment_1.bones == null) {\r\n                                var setupVertices = vertexAttachment_1.vertices;\r\n                                for (var i_3 = 0; i_3 < vertexCount; i_3++) {\r\n                                    var setup = setupVertices[i_3];\r\n                                    deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_4 = 0; i_4 < vertexCount; i_4++)\r\n                                    deform[i_4] = lastVertices[i_4] * alpha;\r\n                            }\r\n                            break;\r\n                        }\r\n                        case MixBlend.first:\r\n                        case MixBlend.replace:\r\n                            for (var i_5 = 0; i_5 < vertexCount; i_5++)\r\n                                deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;\r\n                        case MixBlend.add:\r\n                            var vertexAttachment = slotAttachment;\r\n                            if (vertexAttachment.bones == null) {\r\n                                var setupVertices = vertexAttachment.vertices;\r\n                                for (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n                                    deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\r\n                                }\r\n                            }\r\n                            else {\r\n                                for (var i_7 = 0; i_7 < vertexCount; i_7++)\r\n                                    deform[i_7] += lastVertices[i_7] * alpha;\r\n                            }\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            var frame = Animation.binarySearch(frames, time);\r\n            var prevVertices = frameVertices[frame - 1];\r\n            var nextVertices = frameVertices[frame];\r\n            var frameTime = frames[frame];\r\n            var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    var vertexAttachment = slotAttachment;\r\n                    if (vertexAttachment.bones == null) {\r\n                        var setupVertices = vertexAttachment.vertices;\r\n                        for (var i_8 = 0; i_8 < vertexCount; i_8++) {\r\n                            var prev = prevVertices[i_8];\r\n                            deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i_9 = 0; i_9 < vertexCount; i_9++) {\r\n                            var prev = prevVertices[i_9];\r\n                            deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i_10 = 0; i_10 < vertexCount; i_10++) {\r\n                        var prev = prevVertices[i_10];\r\n                        deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        var vertexAttachment_2 = slotAttachment;\r\n                        if (vertexAttachment_2.bones == null) {\r\n                            var setupVertices = vertexAttachment_2.vertices;\r\n                            for (var i_11 = 0; i_11 < vertexCount; i_11++) {\r\n                                var prev = prevVertices[i_11], setup = setupVertices[i_11];\r\n                                deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i_12 = 0; i_12 < vertexCount; i_12++) {\r\n                                var prev = prevVertices[i_12];\r\n                                deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (var i_13 = 0; i_13 < vertexCount; i_13++) {\r\n                            var prev = prevVertices[i_13];\r\n                            deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;\r\n                        }\r\n                        break;\r\n                    case MixBlend.add:\r\n                        var vertexAttachment = slotAttachment;\r\n                        if (vertexAttachment.bones == null) {\r\n                            var setupVertices = vertexAttachment.vertices;\r\n                            for (var i_14 = 0; i_14 < vertexCount; i_14++) {\r\n                                var prev = prevVertices[i_14];\r\n                                deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (var i_15 = 0; i_15 < vertexCount; i_15++) {\r\n                                var prev = prevVertices[i_15];\r\n                                deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n        };\r\n        return DeformTimeline;\r\n    }(CurveTimeline));\r\n    spine.DeformTimeline = DeformTimeline;\r\n    var EventTimeline = (function () {\r\n        function EventTimeline(frameCount) {\r\n            this.frames = spine.Utils.newFloatArray(frameCount);\r\n            this.events = new Array(frameCount);\r\n        }\r\n        EventTimeline.prototype.getPropertyId = function () {\r\n            return TimelineType.event << 24;\r\n        };\r\n        EventTimeline.prototype.getFrameCount = function () {\r\n            return this.frames.length;\r\n        };\r\n        EventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n            this.frames[frameIndex] = event.time;\r\n            this.events[frameIndex] = event;\r\n        };\r\n        EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            if (firedEvents == null)\r\n                return;\r\n            var frames = this.frames;\r\n            var frameCount = this.frames.length;\r\n            if (lastTime > time) {\r\n                this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n                lastTime = -1;\r\n            }\r\n            else if (lastTime >= frames[frameCount - 1])\r\n                return;\r\n            if (time < frames[0])\r\n                return;\r\n            var frame = 0;\r\n            if (lastTime < frames[0])\r\n                frame = 0;\r\n            else {\r\n                frame = Animation.binarySearch(frames, lastTime);\r\n                var frameTime = frames[frame];\r\n                while (frame > 0) {\r\n                    if (frames[frame - 1] != frameTime)\r\n                        break;\r\n                    frame--;\r\n                }\r\n            }\r\n            for (; frame < frameCount && time >= frames[frame]; frame++)\r\n                firedEvents.push(this.events[frame]);\r\n        };\r\n        return EventTimeline;\r\n    }());\r\n    spine.EventTimeline = EventTimeline;\r\n    var DrawOrderTimeline = (function () {\r\n        function DrawOrderTimeline(frameCount) {\r\n            this.frames = spine.Utils.newFloatArray(frameCount);\r\n            this.drawOrders = new Array(frameCount);\r\n        }\r\n        DrawOrderTimeline.prototype.getPropertyId = function () {\r\n            return TimelineType.drawOrder << 24;\r\n        };\r\n        DrawOrderTimeline.prototype.getFrameCount = function () {\r\n            return this.frames.length;\r\n        };\r\n        DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n            this.frames[frameIndex] = time;\r\n            this.drawOrders[frameIndex] = drawOrder;\r\n        };\r\n        DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var drawOrder = skeleton.drawOrder;\r\n            var slots = skeleton.slots;\r\n            if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\r\n                spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                return;\r\n            }\r\n            var frames = this.frames;\r\n            if (time < frames[0]) {\r\n                if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                    spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n                return;\r\n            }\r\n            var frame = 0;\r\n            if (time >= frames[frames.length - 1])\r\n                frame = frames.length - 1;\r\n            else\r\n                frame = Animation.binarySearch(frames, time) - 1;\r\n            var drawOrderToSetupIndex = this.drawOrders[frame];\r\n            if (drawOrderToSetupIndex == null)\r\n                spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n            else {\r\n                for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n            }\r\n        };\r\n        return DrawOrderTimeline;\r\n    }());\r\n    spine.DrawOrderTimeline = DrawOrderTimeline;\r\n    var IkConstraintTimeline = (function (_super) {\r\n        __extends(IkConstraintTimeline, _super);\r\n        function IkConstraintTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        IkConstraintTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n        };\r\n        IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {\r\n            frameIndex *= IkConstraintTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n            this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\r\n            this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n            this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\r\n            this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\r\n        };\r\n        IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n            if (!constraint.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        constraint.mix = constraint.data.mix;\r\n                        constraint.softness = constraint.data.softness;\r\n                        constraint.bendDirection = constraint.data.bendDirection;\r\n                        constraint.compress = constraint.data.compress;\r\n                        constraint.stretch = constraint.data.stretch;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                        constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                        constraint.bendDirection = constraint.data.bendDirection;\r\n                        constraint.compress = constraint.data.compress;\r\n                        constraint.stretch = constraint.data.stretch;\r\n                }\r\n                return;\r\n            }\r\n            if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n                if (blend == MixBlend.setup) {\r\n                    constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n                    constraint.softness = constraint.data.softness\r\n                        + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\r\n                    if (direction == MixDirection.mixOut) {\r\n                        constraint.bendDirection = constraint.data.bendDirection;\r\n                        constraint.compress = constraint.data.compress;\r\n                        constraint.stretch = constraint.data.stretch;\r\n                    }\r\n                    else {\r\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n                else {\r\n                    constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n                    constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\r\n                    if (direction == MixDirection.mixIn) {\r\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n            var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n            var softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\r\n            var frameTime = frames[frame];\r\n            var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n            if (blend == MixBlend.setup) {\r\n                constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n                constraint.softness = constraint.data.softness\r\n                    + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\r\n                if (direction == MixDirection.mixOut) {\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                }\r\n                else {\r\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            }\r\n            else {\r\n                constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n                constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\r\n                if (direction == MixDirection.mixIn) {\r\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\r\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\r\n                }\r\n            }\r\n        };\r\n        IkConstraintTimeline.ENTRIES = 6;\r\n        IkConstraintTimeline.PREV_TIME = -6;\r\n        IkConstraintTimeline.PREV_MIX = -5;\r\n        IkConstraintTimeline.PREV_SOFTNESS = -4;\r\n        IkConstraintTimeline.PREV_BEND_DIRECTION = -3;\r\n        IkConstraintTimeline.PREV_COMPRESS = -2;\r\n        IkConstraintTimeline.PREV_STRETCH = -1;\r\n        IkConstraintTimeline.MIX = 1;\r\n        IkConstraintTimeline.SOFTNESS = 2;\r\n        IkConstraintTimeline.BEND_DIRECTION = 3;\r\n        IkConstraintTimeline.COMPRESS = 4;\r\n        IkConstraintTimeline.STRETCH = 5;\r\n        return IkConstraintTimeline;\r\n    }(CurveTimeline));\r\n    spine.IkConstraintTimeline = IkConstraintTimeline;\r\n    var TransformConstraintTimeline = (function (_super) {\r\n        __extends(TransformConstraintTimeline, _super);\r\n        function TransformConstraintTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        TransformConstraintTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n        };\r\n        TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n            frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n            this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n            this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n            this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n        };\r\n        TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n            if (!constraint.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                var data = constraint.data;\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        constraint.rotateMix = data.rotateMix;\r\n                        constraint.translateMix = data.translateMix;\r\n                        constraint.scaleMix = data.scaleMix;\r\n                        constraint.shearMix = data.shearMix;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var rotate = 0, translate = 0, scale = 0, shear = 0;\r\n            if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n                var i = frames.length;\r\n                rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n                translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n                shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n                rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n                translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n                scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n                shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n                rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n                translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n                scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n                shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n            }\r\n            if (blend == MixBlend.setup) {\r\n                var data = constraint.data;\r\n                constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n                constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n                constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n                constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n            }\r\n            else {\r\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n                constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n                constraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n            }\r\n        };\r\n        TransformConstraintTimeline.ENTRIES = 5;\r\n        TransformConstraintTimeline.PREV_TIME = -5;\r\n        TransformConstraintTimeline.PREV_ROTATE = -4;\r\n        TransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n        TransformConstraintTimeline.PREV_SCALE = -2;\r\n        TransformConstraintTimeline.PREV_SHEAR = -1;\r\n        TransformConstraintTimeline.ROTATE = 1;\r\n        TransformConstraintTimeline.TRANSLATE = 2;\r\n        TransformConstraintTimeline.SCALE = 3;\r\n        TransformConstraintTimeline.SHEAR = 4;\r\n        return TransformConstraintTimeline;\r\n    }(CurveTimeline));\r\n    spine.TransformConstraintTimeline = TransformConstraintTimeline;\r\n    var PathConstraintPositionTimeline = (function (_super) {\r\n        __extends(PathConstraintPositionTimeline, _super);\r\n        function PathConstraintPositionTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        PathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n        };\r\n        PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n            frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n        };\r\n        PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n            if (!constraint.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        constraint.position = constraint.data.position;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var position = 0;\r\n            if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n                position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n                position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n                position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n            }\r\n            if (blend == MixBlend.setup)\r\n                constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n            else\r\n                constraint.position += (position - constraint.position) * alpha;\r\n        };\r\n        PathConstraintPositionTimeline.ENTRIES = 2;\r\n        PathConstraintPositionTimeline.PREV_TIME = -2;\r\n        PathConstraintPositionTimeline.PREV_VALUE = -1;\r\n        PathConstraintPositionTimeline.VALUE = 1;\r\n        return PathConstraintPositionTimeline;\r\n    }(CurveTimeline));\r\n    spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n    var PathConstraintSpacingTimeline = (function (_super) {\r\n        __extends(PathConstraintSpacingTimeline, _super);\r\n        function PathConstraintSpacingTimeline(frameCount) {\r\n            return _super.call(this, frameCount) || this;\r\n        }\r\n        PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n        };\r\n        PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n            if (!constraint.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        constraint.spacing = constraint.data.spacing;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var spacing = 0;\r\n            if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n                spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n                spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n                spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n            }\r\n            if (blend == MixBlend.setup)\r\n                constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n            else\r\n                constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n        };\r\n        return PathConstraintSpacingTimeline;\r\n    }(PathConstraintPositionTimeline));\r\n    spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n    var PathConstraintMixTimeline = (function (_super) {\r\n        __extends(PathConstraintMixTimeline, _super);\r\n        function PathConstraintMixTimeline(frameCount) {\r\n            var _this = _super.call(this, frameCount) || this;\r\n            _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n            return _this;\r\n        }\r\n        PathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n            return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n        };\r\n        PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n            frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n            this.frames[frameIndex] = time;\r\n            this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n            this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n        };\r\n        PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\r\n            var frames = this.frames;\r\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n            if (!constraint.active)\r\n                return;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        constraint.rotateMix = constraint.data.rotateMix;\r\n                        constraint.translateMix = constraint.data.translateMix;\r\n                        return;\r\n                    case MixBlend.first:\r\n                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n                }\r\n                return;\r\n            }\r\n            var rotate = 0, translate = 0;\r\n            if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n                rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n                translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n            }\r\n            else {\r\n                var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n                rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n                translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n                var frameTime = frames[frame];\r\n                var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n                rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n                translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n            }\r\n            if (blend == MixBlend.setup) {\r\n                constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n                constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n            }\r\n            else {\r\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n            }\r\n        };\r\n        PathConstraintMixTimeline.ENTRIES = 3;\r\n        PathConstraintMixTimeline.PREV_TIME = -3;\r\n        PathConstraintMixTimeline.PREV_ROTATE = -2;\r\n        PathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n        PathConstraintMixTimeline.ROTATE = 1;\r\n        PathConstraintMixTimeline.TRANSLATE = 2;\r\n        return PathConstraintMixTimeline;\r\n    }(CurveTimeline));\r\n    spine.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var AnimationState = (function () {\r\n        function AnimationState(data) {\r\n            this.tracks = new Array();\r\n            this.timeScale = 1;\r\n            this.events = new Array();\r\n            this.listeners = new Array();\r\n            this.queue = new EventQueue(this);\r\n            this.propertyIDs = new spine.IntSet();\r\n            this.animationsChanged = false;\r\n            this.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\r\n            this.data = data;\r\n        }\r\n        AnimationState.prototype.update = function (delta) {\r\n            delta *= this.timeScale;\r\n            var tracks = this.tracks;\r\n            for (var i = 0, n = tracks.length; i < n; i++) {\r\n                var current = tracks[i];\r\n                if (current == null)\r\n                    continue;\r\n                current.animationLast = current.nextAnimationLast;\r\n                current.trackLast = current.nextTrackLast;\r\n                var currentDelta = delta * current.timeScale;\r\n                if (current.delay > 0) {\r\n                    current.delay -= currentDelta;\r\n                    if (current.delay > 0)\r\n                        continue;\r\n                    currentDelta = -current.delay;\r\n                    current.delay = 0;\r\n                }\r\n                var next = current.next;\r\n                if (next != null) {\r\n                    var nextTime = current.trackLast - next.delay;\r\n                    if (nextTime >= 0) {\r\n                        next.delay = 0;\r\n                        next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                        current.trackTime += currentDelta;\r\n                        this.setCurrent(i, next, true);\r\n                        while (next.mixingFrom != null) {\r\n                            next.mixTime += delta;\r\n                            next = next.mixingFrom;\r\n                        }\r\n                        continue;\r\n                    }\r\n                }\r\n                else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n                    tracks[i] = null;\r\n                    this.queue.end(current);\r\n                    this.disposeNext(current);\r\n                    continue;\r\n                }\r\n                if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n                    var from = current.mixingFrom;\r\n                    current.mixingFrom = null;\r\n                    if (from != null)\r\n                        from.mixingTo = null;\r\n                    while (from != null) {\r\n                        this.queue.end(from);\r\n                        from = from.mixingFrom;\r\n                    }\r\n                }\r\n                current.trackTime += currentDelta;\r\n            }\r\n            this.queue.drain();\r\n        };\r\n        AnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n            var from = to.mixingFrom;\r\n            if (from == null)\r\n                return true;\r\n            var finished = this.updateMixingFrom(from, delta);\r\n            from.animationLast = from.nextAnimationLast;\r\n            from.trackLast = from.nextTrackLast;\r\n            if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n                if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                    to.mixingFrom = from.mixingFrom;\r\n                    if (from.mixingFrom != null)\r\n                        from.mixingFrom.mixingTo = to;\r\n                    to.interruptAlpha = from.interruptAlpha;\r\n                    this.queue.end(from);\r\n                }\r\n                return finished;\r\n            }\r\n            from.trackTime += delta * from.timeScale;\r\n            to.mixTime += delta;\r\n            return false;\r\n        };\r\n        AnimationState.prototype.apply = function (skeleton) {\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            if (this.animationsChanged)\r\n                this._animationsChanged();\r\n            var events = this.events;\r\n            var tracks = this.tracks;\r\n            var applied = false;\r\n            for (var i = 0, n = tracks.length; i < n; i++) {\r\n                var current = tracks[i];\r\n                if (current == null || current.delay > 0)\r\n                    continue;\r\n                applied = true;\r\n                var blend = i == 0 ? spine.MixBlend.first : current.mixBlend;\r\n                var mix = current.alpha;\r\n                if (current.mixingFrom != null)\r\n                    mix *= this.applyMixingFrom(current, skeleton, blend);\r\n                else if (current.trackTime >= current.trackEnd && current.next == null)\r\n                    mix = 0;\r\n                var animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n                var timelineCount = current.animation.timelines.length;\r\n                var timelines = current.animation.timelines;\r\n                if ((i == 0 && mix == 1) || blend == spine.MixBlend.add) {\r\n                    for (var ii = 0; ii < timelineCount; ii++) {\r\n                        spine.Utils.webkit602BugfixHelper(mix, blend);\r\n                        timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection.mixIn);\r\n                    }\r\n                }\r\n                else {\r\n                    var timelineMode = current.timelineMode;\r\n                    var firstFrame = current.timelinesRotation.length == 0;\r\n                    if (firstFrame)\r\n                        spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n                    var timelinesRotation = current.timelinesRotation;\r\n                    for (var ii = 0; ii < timelineCount; ii++) {\r\n                        var timeline = timelines[ii];\r\n                        var timelineBlend = (timelineMode[ii] & (AnimationState.NOT_LAST - 1)) == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;\r\n                        if (timeline instanceof spine.RotateTimeline) {\r\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\r\n                        }\r\n                        else {\r\n                            spine.Utils.webkit602BugfixHelper(mix, blend);\r\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection.mixIn);\r\n                        }\r\n                    }\r\n                }\r\n                this.queueEvents(current, animationTime);\r\n                events.length = 0;\r\n                current.nextAnimationLast = animationTime;\r\n                current.nextTrackLast = current.trackTime;\r\n            }\r\n            this.queue.drain();\r\n            return applied;\r\n        };\r\n        AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\r\n            var from = to.mixingFrom;\r\n            if (from.mixingFrom != null)\r\n                this.applyMixingFrom(from, skeleton, blend);\r\n            var mix = 0;\r\n            if (to.mixDuration == 0) {\r\n                mix = 1;\r\n                if (blend == spine.MixBlend.first)\r\n                    blend = spine.MixBlend.setup;\r\n            }\r\n            else {\r\n                mix = to.mixTime / to.mixDuration;\r\n                if (mix > 1)\r\n                    mix = 1;\r\n                if (blend != spine.MixBlend.first)\r\n                    blend = from.mixBlend;\r\n            }\r\n            var events = mix < from.eventThreshold ? this.events : null;\r\n            var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n            var animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n            var timelineCount = from.animation.timelines.length;\r\n            var timelines = from.animation.timelines;\r\n            var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n            if (blend == spine.MixBlend.add) {\r\n                for (var i = 0; i < timelineCount; i++)\r\n                    timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.mixOut);\r\n            }\r\n            else {\r\n                var timelineMode = from.timelineMode;\r\n                var timelineHoldMix = from.timelineHoldMix;\r\n                var firstFrame = from.timelinesRotation.length == 0;\r\n                if (firstFrame)\r\n                    spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n                var timelinesRotation = from.timelinesRotation;\r\n                from.totalAlpha = 0;\r\n                for (var i = 0; i < timelineCount; i++) {\r\n                    var timeline = timelines[i];\r\n                    var direction = spine.MixDirection.mixOut;\r\n                    var timelineBlend = void 0;\r\n                    var alpha = 0;\r\n                    switch (timelineMode[i] & (AnimationState.NOT_LAST - 1)) {\r\n                        case AnimationState.SUBSEQUENT:\r\n                            timelineBlend = blend;\r\n                            if (!attachments && timeline instanceof spine.AttachmentTimeline) {\r\n                                if ((timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST)\r\n                                    continue;\r\n                                timelineBlend = spine.MixBlend.setup;\r\n                            }\r\n                            if (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\r\n                                continue;\r\n                            alpha = alphaMix;\r\n                            break;\r\n                        case AnimationState.FIRST:\r\n                            timelineBlend = spine.MixBlend.setup;\r\n                            alpha = alphaMix;\r\n                            break;\r\n                        case AnimationState.HOLD:\r\n                            timelineBlend = spine.MixBlend.setup;\r\n                            alpha = alphaHold;\r\n                            break;\r\n                        default:\r\n                            timelineBlend = spine.MixBlend.setup;\r\n                            var holdMix = timelineHoldMix[i];\r\n                            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                            break;\r\n                    }\r\n                    from.totalAlpha += alpha;\r\n                    if (timeline instanceof spine.RotateTimeline)\r\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\r\n                    else {\r\n                        spine.Utils.webkit602BugfixHelper(alpha, blend);\r\n                        if (timelineBlend == spine.MixBlend.setup) {\r\n                            if (timeline instanceof spine.AttachmentTimeline) {\r\n                                if (attachments || (timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST)\r\n                                    direction = spine.MixDirection.mixIn;\r\n                            }\r\n                            else if (timeline instanceof spine.DrawOrderTimeline) {\r\n                                if (drawOrder)\r\n                                    direction = spine.MixDirection.mixIn;\r\n                            }\r\n                        }\r\n                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\r\n                    }\r\n                }\r\n            }\r\n            if (to.mixDuration > 0)\r\n                this.queueEvents(from, animationTime);\r\n            this.events.length = 0;\r\n            from.nextAnimationLast = animationTime;\r\n            from.nextTrackLast = from.trackTime;\r\n            return mix;\r\n        };\r\n        AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\r\n            if (firstFrame)\r\n                timelinesRotation[i] = 0;\r\n            if (alpha == 1) {\r\n                timeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection.mixIn);\r\n                return;\r\n            }\r\n            var rotateTimeline = timeline;\r\n            var frames = rotateTimeline.frames;\r\n            var bone = skeleton.bones[rotateTimeline.boneIndex];\r\n            if (!bone.active)\r\n                return;\r\n            var r1 = 0, r2 = 0;\r\n            if (time < frames[0]) {\r\n                switch (blend) {\r\n                    case spine.MixBlend.setup:\r\n                        bone.rotation = bone.data.rotation;\r\n                    default:\r\n                        return;\r\n                    case spine.MixBlend.first:\r\n                        r1 = bone.rotation;\r\n                        r2 = bone.data.rotation;\r\n                }\r\n            }\r\n            else {\r\n                r1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n                if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\r\n                    r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\r\n                else {\r\n                    var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\r\n                    var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\r\n                    var frameTime = frames[frame];\r\n                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\r\n                    r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\r\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                    r2 = prevRotation + r2 * percent + bone.data.rotation;\r\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n                }\r\n            }\r\n            var total = 0, diff = r2 - r1;\r\n            diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n            if (diff == 0) {\r\n                total = timelinesRotation[i];\r\n            }\r\n            else {\r\n                var lastTotal = 0, lastDiff = 0;\r\n                if (firstFrame) {\r\n                    lastTotal = 0;\r\n                    lastDiff = diff;\r\n                }\r\n                else {\r\n                    lastTotal = timelinesRotation[i];\r\n                    lastDiff = timelinesRotation[i + 1];\r\n                }\r\n                var current = diff > 0, dir = lastTotal >= 0;\r\n                if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                    if (Math.abs(lastTotal) > 180)\r\n                        lastTotal += 360 * spine.MathUtils.signum(lastTotal);\r\n                    dir = current;\r\n                }\r\n                total = diff + lastTotal - lastTotal % 360;\r\n                if (dir != current)\r\n                    total += 360 * spine.MathUtils.signum(lastTotal);\r\n                timelinesRotation[i] = total;\r\n            }\r\n            timelinesRotation[i + 1] = diff;\r\n            r1 += total * alpha;\r\n            bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n        };\r\n        AnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n            var animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n            var duration = animationEnd - animationStart;\r\n            var trackLastWrapped = entry.trackLast % duration;\r\n            var events = this.events;\r\n            var i = 0, n = events.length;\r\n            for (; i < n; i++) {\r\n                var event_1 = events[i];\r\n                if (event_1.time < trackLastWrapped)\r\n                    break;\r\n                if (event_1.time > animationEnd)\r\n                    continue;\r\n                this.queue.event(entry, event_1);\r\n            }\r\n            var complete = false;\r\n            if (entry.loop)\r\n                complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n            else\r\n                complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n            if (complete)\r\n                this.queue.complete(entry);\r\n            for (; i < n; i++) {\r\n                var event_2 = events[i];\r\n                if (event_2.time < animationStart)\r\n                    continue;\r\n                this.queue.event(entry, events[i]);\r\n            }\r\n        };\r\n        AnimationState.prototype.clearTracks = function () {\r\n            var oldDrainDisabled = this.queue.drainDisabled;\r\n            this.queue.drainDisabled = true;\r\n            for (var i = 0, n = this.tracks.length; i < n; i++)\r\n                this.clearTrack(i);\r\n            this.tracks.length = 0;\r\n            this.queue.drainDisabled = oldDrainDisabled;\r\n            this.queue.drain();\r\n        };\r\n        AnimationState.prototype.clearTrack = function (trackIndex) {\r\n            if (trackIndex >= this.tracks.length)\r\n                return;\r\n            var current = this.tracks[trackIndex];\r\n            if (current == null)\r\n                return;\r\n            this.queue.end(current);\r\n            this.disposeNext(current);\r\n            var entry = current;\r\n            while (true) {\r\n                var from = entry.mixingFrom;\r\n                if (from == null)\r\n                    break;\r\n                this.queue.end(from);\r\n                entry.mixingFrom = null;\r\n                entry.mixingTo = null;\r\n                entry = from;\r\n            }\r\n            this.tracks[current.trackIndex] = null;\r\n            this.queue.drain();\r\n        };\r\n        AnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n            var from = this.expandToIndex(index);\r\n            this.tracks[index] = current;\r\n            if (from != null) {\r\n                if (interrupt)\r\n                    this.queue.interrupt(from);\r\n                current.mixingFrom = from;\r\n                from.mixingTo = current;\r\n                current.mixTime = 0;\r\n                if (from.mixingFrom != null && from.mixDuration > 0)\r\n                    current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n                from.timelinesRotation.length = 0;\r\n            }\r\n            this.queue.start(current);\r\n        };\r\n        AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n            var animation = this.data.skeletonData.findAnimation(animationName);\r\n            if (animation == null)\r\n                throw new Error(\"Animation not found: \" + animationName);\r\n            return this.setAnimationWith(trackIndex, animation, loop);\r\n        };\r\n        AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n            if (animation == null)\r\n                throw new Error(\"animation cannot be null.\");\r\n            var interrupt = true;\r\n            var current = this.expandToIndex(trackIndex);\r\n            if (current != null) {\r\n                if (current.nextTrackLast == -1) {\r\n                    this.tracks[trackIndex] = current.mixingFrom;\r\n                    this.queue.interrupt(current);\r\n                    this.queue.end(current);\r\n                    this.disposeNext(current);\r\n                    current = current.mixingFrom;\r\n                    interrupt = false;\r\n                }\r\n                else\r\n                    this.disposeNext(current);\r\n            }\r\n            var entry = this.trackEntry(trackIndex, animation, loop, current);\r\n            this.setCurrent(trackIndex, entry, interrupt);\r\n            this.queue.drain();\r\n            return entry;\r\n        };\r\n        AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n            var animation = this.data.skeletonData.findAnimation(animationName);\r\n            if (animation == null)\r\n                throw new Error(\"Animation not found: \" + animationName);\r\n            return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n        };\r\n        AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n            if (animation == null)\r\n                throw new Error(\"animation cannot be null.\");\r\n            var last = this.expandToIndex(trackIndex);\r\n            if (last != null) {\r\n                while (last.next != null)\r\n                    last = last.next;\r\n            }\r\n            var entry = this.trackEntry(trackIndex, animation, loop, last);\r\n            if (last == null) {\r\n                this.setCurrent(trackIndex, entry, true);\r\n                this.queue.drain();\r\n            }\r\n            else {\r\n                last.next = entry;\r\n                if (delay <= 0) {\r\n                    var duration = last.animationEnd - last.animationStart;\r\n                    if (duration != 0) {\r\n                        if (last.loop)\r\n                            delay += duration * (1 + ((last.trackTime / duration) | 0));\r\n                        else\r\n                            delay += Math.max(duration, last.trackTime);\r\n                        delay -= this.data.getMix(last.animation, animation);\r\n                    }\r\n                    else\r\n                        delay = last.trackTime;\r\n                }\r\n            }\r\n            entry.delay = delay;\r\n            return entry;\r\n        };\r\n        AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n            var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n            entry.mixDuration = mixDuration;\r\n            entry.trackEnd = mixDuration;\r\n            return entry;\r\n        };\r\n        AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n            if (delay <= 0)\r\n                delay -= mixDuration;\r\n            var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n            entry.mixDuration = mixDuration;\r\n            entry.trackEnd = mixDuration;\r\n            return entry;\r\n        };\r\n        AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n            var oldDrainDisabled = this.queue.drainDisabled;\r\n            this.queue.drainDisabled = true;\r\n            for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                var current = this.tracks[i];\r\n                if (current != null)\r\n                    this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n            }\r\n            this.queue.drainDisabled = oldDrainDisabled;\r\n            this.queue.drain();\r\n        };\r\n        AnimationState.prototype.expandToIndex = function (index) {\r\n            if (index < this.tracks.length)\r\n                return this.tracks[index];\r\n            spine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n            this.tracks.length = index + 1;\r\n            return null;\r\n        };\r\n        AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n            var entry = this.trackEntryPool.obtain();\r\n            entry.trackIndex = trackIndex;\r\n            entry.animation = animation;\r\n            entry.loop = loop;\r\n            entry.holdPrevious = false;\r\n            entry.eventThreshold = 0;\r\n            entry.attachmentThreshold = 0;\r\n            entry.drawOrderThreshold = 0;\r\n            entry.animationStart = 0;\r\n            entry.animationEnd = animation.duration;\r\n            entry.animationLast = -1;\r\n            entry.nextAnimationLast = -1;\r\n            entry.delay = 0;\r\n            entry.trackTime = 0;\r\n            entry.trackLast = -1;\r\n            entry.nextTrackLast = -1;\r\n            entry.trackEnd = Number.MAX_VALUE;\r\n            entry.timeScale = 1;\r\n            entry.alpha = 1;\r\n            entry.interruptAlpha = 1;\r\n            entry.mixTime = 0;\r\n            entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n            return entry;\r\n        };\r\n        AnimationState.prototype.disposeNext = function (entry) {\r\n            var next = entry.next;\r\n            while (next != null) {\r\n                this.queue.dispose(next);\r\n                next = next.next;\r\n            }\r\n            entry.next = null;\r\n        };\r\n        AnimationState.prototype._animationsChanged = function () {\r\n            this.animationsChanged = false;\r\n            this.propertyIDs.clear();\r\n            for (var i = 0, n = this.tracks.length; i < n; i++) {\r\n                var entry = this.tracks[i];\r\n                if (entry == null)\r\n                    continue;\r\n                while (entry.mixingFrom != null)\r\n                    entry = entry.mixingFrom;\r\n                do {\r\n                    if (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add)\r\n                        this.computeHold(entry);\r\n                    entry = entry.mixingTo;\r\n                } while (entry != null);\r\n            }\r\n            this.propertyIDs.clear();\r\n            for (var i = this.tracks.length - 1; i >= 0; i--) {\r\n                var entry = this.tracks[i];\r\n                while (entry != null) {\r\n                    this.computeNotLast(entry);\r\n                    entry = entry.mixingFrom;\r\n                }\r\n            }\r\n        };\r\n        AnimationState.prototype.computeHold = function (entry) {\r\n            var to = entry.mixingTo;\r\n            var timelines = entry.animation.timelines;\r\n            var timelinesCount = entry.animation.timelines.length;\r\n            var timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);\r\n            entry.timelineHoldMix.length = 0;\r\n            var timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\r\n            var propertyIDs = this.propertyIDs;\r\n            if (to != null && to.holdPrevious) {\r\n                for (var i = 0; i < timelinesCount; i++) {\r\n                    propertyIDs.add(timelines[i].getPropertyId());\r\n                    timelineMode[i] = AnimationState.HOLD;\r\n                }\r\n                return;\r\n            }\r\n            outer: for (var i = 0; i < timelinesCount; i++) {\r\n                var timeline = timelines[i];\r\n                var id = timeline.getPropertyId();\r\n                if (!propertyIDs.add(id))\r\n                    timelineMode[i] = AnimationState.SUBSEQUENT;\r\n                else if (to == null || timeline instanceof spine.AttachmentTimeline || timeline instanceof spine.DrawOrderTimeline\r\n                    || timeline instanceof spine.EventTimeline || !to.animation.hasTimeline(id)) {\r\n                    timelineMode[i] = AnimationState.FIRST;\r\n                }\r\n                else {\r\n                    for (var next = to.mixingTo; next != null; next = next.mixingTo) {\r\n                        if (next.animation.hasTimeline(id))\r\n                            continue;\r\n                        if (entry.mixDuration > 0) {\r\n                            timelineMode[i] = AnimationState.HOLD_MIX;\r\n                            timelineDipMix[i] = next;\r\n                            continue outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                    timelineMode[i] = AnimationState.HOLD;\r\n                }\r\n            }\r\n        };\r\n        AnimationState.prototype.computeNotLast = function (entry) {\r\n            var timelines = entry.animation.timelines;\r\n            var timelinesCount = entry.animation.timelines.length;\r\n            var timelineMode = entry.timelineMode;\r\n            var propertyIDs = this.propertyIDs;\r\n            for (var i = 0; i < timelinesCount; i++) {\r\n                if (timelines[i] instanceof spine.AttachmentTimeline) {\r\n                    var timeline = timelines[i];\r\n                    if (!propertyIDs.add(timeline.slotIndex))\r\n                        timelineMode[i] |= AnimationState.NOT_LAST;\r\n                }\r\n            }\r\n        };\r\n        AnimationState.prototype.getCurrent = function (trackIndex) {\r\n            if (trackIndex >= this.tracks.length)\r\n                return null;\r\n            return this.tracks[trackIndex];\r\n        };\r\n        AnimationState.prototype.addListener = function (listener) {\r\n            if (listener == null)\r\n                throw new Error(\"listener cannot be null.\");\r\n            this.listeners.push(listener);\r\n        };\r\n        AnimationState.prototype.removeListener = function (listener) {\r\n            var index = this.listeners.indexOf(listener);\r\n            if (index >= 0)\r\n                this.listeners.splice(index, 1);\r\n        };\r\n        AnimationState.prototype.clearListeners = function () {\r\n            this.listeners.length = 0;\r\n        };\r\n        AnimationState.prototype.clearListenerNotifications = function () {\r\n            this.queue.clear();\r\n        };\r\n        AnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\r\n        AnimationState.SUBSEQUENT = 0;\r\n        AnimationState.FIRST = 1;\r\n        AnimationState.HOLD = 2;\r\n        AnimationState.HOLD_MIX = 3;\r\n        AnimationState.NOT_LAST = 4;\r\n        return AnimationState;\r\n    }());\r\n    spine.AnimationState = AnimationState;\r\n    var TrackEntry = (function () {\r\n        function TrackEntry() {\r\n            this.mixBlend = spine.MixBlend.replace;\r\n            this.timelineMode = new Array();\r\n            this.timelineHoldMix = new Array();\r\n            this.timelinesRotation = new Array();\r\n        }\r\n        TrackEntry.prototype.reset = function () {\r\n            this.next = null;\r\n            this.mixingFrom = null;\r\n            this.mixingTo = null;\r\n            this.animation = null;\r\n            this.listener = null;\r\n            this.timelineMode.length = 0;\r\n            this.timelineHoldMix.length = 0;\r\n            this.timelinesRotation.length = 0;\r\n        };\r\n        TrackEntry.prototype.getAnimationTime = function () {\r\n            if (this.loop) {\r\n                var duration = this.animationEnd - this.animationStart;\r\n                if (duration == 0)\r\n                    return this.animationStart;\r\n                return (this.trackTime % duration) + this.animationStart;\r\n            }\r\n            return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n        };\r\n        TrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n            this.animationLast = animationLast;\r\n            this.nextAnimationLast = animationLast;\r\n        };\r\n        TrackEntry.prototype.isComplete = function () {\r\n            return this.trackTime >= this.animationEnd - this.animationStart;\r\n        };\r\n        TrackEntry.prototype.resetRotationDirections = function () {\r\n            this.timelinesRotation.length = 0;\r\n        };\r\n        return TrackEntry;\r\n    }());\r\n    spine.TrackEntry = TrackEntry;\r\n    var EventQueue = (function () {\r\n        function EventQueue(animState) {\r\n            this.objects = [];\r\n            this.drainDisabled = false;\r\n            this.animState = animState;\r\n        }\r\n        EventQueue.prototype.start = function (entry) {\r\n            this.objects.push(EventType.start);\r\n            this.objects.push(entry);\r\n            this.animState.animationsChanged = true;\r\n        };\r\n        EventQueue.prototype.interrupt = function (entry) {\r\n            this.objects.push(EventType.interrupt);\r\n            this.objects.push(entry);\r\n        };\r\n        EventQueue.prototype.end = function (entry) {\r\n            this.objects.push(EventType.end);\r\n            this.objects.push(entry);\r\n            this.animState.animationsChanged = true;\r\n        };\r\n        EventQueue.prototype.dispose = function (entry) {\r\n            this.objects.push(EventType.dispose);\r\n            this.objects.push(entry);\r\n        };\r\n        EventQueue.prototype.complete = function (entry) {\r\n            this.objects.push(EventType.complete);\r\n            this.objects.push(entry);\r\n        };\r\n        EventQueue.prototype.event = function (entry, event) {\r\n            this.objects.push(EventType.event);\r\n            this.objects.push(entry);\r\n            this.objects.push(event);\r\n        };\r\n        EventQueue.prototype.drain = function () {\r\n            if (this.drainDisabled)\r\n                return;\r\n            this.drainDisabled = true;\r\n            var objects = this.objects;\r\n            var listeners = this.animState.listeners;\r\n            for (var i = 0; i < objects.length; i += 2) {\r\n                var type = objects[i];\r\n                var entry = objects[i + 1];\r\n                switch (type) {\r\n                    case EventType.start:\r\n                        if (entry.listener != null && entry.listener.start)\r\n                            entry.listener.start(entry);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].start)\r\n                                listeners[ii].start(entry);\r\n                        break;\r\n                    case EventType.interrupt:\r\n                        if (entry.listener != null && entry.listener.interrupt)\r\n                            entry.listener.interrupt(entry);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].interrupt)\r\n                                listeners[ii].interrupt(entry);\r\n                        break;\r\n                    case EventType.end:\r\n                        if (entry.listener != null && entry.listener.end)\r\n                            entry.listener.end(entry);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].end)\r\n                                listeners[ii].end(entry);\r\n                    case EventType.dispose:\r\n                        if (entry.listener != null && entry.listener.dispose)\r\n                            entry.listener.dispose(entry);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].dispose)\r\n                                listeners[ii].dispose(entry);\r\n                        this.animState.trackEntryPool.free(entry);\r\n                        break;\r\n                    case EventType.complete:\r\n                        if (entry.listener != null && entry.listener.complete)\r\n                            entry.listener.complete(entry);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].complete)\r\n                                listeners[ii].complete(entry);\r\n                        break;\r\n                    case EventType.event:\r\n                        var event_3 = objects[i++ + 2];\r\n                        if (entry.listener != null && entry.listener.event)\r\n                            entry.listener.event(entry, event_3);\r\n                        for (var ii = 0; ii < listeners.length; ii++)\r\n                            if (listeners[ii].event)\r\n                                listeners[ii].event(entry, event_3);\r\n                        break;\r\n                }\r\n            }\r\n            this.clear();\r\n            this.drainDisabled = false;\r\n        };\r\n        EventQueue.prototype.clear = function () {\r\n            this.objects.length = 0;\r\n        };\r\n        return EventQueue;\r\n    }());\r\n    spine.EventQueue = EventQueue;\r\n    var EventType;\r\n    (function (EventType) {\r\n        EventType[EventType[\"start\"] = 0] = \"start\";\r\n        EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n        EventType[EventType[\"end\"] = 2] = \"end\";\r\n        EventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n        EventType[EventType[\"complete\"] = 4] = \"complete\";\r\n        EventType[EventType[\"event\"] = 5] = \"event\";\r\n    })(EventType = spine.EventType || (spine.EventType = {}));\r\n    var AnimationStateAdapter = (function () {\r\n        function AnimationStateAdapter() {\r\n        }\r\n        AnimationStateAdapter.prototype.start = function (entry) {\r\n        };\r\n        AnimationStateAdapter.prototype.interrupt = function (entry) {\r\n        };\r\n        AnimationStateAdapter.prototype.end = function (entry) {\r\n        };\r\n        AnimationStateAdapter.prototype.dispose = function (entry) {\r\n        };\r\n        AnimationStateAdapter.prototype.complete = function (entry) {\r\n        };\r\n        AnimationStateAdapter.prototype.event = function (entry, event) {\r\n        };\r\n        return AnimationStateAdapter;\r\n    }());\r\n    spine.AnimationStateAdapter = AnimationStateAdapter;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var AnimationStateData = (function () {\r\n        function AnimationStateData(skeletonData) {\r\n            this.animationToMixTime = {};\r\n            this.defaultMix = 0;\r\n            if (skeletonData == null)\r\n                throw new Error(\"skeletonData cannot be null.\");\r\n            this.skeletonData = skeletonData;\r\n        }\r\n        AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n            var from = this.skeletonData.findAnimation(fromName);\r\n            if (from == null)\r\n                throw new Error(\"Animation not found: \" + fromName);\r\n            var to = this.skeletonData.findAnimation(toName);\r\n            if (to == null)\r\n                throw new Error(\"Animation not found: \" + toName);\r\n            this.setMixWith(from, to, duration);\r\n        };\r\n        AnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n            if (from == null)\r\n                throw new Error(\"from cannot be null.\");\r\n            if (to == null)\r\n                throw new Error(\"to cannot be null.\");\r\n            var key = from.name + \".\" + to.name;\r\n            this.animationToMixTime[key] = duration;\r\n        };\r\n        AnimationStateData.prototype.getMix = function (from, to) {\r\n            var key = from.name + \".\" + to.name;\r\n            var value = this.animationToMixTime[key];\r\n            return value === undefined ? this.defaultMix : value;\r\n        };\r\n        return AnimationStateData;\r\n    }());\r\n    spine.AnimationStateData = AnimationStateData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var AssetManager = (function () {\r\n        function AssetManager(textureLoader, pathPrefix) {\r\n            if (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n            this.assets = {};\r\n            this.errors = {};\r\n            this.toLoad = 0;\r\n            this.loaded = 0;\r\n            this.textureLoader = textureLoader;\r\n            this.pathPrefix = pathPrefix;\r\n        }\r\n        AssetManager.downloadText = function (url, success, error) {\r\n            var request = new XMLHttpRequest();\r\n            request.open(\"GET\", url, true);\r\n            request.onload = function () {\r\n                if (request.status == 200) {\r\n                    success(request.responseText);\r\n                }\r\n                else {\r\n                    error(request.status, request.responseText);\r\n                }\r\n            };\r\n            request.onerror = function () {\r\n                error(request.status, request.responseText);\r\n            };\r\n            request.send();\r\n        };\r\n        AssetManager.downloadBinary = function (url, success, error) {\r\n            var request = new XMLHttpRequest();\r\n            request.open(\"GET\", url, true);\r\n            request.responseType = \"arraybuffer\";\r\n            request.onload = function () {\r\n                if (request.status == 200) {\r\n                    success(new Uint8Array(request.response));\r\n                }\r\n                else {\r\n                    error(request.status, request.responseText);\r\n                }\r\n            };\r\n            request.onerror = function () {\r\n                error(request.status, request.responseText);\r\n            };\r\n            request.send();\r\n        };\r\n        AssetManager.prototype.loadBinary = function (path, success, error) {\r\n            var _this = this;\r\n            if (success === void 0) { success = null; }\r\n            if (error === void 0) { error = null; }\r\n            path = this.pathPrefix + path;\r\n            this.toLoad++;\r\n            AssetManager.downloadBinary(path, function (data) {\r\n                _this.assets[path] = data;\r\n                if (success)\r\n                    success(path, data);\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n            }, function (state, responseText) {\r\n                _this.errors[path] = \"Couldn't load binary \" + path + \": status \" + status + \", \" + responseText;\r\n                if (error)\r\n                    error(path, \"Couldn't load binary \" + path + \": status \" + status + \", \" + responseText);\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n            });\r\n        };\r\n        AssetManager.prototype.loadText = function (path, success, error) {\r\n            var _this = this;\r\n            if (success === void 0) { success = null; }\r\n            if (error === void 0) { error = null; }\r\n            path = this.pathPrefix + path;\r\n            this.toLoad++;\r\n            AssetManager.downloadText(path, function (data) {\r\n                _this.assets[path] = data;\r\n                if (success)\r\n                    success(path, data);\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n            }, function (state, responseText) {\r\n                _this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\r\n                if (error)\r\n                    error(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n            });\r\n        };\r\n        AssetManager.prototype.loadTexture = function (path, success, error) {\r\n            var _this = this;\r\n            if (success === void 0) { success = null; }\r\n            if (error === void 0) { error = null; }\r\n            path = this.pathPrefix + path;\r\n            this.toLoad++;\r\n            var img = new Image();\r\n            img.crossOrigin = \"anonymous\";\r\n            img.onload = function (ev) {\r\n                var texture = _this.textureLoader(img);\r\n                _this.assets[path] = texture;\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n                if (success)\r\n                    success(path, img);\r\n            };\r\n            img.onerror = function (ev) {\r\n                _this.errors[path] = \"Couldn't load image \" + path;\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n                if (error)\r\n                    error(path, \"Couldn't load image \" + path);\r\n            };\r\n            img.src = path;\r\n        };\r\n        AssetManager.prototype.loadTextureData = function (path, data, success, error) {\r\n            var _this = this;\r\n            if (success === void 0) { success = null; }\r\n            if (error === void 0) { error = null; }\r\n            path = this.pathPrefix + path;\r\n            this.toLoad++;\r\n            var img = new Image();\r\n            img.onload = function (ev) {\r\n                var texture = _this.textureLoader(img);\r\n                _this.assets[path] = texture;\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n                if (success)\r\n                    success(path, img);\r\n            };\r\n            img.onerror = function (ev) {\r\n                _this.errors[path] = \"Couldn't load image \" + path;\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n                if (error)\r\n                    error(path, \"Couldn't load image \" + path);\r\n            };\r\n            img.src = data;\r\n        };\r\n        AssetManager.prototype.loadTextureAtlas = function (path, success, error) {\r\n            var _this = this;\r\n            if (success === void 0) { success = null; }\r\n            if (error === void 0) { error = null; }\r\n            var parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\r\n            path = this.pathPrefix + path;\r\n            this.toLoad++;\r\n            AssetManager.downloadText(path, function (atlasData) {\r\n                var pagesLoaded = { count: 0 };\r\n                var atlasPages = new Array();\r\n                try {\r\n                    var atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n                        atlasPages.push(parent + \"/\" + path);\r\n                        var image = document.createElement(\"img\");\r\n                        image.width = 16;\r\n                        image.height = 16;\r\n                        return new spine.FakeTexture(image);\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    var ex = e;\r\n                    _this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n                    if (error)\r\n                        error(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n                    _this.toLoad--;\r\n                    _this.loaded++;\r\n                    return;\r\n                }\r\n                var _loop_1 = function (atlasPage) {\r\n                    var pageLoadError = false;\r\n                    _this.loadTexture(atlasPage, function (imagePath, image) {\r\n                        pagesLoaded.count++;\r\n                        if (pagesLoaded.count == atlasPages.length) {\r\n                            if (!pageLoadError) {\r\n                                try {\r\n                                    var atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n                                        return _this.get(parent + \"/\" + path);\r\n                                    });\r\n                                    _this.assets[path] = atlas;\r\n                                    if (success)\r\n                                        success(path, atlas);\r\n                                    _this.toLoad--;\r\n                                    _this.loaded++;\r\n                                }\r\n                                catch (e) {\r\n                                    var ex = e;\r\n                                    _this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n                                    if (error)\r\n                                        error(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n                                    _this.toLoad--;\r\n                                    _this.loaded++;\r\n                                }\r\n                            }\r\n                            else {\r\n                                _this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n                                if (error)\r\n                                    error(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n                                _this.toLoad--;\r\n                                _this.loaded++;\r\n                            }\r\n                        }\r\n                    }, function (imagePath, errorMessage) {\r\n                        pageLoadError = true;\r\n                        pagesLoaded.count++;\r\n                        if (pagesLoaded.count == atlasPages.length) {\r\n                            _this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n                            if (error)\r\n                                error(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n                            _this.toLoad--;\r\n                            _this.loaded++;\r\n                        }\r\n                    });\r\n                };\r\n                for (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\r\n                    var atlasPage = atlasPages_1[_i];\r\n                    _loop_1(atlasPage);\r\n                }\r\n            }, function (state, responseText) {\r\n                _this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\r\n                if (error)\r\n                    error(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\r\n                _this.toLoad--;\r\n                _this.loaded++;\r\n            });\r\n        };\r\n        AssetManager.prototype.get = function (path) {\r\n            path = this.pathPrefix + path;\r\n            return this.assets[path];\r\n        };\r\n        AssetManager.prototype.remove = function (path) {\r\n            path = this.pathPrefix + path;\r\n            var asset = this.assets[path];\r\n            if (asset.dispose)\r\n                asset.dispose();\r\n            this.assets[path] = null;\r\n        };\r\n        AssetManager.prototype.removeAll = function () {\r\n            for (var key in this.assets) {\r\n                var asset = this.assets[key];\r\n                if (asset.dispose)\r\n                    asset.dispose();\r\n            }\r\n            this.assets = {};\r\n        };\r\n        AssetManager.prototype.isLoadingComplete = function () {\r\n            return this.toLoad == 0;\r\n        };\r\n        AssetManager.prototype.getToLoad = function () {\r\n            return this.toLoad;\r\n        };\r\n        AssetManager.prototype.getLoaded = function () {\r\n            return this.loaded;\r\n        };\r\n        AssetManager.prototype.dispose = function () {\r\n            this.removeAll();\r\n        };\r\n        AssetManager.prototype.hasErrors = function () {\r\n            return Object.keys(this.errors).length > 0;\r\n        };\r\n        AssetManager.prototype.getErrors = function () {\r\n            return this.errors;\r\n        };\r\n        return AssetManager;\r\n    }());\r\n    spine.AssetManager = AssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var AtlasAttachmentLoader = (function () {\r\n        function AtlasAttachmentLoader(atlas) {\r\n            this.atlas = atlas;\r\n        }\r\n        AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n            var region = this.atlas.findRegion(path);\r\n            if (region == null)\r\n                throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n            region.renderObject = region;\r\n            var attachment = new spine.RegionAttachment(name);\r\n            attachment.setRegion(region);\r\n            return attachment;\r\n        };\r\n        AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n            var region = this.atlas.findRegion(path);\r\n            if (region == null)\r\n                throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n            region.renderObject = region;\r\n            var attachment = new spine.MeshAttachment(name);\r\n            attachment.region = region;\r\n            return attachment;\r\n        };\r\n        AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n            return new spine.BoundingBoxAttachment(name);\r\n        };\r\n        AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n            return new spine.PathAttachment(name);\r\n        };\r\n        AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n            return new spine.PointAttachment(name);\r\n        };\r\n        AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n            return new spine.ClippingAttachment(name);\r\n        };\r\n        return AtlasAttachmentLoader;\r\n    }());\r\n    spine.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var BlendMode;\r\n    (function (BlendMode) {\r\n        BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n        BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n        BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n        BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n    })(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Bone = (function () {\r\n        function Bone(data, skeleton, parent) {\r\n            this.children = new Array();\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.rotation = 0;\r\n            this.scaleX = 0;\r\n            this.scaleY = 0;\r\n            this.shearX = 0;\r\n            this.shearY = 0;\r\n            this.ax = 0;\r\n            this.ay = 0;\r\n            this.arotation = 0;\r\n            this.ascaleX = 0;\r\n            this.ascaleY = 0;\r\n            this.ashearX = 0;\r\n            this.ashearY = 0;\r\n            this.appliedValid = false;\r\n            this.a = 0;\r\n            this.b = 0;\r\n            this.c = 0;\r\n            this.d = 0;\r\n            this.worldY = 0;\r\n            this.worldX = 0;\r\n            this.sorted = false;\r\n            this.active = false;\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.skeleton = skeleton;\r\n            this.parent = parent;\r\n            this.setToSetupPose();\r\n        }\r\n        Bone.prototype.isActive = function () {\r\n            return this.active;\r\n        };\r\n        Bone.prototype.update = function () {\r\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n        };\r\n        Bone.prototype.updateWorldTransform = function () {\r\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n        };\r\n        Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n            this.ax = x;\r\n            this.ay = y;\r\n            this.arotation = rotation;\r\n            this.ascaleX = scaleX;\r\n            this.ascaleY = scaleY;\r\n            this.ashearX = shearX;\r\n            this.ashearY = shearY;\r\n            this.appliedValid = true;\r\n            var parent = this.parent;\r\n            if (parent == null) {\r\n                var skeleton = this.skeleton;\r\n                var rotationY = rotation + 90 + shearY;\r\n                var sx = skeleton.scaleX;\r\n                var sy = skeleton.scaleY;\r\n                this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n                this.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n                this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n                this.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n                this.worldX = x * sx + skeleton.x;\r\n                this.worldY = y * sy + skeleton.y;\r\n                return;\r\n            }\r\n            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n            this.worldX = pa * x + pb * y + parent.worldX;\r\n            this.worldY = pc * x + pd * y + parent.worldY;\r\n            switch (this.data.transformMode) {\r\n                case spine.TransformMode.Normal: {\r\n                    var rotationY = rotation + 90 + shearY;\r\n                    var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                    var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n                    var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                    var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n                    this.a = pa * la + pb * lc;\r\n                    this.b = pa * lb + pb * ld;\r\n                    this.c = pc * la + pd * lc;\r\n                    this.d = pc * lb + pd * ld;\r\n                    return;\r\n                }\r\n                case spine.TransformMode.OnlyTranslation: {\r\n                    var rotationY = rotation + 90 + shearY;\r\n                    this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                    this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n                    this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                    this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n                    break;\r\n                }\r\n                case spine.TransformMode.NoRotationOrReflection: {\r\n                    var s = pa * pa + pc * pc;\r\n                    var prx = 0;\r\n                    if (s > 0.0001) {\r\n                        s = Math.abs(pa * pd - pb * pc) / s;\r\n                        pb = pc * s;\r\n                        pd = pa * s;\r\n                        prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\r\n                    }\r\n                    else {\r\n                        pa = 0;\r\n                        pc = 0;\r\n                        prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\r\n                    }\r\n                    var rx = rotation + shearX - prx;\r\n                    var ry = rotation + shearY - prx + 90;\r\n                    var la = spine.MathUtils.cosDeg(rx) * scaleX;\r\n                    var lb = spine.MathUtils.cosDeg(ry) * scaleY;\r\n                    var lc = spine.MathUtils.sinDeg(rx) * scaleX;\r\n                    var ld = spine.MathUtils.sinDeg(ry) * scaleY;\r\n                    this.a = pa * la - pb * lc;\r\n                    this.b = pa * lb - pb * ld;\r\n                    this.c = pc * la + pd * lc;\r\n                    this.d = pc * lb + pd * ld;\r\n                    break;\r\n                }\r\n                case spine.TransformMode.NoScale:\r\n                case spine.TransformMode.NoScaleOrReflection: {\r\n                    var cos = spine.MathUtils.cosDeg(rotation);\r\n                    var sin = spine.MathUtils.sinDeg(rotation);\r\n                    var za = (pa * cos + pb * sin) / this.skeleton.scaleX;\r\n                    var zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\r\n                    var s = Math.sqrt(za * za + zc * zc);\r\n                    if (s > 0.00001)\r\n                        s = 1 / s;\r\n                    za *= s;\r\n                    zc *= s;\r\n                    s = Math.sqrt(za * za + zc * zc);\r\n                    if (this.data.transformMode == spine.TransformMode.NoScale\r\n                        && (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\r\n                        s = -s;\r\n                    var r = Math.PI / 2 + Math.atan2(zc, za);\r\n                    var zb = Math.cos(r) * s;\r\n                    var zd = Math.sin(r) * s;\r\n                    var la = spine.MathUtils.cosDeg(shearX) * scaleX;\r\n                    var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                    var lc = spine.MathUtils.sinDeg(shearX) * scaleX;\r\n                    var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                    this.a = za * la + zb * lc;\r\n                    this.b = za * lb + zb * ld;\r\n                    this.c = zc * la + zd * lc;\r\n                    this.d = zc * lb + zd * ld;\r\n                    break;\r\n                }\r\n            }\r\n            this.a *= this.skeleton.scaleX;\r\n            this.b *= this.skeleton.scaleX;\r\n            this.c *= this.skeleton.scaleY;\r\n            this.d *= this.skeleton.scaleY;\r\n        };\r\n        Bone.prototype.setToSetupPose = function () {\r\n            var data = this.data;\r\n            this.x = data.x;\r\n            this.y = data.y;\r\n            this.rotation = data.rotation;\r\n            this.scaleX = data.scaleX;\r\n            this.scaleY = data.scaleY;\r\n            this.shearX = data.shearX;\r\n            this.shearY = data.shearY;\r\n        };\r\n        Bone.prototype.getWorldRotationX = function () {\r\n            return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n        };\r\n        Bone.prototype.getWorldRotationY = function () {\r\n            return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\r\n        };\r\n        Bone.prototype.getWorldScaleX = function () {\r\n            return Math.sqrt(this.a * this.a + this.c * this.c);\r\n        };\r\n        Bone.prototype.getWorldScaleY = function () {\r\n            return Math.sqrt(this.b * this.b + this.d * this.d);\r\n        };\r\n        Bone.prototype.updateAppliedTransform = function () {\r\n            this.appliedValid = true;\r\n            var parent = this.parent;\r\n            if (parent == null) {\r\n                this.ax = this.worldX;\r\n                this.ay = this.worldY;\r\n                this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n                this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\r\n                this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\r\n                this.ashearX = 0;\r\n                this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\r\n                return;\r\n            }\r\n            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n            var pid = 1 / (pa * pd - pb * pc);\r\n            var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\r\n            this.ax = (dx * pd * pid - dy * pb * pid);\r\n            this.ay = (dy * pa * pid - dx * pc * pid);\r\n            var ia = pid * pd;\r\n            var id = pid * pa;\r\n            var ib = pid * pb;\r\n            var ic = pid * pc;\r\n            var ra = ia * this.a - ib * this.c;\r\n            var rb = ia * this.b - ib * this.d;\r\n            var rc = id * this.c - ic * this.a;\r\n            var rd = id * this.d - ic * this.b;\r\n            this.ashearX = 0;\r\n            this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n            if (this.ascaleX > 0.0001) {\r\n                var det = ra * rd - rb * rc;\r\n                this.ascaleY = det / this.ascaleX;\r\n                this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\r\n                this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\r\n            }\r\n            else {\r\n                this.ascaleX = 0;\r\n                this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n                this.ashearY = 0;\r\n                this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\r\n            }\r\n        };\r\n        Bone.prototype.worldToLocal = function (world) {\r\n            var a = this.a, b = this.b, c = this.c, d = this.d;\r\n            var invDet = 1 / (a * d - b * c);\r\n            var x = world.x - this.worldX, y = world.y - this.worldY;\r\n            world.x = (x * d * invDet - y * b * invDet);\r\n            world.y = (y * a * invDet - x * c * invDet);\r\n            return world;\r\n        };\r\n        Bone.prototype.localToWorld = function (local) {\r\n            var x = local.x, y = local.y;\r\n            local.x = x * this.a + y * this.b + this.worldX;\r\n            local.y = x * this.c + y * this.d + this.worldY;\r\n            return local;\r\n        };\r\n        Bone.prototype.worldToLocalRotation = function (worldRotation) {\r\n            var sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\r\n            return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;\r\n        };\r\n        Bone.prototype.localToWorldRotation = function (localRotation) {\r\n            localRotation -= this.rotation - this.shearX;\r\n            var sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\r\n            return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\r\n        };\r\n        Bone.prototype.rotateWorld = function (degrees) {\r\n            var a = this.a, b = this.b, c = this.c, d = this.d;\r\n            var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\r\n            this.a = cos * a - sin * c;\r\n            this.b = cos * b - sin * d;\r\n            this.c = sin * a + cos * c;\r\n            this.d = sin * b + cos * d;\r\n            this.appliedValid = false;\r\n        };\r\n        return Bone;\r\n    }());\r\n    spine.Bone = Bone;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var BoneData = (function () {\r\n        function BoneData(index, name, parent) {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.rotation = 0;\r\n            this.scaleX = 1;\r\n            this.scaleY = 1;\r\n            this.shearX = 0;\r\n            this.shearY = 0;\r\n            this.transformMode = TransformMode.Normal;\r\n            this.skinRequired = false;\r\n            this.color = new spine.Color();\r\n            if (index < 0)\r\n                throw new Error(\"index must be >= 0.\");\r\n            if (name == null)\r\n                throw new Error(\"name cannot be null.\");\r\n            this.index = index;\r\n            this.name = name;\r\n            this.parent = parent;\r\n        }\r\n        return BoneData;\r\n    }());\r\n    spine.BoneData = BoneData;\r\n    var TransformMode;\r\n    (function (TransformMode) {\r\n        TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n        TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n        TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n        TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n        TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n    })(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var ConstraintData = (function () {\r\n        function ConstraintData(name, order, skinRequired) {\r\n            this.name = name;\r\n            this.order = order;\r\n            this.skinRequired = skinRequired;\r\n        }\r\n        return ConstraintData;\r\n    }());\r\n    spine.ConstraintData = ConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Event = (function () {\r\n        function Event(time, data) {\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            this.time = time;\r\n            this.data = data;\r\n        }\r\n        return Event;\r\n    }());\r\n    spine.Event = Event;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var EventData = (function () {\r\n        function EventData(name) {\r\n            this.name = name;\r\n        }\r\n        return EventData;\r\n    }());\r\n    spine.EventData = EventData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var IkConstraint = (function () {\r\n        function IkConstraint(data, skeleton) {\r\n            this.bendDirection = 0;\r\n            this.compress = false;\r\n            this.stretch = false;\r\n            this.mix = 1;\r\n            this.softness = 0;\r\n            this.active = false;\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.mix = data.mix;\r\n            this.softness = data.softness;\r\n            this.bendDirection = data.bendDirection;\r\n            this.compress = data.compress;\r\n            this.stretch = data.stretch;\r\n            this.bones = new Array();\r\n            for (var i = 0; i < data.bones.length; i++)\r\n                this.bones.push(skeleton.findBone(data.bones[i].name));\r\n            this.target = skeleton.findBone(data.target.name);\r\n        }\r\n        IkConstraint.prototype.isActive = function () {\r\n            return this.active;\r\n        };\r\n        IkConstraint.prototype.apply = function () {\r\n            this.update();\r\n        };\r\n        IkConstraint.prototype.update = function () {\r\n            var target = this.target;\r\n            var bones = this.bones;\r\n            switch (bones.length) {\r\n                case 1:\r\n                    this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                    break;\r\n                case 2:\r\n                    this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\r\n                    break;\r\n            }\r\n        };\r\n        IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\r\n            if (!bone.appliedValid)\r\n                bone.updateAppliedTransform();\r\n            var p = bone.parent;\r\n            var id = 1 / (p.a * p.d - p.b * p.c);\r\n            var x = targetX - p.worldX, y = targetY - p.worldY;\r\n            var tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;\r\n            var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;\r\n            if (bone.ascaleX < 0)\r\n                rotationIK += 180;\r\n            if (rotationIK > 180)\r\n                rotationIK -= 360;\r\n            else if (rotationIK < -180)\r\n                rotationIK += 360;\r\n            var sx = bone.ascaleX, sy = bone.ascaleY;\r\n            if (compress || stretch) {\r\n                var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n                if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                    var s = (dd / b - 1) * alpha + 1;\r\n                    sx *= s;\r\n                    if (uniform)\r\n                        sy *= s;\r\n                }\r\n            }\r\n            bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n        };\r\n        IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {\r\n            if (alpha == 0) {\r\n                child.updateWorldTransform();\r\n                return;\r\n            }\r\n            if (!parent.appliedValid)\r\n                parent.updateAppliedTransform();\r\n            if (!child.appliedValid)\r\n                child.updateAppliedTransform();\r\n            var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\r\n            var os1 = 0, os2 = 0, s2 = 0;\r\n            if (psx < 0) {\r\n                psx = -psx;\r\n                os1 = 180;\r\n                s2 = -1;\r\n            }\r\n            else {\r\n                os1 = 0;\r\n                s2 = 1;\r\n            }\r\n            if (psy < 0) {\r\n                psy = -psy;\r\n                s2 = -s2;\r\n            }\r\n            if (csx < 0) {\r\n                csx = -csx;\r\n                os2 = 180;\r\n            }\r\n            else\r\n                os2 = 0;\r\n            var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\r\n            var u = Math.abs(psx - psy) <= 0.0001;\r\n            if (!u) {\r\n                cy = 0;\r\n                cwx = a * cx + parent.worldX;\r\n                cwy = c * cx + parent.worldY;\r\n            }\r\n            else {\r\n                cy = child.ay;\r\n                cwx = a * cx + b * cy + parent.worldX;\r\n                cwy = c * cx + d * cy + parent.worldY;\r\n            }\r\n            var pp = parent.parent;\r\n            a = pp.a;\r\n            b = pp.b;\r\n            c = pp.c;\r\n            d = pp.d;\r\n            var id = 1 / (a * d - b * c), x = cwx - pp.worldX, y = cwy - pp.worldY;\r\n            var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n            var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n            if (l1 < 0.0001) {\r\n                this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n                child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n                return;\r\n            }\r\n            x = targetX - pp.worldX;\r\n            y = targetY - pp.worldY;\r\n            var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n            var dd = tx * tx + ty * ty;\r\n            if (softness != 0) {\r\n                softness *= psx * (csx + 1) / 2;\r\n                var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n                if (sd > 0) {\r\n                    var p = Math.min(1, sd / (softness * 2)) - 1;\r\n                    p = (sd - softness * (1 - p * p)) / td;\r\n                    tx -= p * tx;\r\n                    ty -= p * ty;\r\n                    dd = tx * tx + ty * ty;\r\n                }\r\n            }\r\n            outer: if (u) {\r\n                l2 *= psx;\r\n                var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                if (cos < -1)\r\n                    cos = -1;\r\n                else if (cos > 1) {\r\n                    cos = 1;\r\n                    if (stretch)\r\n                        sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                }\r\n                a2 = Math.acos(cos) * bendDir;\r\n                a = l1 + l2 * cos;\r\n                b = l2 * Math.sin(a2);\r\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n            }\r\n            else {\r\n                a = psx * l2;\r\n                b = psy * l2;\r\n                var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                var c1 = -2 * bb * l1, c2 = bb - aa;\r\n                d = c1 * c1 - 4 * c2 * c;\r\n                if (d >= 0) {\r\n                    var q = Math.sqrt(d);\r\n                    if (c1 < 0)\r\n                        q = -q;\r\n                    q = -(c1 + q) / 2;\r\n                    var r0 = q / c2, r1 = c / q;\r\n                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                    if (r * r <= dd) {\r\n                        y = Math.sqrt(dd - r * r) * bendDir;\r\n                        a1 = ta - Math.atan2(y, r);\r\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                        break outer;\r\n                    }\r\n                }\r\n                var minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                c = -a * l1 / (aa - bb);\r\n                if (c >= -1 && c <= 1) {\r\n                    c = Math.acos(c);\r\n                    x = a * Math.cos(c) + l1;\r\n                    y = b * Math.sin(c);\r\n                    d = x * x + y * y;\r\n                    if (d < minDist) {\r\n                        minAngle = c;\r\n                        minDist = d;\r\n                        minX = x;\r\n                        minY = y;\r\n                    }\r\n                    if (d > maxDist) {\r\n                        maxAngle = c;\r\n                        maxDist = d;\r\n                        maxX = x;\r\n                        maxY = y;\r\n                    }\r\n                }\r\n                if (dd <= (minDist + maxDist) / 2) {\r\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                    a2 = minAngle * bendDir;\r\n                }\r\n                else {\r\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                    a2 = maxAngle * bendDir;\r\n                }\r\n            }\r\n            var os = Math.atan2(cy, cx) * s2;\r\n            var rotation = parent.arotation;\r\n            a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\r\n            if (a1 > 180)\r\n                a1 -= 360;\r\n            else if (a1 < -180)\r\n                a1 += 360;\r\n            parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\r\n            rotation = child.arotation;\r\n            a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n            if (a2 > 180)\r\n                a2 -= 360;\r\n            else if (a2 < -180)\r\n                a2 += 360;\r\n            child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n        };\r\n        return IkConstraint;\r\n    }());\r\n    spine.IkConstraint = IkConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var IkConstraintData = (function (_super) {\r\n        __extends(IkConstraintData, _super);\r\n        function IkConstraintData(name) {\r\n            var _this = _super.call(this, name, 0, false) || this;\r\n            _this.bones = new Array();\r\n            _this.bendDirection = 1;\r\n            _this.compress = false;\r\n            _this.stretch = false;\r\n            _this.uniform = false;\r\n            _this.mix = 1;\r\n            _this.softness = 0;\r\n            return _this;\r\n        }\r\n        return IkConstraintData;\r\n    }(spine.ConstraintData));\r\n    spine.IkConstraintData = IkConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var PathConstraint = (function () {\r\n        function PathConstraint(data, skeleton) {\r\n            this.position = 0;\r\n            this.spacing = 0;\r\n            this.rotateMix = 0;\r\n            this.translateMix = 0;\r\n            this.spaces = new Array();\r\n            this.positions = new Array();\r\n            this.world = new Array();\r\n            this.curves = new Array();\r\n            this.lengths = new Array();\r\n            this.segments = new Array();\r\n            this.active = false;\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.bones = new Array();\r\n            for (var i = 0, n = data.bones.length; i < n; i++)\r\n                this.bones.push(skeleton.findBone(data.bones[i].name));\r\n            this.target = skeleton.findSlot(data.target.name);\r\n            this.position = data.position;\r\n            this.spacing = data.spacing;\r\n            this.rotateMix = data.rotateMix;\r\n            this.translateMix = data.translateMix;\r\n        }\r\n        PathConstraint.prototype.isActive = function () {\r\n            return this.active;\r\n        };\r\n        PathConstraint.prototype.apply = function () {\r\n            this.update();\r\n        };\r\n        PathConstraint.prototype.update = function () {\r\n            var attachment = this.target.getAttachment();\r\n            if (!(attachment instanceof spine.PathAttachment))\r\n                return;\r\n            var rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n            var translate = translateMix > 0, rotate = rotateMix > 0;\r\n            if (!translate && !rotate)\r\n                return;\r\n            var data = this.data;\r\n            var percentSpacing = data.spacingMode == spine.SpacingMode.Percent;\r\n            var rotateMode = data.rotateMode;\r\n            var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\r\n            var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n            var bones = this.bones;\r\n            var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n            var spacing = this.spacing;\r\n            if (scale || !percentSpacing) {\r\n                if (scale)\r\n                    lengths = spine.Utils.setArraySize(this.lengths, boneCount);\r\n                var lengthSpacing = data.spacingMode == spine.SpacingMode.Length;\r\n                for (var i = 0, n = spacesCount - 1; i < n;) {\r\n                    var bone = bones[i];\r\n                    var setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale)\r\n                            lengths[i] = 0;\r\n                        spaces[++i] = 0;\r\n                    }\r\n                    else if (percentSpacing) {\r\n                        if (scale) {\r\n                            var x = setupLength * bone.a, y = setupLength * bone.c;\r\n                            var length_1 = Math.sqrt(x * x + y * y);\r\n                            lengths[i] = length_1;\r\n                        }\r\n                        spaces[++i] = spacing;\r\n                    }\r\n                    else {\r\n                        var x = setupLength * bone.a, y = setupLength * bone.c;\r\n                        var length_2 = Math.sqrt(x * x + y * y);\r\n                        if (scale)\r\n                            lengths[i] = length_2;\r\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 1; i < spacesCount; i++)\r\n                    spaces[i] = spacing;\r\n            }\r\n            var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);\r\n            var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n            var tip = false;\r\n            if (offsetRotation == 0)\r\n                tip = rotateMode == spine.RotateMode.Chain;\r\n            else {\r\n                tip = false;\r\n                var p = this.target.bone;\r\n                offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n            }\r\n            for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n                var bone = bones[i];\r\n                bone.worldX += (boneX - bone.worldX) * translateMix;\r\n                bone.worldY += (boneY - bone.worldY) * translateMix;\r\n                var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n                if (scale) {\r\n                    var length_3 = lengths[i];\r\n                    if (length_3 != 0) {\r\n                        var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;\r\n                        bone.a *= s;\r\n                        bone.c *= s;\r\n                    }\r\n                }\r\n                boneX = x;\r\n                boneY = y;\r\n                if (rotate) {\r\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\r\n                    if (tangents)\r\n                        r = positions[p - 1];\r\n                    else if (spaces[i + 1] == 0)\r\n                        r = positions[p + 2];\r\n                    else\r\n                        r = Math.atan2(dy, dx);\r\n                    r -= Math.atan2(c, a);\r\n                    if (tip) {\r\n                        cos = Math.cos(r);\r\n                        sin = Math.sin(r);\r\n                        var length_4 = bone.data.length;\r\n                        boneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;\r\n                        boneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;\r\n                    }\r\n                    else {\r\n                        r += offsetRotation;\r\n                    }\r\n                    if (r > spine.MathUtils.PI)\r\n                        r -= spine.MathUtils.PI2;\r\n                    else if (r < -spine.MathUtils.PI)\r\n                        r += spine.MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    bone.a = cos * a - sin * c;\r\n                    bone.b = cos * b - sin * d;\r\n                    bone.c = sin * a + cos * c;\r\n                    bone.d = sin * b + cos * d;\r\n                }\r\n                bone.appliedValid = false;\r\n            }\r\n        };\r\n        PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n            var target = this.target;\r\n            var position = this.position;\r\n            var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n            var closed = path.closed;\r\n            var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n            if (!path.constantSpeed) {\r\n                var lengths = path.lengths;\r\n                curveCount -= closed ? 1 : 2;\r\n                var pathLength_1 = lengths[curveCount];\r\n                if (percentPosition)\r\n                    position *= pathLength_1;\r\n                if (percentSpacing) {\r\n                    for (var i = 1; i < spacesCount; i++)\r\n                        spaces[i] *= pathLength_1;\r\n                }\r\n                world = spine.Utils.setArraySize(this.world, 8);\r\n                for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                    var space = spaces[i];\r\n                    position += space;\r\n                    var p = position;\r\n                    if (closed) {\r\n                        p %= pathLength_1;\r\n                        if (p < 0)\r\n                            p += pathLength_1;\r\n                        curve = 0;\r\n                    }\r\n                    else if (p < 0) {\r\n                        if (prevCurve != PathConstraint.BEFORE) {\r\n                            prevCurve = PathConstraint.BEFORE;\r\n                            path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                        }\r\n                        this.addBeforePosition(p, world, 0, out, o);\r\n                        continue;\r\n                    }\r\n                    else if (p > pathLength_1) {\r\n                        if (prevCurve != PathConstraint.AFTER) {\r\n                            prevCurve = PathConstraint.AFTER;\r\n                            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                        }\r\n                        this.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n                        continue;\r\n                    }\r\n                    for (;; curve++) {\r\n                        var length_5 = lengths[curve];\r\n                        if (p > length_5)\r\n                            continue;\r\n                        if (curve == 0)\r\n                            p /= length_5;\r\n                        else {\r\n                            var prev = lengths[curve - 1];\r\n                            p = (p - prev) / (length_5 - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (curve != prevCurve) {\r\n                        prevCurve = curve;\r\n                        if (closed && curve == curveCount) {\r\n                            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                            path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                        }\r\n                        else\r\n                            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                    }\r\n                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n                }\r\n                return out;\r\n            }\r\n            if (closed) {\r\n                verticesLength += 2;\r\n                world = spine.Utils.setArraySize(this.world, verticesLength);\r\n                path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n                path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n                world[verticesLength - 2] = world[0];\r\n                world[verticesLength - 1] = world[1];\r\n            }\r\n            else {\r\n                curveCount--;\r\n                verticesLength -= 4;\r\n                world = spine.Utils.setArraySize(this.world, verticesLength);\r\n                path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n            }\r\n            var curves = spine.Utils.setArraySize(this.curves, curveCount);\r\n            var pathLength = 0;\r\n            var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n            var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n            for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n                cx1 = world[w];\r\n                cy1 = world[w + 1];\r\n                cx2 = world[w + 2];\r\n                cy2 = world[w + 3];\r\n                x2 = world[w + 4];\r\n                y2 = world[w + 5];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                ddfx += dddfx;\r\n                ddfy += dddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                curves[i] = pathLength;\r\n                x1 = x2;\r\n                y1 = y2;\r\n            }\r\n            if (percentPosition)\r\n                position *= pathLength;\r\n            else\r\n                position *= pathLength / path.lengths[curveCount - 1];\r\n            if (percentSpacing) {\r\n                for (var i = 1; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n            var segments = this.segments;\r\n            var curveLength = 0;\r\n            for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n                var space = spaces[i];\r\n                position += space;\r\n                var p = position;\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0)\r\n                        p += pathLength;\r\n                    curve = 0;\r\n                }\r\n                else if (p < 0) {\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                }\r\n                else if (p > pathLength) {\r\n                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                    continue;\r\n                }\r\n                for (;; curve++) {\r\n                    var length_6 = curves[curve];\r\n                    if (p > length_6)\r\n                        continue;\r\n                    if (curve == 0)\r\n                        p /= length_6;\r\n                    else {\r\n                        var prev = curves[curve - 1];\r\n                        p = (p - prev) / (length_6 - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    var ii = curve * 6;\r\n                    x1 = world[ii];\r\n                    y1 = world[ii + 1];\r\n                    cx1 = world[ii + 2];\r\n                    cy1 = world[ii + 3];\r\n                    cx2 = world[ii + 4];\r\n                    cy2 = world[ii + 5];\r\n                    x2 = world[ii + 6];\r\n                    y2 = world[ii + 7];\r\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                    ddfx = tmpx * 2 + dddfx;\r\n                    ddfy = tmpy * 2 + dddfy;\r\n                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[0] = curveLength;\r\n                    for (ii = 1; ii < 8; ii++) {\r\n                        dfx += ddfx;\r\n                        dfy += ddfy;\r\n                        ddfx += dddfx;\r\n                        ddfy += dddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[ii] = curveLength;\r\n                    }\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[8] = curveLength;\r\n                    dfx += ddfx + dddfx;\r\n                    dfy += ddfy + dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[9] = curveLength;\r\n                    segment = 0;\r\n                }\r\n                p *= curveLength;\r\n                for (;; segment++) {\r\n                    var length_7 = segments[segment];\r\n                    if (p > length_7)\r\n                        continue;\r\n                    if (segment == 0)\r\n                        p /= length_7;\r\n                    else {\r\n                        var prev = segments[segment - 1];\r\n                        p = segment + (p - prev) / (length_7 - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        };\r\n        PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n            var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n            out[o] = x1 + p * Math.cos(r);\r\n            out[o + 1] = y1 + p * Math.sin(r);\r\n            out[o + 2] = r;\r\n        };\r\n        PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n            var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n            out[o] = x1 + p * Math.cos(r);\r\n            out[o + 1] = y1 + p * Math.sin(r);\r\n            out[o + 2] = r;\r\n        };\r\n        PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n            if (p == 0 || isNaN(p)) {\r\n                out[o] = x1;\r\n                out[o + 1] = y1;\r\n                out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n                return;\r\n            }\r\n            var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n            var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n            var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n            out[o] = x;\r\n            out[o + 1] = y;\r\n            if (tangents) {\r\n                if (p < 0.001)\r\n                    out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n                else\r\n                    out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n            }\r\n        };\r\n        PathConstraint.NONE = -1;\r\n        PathConstraint.BEFORE = -2;\r\n        PathConstraint.AFTER = -3;\r\n        PathConstraint.epsilon = 0.00001;\r\n        return PathConstraint;\r\n    }());\r\n    spine.PathConstraint = PathConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var PathConstraintData = (function (_super) {\r\n        __extends(PathConstraintData, _super);\r\n        function PathConstraintData(name) {\r\n            var _this = _super.call(this, name, 0, false) || this;\r\n            _this.bones = new Array();\r\n            return _this;\r\n        }\r\n        return PathConstraintData;\r\n    }(spine.ConstraintData));\r\n    spine.PathConstraintData = PathConstraintData;\r\n    var PositionMode;\r\n    (function (PositionMode) {\r\n        PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n        PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n    })(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\r\n    var SpacingMode;\r\n    (function (SpacingMode) {\r\n        SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n        SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n        SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n    })(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\r\n    var RotateMode;\r\n    (function (RotateMode) {\r\n        RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n        RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n        RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n    })(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Assets = (function () {\r\n        function Assets(clientId) {\r\n            this.toLoad = new Array();\r\n            this.assets = {};\r\n            this.clientId = clientId;\r\n        }\r\n        Assets.prototype.loaded = function () {\r\n            var i = 0;\r\n            for (var v in this.assets)\r\n                i++;\r\n            return i;\r\n        };\r\n        return Assets;\r\n    }());\r\n    var SharedAssetManager = (function () {\r\n        function SharedAssetManager(pathPrefix) {\r\n            if (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n            this.clientAssets = {};\r\n            this.queuedAssets = {};\r\n            this.rawAssets = {};\r\n            this.errors = {};\r\n            this.pathPrefix = pathPrefix;\r\n        }\r\n        SharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\r\n            var clientAssets = this.clientAssets[clientId];\r\n            if (clientAssets === null || clientAssets === undefined) {\r\n                clientAssets = new Assets(clientId);\r\n                this.clientAssets[clientId] = clientAssets;\r\n            }\r\n            if (textureLoader !== null)\r\n                clientAssets.textureLoader = textureLoader;\r\n            clientAssets.toLoad.push(path);\r\n            if (this.queuedAssets[path] === path) {\r\n                return false;\r\n            }\r\n            else {\r\n                this.queuedAssets[path] = path;\r\n                return true;\r\n            }\r\n        };\r\n        SharedAssetManager.prototype.loadText = function (clientId, path) {\r\n            var _this = this;\r\n            path = this.pathPrefix + path;\r\n            if (!this.queueAsset(clientId, null, path))\r\n                return;\r\n            var request = new XMLHttpRequest();\r\n            request.onreadystatechange = function () {\r\n                if (request.readyState == XMLHttpRequest.DONE) {\r\n                    if (request.status >= 200 && request.status < 300) {\r\n                        _this.rawAssets[path] = request.responseText;\r\n                    }\r\n                    else {\r\n                        _this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n                    }\r\n                }\r\n            };\r\n            request.open(\"GET\", path, true);\r\n            request.send();\r\n        };\r\n        SharedAssetManager.prototype.loadJson = function (clientId, path) {\r\n            var _this = this;\r\n            path = this.pathPrefix + path;\r\n            if (!this.queueAsset(clientId, null, path))\r\n                return;\r\n            var request = new XMLHttpRequest();\r\n            request.onreadystatechange = function () {\r\n                if (request.readyState == XMLHttpRequest.DONE) {\r\n                    if (request.status >= 200 && request.status < 300) {\r\n                        _this.rawAssets[path] = JSON.parse(request.responseText);\r\n                    }\r\n                    else {\r\n                        _this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n                    }\r\n                }\r\n            };\r\n            request.open(\"GET\", path, true);\r\n            request.send();\r\n        };\r\n        SharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\r\n            var _this = this;\r\n            path = this.pathPrefix + path;\r\n            if (!this.queueAsset(clientId, textureLoader, path))\r\n                return;\r\n            var img = new Image();\r\n            img.src = path;\r\n            img.crossOrigin = \"anonymous\";\r\n            img.onload = function (ev) {\r\n                _this.rawAssets[path] = img;\r\n            };\r\n            img.onerror = function (ev) {\r\n                _this.errors[path] = \"Couldn't load image \" + path;\r\n            };\r\n        };\r\n        SharedAssetManager.prototype.get = function (clientId, path) {\r\n            path = this.pathPrefix + path;\r\n            var clientAssets = this.clientAssets[clientId];\r\n            if (clientAssets === null || clientAssets === undefined)\r\n                return true;\r\n            return clientAssets.assets[path];\r\n        };\r\n        SharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\r\n            for (var i = 0; i < clientAssets.toLoad.length; i++) {\r\n                var path = clientAssets.toLoad[i];\r\n                var asset = clientAssets.assets[path];\r\n                if (asset === null || asset === undefined) {\r\n                    var rawAsset = this.rawAssets[path];\r\n                    if (rawAsset === null || rawAsset === undefined)\r\n                        continue;\r\n                    if (rawAsset instanceof HTMLImageElement) {\r\n                        clientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\r\n                    }\r\n                    else {\r\n                        clientAssets.assets[path] = rawAsset;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        SharedAssetManager.prototype.isLoadingComplete = function (clientId) {\r\n            var clientAssets = this.clientAssets[clientId];\r\n            if (clientAssets === null || clientAssets === undefined)\r\n                return true;\r\n            this.updateClientAssets(clientAssets);\r\n            return clientAssets.toLoad.length == clientAssets.loaded();\r\n        };\r\n        SharedAssetManager.prototype.dispose = function () {\r\n        };\r\n        SharedAssetManager.prototype.hasErrors = function () {\r\n            return Object.keys(this.errors).length > 0;\r\n        };\r\n        SharedAssetManager.prototype.getErrors = function () {\r\n            return this.errors;\r\n        };\r\n        return SharedAssetManager;\r\n    }());\r\n    spine.SharedAssetManager = SharedAssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Skeleton = (function () {\r\n        function Skeleton(data) {\r\n            this._updateCache = new Array();\r\n            this.updateCacheReset = new Array();\r\n            this.time = 0;\r\n            this.scaleX = 1;\r\n            this.scaleY = 1;\r\n            this.x = 0;\r\n            this.y = 0;\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            this.data = data;\r\n            this.bones = new Array();\r\n            for (var i = 0; i < data.bones.length; i++) {\r\n                var boneData = data.bones[i];\r\n                var bone = void 0;\r\n                if (boneData.parent == null)\r\n                    bone = new spine.Bone(boneData, this, null);\r\n                else {\r\n                    var parent_1 = this.bones[boneData.parent.index];\r\n                    bone = new spine.Bone(boneData, this, parent_1);\r\n                    parent_1.children.push(bone);\r\n                }\r\n                this.bones.push(bone);\r\n            }\r\n            this.slots = new Array();\r\n            this.drawOrder = new Array();\r\n            for (var i = 0; i < data.slots.length; i++) {\r\n                var slotData = data.slots[i];\r\n                var bone = this.bones[slotData.boneData.index];\r\n                var slot = new spine.Slot(slotData, bone);\r\n                this.slots.push(slot);\r\n                this.drawOrder.push(slot);\r\n            }\r\n            this.ikConstraints = new Array();\r\n            for (var i = 0; i < data.ikConstraints.length; i++) {\r\n                var ikConstraintData = data.ikConstraints[i];\r\n                this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\r\n            }\r\n            this.transformConstraints = new Array();\r\n            for (var i = 0; i < data.transformConstraints.length; i++) {\r\n                var transformConstraintData = data.transformConstraints[i];\r\n                this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\r\n            }\r\n            this.pathConstraints = new Array();\r\n            for (var i = 0; i < data.pathConstraints.length; i++) {\r\n                var pathConstraintData = data.pathConstraints[i];\r\n                this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\r\n            }\r\n            this.color = new spine.Color(1, 1, 1, 1);\r\n            this.updateCache();\r\n        }\r\n        Skeleton.prototype.updateCache = function () {\r\n            var updateCache = this._updateCache;\r\n            updateCache.length = 0;\r\n            this.updateCacheReset.length = 0;\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                bone.sorted = bone.data.skinRequired;\r\n                bone.active = !bone.sorted;\r\n            }\r\n            if (this.skin != null) {\r\n                var skinBones = this.skin.bones;\r\n                for (var i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                    var bone = this.bones[skinBones[i].index];\r\n                    do {\r\n                        bone.sorted = false;\r\n                        bone.active = true;\r\n                        bone = bone.parent;\r\n                    } while (bone != null);\r\n                }\r\n            }\r\n            var ikConstraints = this.ikConstraints;\r\n            var transformConstraints = this.transformConstraints;\r\n            var pathConstraints = this.pathConstraints;\r\n            var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n            var constraintCount = ikCount + transformCount + pathCount;\r\n            outer: for (var i = 0; i < constraintCount; i++) {\r\n                for (var ii = 0; ii < ikCount; ii++) {\r\n                    var constraint = ikConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortIkConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (var ii = 0; ii < transformCount; ii++) {\r\n                    var constraint = transformConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortTransformConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n                for (var ii = 0; ii < pathCount; ii++) {\r\n                    var constraint = pathConstraints[ii];\r\n                    if (constraint.data.order == i) {\r\n                        this.sortPathConstraint(constraint);\r\n                        continue outer;\r\n                    }\r\n                }\r\n            }\r\n            for (var i = 0, n = bones.length; i < n; i++)\r\n                this.sortBone(bones[i]);\r\n        };\r\n        Skeleton.prototype.sortIkConstraint = function (constraint) {\r\n            constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active)\r\n                return;\r\n            var target = constraint.target;\r\n            this.sortBone(target);\r\n            var constrained = constraint.bones;\r\n            var parent = constrained[0];\r\n            this.sortBone(parent);\r\n            if (constrained.length > 1) {\r\n                var child = constrained[constrained.length - 1];\r\n                if (!(this._updateCache.indexOf(child) > -1))\r\n                    this.updateCacheReset.push(child);\r\n            }\r\n            this._updateCache.push(constraint);\r\n            this.sortReset(parent.children);\r\n            constrained[constrained.length - 1].sorted = true;\r\n        };\r\n        Skeleton.prototype.sortPathConstraint = function (constraint) {\r\n            constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active)\r\n                return;\r\n            var slot = constraint.target;\r\n            var slotIndex = slot.data.index;\r\n            var slotBone = slot.bone;\r\n            if (this.skin != null)\r\n                this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n            for (var i = 0, n = this.data.skins.length; i < n; i++)\r\n                this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n            var attachment = slot.getAttachment();\r\n            if (attachment instanceof spine.PathAttachment)\r\n                this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n            var constrained = constraint.bones;\r\n            var boneCount = constrained.length;\r\n            for (var i = 0; i < boneCount; i++)\r\n                this.sortBone(constrained[i]);\r\n            this._updateCache.push(constraint);\r\n            for (var i = 0; i < boneCount; i++)\r\n                this.sortReset(constrained[i].children);\r\n            for (var i = 0; i < boneCount; i++)\r\n                constrained[i].sorted = true;\r\n        };\r\n        Skeleton.prototype.sortTransformConstraint = function (constraint) {\r\n            constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active)\r\n                return;\r\n            this.sortBone(constraint.target);\r\n            var constrained = constraint.bones;\r\n            var boneCount = constrained.length;\r\n            if (constraint.data.local) {\r\n                for (var i = 0; i < boneCount; i++) {\r\n                    var child = constrained[i];\r\n                    this.sortBone(child.parent);\r\n                    if (!(this._updateCache.indexOf(child) > -1))\r\n                        this.updateCacheReset.push(child);\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i < boneCount; i++) {\r\n                    this.sortBone(constrained[i]);\r\n                }\r\n            }\r\n            this._updateCache.push(constraint);\r\n            for (var ii = 0; ii < boneCount; ii++)\r\n                this.sortReset(constrained[ii].children);\r\n            for (var ii = 0; ii < boneCount; ii++)\r\n                constrained[ii].sorted = true;\r\n        };\r\n        Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n            var attachments = skin.attachments[slotIndex];\r\n            if (!attachments)\r\n                return;\r\n            for (var key in attachments) {\r\n                this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n            }\r\n        };\r\n        Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n            if (!(attachment instanceof spine.PathAttachment))\r\n                return;\r\n            var pathBones = attachment.bones;\r\n            if (pathBones == null)\r\n                this.sortBone(slotBone);\r\n            else {\r\n                var bones = this.bones;\r\n                var i = 0;\r\n                while (i < pathBones.length) {\r\n                    var boneCount = pathBones[i++];\r\n                    for (var n = i + boneCount; i < n; i++) {\r\n                        var boneIndex = pathBones[i];\r\n                        this.sortBone(bones[boneIndex]);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Skeleton.prototype.sortBone = function (bone) {\r\n            if (bone.sorted)\r\n                return;\r\n            var parent = bone.parent;\r\n            if (parent != null)\r\n                this.sortBone(parent);\r\n            bone.sorted = true;\r\n            this._updateCache.push(bone);\r\n        };\r\n        Skeleton.prototype.sortReset = function (bones) {\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                if (!bone.active)\r\n                    continue;\r\n                if (bone.sorted)\r\n                    this.sortReset(bone.children);\r\n                bone.sorted = false;\r\n            }\r\n        };\r\n        Skeleton.prototype.updateWorldTransform = function () {\r\n            var updateCacheReset = this.updateCacheReset;\r\n            for (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n                var bone = updateCacheReset[i];\r\n                bone.ax = bone.x;\r\n                bone.ay = bone.y;\r\n                bone.arotation = bone.rotation;\r\n                bone.ascaleX = bone.scaleX;\r\n                bone.ascaleY = bone.scaleY;\r\n                bone.ashearX = bone.shearX;\r\n                bone.ashearY = bone.shearY;\r\n                bone.appliedValid = true;\r\n            }\r\n            var updateCache = this._updateCache;\r\n            for (var i = 0, n = updateCache.length; i < n; i++)\r\n                updateCache[i].update();\r\n        };\r\n        Skeleton.prototype.setToSetupPose = function () {\r\n            this.setBonesToSetupPose();\r\n            this.setSlotsToSetupPose();\r\n        };\r\n        Skeleton.prototype.setBonesToSetupPose = function () {\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++)\r\n                bones[i].setToSetupPose();\r\n            var ikConstraints = this.ikConstraints;\r\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                var constraint = ikConstraints[i];\r\n                constraint.mix = constraint.data.mix;\r\n                constraint.softness = constraint.data.softness;\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            }\r\n            var transformConstraints = this.transformConstraints;\r\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                var constraint = transformConstraints[i];\r\n                var data = constraint.data;\r\n                constraint.rotateMix = data.rotateMix;\r\n                constraint.translateMix = data.translateMix;\r\n                constraint.scaleMix = data.scaleMix;\r\n                constraint.shearMix = data.shearMix;\r\n            }\r\n            var pathConstraints = this.pathConstraints;\r\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                var constraint = pathConstraints[i];\r\n                var data = constraint.data;\r\n                constraint.position = data.position;\r\n                constraint.spacing = data.spacing;\r\n                constraint.rotateMix = data.rotateMix;\r\n                constraint.translateMix = data.translateMix;\r\n            }\r\n        };\r\n        Skeleton.prototype.setSlotsToSetupPose = function () {\r\n            var slots = this.slots;\r\n            spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n            for (var i = 0, n = slots.length; i < n; i++)\r\n                slots[i].setToSetupPose();\r\n        };\r\n        Skeleton.prototype.getRootBone = function () {\r\n            if (this.bones.length == 0)\r\n                return null;\r\n            return this.bones[0];\r\n        };\r\n        Skeleton.prototype.findBone = function (boneName) {\r\n            if (boneName == null)\r\n                throw new Error(\"boneName cannot be null.\");\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                if (bone.data.name == boneName)\r\n                    return bone;\r\n            }\r\n            return null;\r\n        };\r\n        Skeleton.prototype.findBoneIndex = function (boneName) {\r\n            if (boneName == null)\r\n                throw new Error(\"boneName cannot be null.\");\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++)\r\n                if (bones[i].data.name == boneName)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        Skeleton.prototype.findSlot = function (slotName) {\r\n            if (slotName == null)\r\n                throw new Error(\"slotName cannot be null.\");\r\n            var slots = this.slots;\r\n            for (var i = 0, n = slots.length; i < n; i++) {\r\n                var slot = slots[i];\r\n                if (slot.data.name == slotName)\r\n                    return slot;\r\n            }\r\n            return null;\r\n        };\r\n        Skeleton.prototype.findSlotIndex = function (slotName) {\r\n            if (slotName == null)\r\n                throw new Error(\"slotName cannot be null.\");\r\n            var slots = this.slots;\r\n            for (var i = 0, n = slots.length; i < n; i++)\r\n                if (slots[i].data.name == slotName)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        Skeleton.prototype.setSkinByName = function (skinName) {\r\n            var skin = this.data.findSkin(skinName);\r\n            if (skin == null)\r\n                throw new Error(\"Skin not found: \" + skinName);\r\n            this.setSkin(skin);\r\n        };\r\n        Skeleton.prototype.setSkin = function (newSkin) {\r\n            if (newSkin == this.skin)\r\n                return;\r\n            if (newSkin != null) {\r\n                if (this.skin != null)\r\n                    newSkin.attachAll(this, this.skin);\r\n                else {\r\n                    var slots = this.slots;\r\n                    for (var i = 0, n = slots.length; i < n; i++) {\r\n                        var slot = slots[i];\r\n                        var name_1 = slot.data.attachmentName;\r\n                        if (name_1 != null) {\r\n                            var attachment = newSkin.getAttachment(i, name_1);\r\n                            if (attachment != null)\r\n                                slot.setAttachment(attachment);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.skin = newSkin;\r\n            this.updateCache();\r\n        };\r\n        Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n            return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n        };\r\n        Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n            if (attachmentName == null)\r\n                throw new Error(\"attachmentName cannot be null.\");\r\n            if (this.skin != null) {\r\n                var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n                if (attachment != null)\r\n                    return attachment;\r\n            }\r\n            if (this.data.defaultSkin != null)\r\n                return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n            return null;\r\n        };\r\n        Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n            if (slotName == null)\r\n                throw new Error(\"slotName cannot be null.\");\r\n            var slots = this.slots;\r\n            for (var i = 0, n = slots.length; i < n; i++) {\r\n                var slot = slots[i];\r\n                if (slot.data.name == slotName) {\r\n                    var attachment = null;\r\n                    if (attachmentName != null) {\r\n                        attachment = this.getAttachment(i, attachmentName);\r\n                        if (attachment == null)\r\n                            throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                    }\r\n                    slot.setAttachment(attachment);\r\n                    return;\r\n                }\r\n            }\r\n            throw new Error(\"Slot not found: \" + slotName);\r\n        };\r\n        Skeleton.prototype.findIkConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var ikConstraints = this.ikConstraints;\r\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                var ikConstraint = ikConstraints[i];\r\n                if (ikConstraint.data.name == constraintName)\r\n                    return ikConstraint;\r\n            }\r\n            return null;\r\n        };\r\n        Skeleton.prototype.findTransformConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var transformConstraints = this.transformConstraints;\r\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                var constraint = transformConstraints[i];\r\n                if (constraint.data.name == constraintName)\r\n                    return constraint;\r\n            }\r\n            return null;\r\n        };\r\n        Skeleton.prototype.findPathConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var pathConstraints = this.pathConstraints;\r\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                var constraint = pathConstraints[i];\r\n                if (constraint.data.name == constraintName)\r\n                    return constraint;\r\n            }\r\n            return null;\r\n        };\r\n        Skeleton.prototype.getBounds = function (offset, size, temp) {\r\n            if (temp === void 0) { temp = new Array(2); }\r\n            if (offset == null)\r\n                throw new Error(\"offset cannot be null.\");\r\n            if (size == null)\r\n                throw new Error(\"size cannot be null.\");\r\n            var drawOrder = this.drawOrder;\r\n            var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                var slot = drawOrder[i];\r\n                if (!slot.bone.active)\r\n                    continue;\r\n                var verticesLength = 0;\r\n                var vertices = null;\r\n                var attachment = slot.getAttachment();\r\n                if (attachment instanceof spine.RegionAttachment) {\r\n                    verticesLength = 8;\r\n                    vertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n                    attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n                }\r\n                else if (attachment instanceof spine.MeshAttachment) {\r\n                    var mesh = attachment;\r\n                    verticesLength = mesh.worldVerticesLength;\r\n                    vertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n                    mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n                }\r\n                if (vertices != null) {\r\n                    for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                        var x = vertices[ii], y = vertices[ii + 1];\r\n                        minX = Math.min(minX, x);\r\n                        minY = Math.min(minY, y);\r\n                        maxX = Math.max(maxX, x);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                }\r\n            }\r\n            offset.set(minX, minY);\r\n            size.set(maxX - minX, maxY - minY);\r\n        };\r\n        Skeleton.prototype.update = function (delta) {\r\n            this.time += delta;\r\n        };\r\n        return Skeleton;\r\n    }());\r\n    spine.Skeleton = Skeleton;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkeletonBinary = (function () {\r\n        function SkeletonBinary(attachmentLoader) {\r\n            this.scale = 1;\r\n            this.linkedMeshes = new Array();\r\n            this.attachmentLoader = attachmentLoader;\r\n        }\r\n        SkeletonBinary.prototype.readSkeletonData = function (binary) {\r\n            var scale = this.scale;\r\n            var skeletonData = new spine.SkeletonData();\r\n            skeletonData.name = \"\";\r\n            var input = new BinaryInput(binary);\r\n            skeletonData.hash = input.readString();\r\n            skeletonData.version = input.readString();\r\n            skeletonData.x = input.readFloat();\r\n            skeletonData.y = input.readFloat();\r\n            skeletonData.width = input.readFloat();\r\n            skeletonData.height = input.readFloat();\r\n            var nonessential = input.readBoolean();\r\n            if (nonessential) {\r\n                skeletonData.fps = input.readFloat();\r\n                skeletonData.imagesPath = input.readString();\r\n                skeletonData.audioPath = input.readString();\r\n            }\r\n            var n = 0;\r\n            n = input.readInt(true);\r\n            for (var i = 0; i < n; i++)\r\n                input.strings.push(input.readString());\r\n            n = input.readInt(true);\r\n            for (var i = 0; i < n; i++) {\r\n                var name_2 = input.readString();\r\n                var parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n                var data = new spine.BoneData(i, name_2, parent_2);\r\n                data.rotation = input.readFloat();\r\n                data.x = input.readFloat() * scale;\r\n                data.y = input.readFloat() * scale;\r\n                data.scaleX = input.readFloat();\r\n                data.scaleY = input.readFloat();\r\n                data.shearX = input.readFloat();\r\n                data.shearY = input.readFloat();\r\n                data.length = input.readFloat() * scale;\r\n                data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n                data.skinRequired = input.readBoolean();\r\n                if (nonessential)\r\n                    spine.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                skeletonData.bones.push(data);\r\n            }\r\n            n = input.readInt(true);\r\n            for (var i = 0; i < n; i++) {\r\n                var slotName = input.readString();\r\n                var boneData = skeletonData.bones[input.readInt(true)];\r\n                var data = new spine.SlotData(i, slotName, boneData);\r\n                spine.Color.rgba8888ToColor(data.color, input.readInt32());\r\n                var darkColor = input.readInt32();\r\n                if (darkColor != -1)\r\n                    spine.Color.rgb888ToColor(data.darkColor = new spine.Color(), darkColor);\r\n                data.attachmentName = input.readStringRef();\r\n                data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n                skeletonData.slots.push(data);\r\n            }\r\n            n = input.readInt(true);\r\n            for (var i = 0, nn = void 0; i < n; i++) {\r\n                var data = new spine.IkConstraintData(input.readString());\r\n                data.order = input.readInt(true);\r\n                data.skinRequired = input.readBoolean();\r\n                nn = input.readInt(true);\r\n                for (var ii = 0; ii < nn; ii++)\r\n                    data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                data.target = skeletonData.bones[input.readInt(true)];\r\n                data.mix = input.readFloat();\r\n                data.softness = input.readFloat() * scale;\r\n                data.bendDirection = input.readByte();\r\n                data.compress = input.readBoolean();\r\n                data.stretch = input.readBoolean();\r\n                data.uniform = input.readBoolean();\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n            n = input.readInt(true);\r\n            for (var i = 0, nn = void 0; i < n; i++) {\r\n                var data = new spine.TransformConstraintData(input.readString());\r\n                data.order = input.readInt(true);\r\n                data.skinRequired = input.readBoolean();\r\n                nn = input.readInt(true);\r\n                for (var ii = 0; ii < nn; ii++)\r\n                    data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                data.target = skeletonData.bones[input.readInt(true)];\r\n                data.local = input.readBoolean();\r\n                data.relative = input.readBoolean();\r\n                data.offsetRotation = input.readFloat();\r\n                data.offsetX = input.readFloat() * scale;\r\n                data.offsetY = input.readFloat() * scale;\r\n                data.offsetScaleX = input.readFloat();\r\n                data.offsetScaleY = input.readFloat();\r\n                data.offsetShearY = input.readFloat();\r\n                data.rotateMix = input.readFloat();\r\n                data.translateMix = input.readFloat();\r\n                data.scaleMix = input.readFloat();\r\n                data.shearMix = input.readFloat();\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n            n = input.readInt(true);\r\n            for (var i = 0, nn = void 0; i < n; i++) {\r\n                var data = new spine.PathConstraintData(input.readString());\r\n                data.order = input.readInt(true);\r\n                data.skinRequired = input.readBoolean();\r\n                nn = input.readInt(true);\r\n                for (var ii = 0; ii < nn; ii++)\r\n                    data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n                data.target = skeletonData.slots[input.readInt(true)];\r\n                data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n                data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n                data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n                data.offsetRotation = input.readFloat();\r\n                data.position = input.readFloat();\r\n                if (data.positionMode == spine.PositionMode.Fixed)\r\n                    data.position *= scale;\r\n                data.spacing = input.readFloat();\r\n                if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n                    data.spacing *= scale;\r\n                data.rotateMix = input.readFloat();\r\n                data.translateMix = input.readFloat();\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n            var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n            if (defaultSkin != null) {\r\n                skeletonData.defaultSkin = defaultSkin;\r\n                skeletonData.skins.push(defaultSkin);\r\n            }\r\n            {\r\n                var i = skeletonData.skins.length;\r\n                spine.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n                for (; i < n; i++)\r\n                    skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n            }\r\n            n = this.linkedMeshes.length;\r\n            for (var i = 0; i < n; i++) {\r\n                var linkedMesh = this.linkedMeshes[i];\r\n                var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                if (skin == null)\r\n                    throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                if (parent_3 == null)\r\n                    throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;\r\n                linkedMesh.mesh.setParentMesh(parent_3);\r\n                linkedMesh.mesh.updateUVs();\r\n            }\r\n            this.linkedMeshes.length = 0;\r\n            n = input.readInt(true);\r\n            for (var i = 0; i < n; i++) {\r\n                var data = new spine.EventData(input.readStringRef());\r\n                data.intValue = input.readInt(false);\r\n                data.floatValue = input.readFloat();\r\n                data.stringValue = input.readString();\r\n                data.audioPath = input.readString();\r\n                if (data.audioPath != null) {\r\n                    data.volume = input.readFloat();\r\n                    data.balance = input.readFloat();\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n            n = input.readInt(true);\r\n            for (var i = 0; i < n; i++)\r\n                skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n            return skeletonData;\r\n        };\r\n        SkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {\r\n            var skin = null;\r\n            var slotCount = 0;\r\n            if (defaultSkin) {\r\n                slotCount = input.readInt(true);\r\n                if (slotCount == 0)\r\n                    return null;\r\n                skin = new spine.Skin(\"default\");\r\n            }\r\n            else {\r\n                skin = new spine.Skin(input.readStringRef());\r\n                skin.bones.length = input.readInt(true);\r\n                for (var i = 0, n = skin.bones.length; i < n; i++)\r\n                    skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n                for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n                for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n                for (var i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n                slotCount = input.readInt(true);\r\n            }\r\n            for (var i = 0; i < slotCount; i++) {\r\n                var slotIndex = input.readInt(true);\r\n                for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    var name_3 = input.readStringRef();\r\n                    var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);\r\n                    if (attachment != null)\r\n                        skin.setAttachment(slotIndex, name_3, attachment);\r\n                }\r\n            }\r\n            return skin;\r\n        };\r\n        SkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\r\n            var scale = this.scale;\r\n            var name = input.readStringRef();\r\n            if (name == null)\r\n                name = attachmentName;\r\n            var typeIndex = input.readByte();\r\n            var type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n            switch (type) {\r\n                case spine.AttachmentType.Region: {\r\n                    var path = input.readStringRef();\r\n                    var rotation = input.readFloat();\r\n                    var x = input.readFloat();\r\n                    var y = input.readFloat();\r\n                    var scaleX = input.readFloat();\r\n                    var scaleY = input.readFloat();\r\n                    var width = input.readFloat();\r\n                    var height = input.readFloat();\r\n                    var color = input.readInt32();\r\n                    if (path == null)\r\n                        path = name;\r\n                    var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                    if (region == null)\r\n                        return null;\r\n                    region.path = path;\r\n                    region.x = x * scale;\r\n                    region.y = y * scale;\r\n                    region.scaleX = scaleX;\r\n                    region.scaleY = scaleY;\r\n                    region.rotation = rotation;\r\n                    region.width = width * scale;\r\n                    region.height = height * scale;\r\n                    spine.Color.rgba8888ToColor(region.color, color);\r\n                    region.updateOffset();\r\n                    return region;\r\n                }\r\n                case spine.AttachmentType.BoundingBox: {\r\n                    var vertexCount = input.readInt(true);\r\n                    var vertices = this.readVertices(input, vertexCount);\r\n                    var color = nonessential ? input.readInt32() : 0;\r\n                    var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                    if (box == null)\r\n                        return null;\r\n                    box.worldVerticesLength = vertexCount << 1;\r\n                    box.vertices = vertices.vertices;\r\n                    box.bones = vertices.bones;\r\n                    if (nonessential)\r\n                        spine.Color.rgba8888ToColor(box.color, color);\r\n                    return box;\r\n                }\r\n                case spine.AttachmentType.Mesh: {\r\n                    var path = input.readStringRef();\r\n                    var color = input.readInt32();\r\n                    var vertexCount = input.readInt(true);\r\n                    var uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                    var triangles = this.readShortArray(input);\r\n                    var vertices = this.readVertices(input, vertexCount);\r\n                    var hullLength = input.readInt(true);\r\n                    var edges = null;\r\n                    var width = 0, height = 0;\r\n                    if (nonessential) {\r\n                        edges = this.readShortArray(input);\r\n                        width = input.readFloat();\r\n                        height = input.readFloat();\r\n                    }\r\n                    if (path == null)\r\n                        path = name;\r\n                    var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                    if (mesh == null)\r\n                        return null;\r\n                    mesh.path = path;\r\n                    spine.Color.rgba8888ToColor(mesh.color, color);\r\n                    mesh.bones = vertices.bones;\r\n                    mesh.vertices = vertices.vertices;\r\n                    mesh.worldVerticesLength = vertexCount << 1;\r\n                    mesh.triangles = triangles;\r\n                    mesh.regionUVs = uvs;\r\n                    mesh.updateUVs();\r\n                    mesh.hullLength = hullLength << 1;\r\n                    if (nonessential) {\r\n                        mesh.edges = edges;\r\n                        mesh.width = width * scale;\r\n                        mesh.height = height * scale;\r\n                    }\r\n                    return mesh;\r\n                }\r\n                case spine.AttachmentType.LinkedMesh: {\r\n                    var path = input.readStringRef();\r\n                    var color = input.readInt32();\r\n                    var skinName = input.readStringRef();\r\n                    var parent_4 = input.readStringRef();\r\n                    var inheritDeform = input.readBoolean();\r\n                    var width = 0, height = 0;\r\n                    if (nonessential) {\r\n                        width = input.readFloat();\r\n                        height = input.readFloat();\r\n                    }\r\n                    if (path == null)\r\n                        path = name;\r\n                    var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                    if (mesh == null)\r\n                        return null;\r\n                    mesh.path = path;\r\n                    spine.Color.rgba8888ToColor(mesh.color, color);\r\n                    if (nonessential) {\r\n                        mesh.width = width * scale;\r\n                        mesh.height = height * scale;\r\n                    }\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));\r\n                    return mesh;\r\n                }\r\n                case spine.AttachmentType.Path: {\r\n                    var closed_1 = input.readBoolean();\r\n                    var constantSpeed = input.readBoolean();\r\n                    var vertexCount = input.readInt(true);\r\n                    var vertices = this.readVertices(input, vertexCount);\r\n                    var lengths = spine.Utils.newArray(vertexCount / 3, 0);\r\n                    for (var i = 0, n = lengths.length; i < n; i++)\r\n                        lengths[i] = input.readFloat() * scale;\r\n                    var color = nonessential ? input.readInt32() : 0;\r\n                    var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                    if (path == null)\r\n                        return null;\r\n                    path.closed = closed_1;\r\n                    path.constantSpeed = constantSpeed;\r\n                    path.worldVerticesLength = vertexCount << 1;\r\n                    path.vertices = vertices.vertices;\r\n                    path.bones = vertices.bones;\r\n                    path.lengths = lengths;\r\n                    if (nonessential)\r\n                        spine.Color.rgba8888ToColor(path.color, color);\r\n                    return path;\r\n                }\r\n                case spine.AttachmentType.Point: {\r\n                    var rotation = input.readFloat();\r\n                    var x = input.readFloat();\r\n                    var y = input.readFloat();\r\n                    var color = nonessential ? input.readInt32() : 0;\r\n                    var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                    if (point == null)\r\n                        return null;\r\n                    point.x = x * scale;\r\n                    point.y = y * scale;\r\n                    point.rotation = rotation;\r\n                    if (nonessential)\r\n                        spine.Color.rgba8888ToColor(point.color, color);\r\n                    return point;\r\n                }\r\n                case spine.AttachmentType.Clipping: {\r\n                    var endSlotIndex = input.readInt(true);\r\n                    var vertexCount = input.readInt(true);\r\n                    var vertices = this.readVertices(input, vertexCount);\r\n                    var color = nonessential ? input.readInt32() : 0;\r\n                    var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                    if (clip == null)\r\n                        return null;\r\n                    clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                    clip.worldVerticesLength = vertexCount << 1;\r\n                    clip.vertices = vertices.vertices;\r\n                    clip.bones = vertices.bones;\r\n                    if (nonessential)\r\n                        spine.Color.rgba8888ToColor(clip.color, color);\r\n                    return clip;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonBinary.prototype.readVertices = function (input, vertexCount) {\r\n            var verticesLength = vertexCount << 1;\r\n            var vertices = new Vertices();\r\n            var scale = this.scale;\r\n            if (!input.readBoolean()) {\r\n                vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n                return vertices;\r\n            }\r\n            var weights = new Array();\r\n            var bonesArray = new Array();\r\n            for (var i = 0; i < vertexCount; i++) {\r\n                var boneCount = input.readInt(true);\r\n                bonesArray.push(boneCount);\r\n                for (var ii = 0; ii < boneCount; ii++) {\r\n                    bonesArray.push(input.readInt(true));\r\n                    weights.push(input.readFloat() * scale);\r\n                    weights.push(input.readFloat() * scale);\r\n                    weights.push(input.readFloat());\r\n                }\r\n            }\r\n            vertices.vertices = spine.Utils.toFloatArray(weights);\r\n            vertices.bones = bonesArray;\r\n            return vertices;\r\n        };\r\n        SkeletonBinary.prototype.readFloatArray = function (input, n, scale) {\r\n            var array = new Array(n);\r\n            if (scale == 1) {\r\n                for (var i = 0; i < n; i++)\r\n                    array[i] = input.readFloat();\r\n            }\r\n            else {\r\n                for (var i = 0; i < n; i++)\r\n                    array[i] = input.readFloat() * scale;\r\n            }\r\n            return array;\r\n        };\r\n        SkeletonBinary.prototype.readShortArray = function (input) {\r\n            var n = input.readInt(true);\r\n            var array = new Array(n);\r\n            for (var i = 0; i < n; i++)\r\n                array[i] = input.readShort();\r\n            return array;\r\n        };\r\n        SkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {\r\n            var timelines = new Array();\r\n            var scale = this.scale;\r\n            var duration = 0;\r\n            var tempColor1 = new spine.Color();\r\n            var tempColor2 = new spine.Color();\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var slotIndex = input.readInt(true);\r\n                for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    var timelineType = input.readByte();\r\n                    var frameCount = input.readInt(true);\r\n                    switch (timelineType) {\r\n                        case SkeletonBinary.SLOT_ATTACHMENT: {\r\n                            var timeline = new spine.AttachmentTimeline(frameCount);\r\n                            timeline.slotIndex = slotIndex;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)\r\n                                timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                            break;\r\n                        }\r\n                        case SkeletonBinary.SLOT_COLOR: {\r\n                            var timeline = new spine.ColorTimeline(frameCount);\r\n                            timeline.slotIndex = slotIndex;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                var time = input.readFloat();\r\n                                spine.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.ColorTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                        case SkeletonBinary.SLOT_TWO_COLOR: {\r\n                            var timeline = new spine.TwoColorTimeline(frameCount);\r\n                            timeline.slotIndex = slotIndex;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                var time = input.readFloat();\r\n                                spine.Color.rgba8888ToColor(tempColor1, input.readInt32());\r\n                                spine.Color.rgb888ToColor(tempColor2, input.readInt32());\r\n                                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TwoColorTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var boneIndex = input.readInt(true);\r\n                for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    var timelineType = input.readByte();\r\n                    var frameCount = input.readInt(true);\r\n                    switch (timelineType) {\r\n                        case SkeletonBinary.BONE_ROTATE: {\r\n                            var timeline = new spine.RotateTimeline(frameCount);\r\n                            timeline.boneIndex = boneIndex;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.RotateTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                        case SkeletonBinary.BONE_TRANSLATE:\r\n                        case SkeletonBinary.BONE_SCALE:\r\n                        case SkeletonBinary.BONE_SHEAR: {\r\n                            var timeline = void 0;\r\n                            var timelineScale = 1;\r\n                            if (timelineType == SkeletonBinary.BONE_SCALE)\r\n                                timeline = new spine.ScaleTimeline(frameCount);\r\n                            else if (timelineType == SkeletonBinary.BONE_SHEAR)\r\n                                timeline = new spine.ShearTimeline(frameCount);\r\n                            else {\r\n                                timeline = new spine.TranslateTimeline(frameCount);\r\n                                timelineScale = scale;\r\n                            }\r\n                            timeline.boneIndex = boneIndex;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TranslateTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var index = input.readInt(true);\r\n                var frameCount = input.readInt(true);\r\n                var timeline = new spine.IkConstraintTimeline(frameCount);\r\n                timeline.ikConstraintIndex = index;\r\n                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                    if (frameIndex < frameCount - 1)\r\n                        this.readCurve(input, frameIndex, timeline);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.IkConstraintTimeline.ENTRIES]);\r\n            }\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var index = input.readInt(true);\r\n                var frameCount = input.readInt(true);\r\n                var timeline = new spine.TransformConstraintTimeline(frameCount);\r\n                timeline.transformConstraintIndex = index;\r\n                for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                    timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                    if (frameIndex < frameCount - 1)\r\n                        this.readCurve(input, frameIndex, timeline);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var index = input.readInt(true);\r\n                var data = skeletonData.pathConstraints[index];\r\n                for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    var timelineType = input.readByte();\r\n                    var frameCount = input.readInt(true);\r\n                    switch (timelineType) {\r\n                        case SkeletonBinary.PATH_POSITION:\r\n                        case SkeletonBinary.PATH_SPACING: {\r\n                            var timeline = void 0;\r\n                            var timelineScale = 1;\r\n                            if (timelineType == SkeletonBinary.PATH_SPACING) {\r\n                                timeline = new spine.PathConstraintSpacingTimeline(frameCount);\r\n                                if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n                                    timelineScale = scale;\r\n                            }\r\n                            else {\r\n                                timeline = new spine.PathConstraintPositionTimeline(frameCount);\r\n                                if (data.positionMode == spine.PositionMode.Fixed)\r\n                                    timelineScale = scale;\r\n                            }\r\n                            timeline.pathConstraintIndex = index;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                        case SkeletonBinary.PATH_MIX: {\r\n                            var timeline = new spine.PathConstraintMixTimeline(frameCount);\r\n                            timeline.pathConstraintIndex = index;\r\n                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n                                if (frameIndex < frameCount - 1)\r\n                                    this.readCurve(input, frameIndex, timeline);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (var i = 0, n = input.readInt(true); i < n; i++) {\r\n                var skin = skeletonData.skins[input.readInt(true)];\r\n                for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    var slotIndex = input.readInt(true);\r\n                    for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                        var attachment = skin.getAttachment(slotIndex, input.readStringRef());\r\n                        var weighted = attachment.bones != null;\r\n                        var vertices = attachment.vertices;\r\n                        var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                        var frameCount = input.readInt(true);\r\n                        var timeline = new spine.DeformTimeline(frameCount);\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n                        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n                            var time = input.readFloat();\r\n                            var deform = void 0;\r\n                            var end = input.readInt(true);\r\n                            if (end == 0)\r\n                                deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = spine.Utils.newFloatArray(deformLength);\r\n                                var start = input.readInt(true);\r\n                                end += start;\r\n                                if (scale == 1) {\r\n                                    for (var v = start; v < end; v++)\r\n                                        deform[v] = input.readFloat();\r\n                                }\r\n                                else {\r\n                                    for (var v = start; v < end; v++)\r\n                                        deform[v] = input.readFloat() * scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (var v = 0, vn = deform.length; v < vn; v++)\r\n                                        deform[v] += vertices[v];\r\n                                }\r\n                            }\r\n                            timeline.setFrame(frameIndex, time, deform);\r\n                            if (frameIndex < frameCount - 1)\r\n                                this.readCurve(input, frameIndex, timeline);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n                    }\r\n                }\r\n            }\r\n            var drawOrderCount = input.readInt(true);\r\n            if (drawOrderCount > 0) {\r\n                var timeline = new spine.DrawOrderTimeline(drawOrderCount);\r\n                var slotCount = skeletonData.slots.length;\r\n                for (var i = 0; i < drawOrderCount; i++) {\r\n                    var time = input.readFloat();\r\n                    var offsetCount = input.readInt(true);\r\n                    var drawOrder = spine.Utils.newArray(slotCount, 0);\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        drawOrder[ii] = -1;\r\n                    var unchanged = spine.Utils.newArray(slotCount - offsetCount, 0);\r\n                    var originalIndex = 0, unchangedIndex = 0;\r\n                    for (var ii = 0; ii < offsetCount; ii++) {\r\n                        var slotIndex = input.readInt(true);\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                    }\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1)\r\n                            drawOrder[ii] = unchanged[--unchangedIndex];\r\n                    timeline.setFrame(i, time, drawOrder);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n            }\r\n            var eventCount = input.readInt(true);\r\n            if (eventCount > 0) {\r\n                var timeline = new spine.EventTimeline(eventCount);\r\n                for (var i = 0; i < eventCount; i++) {\r\n                    var time = input.readFloat();\r\n                    var eventData = skeletonData.events[input.readInt(true)];\r\n                    var event_4 = new spine.Event(time, eventData);\r\n                    event_4.intValue = input.readInt(false);\r\n                    event_4.floatValue = input.readFloat();\r\n                    event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                    if (event_4.data.audioPath != null) {\r\n                        event_4.volume = input.readFloat();\r\n                        event_4.balance = input.readFloat();\r\n                    }\r\n                    timeline.setFrame(i, event_4);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n            }\r\n            return new spine.Animation(name, timelines, duration);\r\n        };\r\n        SkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {\r\n            switch (input.readByte()) {\r\n                case SkeletonBinary.CURVE_STEPPED:\r\n                    timeline.setStepped(frameIndex);\r\n                    break;\r\n                case SkeletonBinary.CURVE_BEZIER:\r\n                    this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n                    break;\r\n            }\r\n        };\r\n        SkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {\r\n            timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n        };\r\n        SkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];\r\n        SkeletonBinary.TransformModeValues = [spine.TransformMode.Normal, spine.TransformMode.OnlyTranslation, spine.TransformMode.NoRotationOrReflection, spine.TransformMode.NoScale, spine.TransformMode.NoScaleOrReflection];\r\n        SkeletonBinary.PositionModeValues = [spine.PositionMode.Fixed, spine.PositionMode.Percent];\r\n        SkeletonBinary.SpacingModeValues = [spine.SpacingMode.Length, spine.SpacingMode.Fixed, spine.SpacingMode.Percent];\r\n        SkeletonBinary.RotateModeValues = [spine.RotateMode.Tangent, spine.RotateMode.Chain, spine.RotateMode.ChainScale];\r\n        SkeletonBinary.BlendModeValues = [spine.BlendMode.Normal, spine.BlendMode.Additive, spine.BlendMode.Multiply, spine.BlendMode.Screen];\r\n        SkeletonBinary.BONE_ROTATE = 0;\r\n        SkeletonBinary.BONE_TRANSLATE = 1;\r\n        SkeletonBinary.BONE_SCALE = 2;\r\n        SkeletonBinary.BONE_SHEAR = 3;\r\n        SkeletonBinary.SLOT_ATTACHMENT = 0;\r\n        SkeletonBinary.SLOT_COLOR = 1;\r\n        SkeletonBinary.SLOT_TWO_COLOR = 2;\r\n        SkeletonBinary.PATH_POSITION = 0;\r\n        SkeletonBinary.PATH_SPACING = 1;\r\n        SkeletonBinary.PATH_MIX = 2;\r\n        SkeletonBinary.CURVE_LINEAR = 0;\r\n        SkeletonBinary.CURVE_STEPPED = 1;\r\n        SkeletonBinary.CURVE_BEZIER = 2;\r\n        return SkeletonBinary;\r\n    }());\r\n    spine.SkeletonBinary = SkeletonBinary;\r\n    var BinaryInput = (function () {\r\n        function BinaryInput(data, strings, index, buffer) {\r\n            if (strings === void 0) { strings = new Array(); }\r\n            if (index === void 0) { index = 0; }\r\n            if (buffer === void 0) { buffer = new DataView(data.buffer); }\r\n            this.strings = strings;\r\n            this.index = index;\r\n            this.buffer = buffer;\r\n        }\r\n        BinaryInput.prototype.readByte = function () {\r\n            return this.buffer.getInt8(this.index++);\r\n        };\r\n        BinaryInput.prototype.readShort = function () {\r\n            var value = this.buffer.getInt16(this.index);\r\n            this.index += 2;\r\n            return value;\r\n        };\r\n        BinaryInput.prototype.readInt32 = function () {\r\n            var value = this.buffer.getInt32(this.index);\r\n            this.index += 4;\r\n            return value;\r\n        };\r\n        BinaryInput.prototype.readInt = function (optimizePositive) {\r\n            var b = this.readByte();\r\n            var result = b & 0x7F;\r\n            if ((b & 0x80) != 0) {\r\n                b = this.readByte();\r\n                result |= (b & 0x7F) << 7;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 14;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 21;\r\n                        if ((b & 0x80) != 0) {\r\n                            b = this.readByte();\r\n                            result |= (b & 0x7F) << 28;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n        };\r\n        BinaryInput.prototype.readStringRef = function () {\r\n            var index = this.readInt(true);\r\n            return index == 0 ? null : this.strings[index - 1];\r\n        };\r\n        BinaryInput.prototype.readString = function () {\r\n            var byteCount = this.readInt(true);\r\n            switch (byteCount) {\r\n                case 0:\r\n                    return null;\r\n                case 1:\r\n                    return \"\";\r\n            }\r\n            byteCount--;\r\n            var chars = \"\";\r\n            var charCount = 0;\r\n            for (var i = 0; i < byteCount;) {\r\n                var b = this.readByte();\r\n                switch (b >> 4) {\r\n                    case 12:\r\n                    case 13:\r\n                        chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                        i += 2;\r\n                        break;\r\n                    case 14:\r\n                        chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                        i += 3;\r\n                        break;\r\n                    default:\r\n                        chars += String.fromCharCode(b);\r\n                        i++;\r\n                }\r\n            }\r\n            return chars;\r\n        };\r\n        BinaryInput.prototype.readFloat = function () {\r\n            var value = this.buffer.getFloat32(this.index);\r\n            this.index += 4;\r\n            return value;\r\n        };\r\n        BinaryInput.prototype.readBoolean = function () {\r\n            return this.readByte() != 0;\r\n        };\r\n        return BinaryInput;\r\n    }());\r\n    var LinkedMesh = (function () {\r\n        function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n            this.mesh = mesh;\r\n            this.skin = skin;\r\n            this.slotIndex = slotIndex;\r\n            this.parent = parent;\r\n            this.inheritDeform = inheritDeform;\r\n        }\r\n        return LinkedMesh;\r\n    }());\r\n    var Vertices = (function () {\r\n        function Vertices(bones, vertices) {\r\n            if (bones === void 0) { bones = null; }\r\n            if (vertices === void 0) { vertices = null; }\r\n            this.bones = bones;\r\n            this.vertices = vertices;\r\n        }\r\n        return Vertices;\r\n    }());\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkeletonBounds = (function () {\r\n        function SkeletonBounds() {\r\n            this.minX = 0;\r\n            this.minY = 0;\r\n            this.maxX = 0;\r\n            this.maxY = 0;\r\n            this.boundingBoxes = new Array();\r\n            this.polygons = new Array();\r\n            this.polygonPool = new spine.Pool(function () {\r\n                return spine.Utils.newFloatArray(16);\r\n            });\r\n        }\r\n        SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            var boundingBoxes = this.boundingBoxes;\r\n            var polygons = this.polygons;\r\n            var polygonPool = this.polygonPool;\r\n            var slots = skeleton.slots;\r\n            var slotCount = slots.length;\r\n            boundingBoxes.length = 0;\r\n            polygonPool.freeAll(polygons);\r\n            polygons.length = 0;\r\n            for (var i = 0; i < slotCount; i++) {\r\n                var slot = slots[i];\r\n                if (!slot.bone.active)\r\n                    continue;\r\n                var attachment = slot.getAttachment();\r\n                if (attachment instanceof spine.BoundingBoxAttachment) {\r\n                    var boundingBox = attachment;\r\n                    boundingBoxes.push(boundingBox);\r\n                    var polygon = polygonPool.obtain();\r\n                    if (polygon.length != boundingBox.worldVerticesLength) {\r\n                        polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                    }\r\n                    polygons.push(polygon);\r\n                    boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n                }\r\n            }\r\n            if (updateAabb) {\r\n                this.aabbCompute();\r\n            }\r\n            else {\r\n                this.minX = Number.POSITIVE_INFINITY;\r\n                this.minY = Number.POSITIVE_INFINITY;\r\n                this.maxX = Number.NEGATIVE_INFINITY;\r\n                this.maxY = Number.NEGATIVE_INFINITY;\r\n            }\r\n        };\r\n        SkeletonBounds.prototype.aabbCompute = function () {\r\n            var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n            var polygons = this.polygons;\r\n            for (var i = 0, n = polygons.length; i < n; i++) {\r\n                var polygon = polygons[i];\r\n                var vertices = polygon;\r\n                for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                    var x = vertices[ii];\r\n                    var y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n            this.minX = minX;\r\n            this.minY = minY;\r\n            this.maxX = maxX;\r\n            this.maxY = maxY;\r\n        };\r\n        SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n            return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n        };\r\n        SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n            var minX = this.minX;\r\n            var minY = this.minY;\r\n            var maxX = this.maxX;\r\n            var maxY = this.maxY;\r\n            if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n                return false;\r\n            var m = (y2 - y1) / (x2 - x1);\r\n            var y = m * (minX - x1) + y1;\r\n            if (y > minY && y < maxY)\r\n                return true;\r\n            y = m * (maxX - x1) + y1;\r\n            if (y > minY && y < maxY)\r\n                return true;\r\n            var x = (minY - y1) / m + x1;\r\n            if (x > minX && x < maxX)\r\n                return true;\r\n            x = (maxY - y1) / m + x1;\r\n            if (x > minX && x < maxX)\r\n                return true;\r\n            return false;\r\n        };\r\n        SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n            return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n        };\r\n        SkeletonBounds.prototype.containsPoint = function (x, y) {\r\n            var polygons = this.polygons;\r\n            for (var i = 0, n = polygons.length; i < n; i++)\r\n                if (this.containsPointPolygon(polygons[i], x, y))\r\n                    return this.boundingBoxes[i];\r\n            return null;\r\n        };\r\n        SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n            var vertices = polygon;\r\n            var nn = polygon.length;\r\n            var prevIndex = nn - 2;\r\n            var inside = false;\r\n            for (var ii = 0; ii < nn; ii += 2) {\r\n                var vertexY = vertices[ii + 1];\r\n                var prevY = vertices[prevIndex + 1];\r\n                if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                    var vertexX = vertices[ii];\r\n                    if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n                        inside = !inside;\r\n                }\r\n                prevIndex = ii;\r\n            }\r\n            return inside;\r\n        };\r\n        SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n            var polygons = this.polygons;\r\n            for (var i = 0, n = polygons.length; i < n; i++)\r\n                if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n                    return this.boundingBoxes[i];\r\n            return null;\r\n        };\r\n        SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n            var vertices = polygon;\r\n            var nn = polygon.length;\r\n            var width12 = x1 - x2, height12 = y1 - y2;\r\n            var det1 = x1 * y2 - y1 * x2;\r\n            var x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n            for (var ii = 0; ii < nn; ii += 2) {\r\n                var x4 = vertices[ii], y4 = vertices[ii + 1];\r\n                var det2 = x3 * y4 - y3 * x4;\r\n                var width34 = x3 - x4, height34 = y3 - y4;\r\n                var det3 = width12 * height34 - height12 * width34;\r\n                var x = (det1 * width34 - width12 * det2) / det3;\r\n                if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                    var y = (det1 * height34 - height12 * det2) / det3;\r\n                    if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n                        return true;\r\n                }\r\n                x3 = x4;\r\n                y3 = y4;\r\n            }\r\n            return false;\r\n        };\r\n        SkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n            if (boundingBox == null)\r\n                throw new Error(\"boundingBox cannot be null.\");\r\n            var index = this.boundingBoxes.indexOf(boundingBox);\r\n            return index == -1 ? null : this.polygons[index];\r\n        };\r\n        SkeletonBounds.prototype.getWidth = function () {\r\n            return this.maxX - this.minX;\r\n        };\r\n        SkeletonBounds.prototype.getHeight = function () {\r\n            return this.maxY - this.minY;\r\n        };\r\n        return SkeletonBounds;\r\n    }());\r\n    spine.SkeletonBounds = SkeletonBounds;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkeletonClipping = (function () {\r\n        function SkeletonClipping() {\r\n            this.triangulator = new spine.Triangulator();\r\n            this.clippingPolygon = new Array();\r\n            this.clipOutput = new Array();\r\n            this.clippedVertices = new Array();\r\n            this.clippedTriangles = new Array();\r\n            this.scratch = new Array();\r\n        }\r\n        SkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n            if (this.clipAttachment != null)\r\n                return 0;\r\n            this.clipAttachment = clip;\r\n            var n = clip.worldVerticesLength;\r\n            var vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\r\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n            var clippingPolygon = this.clippingPolygon;\r\n            SkeletonClipping.makeClockwise(clippingPolygon);\r\n            var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n            for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\r\n                var polygon = clippingPolygons[i];\r\n                SkeletonClipping.makeClockwise(polygon);\r\n                polygon.push(polygon[0]);\r\n                polygon.push(polygon[1]);\r\n            }\r\n            return clippingPolygons.length;\r\n        };\r\n        SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n            if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n                this.clipEnd();\r\n        };\r\n        SkeletonClipping.prototype.clipEnd = function () {\r\n            if (this.clipAttachment == null)\r\n                return;\r\n            this.clipAttachment = null;\r\n            this.clippingPolygons = null;\r\n            this.clippedVertices.length = 0;\r\n            this.clippedTriangles.length = 0;\r\n            this.clippingPolygon.length = 0;\r\n        };\r\n        SkeletonClipping.prototype.isClipping = function () {\r\n            return this.clipAttachment != null;\r\n        };\r\n        SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n            var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n            var clippedTriangles = this.clippedTriangles;\r\n            var polygons = this.clippingPolygons;\r\n            var polygonsCount = this.clippingPolygons.length;\r\n            var vertexSize = twoColor ? 12 : 8;\r\n            var index = 0;\r\n            clippedVertices.length = 0;\r\n            clippedTriangles.length = 0;\r\n            outer: for (var i = 0; i < trianglesLength; i += 3) {\r\n                var vertexOffset = triangles[i] << 1;\r\n                var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n                var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n                vertexOffset = triangles[i + 1] << 1;\r\n                var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n                var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n                vertexOffset = triangles[i + 2] << 1;\r\n                var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n                var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n                for (var p = 0; p < polygonsCount; p++) {\r\n                    var s = clippedVertices.length;\r\n                    if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n                        var clipOutputLength = clipOutput.length;\r\n                        if (clipOutputLength == 0)\r\n                            continue;\r\n                        var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n                        var d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n                        var clipOutputCount = clipOutputLength >> 1;\r\n                        var clipOutputItems = this.clipOutput;\r\n                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n                        for (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n                            var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n                            clippedVerticesItems[s] = x;\r\n                            clippedVerticesItems[s + 1] = y;\r\n                            clippedVerticesItems[s + 2] = light.r;\r\n                            clippedVerticesItems[s + 3] = light.g;\r\n                            clippedVerticesItems[s + 4] = light.b;\r\n                            clippedVerticesItems[s + 5] = light.a;\r\n                            var c0 = x - x3, c1 = y - y3;\r\n                            var a = (d0 * c0 + d1 * c1) * d;\r\n                            var b = (d4 * c0 + d2 * c1) * d;\r\n                            var c = 1 - a - b;\r\n                            clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n                            clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n                            if (twoColor) {\r\n                                clippedVerticesItems[s + 8] = dark.r;\r\n                                clippedVerticesItems[s + 9] = dark.g;\r\n                                clippedVerticesItems[s + 10] = dark.b;\r\n                                clippedVerticesItems[s + 11] = dark.a;\r\n                            }\r\n                            s += vertexSize;\r\n                        }\r\n                        s = clippedTriangles.length;\r\n                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n                        clipOutputCount--;\r\n                        for (var ii = 1; ii < clipOutputCount; ii++) {\r\n                            clippedTrianglesItems[s] = index;\r\n                            clippedTrianglesItems[s + 1] = (index + ii);\r\n                            clippedTrianglesItems[s + 2] = (index + ii + 1);\r\n                            s += 3;\r\n                        }\r\n                        index += clipOutputCount + 1;\r\n                    }\r\n                    else {\r\n                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n                        clippedVerticesItems[s] = x1;\r\n                        clippedVerticesItems[s + 1] = y1;\r\n                        clippedVerticesItems[s + 2] = light.r;\r\n                        clippedVerticesItems[s + 3] = light.g;\r\n                        clippedVerticesItems[s + 4] = light.b;\r\n                        clippedVerticesItems[s + 5] = light.a;\r\n                        if (!twoColor) {\r\n                            clippedVerticesItems[s + 6] = u1;\r\n                            clippedVerticesItems[s + 7] = v1;\r\n                            clippedVerticesItems[s + 8] = x2;\r\n                            clippedVerticesItems[s + 9] = y2;\r\n                            clippedVerticesItems[s + 10] = light.r;\r\n                            clippedVerticesItems[s + 11] = light.g;\r\n                            clippedVerticesItems[s + 12] = light.b;\r\n                            clippedVerticesItems[s + 13] = light.a;\r\n                            clippedVerticesItems[s + 14] = u2;\r\n                            clippedVerticesItems[s + 15] = v2;\r\n                            clippedVerticesItems[s + 16] = x3;\r\n                            clippedVerticesItems[s + 17] = y3;\r\n                            clippedVerticesItems[s + 18] = light.r;\r\n                            clippedVerticesItems[s + 19] = light.g;\r\n                            clippedVerticesItems[s + 20] = light.b;\r\n                            clippedVerticesItems[s + 21] = light.a;\r\n                            clippedVerticesItems[s + 22] = u3;\r\n                            clippedVerticesItems[s + 23] = v3;\r\n                        }\r\n                        else {\r\n                            clippedVerticesItems[s + 6] = u1;\r\n                            clippedVerticesItems[s + 7] = v1;\r\n                            clippedVerticesItems[s + 8] = dark.r;\r\n                            clippedVerticesItems[s + 9] = dark.g;\r\n                            clippedVerticesItems[s + 10] = dark.b;\r\n                            clippedVerticesItems[s + 11] = dark.a;\r\n                            clippedVerticesItems[s + 12] = x2;\r\n                            clippedVerticesItems[s + 13] = y2;\r\n                            clippedVerticesItems[s + 14] = light.r;\r\n                            clippedVerticesItems[s + 15] = light.g;\r\n                            clippedVerticesItems[s + 16] = light.b;\r\n                            clippedVerticesItems[s + 17] = light.a;\r\n                            clippedVerticesItems[s + 18] = u2;\r\n                            clippedVerticesItems[s + 19] = v2;\r\n                            clippedVerticesItems[s + 20] = dark.r;\r\n                            clippedVerticesItems[s + 21] = dark.g;\r\n                            clippedVerticesItems[s + 22] = dark.b;\r\n                            clippedVerticesItems[s + 23] = dark.a;\r\n                            clippedVerticesItems[s + 24] = x3;\r\n                            clippedVerticesItems[s + 25] = y3;\r\n                            clippedVerticesItems[s + 26] = light.r;\r\n                            clippedVerticesItems[s + 27] = light.g;\r\n                            clippedVerticesItems[s + 28] = light.b;\r\n                            clippedVerticesItems[s + 29] = light.a;\r\n                            clippedVerticesItems[s + 30] = u3;\r\n                            clippedVerticesItems[s + 31] = v3;\r\n                            clippedVerticesItems[s + 32] = dark.r;\r\n                            clippedVerticesItems[s + 33] = dark.g;\r\n                            clippedVerticesItems[s + 34] = dark.b;\r\n                            clippedVerticesItems[s + 35] = dark.a;\r\n                        }\r\n                        s = clippedTriangles.length;\r\n                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\r\n                        clippedTrianglesItems[s] = index;\r\n                        clippedTrianglesItems[s + 1] = (index + 1);\r\n                        clippedTrianglesItems[s + 2] = (index + 2);\r\n                        index += 3;\r\n                        continue outer;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n            var originalOutput = output;\r\n            var clipped = false;\r\n            var input = null;\r\n            if (clippingArea.length % 4 >= 2) {\r\n                input = output;\r\n                output = this.scratch;\r\n            }\r\n            else\r\n                input = this.scratch;\r\n            input.length = 0;\r\n            input.push(x1);\r\n            input.push(y1);\r\n            input.push(x2);\r\n            input.push(y2);\r\n            input.push(x3);\r\n            input.push(y3);\r\n            input.push(x1);\r\n            input.push(y1);\r\n            output.length = 0;\r\n            var clippingVertices = clippingArea;\r\n            var clippingVerticesLast = clippingArea.length - 4;\r\n            for (var i = 0;; i += 2) {\r\n                var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n                var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n                var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n                var inputVertices = input;\r\n                var inputVerticesLength = input.length - 2, outputStart = output.length;\r\n                for (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n                    var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n                    var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n                    var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n                    if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n                        if (side2) {\r\n                            output.push(inputX2);\r\n                            output.push(inputY2);\r\n                            continue;\r\n                        }\r\n                        var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\r\n                        if (Math.abs(s) > 0.000001) {\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                        }\r\n                        else {\r\n                            output.push(edgeX);\r\n                            output.push(edgeY);\r\n                        }\r\n                    }\r\n                    else if (side2) {\r\n                        var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\r\n                        if (Math.abs(s) > 0.000001) {\r\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\r\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\r\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\r\n                        }\r\n                        else {\r\n                            output.push(edgeX);\r\n                            output.push(edgeY);\r\n                        }\r\n                        output.push(inputX2);\r\n                        output.push(inputY2);\r\n                    }\r\n                    clipped = true;\r\n                }\r\n                if (outputStart == output.length) {\r\n                    originalOutput.length = 0;\r\n                    return true;\r\n                }\r\n                output.push(output[0]);\r\n                output.push(output[1]);\r\n                if (i == clippingVerticesLast)\r\n                    break;\r\n                var temp = output;\r\n                output = input;\r\n                output.length = 0;\r\n                input = temp;\r\n            }\r\n            if (originalOutput != output) {\r\n                originalOutput.length = 0;\r\n                for (var i = 0, n = output.length - 2; i < n; i++)\r\n                    originalOutput[i] = output[i];\r\n            }\r\n            else\r\n                originalOutput.length = originalOutput.length - 2;\r\n            return clipped;\r\n        };\r\n        SkeletonClipping.makeClockwise = function (polygon) {\r\n            var vertices = polygon;\r\n            var verticeslength = polygon.length;\r\n            var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n            for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n                p1x = vertices[i];\r\n                p1y = vertices[i + 1];\r\n                p2x = vertices[i + 2];\r\n                p2y = vertices[i + 3];\r\n                area += p1x * p2y - p2x * p1y;\r\n            }\r\n            if (area < 0)\r\n                return;\r\n            for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n                var x = vertices[i], y = vertices[i + 1];\r\n                var other = lastX - i;\r\n                vertices[i] = vertices[other];\r\n                vertices[i + 1] = vertices[other + 1];\r\n                vertices[other] = x;\r\n                vertices[other + 1] = y;\r\n            }\r\n        };\r\n        return SkeletonClipping;\r\n    }());\r\n    spine.SkeletonClipping = SkeletonClipping;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkeletonData = (function () {\r\n        function SkeletonData() {\r\n            this.bones = new Array();\r\n            this.slots = new Array();\r\n            this.skins = new Array();\r\n            this.events = new Array();\r\n            this.animations = new Array();\r\n            this.ikConstraints = new Array();\r\n            this.transformConstraints = new Array();\r\n            this.pathConstraints = new Array();\r\n            this.fps = 0;\r\n        }\r\n        SkeletonData.prototype.findBone = function (boneName) {\r\n            if (boneName == null)\r\n                throw new Error(\"boneName cannot be null.\");\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                if (bone.name == boneName)\r\n                    return bone;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findBoneIndex = function (boneName) {\r\n            if (boneName == null)\r\n                throw new Error(\"boneName cannot be null.\");\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++)\r\n                if (bones[i].name == boneName)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        SkeletonData.prototype.findSlot = function (slotName) {\r\n            if (slotName == null)\r\n                throw new Error(\"slotName cannot be null.\");\r\n            var slots = this.slots;\r\n            for (var i = 0, n = slots.length; i < n; i++) {\r\n                var slot = slots[i];\r\n                if (slot.name == slotName)\r\n                    return slot;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findSlotIndex = function (slotName) {\r\n            if (slotName == null)\r\n                throw new Error(\"slotName cannot be null.\");\r\n            var slots = this.slots;\r\n            for (var i = 0, n = slots.length; i < n; i++)\r\n                if (slots[i].name == slotName)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        SkeletonData.prototype.findSkin = function (skinName) {\r\n            if (skinName == null)\r\n                throw new Error(\"skinName cannot be null.\");\r\n            var skins = this.skins;\r\n            for (var i = 0, n = skins.length; i < n; i++) {\r\n                var skin = skins[i];\r\n                if (skin.name == skinName)\r\n                    return skin;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findEvent = function (eventDataName) {\r\n            if (eventDataName == null)\r\n                throw new Error(\"eventDataName cannot be null.\");\r\n            var events = this.events;\r\n            for (var i = 0, n = events.length; i < n; i++) {\r\n                var event_5 = events[i];\r\n                if (event_5.name == eventDataName)\r\n                    return event_5;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findAnimation = function (animationName) {\r\n            if (animationName == null)\r\n                throw new Error(\"animationName cannot be null.\");\r\n            var animations = this.animations;\r\n            for (var i = 0, n = animations.length; i < n; i++) {\r\n                var animation = animations[i];\r\n                if (animation.name == animationName)\r\n                    return animation;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var ikConstraints = this.ikConstraints;\r\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n                var constraint = ikConstraints[i];\r\n                if (constraint.name == constraintName)\r\n                    return constraint;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var transformConstraints = this.transformConstraints;\r\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n                var constraint = transformConstraints[i];\r\n                if (constraint.name == constraintName)\r\n                    return constraint;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n            if (constraintName == null)\r\n                throw new Error(\"constraintName cannot be null.\");\r\n            var pathConstraints = this.pathConstraints;\r\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n                var constraint = pathConstraints[i];\r\n                if (constraint.name == constraintName)\r\n                    return constraint;\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n            if (pathConstraintName == null)\r\n                throw new Error(\"pathConstraintName cannot be null.\");\r\n            var pathConstraints = this.pathConstraints;\r\n            for (var i = 0, n = pathConstraints.length; i < n; i++)\r\n                if (pathConstraints[i].name == pathConstraintName)\r\n                    return i;\r\n            return -1;\r\n        };\r\n        return SkeletonData;\r\n    }());\r\n    spine.SkeletonData = SkeletonData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkeletonJson = (function () {\r\n        function SkeletonJson(attachmentLoader) {\r\n            this.scale = 1;\r\n            this.linkedMeshes = new Array();\r\n            this.attachmentLoader = attachmentLoader;\r\n        }\r\n        SkeletonJson.prototype.readSkeletonData = function (json) {\r\n            var scale = this.scale;\r\n            var skeletonData = new spine.SkeletonData();\r\n            var root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n            var skeletonMap = root.skeleton;\r\n            if (skeletonMap != null) {\r\n                skeletonData.hash = skeletonMap.hash;\r\n                skeletonData.version = skeletonMap.spine;\r\n                skeletonData.x = skeletonMap.x;\r\n                skeletonData.y = skeletonMap.y;\r\n                skeletonData.width = skeletonMap.width;\r\n                skeletonData.height = skeletonMap.height;\r\n                skeletonData.fps = skeletonMap.fps;\r\n                skeletonData.imagesPath = skeletonMap.images;\r\n            }\r\n            if (root.bones) {\r\n                for (var i = 0; i < root.bones.length; i++) {\r\n                    var boneMap = root.bones[i];\r\n                    var parent_5 = null;\r\n                    var parentName = this.getValue(boneMap, \"parent\", null);\r\n                    if (parentName != null) {\r\n                        parent_5 = skeletonData.findBone(parentName);\r\n                        if (parent_5 == null)\r\n                            throw new Error(\"Parent bone not found: \" + parentName);\r\n                    }\r\n                    var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_5);\r\n                    data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                    data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                    data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                    data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                    data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                    data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                    data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                    data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n                    data.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n                    skeletonData.bones.push(data);\r\n                }\r\n            }\r\n            if (root.slots) {\r\n                for (var i = 0; i < root.slots.length; i++) {\r\n                    var slotMap = root.slots[i];\r\n                    var slotName = slotMap.name;\r\n                    var boneName = slotMap.bone;\r\n                    var boneData = skeletonData.findBone(boneName);\r\n                    if (boneData == null)\r\n                        throw new Error(\"Slot bone not found: \" + boneName);\r\n                    var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\r\n                    var color = this.getValue(slotMap, \"color\", null);\r\n                    if (color != null)\r\n                        data.color.setFromString(color);\r\n                    var dark = this.getValue(slotMap, \"dark\", null);\r\n                    if (dark != null) {\r\n                        data.darkColor = new spine.Color(1, 1, 1, 1);\r\n                        data.darkColor.setFromString(dark);\r\n                    }\r\n                    data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                    data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                    skeletonData.slots.push(data);\r\n                }\r\n            }\r\n            if (root.ik) {\r\n                for (var i = 0; i < root.ik.length; i++) {\r\n                    var constraintMap = root.ik[i];\r\n                    var data = new spine.IkConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                        var boneName = constraintMap.bones[j];\r\n                        var bone = skeletonData.findBone(boneName);\r\n                        if (bone == null)\r\n                            throw new Error(\"IK bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n                    var targetName = constraintMap.target;\r\n                    data.target = skeletonData.findBone(targetName);\r\n                    if (data.target == null)\r\n                        throw new Error(\"IK target bone not found: \" + targetName);\r\n                    data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n                    data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n                    data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                    data.compress = this.getValue(constraintMap, \"compress\", false);\r\n                    data.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n                    data.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n                    skeletonData.ikConstraints.push(data);\r\n                }\r\n            }\r\n            if (root.transform) {\r\n                for (var i = 0; i < root.transform.length; i++) {\r\n                    var constraintMap = root.transform[i];\r\n                    var data = new spine.TransformConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                        var boneName = constraintMap.bones[j];\r\n                        var bone = skeletonData.findBone(boneName);\r\n                        if (bone == null)\r\n                            throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n                    var targetName = constraintMap.target;\r\n                    data.target = skeletonData.findBone(targetName);\r\n                    if (data.target == null)\r\n                        throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n                    data.local = this.getValue(constraintMap, \"local\", false);\r\n                    data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                    data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                    data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                    data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                    data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                    data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                    data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                    data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n                    skeletonData.transformConstraints.push(data);\r\n                }\r\n            }\r\n            if (root.path) {\r\n                for (var i = 0; i < root.path.length; i++) {\r\n                    var constraintMap = root.path[i];\r\n                    var data = new spine.PathConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\r\n                        var boneName = constraintMap.bones[j];\r\n                        var bone = skeletonData.findBone(boneName);\r\n                        if (bone == null)\r\n                            throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n                    var targetName = constraintMap.target;\r\n                    data.target = skeletonData.findSlot(targetName);\r\n                    if (data.target == null)\r\n                        throw new Error(\"Path target slot not found: \" + targetName);\r\n                    data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                    data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                    data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                    data.position = this.getValue(constraintMap, \"position\", 0);\r\n                    if (data.positionMode == spine.PositionMode.Fixed)\r\n                        data.position *= scale;\r\n                    data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                    if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n                        data.spacing *= scale;\r\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                    skeletonData.pathConstraints.push(data);\r\n                }\r\n            }\r\n            if (root.skins) {\r\n                for (var i = 0; i < root.skins.length; i++) {\r\n                    var skinMap = root.skins[i];\r\n                    var skin = new spine.Skin(skinMap.name);\r\n                    if (skinMap.bones) {\r\n                        for (var ii = 0; ii < skinMap.bones.length; ii++) {\r\n                            var bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                            if (bone == null)\r\n                                throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                            skin.bones.push(bone);\r\n                        }\r\n                    }\r\n                    if (skinMap.ik) {\r\n                        for (var ii = 0; ii < skinMap.ik.length; ii++) {\r\n                            var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                            if (constraint == null)\r\n                                throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n                    if (skinMap.transform) {\r\n                        for (var ii = 0; ii < skinMap.transform.length; ii++) {\r\n                            var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                            if (constraint == null)\r\n                                throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n                    if (skinMap.path) {\r\n                        for (var ii = 0; ii < skinMap.path.length; ii++) {\r\n                            var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                            if (constraint == null)\r\n                                throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n                    for (var slotName in skinMap.attachments) {\r\n                        var slot = skeletonData.findSlot(slotName);\r\n                        if (slot == null)\r\n                            throw new Error(\"Slot not found: \" + slotName);\r\n                        var slotMap = skinMap.attachments[slotName];\r\n                        for (var entryName in slotMap) {\r\n                            var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                            if (attachment != null)\r\n                                skin.setAttachment(slot.index, entryName, attachment);\r\n                        }\r\n                    }\r\n                    skeletonData.skins.push(skin);\r\n                    if (skin.name == \"default\")\r\n                        skeletonData.defaultSkin = skin;\r\n                }\r\n            }\r\n            for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n                var linkedMesh = this.linkedMeshes[i];\r\n                var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                if (skin == null)\r\n                    throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                if (parent_6 == null)\r\n                    throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;\r\n                linkedMesh.mesh.setParentMesh(parent_6);\r\n                linkedMesh.mesh.updateUVs();\r\n            }\r\n            this.linkedMeshes.length = 0;\r\n            if (root.events) {\r\n                for (var eventName in root.events) {\r\n                    var eventMap = root.events[eventName];\r\n                    var data = new spine.EventData(eventName);\r\n                    data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                    data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                    data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                    data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                    if (data.audioPath != null) {\r\n                        data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                        data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                    }\r\n                    skeletonData.events.push(data);\r\n                }\r\n            }\r\n            if (root.animations) {\r\n                for (var animationName in root.animations) {\r\n                    var animationMap = root.animations[animationName];\r\n                    this.readAnimation(animationMap, animationName, skeletonData);\r\n                }\r\n            }\r\n            return skeletonData;\r\n        };\r\n        SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n            var scale = this.scale;\r\n            name = this.getValue(map, \"name\", name);\r\n            var type = this.getValue(map, \"type\", \"region\");\r\n            switch (type) {\r\n                case \"region\": {\r\n                    var path = this.getValue(map, \"path\", name);\r\n                    var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                    if (region == null)\r\n                        return null;\r\n                    region.path = path;\r\n                    region.x = this.getValue(map, \"x\", 0) * scale;\r\n                    region.y = this.getValue(map, \"y\", 0) * scale;\r\n                    region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                    region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                    region.rotation = this.getValue(map, \"rotation\", 0);\r\n                    region.width = map.width * scale;\r\n                    region.height = map.height * scale;\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        region.color.setFromString(color);\r\n                    region.updateOffset();\r\n                    return region;\r\n                }\r\n                case \"boundingbox\": {\r\n                    var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                    if (box == null)\r\n                        return null;\r\n                    this.readVertices(map, box, map.vertexCount << 1);\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        box.color.setFromString(color);\r\n                    return box;\r\n                }\r\n                case \"mesh\":\r\n                case \"linkedmesh\": {\r\n                    var path = this.getValue(map, \"path\", name);\r\n                    var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                    if (mesh == null)\r\n                        return null;\r\n                    mesh.path = path;\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        mesh.color.setFromString(color);\r\n                    mesh.width = this.getValue(map, \"width\", 0) * scale;\r\n                    mesh.height = this.getValue(map, \"height\", 0) * scale;\r\n                    var parent_7 = this.getValue(map, \"parent\", null);\r\n                    if (parent_7 != null) {\r\n                        this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_7, this.getValue(map, \"deform\", true)));\r\n                        return mesh;\r\n                    }\r\n                    var uvs = map.uvs;\r\n                    this.readVertices(map, mesh, uvs.length);\r\n                    mesh.triangles = map.triangles;\r\n                    mesh.regionUVs = uvs;\r\n                    mesh.updateUVs();\r\n                    mesh.edges = this.getValue(map, \"edges\", null);\r\n                    mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                    return mesh;\r\n                }\r\n                case \"path\": {\r\n                    var path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                    if (path == null)\r\n                        return null;\r\n                    path.closed = this.getValue(map, \"closed\", false);\r\n                    path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n                    var vertexCount = map.vertexCount;\r\n                    this.readVertices(map, path, vertexCount << 1);\r\n                    var lengths = spine.Utils.newArray(vertexCount / 3, 0);\r\n                    for (var i = 0; i < map.lengths.length; i++)\r\n                        lengths[i] = map.lengths[i] * scale;\r\n                    path.lengths = lengths;\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        path.color.setFromString(color);\r\n                    return path;\r\n                }\r\n                case \"point\": {\r\n                    var point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                    if (point == null)\r\n                        return null;\r\n                    point.x = this.getValue(map, \"x\", 0) * scale;\r\n                    point.y = this.getValue(map, \"y\", 0) * scale;\r\n                    point.rotation = this.getValue(map, \"rotation\", 0);\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        point.color.setFromString(color);\r\n                    return point;\r\n                }\r\n                case \"clipping\": {\r\n                    var clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                    if (clip == null)\r\n                        return null;\r\n                    var end = this.getValue(map, \"end\", null);\r\n                    if (end != null) {\r\n                        var slot = skeletonData.findSlot(end);\r\n                        if (slot == null)\r\n                            throw new Error(\"Clipping end slot not found: \" + end);\r\n                        clip.endSlot = slot;\r\n                    }\r\n                    var vertexCount = map.vertexCount;\r\n                    this.readVertices(map, clip, vertexCount << 1);\r\n                    var color = this.getValue(map, \"color\", null);\r\n                    if (color != null)\r\n                        clip.color.setFromString(color);\r\n                    return clip;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n            var scale = this.scale;\r\n            attachment.worldVerticesLength = verticesLength;\r\n            var vertices = map.vertices;\r\n            if (verticesLength == vertices.length) {\r\n                var scaledVertices = spine.Utils.toFloatArray(vertices);\r\n                if (scale != 1) {\r\n                    for (var i = 0, n = vertices.length; i < n; i++)\r\n                        scaledVertices[i] *= scale;\r\n                }\r\n                attachment.vertices = scaledVertices;\r\n                return;\r\n            }\r\n            var weights = new Array();\r\n            var bones = new Array();\r\n            for (var i = 0, n = vertices.length; i < n;) {\r\n                var boneCount = vertices[i++];\r\n                bones.push(boneCount);\r\n                for (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n                    bones.push(vertices[i]);\r\n                    weights.push(vertices[i + 1] * scale);\r\n                    weights.push(vertices[i + 2] * scale);\r\n                    weights.push(vertices[i + 3]);\r\n                }\r\n            }\r\n            attachment.bones = bones;\r\n            attachment.vertices = spine.Utils.toFloatArray(weights);\r\n        };\r\n        SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n            var scale = this.scale;\r\n            var timelines = new Array();\r\n            var duration = 0;\r\n            if (map.slots) {\r\n                for (var slotName in map.slots) {\r\n                    var slotMap = map.slots[slotName];\r\n                    var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1)\r\n                        throw new Error(\"Slot not found: \" + slotName);\r\n                    for (var timelineName in slotMap) {\r\n                        var timelineMap = slotMap[timelineName];\r\n                        if (timelineName == \"attachment\") {\r\n                            var timeline = new spine.AttachmentTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                        }\r\n                        else if (timelineName == \"color\") {\r\n                            var timeline = new spine.ColorTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                var color = new spine.Color();\r\n                                color.setFromString(valueMap.color);\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\r\n                        }\r\n                        else if (timelineName == \"twoColor\") {\r\n                            var timeline = new spine.TwoColorTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                var light = new spine.Color();\r\n                                var dark = new spine.Color();\r\n                                light.setFromString(valueMap.light);\r\n                                dark.setFromString(valueMap.dark);\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\r\n                        }\r\n                        else\r\n                            throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                    }\r\n                }\r\n            }\r\n            if (map.bones) {\r\n                for (var boneName in map.bones) {\r\n                    var boneMap = map.bones[boneName];\r\n                    var boneIndex = skeletonData.findBoneIndex(boneName);\r\n                    if (boneIndex == -1)\r\n                        throw new Error(\"Bone not found: \" + boneName);\r\n                    for (var timelineName in boneMap) {\r\n                        var timelineMap = boneMap[timelineName];\r\n                        if (timelineName === \"rotate\") {\r\n                            var timeline = new spine.RotateTimeline(timelineMap.length);\r\n                            timeline.boneIndex = boneIndex;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\r\n                        }\r\n                        else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                            var timeline = null;\r\n                            var timelineScale = 1, defaultValue = 0;\r\n                            if (timelineName === \"scale\") {\r\n                                timeline = new spine.ScaleTimeline(timelineMap.length);\r\n                                defaultValue = 1;\r\n                            }\r\n                            else if (timelineName === \"shear\")\r\n                                timeline = new spine.ShearTimeline(timelineMap.length);\r\n                            else {\r\n                                timeline = new spine.TranslateTimeline(timelineMap.length);\r\n                                timelineScale = scale;\r\n                            }\r\n                            timeline.boneIndex = boneIndex;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                var x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\r\n                        }\r\n                        else\r\n                            throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                    }\r\n                }\r\n            }\r\n            if (map.ik) {\r\n                for (var constraintName in map.ik) {\r\n                    var constraintMap = map.ik[constraintName];\r\n                    var constraint = skeletonData.findIkConstraint(constraintName);\r\n                    var timeline = new spine.IkConstraintTimeline(constraintMap.length);\r\n                    timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                    var frameIndex = 0;\r\n                    for (var i = 0; i < constraintMap.length; i++) {\r\n                        var valueMap = constraintMap[i];\r\n                        timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale, this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                        this.readCurve(valueMap, timeline, frameIndex);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\r\n                }\r\n            }\r\n            if (map.transform) {\r\n                for (var constraintName in map.transform) {\r\n                    var constraintMap = map.transform[constraintName];\r\n                    var constraint = skeletonData.findTransformConstraint(constraintName);\r\n                    var timeline = new spine.TransformConstraintTimeline(constraintMap.length);\r\n                    timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                    var frameIndex = 0;\r\n                    for (var i = 0; i < constraintMap.length; i++) {\r\n                        var valueMap = constraintMap[i];\r\n                        timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                        this.readCurve(valueMap, timeline, frameIndex);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\r\n                }\r\n            }\r\n            if (map.path) {\r\n                for (var constraintName in map.path) {\r\n                    var constraintMap = map.path[constraintName];\r\n                    var index = skeletonData.findPathConstraintIndex(constraintName);\r\n                    if (index == -1)\r\n                        throw new Error(\"Path constraint not found: \" + constraintName);\r\n                    var data = skeletonData.pathConstraints[index];\r\n                    for (var timelineName in constraintMap) {\r\n                        var timelineMap = constraintMap[timelineName];\r\n                        if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                            var timeline = null;\r\n                            var timelineScale = 1;\r\n                            if (timelineName === \"spacing\") {\r\n                                timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\r\n                                if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n                                    timelineScale = scale;\r\n                            }\r\n                            else {\r\n                                timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\r\n                                if (data.positionMode == spine.PositionMode.Fixed)\r\n                                    timelineScale = scale;\r\n                            }\r\n                            timeline.pathConstraintIndex = index;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\r\n                        }\r\n                        else if (timelineName === \"mix\") {\r\n                            var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\r\n                            timeline.pathConstraintIndex = index;\r\n                            var frameIndex = 0;\r\n                            for (var i = 0; i < timelineMap.length; i++) {\r\n                                var valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (map.deform) {\r\n                for (var deformName in map.deform) {\r\n                    var deformMap = map.deform[deformName];\r\n                    var skin = skeletonData.findSkin(deformName);\r\n                    if (skin == null)\r\n                        throw new Error(\"Skin not found: \" + deformName);\r\n                    for (var slotName in deformMap) {\r\n                        var slotMap = deformMap[slotName];\r\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                        if (slotIndex == -1)\r\n                            throw new Error(\"Slot not found: \" + slotMap.name);\r\n                        for (var timelineName in slotMap) {\r\n                            var timelineMap = slotMap[timelineName];\r\n                            var attachment = skin.getAttachment(slotIndex, timelineName);\r\n                            if (attachment == null)\r\n                                throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                            var weighted = attachment.bones != null;\r\n                            var vertices = attachment.vertices;\r\n                            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n                            var timeline = new spine.DeformTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n                            timeline.attachment = attachment;\r\n                            var frameIndex = 0;\r\n                            for (var j = 0; j < timelineMap.length; j++) {\r\n                                var valueMap = timelineMap[j];\r\n                                var deform = void 0;\r\n                                var verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n                                if (verticesValue == null)\r\n                                    deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = spine.Utils.newFloatArray(deformLength);\r\n                                    var start = this.getValue(valueMap, \"offset\", 0);\r\n                                    spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                    if (scale != 1) {\r\n                                        for (var i = start, n = i + verticesValue.length; i < n; i++)\r\n                                            deform[i] *= scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (var i = 0; i < deformLength; i++)\r\n                                            deform[i] += vertices[i];\r\n                                    }\r\n                                }\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            var drawOrderNode = map.drawOrder;\r\n            if (drawOrderNode == null)\r\n                drawOrderNode = map.draworder;\r\n            if (drawOrderNode != null) {\r\n                var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\r\n                var slotCount = skeletonData.slots.length;\r\n                var frameIndex = 0;\r\n                for (var j = 0; j < drawOrderNode.length; j++) {\r\n                    var drawOrderMap = drawOrderNode[j];\r\n                    var drawOrder = null;\r\n                    var offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                    if (offsets != null) {\r\n                        drawOrder = spine.Utils.newArray(slotCount, -1);\r\n                        var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\r\n                        var originalIndex = 0, unchangedIndex = 0;\r\n                        for (var i = 0; i < offsets.length; i++) {\r\n                            var offsetMap = offsets[i];\r\n                            var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                            if (slotIndex == -1)\r\n                                throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                            while (originalIndex != slotIndex)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                        }\r\n                        while (originalIndex < slotCount)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        for (var i = slotCount - 1; i >= 0; i--)\r\n                            if (drawOrder[i] == -1)\r\n                                drawOrder[i] = unchanged[--unchangedIndex];\r\n                    }\r\n                    timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n            }\r\n            if (map.events) {\r\n                var timeline = new spine.EventTimeline(map.events.length);\r\n                var frameIndex = 0;\r\n                for (var i = 0; i < map.events.length; i++) {\r\n                    var eventMap = map.events[i];\r\n                    var eventData = skeletonData.findEvent(eventMap.name);\r\n                    if (eventData == null)\r\n                        throw new Error(\"Event not found: \" + eventMap.name);\r\n                    var event_6 = new spine.Event(spine.Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n                    event_6.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                    event_6.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                    event_6.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                    if (event_6.data.audioPath != null) {\r\n                        event_6.volume = this.getValue(eventMap, \"volume\", 1);\r\n                        event_6.balance = this.getValue(eventMap, \"balance\", 0);\r\n                    }\r\n                    timeline.setFrame(frameIndex++, event_6);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n            }\r\n            if (isNaN(duration)) {\r\n                throw new Error(\"Error while parsing animation, duration is NaN\");\r\n            }\r\n            skeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n        };\r\n        SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n            if (!map.curve)\r\n                return;\r\n            if (map.curve == \"stepped\")\r\n                timeline.setStepped(frameIndex);\r\n            else {\r\n                var curve = map.curve;\r\n                timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n            }\r\n        };\r\n        SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n            return map[prop] !== undefined ? map[prop] : defaultValue;\r\n        };\r\n        SkeletonJson.blendModeFromString = function (str) {\r\n            str = str.toLowerCase();\r\n            if (str == \"normal\")\r\n                return spine.BlendMode.Normal;\r\n            if (str == \"additive\")\r\n                return spine.BlendMode.Additive;\r\n            if (str == \"multiply\")\r\n                return spine.BlendMode.Multiply;\r\n            if (str == \"screen\")\r\n                return spine.BlendMode.Screen;\r\n            throw new Error(\"Unknown blend mode: \" + str);\r\n        };\r\n        SkeletonJson.positionModeFromString = function (str) {\r\n            str = str.toLowerCase();\r\n            if (str == \"fixed\")\r\n                return spine.PositionMode.Fixed;\r\n            if (str == \"percent\")\r\n                return spine.PositionMode.Percent;\r\n            throw new Error(\"Unknown position mode: \" + str);\r\n        };\r\n        SkeletonJson.spacingModeFromString = function (str) {\r\n            str = str.toLowerCase();\r\n            if (str == \"length\")\r\n                return spine.SpacingMode.Length;\r\n            if (str == \"fixed\")\r\n                return spine.SpacingMode.Fixed;\r\n            if (str == \"percent\")\r\n                return spine.SpacingMode.Percent;\r\n            throw new Error(\"Unknown position mode: \" + str);\r\n        };\r\n        SkeletonJson.rotateModeFromString = function (str) {\r\n            str = str.toLowerCase();\r\n            if (str == \"tangent\")\r\n                return spine.RotateMode.Tangent;\r\n            if (str == \"chain\")\r\n                return spine.RotateMode.Chain;\r\n            if (str == \"chainscale\")\r\n                return spine.RotateMode.ChainScale;\r\n            throw new Error(\"Unknown rotate mode: \" + str);\r\n        };\r\n        SkeletonJson.transformModeFromString = function (str) {\r\n            str = str.toLowerCase();\r\n            if (str == \"normal\")\r\n                return spine.TransformMode.Normal;\r\n            if (str == \"onlytranslation\")\r\n                return spine.TransformMode.OnlyTranslation;\r\n            if (str == \"norotationorreflection\")\r\n                return spine.TransformMode.NoRotationOrReflection;\r\n            if (str == \"noscale\")\r\n                return spine.TransformMode.NoScale;\r\n            if (str == \"noscaleorreflection\")\r\n                return spine.TransformMode.NoScaleOrReflection;\r\n            throw new Error(\"Unknown transform mode: \" + str);\r\n        };\r\n        return SkeletonJson;\r\n    }());\r\n    spine.SkeletonJson = SkeletonJson;\r\n    var LinkedMesh = (function () {\r\n        function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {\r\n            this.mesh = mesh;\r\n            this.skin = skin;\r\n            this.slotIndex = slotIndex;\r\n            this.parent = parent;\r\n            this.inheritDeform = inheritDeform;\r\n        }\r\n        return LinkedMesh;\r\n    }());\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SkinEntry = (function () {\r\n        function SkinEntry(slotIndex, name, attachment) {\r\n            this.slotIndex = slotIndex;\r\n            this.name = name;\r\n            this.attachment = attachment;\r\n        }\r\n        return SkinEntry;\r\n    }());\r\n    spine.SkinEntry = SkinEntry;\r\n    var Skin = (function () {\r\n        function Skin(name) {\r\n            this.attachments = new Array();\r\n            this.bones = Array();\r\n            this.constraints = new Array();\r\n            if (name == null)\r\n                throw new Error(\"name cannot be null.\");\r\n            this.name = name;\r\n        }\r\n        Skin.prototype.setAttachment = function (slotIndex, name, attachment) {\r\n            if (attachment == null)\r\n                throw new Error(\"attachment cannot be null.\");\r\n            var attachments = this.attachments;\r\n            if (slotIndex >= attachments.length)\r\n                attachments.length = slotIndex + 1;\r\n            if (!attachments[slotIndex])\r\n                attachments[slotIndex] = {};\r\n            attachments[slotIndex][name] = attachment;\r\n        };\r\n        Skin.prototype.addSkin = function (skin) {\r\n            for (var i = 0; i < skin.bones.length; i++) {\r\n                var bone = skin.bones[i];\r\n                var contained = false;\r\n                for (var j = 0; j < this.bones.length; j++) {\r\n                    if (this.bones[j] == bone) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained)\r\n                    this.bones.push(bone);\r\n            }\r\n            for (var i = 0; i < skin.constraints.length; i++) {\r\n                var constraint = skin.constraints[i];\r\n                var contained = false;\r\n                for (var j = 0; j < this.constraints.length; j++) {\r\n                    if (this.constraints[j] == constraint) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained)\r\n                    this.constraints.push(constraint);\r\n            }\r\n            var attachments = skin.getAttachments();\r\n            for (var i = 0; i < attachments.length; i++) {\r\n                var attachment = attachments[i];\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        };\r\n        Skin.prototype.copySkin = function (skin) {\r\n            for (var i = 0; i < skin.bones.length; i++) {\r\n                var bone = skin.bones[i];\r\n                var contained = false;\r\n                for (var j = 0; j < this.bones.length; j++) {\r\n                    if (this.bones[j] == bone) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained)\r\n                    this.bones.push(bone);\r\n            }\r\n            for (var i = 0; i < skin.constraints.length; i++) {\r\n                var constraint = skin.constraints[i];\r\n                var contained = false;\r\n                for (var j = 0; j < this.constraints.length; j++) {\r\n                    if (this.constraints[j] == constraint) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained)\r\n                    this.constraints.push(constraint);\r\n            }\r\n            var attachments = skin.getAttachments();\r\n            for (var i = 0; i < attachments.length; i++) {\r\n                var attachment = attachments[i];\r\n                if (attachment.attachment == null)\r\n                    continue;\r\n                if (attachment.attachment instanceof spine.MeshAttachment) {\r\n                    attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                }\r\n                else {\r\n                    attachment.attachment = attachment.attachment.copy();\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                }\r\n            }\r\n        };\r\n        Skin.prototype.getAttachment = function (slotIndex, name) {\r\n            var dictionary = this.attachments[slotIndex];\r\n            return dictionary ? dictionary[name] : null;\r\n        };\r\n        Skin.prototype.removeAttachment = function (slotIndex, name) {\r\n            var dictionary = this.attachments[slotIndex];\r\n            if (dictionary)\r\n                dictionary[name] = null;\r\n        };\r\n        Skin.prototype.getAttachments = function () {\r\n            var entries = new Array();\r\n            for (var i = 0; i < this.attachments.length; i++) {\r\n                var slotAttachments = this.attachments[i];\r\n                if (slotAttachments) {\r\n                    for (var name_4 in slotAttachments) {\r\n                        var attachment = slotAttachments[name_4];\r\n                        if (attachment)\r\n                            entries.push(new SkinEntry(i, name_4, attachment));\r\n                    }\r\n                }\r\n            }\r\n            return entries;\r\n        };\r\n        Skin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {\r\n            var slotAttachments = this.attachments[slotIndex];\r\n            if (slotAttachments) {\r\n                for (var name_5 in slotAttachments) {\r\n                    var attachment = slotAttachments[name_5];\r\n                    if (attachment)\r\n                        attachments.push(new SkinEntry(slotIndex, name_5, attachment));\r\n                }\r\n            }\r\n        };\r\n        Skin.prototype.clear = function () {\r\n            this.attachments.length = 0;\r\n            this.bones.length = 0;\r\n            this.constraints.length = 0;\r\n        };\r\n        Skin.prototype.attachAll = function (skeleton, oldSkin) {\r\n            var slotIndex = 0;\r\n            for (var i = 0; i < skeleton.slots.length; i++) {\r\n                var slot = skeleton.slots[i];\r\n                var slotAttachment = slot.getAttachment();\r\n                if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                    var dictionary = oldSkin.attachments[slotIndex];\r\n                    for (var key in dictionary) {\r\n                        var skinAttachment = dictionary[key];\r\n                        if (slotAttachment == skinAttachment) {\r\n                            var attachment = this.getAttachment(slotIndex, key);\r\n                            if (attachment != null)\r\n                                slot.setAttachment(attachment);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                slotIndex++;\r\n            }\r\n        };\r\n        return Skin;\r\n    }());\r\n    spine.Skin = Skin;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Slot = (function () {\r\n        function Slot(data, bone) {\r\n            this.deform = new Array();\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            if (bone == null)\r\n                throw new Error(\"bone cannot be null.\");\r\n            this.data = data;\r\n            this.bone = bone;\r\n            this.color = new spine.Color();\r\n            this.darkColor = data.darkColor == null ? null : new spine.Color();\r\n            this.setToSetupPose();\r\n        }\r\n        Slot.prototype.getSkeleton = function () {\r\n            return this.bone.skeleton;\r\n        };\r\n        Slot.prototype.getAttachment = function () {\r\n            return this.attachment;\r\n        };\r\n        Slot.prototype.setAttachment = function (attachment) {\r\n            if (this.attachment == attachment)\r\n                return;\r\n            this.attachment = attachment;\r\n            this.attachmentTime = this.bone.skeleton.time;\r\n            this.deform.length = 0;\r\n        };\r\n        Slot.prototype.setAttachmentTime = function (time) {\r\n            this.attachmentTime = this.bone.skeleton.time - time;\r\n        };\r\n        Slot.prototype.getAttachmentTime = function () {\r\n            return this.bone.skeleton.time - this.attachmentTime;\r\n        };\r\n        Slot.prototype.setToSetupPose = function () {\r\n            this.color.setFromColor(this.data.color);\r\n            if (this.darkColor != null)\r\n                this.darkColor.setFromColor(this.data.darkColor);\r\n            if (this.data.attachmentName == null)\r\n                this.attachment = null;\r\n            else {\r\n                this.attachment = null;\r\n                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n            }\r\n        };\r\n        return Slot;\r\n    }());\r\n    spine.Slot = Slot;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SlotData = (function () {\r\n        function SlotData(index, name, boneData) {\r\n            this.color = new spine.Color(1, 1, 1, 1);\r\n            if (index < 0)\r\n                throw new Error(\"index must be >= 0.\");\r\n            if (name == null)\r\n                throw new Error(\"name cannot be null.\");\r\n            if (boneData == null)\r\n                throw new Error(\"boneData cannot be null.\");\r\n            this.index = index;\r\n            this.name = name;\r\n            this.boneData = boneData;\r\n        }\r\n        return SlotData;\r\n    }());\r\n    spine.SlotData = SlotData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Texture = (function () {\r\n        function Texture(image) {\r\n            this._image = image;\r\n        }\r\n        Texture.prototype.getImage = function () {\r\n            return this._image;\r\n        };\r\n        Texture.filterFromString = function (text) {\r\n            switch (text.toLowerCase()) {\r\n                case \"nearest\": return TextureFilter.Nearest;\r\n                case \"linear\": return TextureFilter.Linear;\r\n                case \"mipmap\": return TextureFilter.MipMap;\r\n                case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n                case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n                case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n                case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n                default: throw new Error(\"Unknown texture filter \" + text);\r\n            }\r\n        };\r\n        Texture.wrapFromString = function (text) {\r\n            switch (text.toLowerCase()) {\r\n                case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n                case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n                case \"repeat\": return TextureWrap.Repeat;\r\n                default: throw new Error(\"Unknown texture wrap \" + text);\r\n            }\r\n        };\r\n        return Texture;\r\n    }());\r\n    spine.Texture = Texture;\r\n    var TextureFilter;\r\n    (function (TextureFilter) {\r\n        TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n        TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n        TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n        TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n        TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n        TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n        TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n    })(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\r\n    var TextureWrap;\r\n    (function (TextureWrap) {\r\n        TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n        TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n        TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n    })(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\r\n    var TextureRegion = (function () {\r\n        function TextureRegion() {\r\n            this.u = 0;\r\n            this.v = 0;\r\n            this.u2 = 0;\r\n            this.v2 = 0;\r\n            this.width = 0;\r\n            this.height = 0;\r\n            this.rotate = false;\r\n            this.offsetX = 0;\r\n            this.offsetY = 0;\r\n            this.originalWidth = 0;\r\n            this.originalHeight = 0;\r\n        }\r\n        return TextureRegion;\r\n    }());\r\n    spine.TextureRegion = TextureRegion;\r\n    var FakeTexture = (function (_super) {\r\n        __extends(FakeTexture, _super);\r\n        function FakeTexture() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        FakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n        FakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n        FakeTexture.prototype.dispose = function () { };\r\n        return FakeTexture;\r\n    }(Texture));\r\n    spine.FakeTexture = FakeTexture;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var TextureAtlas = (function () {\r\n        function TextureAtlas(atlasText, textureLoader) {\r\n            this.pages = new Array();\r\n            this.regions = new Array();\r\n            this.load(atlasText, textureLoader);\r\n        }\r\n        TextureAtlas.prototype.load = function (atlasText, textureLoader) {\r\n            if (textureLoader == null)\r\n                throw new Error(\"textureLoader cannot be null.\");\r\n            var reader = new TextureAtlasReader(atlasText);\r\n            var tuple = new Array(4);\r\n            var page = null;\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line == null)\r\n                    break;\r\n                line = line.trim();\r\n                if (line.length == 0)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line;\r\n                    if (reader.readTuple(tuple) == 2) {\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    }\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Texture.filterFromString(tuple[0]);\r\n                    page.magFilter = spine.Texture.filterFromString(tuple[1]);\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.TextureWrap.ClampToEdge;\r\n                    page.vWrap = spine.TextureWrap.ClampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.TextureWrap.Repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.TextureWrap.Repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.TextureWrap.Repeat;\r\n                    page.texture = textureLoader(line);\r\n                    page.texture.setFilters(page.minFilter, page.magFilter);\r\n                    page.texture.setWraps(page.uWrap, page.vWrap);\r\n                    page.width = page.texture.getImage().width;\r\n                    page.height = page.texture.getImage().height;\r\n                    this.pages.push(page);\r\n                }\r\n                else {\r\n                    var region = new TextureAtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n                    var rotateValue = reader.readValue();\r\n                    if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                        region.degrees = 90;\r\n                    }\r\n                    else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                        region.degrees = 0;\r\n                    }\r\n                    else {\r\n                        region.degrees = parseFloat(rotateValue);\r\n                    }\r\n                    region.rotate = region.degrees == 90;\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n                    region.u = x / page.width;\r\n                    region.v = y / page.height;\r\n                    if (region.rotate) {\r\n                        region.u2 = (x + height) / page.width;\r\n                        region.v2 = (y + width) / page.height;\r\n                    }\r\n                    else {\r\n                        region.u2 = (x + width) / page.width;\r\n                        region.v2 = (y + height) / page.height;\r\n                    }\r\n                    region.x = x;\r\n                    region.y = y;\r\n                    region.width = Math.abs(width);\r\n                    region.height = Math.abs(height);\r\n                    if (reader.readTuple(tuple) == 4) {\r\n                        if (reader.readTuple(tuple) == 4) {\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n                    region.originalWidth = parseInt(tuple[0]);\r\n                    region.originalHeight = parseInt(tuple[1]);\r\n                    reader.readTuple(tuple);\r\n                    region.offsetX = parseInt(tuple[0]);\r\n                    region.offsetY = parseInt(tuple[1]);\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture = page.texture;\r\n                    this.regions.push(region);\r\n                }\r\n            }\r\n        };\r\n        TextureAtlas.prototype.findRegion = function (name) {\r\n            for (var i = 0; i < this.regions.length; i++) {\r\n                if (this.regions[i].name == name) {\r\n                    return this.regions[i];\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        TextureAtlas.prototype.dispose = function () {\r\n            for (var i = 0; i < this.pages.length; i++) {\r\n                this.pages[i].texture.dispose();\r\n            }\r\n        };\r\n        return TextureAtlas;\r\n    }());\r\n    spine.TextureAtlas = TextureAtlas;\r\n    var TextureAtlasReader = (function () {\r\n        function TextureAtlasReader(text) {\r\n            this.index = 0;\r\n            this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n        }\r\n        TextureAtlasReader.prototype.readLine = function () {\r\n            if (this.index >= this.lines.length)\r\n                return null;\r\n            return this.lines[this.index++];\r\n        };\r\n        TextureAtlasReader.prototype.readValue = function () {\r\n            var line = this.readLine();\r\n            var colon = line.indexOf(\":\");\r\n            if (colon == -1)\r\n                throw new Error(\"Invalid line: \" + line);\r\n            return line.substring(colon + 1).trim();\r\n        };\r\n        TextureAtlasReader.prototype.readTuple = function (tuple) {\r\n            var line = this.readLine();\r\n            var colon = line.indexOf(\":\");\r\n            if (colon == -1)\r\n                throw new Error(\"Invalid line: \" + line);\r\n            var i = 0, lastMatch = colon + 1;\r\n            for (; i < 3; i++) {\r\n                var comma = line.indexOf(\",\", lastMatch);\r\n                if (comma == -1)\r\n                    break;\r\n                tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n                lastMatch = comma + 1;\r\n            }\r\n            tuple[i] = line.substring(lastMatch).trim();\r\n            return i + 1;\r\n        };\r\n        return TextureAtlasReader;\r\n    }());\r\n    var TextureAtlasPage = (function () {\r\n        function TextureAtlasPage() {\r\n        }\r\n        return TextureAtlasPage;\r\n    }());\r\n    spine.TextureAtlasPage = TextureAtlasPage;\r\n    var TextureAtlasRegion = (function (_super) {\r\n        __extends(TextureAtlasRegion, _super);\r\n        function TextureAtlasRegion() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        return TextureAtlasRegion;\r\n    }(spine.TextureRegion));\r\n    spine.TextureAtlasRegion = TextureAtlasRegion;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var TransformConstraint = (function () {\r\n        function TransformConstraint(data, skeleton) {\r\n            this.rotateMix = 0;\r\n            this.translateMix = 0;\r\n            this.scaleMix = 0;\r\n            this.shearMix = 0;\r\n            this.temp = new spine.Vector2();\r\n            this.active = false;\r\n            if (data == null)\r\n                throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null)\r\n                throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.rotateMix = data.rotateMix;\r\n            this.translateMix = data.translateMix;\r\n            this.scaleMix = data.scaleMix;\r\n            this.shearMix = data.shearMix;\r\n            this.bones = new Array();\r\n            for (var i = 0; i < data.bones.length; i++)\r\n                this.bones.push(skeleton.findBone(data.bones[i].name));\r\n            this.target = skeleton.findBone(data.target.name);\r\n        }\r\n        TransformConstraint.prototype.isActive = function () {\r\n            return this.active;\r\n        };\r\n        TransformConstraint.prototype.apply = function () {\r\n            this.update();\r\n        };\r\n        TransformConstraint.prototype.update = function () {\r\n            if (this.data.local) {\r\n                if (this.data.relative)\r\n                    this.applyRelativeLocal();\r\n                else\r\n                    this.applyAbsoluteLocal();\r\n            }\r\n            else {\r\n                if (this.data.relative)\r\n                    this.applyRelativeWorld();\r\n                else\r\n                    this.applyAbsoluteWorld();\r\n            }\r\n        };\r\n        TransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n            var target = this.target;\r\n            var ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n            var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n            var offsetRotation = this.data.offsetRotation * degRadReflect;\r\n            var offsetShearY = this.data.offsetShearY * degRadReflect;\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                var modified = false;\r\n                if (rotateMix != 0) {\r\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n                    var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                    if (r > spine.MathUtils.PI)\r\n                        r -= spine.MathUtils.PI2;\r\n                    else if (r < -spine.MathUtils.PI)\r\n                        r += spine.MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    var cos = Math.cos(r), sin = Math.sin(r);\r\n                    bone.a = cos * a - sin * c;\r\n                    bone.b = cos * b - sin * d;\r\n                    bone.c = sin * a + cos * c;\r\n                    bone.d = sin * b + cos * d;\r\n                    modified = true;\r\n                }\r\n                if (translateMix != 0) {\r\n                    var temp = this.temp;\r\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                    bone.worldX += (temp.x - bone.worldX) * translateMix;\r\n                    bone.worldY += (temp.y - bone.worldY) * translateMix;\r\n                    modified = true;\r\n                }\r\n                if (scaleMix > 0) {\r\n                    var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\r\n                    var ts = Math.sqrt(ta * ta + tc * tc);\r\n                    if (s > 0.00001)\r\n                        s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                    bone.a *= s;\r\n                    bone.c *= s;\r\n                    s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\r\n                    ts = Math.sqrt(tb * tb + td * td);\r\n                    if (s > 0.00001)\r\n                        s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                    bone.b *= s;\r\n                    bone.d *= s;\r\n                    modified = true;\r\n                }\r\n                if (shearMix > 0) {\r\n                    var b = bone.b, d = bone.d;\r\n                    var by = Math.atan2(d, b);\r\n                    var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\r\n                    if (r > spine.MathUtils.PI)\r\n                        r -= spine.MathUtils.PI2;\r\n                    else if (r < -spine.MathUtils.PI)\r\n                        r += spine.MathUtils.PI2;\r\n                    r = by + (r + offsetShearY) * shearMix;\r\n                    var s = Math.sqrt(b * b + d * d);\r\n                    bone.b = Math.cos(r) * s;\r\n                    bone.d = Math.sin(r) * s;\r\n                    modified = true;\r\n                }\r\n                if (modified)\r\n                    bone.appliedValid = false;\r\n            }\r\n        };\r\n        TransformConstraint.prototype.applyRelativeWorld = function () {\r\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n            var target = this.target;\r\n            var ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n            var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n            var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                var modified = false;\r\n                if (rotateMix != 0) {\r\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n                    var r = Math.atan2(tc, ta) + offsetRotation;\r\n                    if (r > spine.MathUtils.PI)\r\n                        r -= spine.MathUtils.PI2;\r\n                    else if (r < -spine.MathUtils.PI)\r\n                        r += spine.MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    var cos = Math.cos(r), sin = Math.sin(r);\r\n                    bone.a = cos * a - sin * c;\r\n                    bone.b = cos * b - sin * d;\r\n                    bone.c = sin * a + cos * c;\r\n                    bone.d = sin * b + cos * d;\r\n                    modified = true;\r\n                }\r\n                if (translateMix != 0) {\r\n                    var temp = this.temp;\r\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                    bone.worldX += temp.x * translateMix;\r\n                    bone.worldY += temp.y * translateMix;\r\n                    modified = true;\r\n                }\r\n                if (scaleMix > 0) {\r\n                    var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                    bone.a *= s;\r\n                    bone.c *= s;\r\n                    s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                    bone.b *= s;\r\n                    bone.d *= s;\r\n                    modified = true;\r\n                }\r\n                if (shearMix > 0) {\r\n                    var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                    if (r > spine.MathUtils.PI)\r\n                        r -= spine.MathUtils.PI2;\r\n                    else if (r < -spine.MathUtils.PI)\r\n                        r += spine.MathUtils.PI2;\r\n                    var b = bone.b, d = bone.d;\r\n                    r = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                    var s = Math.sqrt(b * b + d * d);\r\n                    bone.b = Math.cos(r) * s;\r\n                    bone.d = Math.sin(r) * s;\r\n                    modified = true;\r\n                }\r\n                if (modified)\r\n                    bone.appliedValid = false;\r\n            }\r\n        };\r\n        TransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n            var target = this.target;\r\n            if (!target.appliedValid)\r\n                target.updateAppliedTransform();\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                if (!bone.appliedValid)\r\n                    bone.updateAppliedTransform();\r\n                var rotation = bone.arotation;\r\n                if (rotateMix != 0) {\r\n                    var r = target.arotation - rotation + this.data.offsetRotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                    rotation += r * rotateMix;\r\n                }\r\n                var x = bone.ax, y = bone.ay;\r\n                if (translateMix != 0) {\r\n                    x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                    y += (target.ay - y + this.data.offsetY) * translateMix;\r\n                }\r\n                var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                if (scaleMix != 0) {\r\n                    if (scaleX > 0.00001)\r\n                        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                    if (scaleY > 0.00001)\r\n                        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n                }\r\n                var shearY = bone.ashearY;\r\n                if (shearMix != 0) {\r\n                    var r = target.ashearY - shearY + this.data.offsetShearY;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                    bone.shearY += r * shearMix;\r\n                }\r\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n            }\r\n        };\r\n        TransformConstraint.prototype.applyRelativeLocal = function () {\r\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n            var target = this.target;\r\n            if (!target.appliedValid)\r\n                target.updateAppliedTransform();\r\n            var bones = this.bones;\r\n            for (var i = 0, n = bones.length; i < n; i++) {\r\n                var bone = bones[i];\r\n                if (!bone.appliedValid)\r\n                    bone.updateAppliedTransform();\r\n                var rotation = bone.arotation;\r\n                if (rotateMix != 0)\r\n                    rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n                var x = bone.ax, y = bone.ay;\r\n                if (translateMix != 0) {\r\n                    x += (target.ax + this.data.offsetX) * translateMix;\r\n                    y += (target.ay + this.data.offsetY) * translateMix;\r\n                }\r\n                var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                if (scaleMix != 0) {\r\n                    if (scaleX > 0.00001)\r\n                        scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                    if (scaleY > 0.00001)\r\n                        scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n                }\r\n                var shearY = bone.ashearY;\r\n                if (shearMix != 0)\r\n                    shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n            }\r\n        };\r\n        return TransformConstraint;\r\n    }());\r\n    spine.TransformConstraint = TransformConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var TransformConstraintData = (function (_super) {\r\n        __extends(TransformConstraintData, _super);\r\n        function TransformConstraintData(name) {\r\n            var _this = _super.call(this, name, 0, false) || this;\r\n            _this.bones = new Array();\r\n            _this.rotateMix = 0;\r\n            _this.translateMix = 0;\r\n            _this.scaleMix = 0;\r\n            _this.shearMix = 0;\r\n            _this.offsetRotation = 0;\r\n            _this.offsetX = 0;\r\n            _this.offsetY = 0;\r\n            _this.offsetScaleX = 0;\r\n            _this.offsetScaleY = 0;\r\n            _this.offsetShearY = 0;\r\n            _this.relative = false;\r\n            _this.local = false;\r\n            return _this;\r\n        }\r\n        return TransformConstraintData;\r\n    }(spine.ConstraintData));\r\n    spine.TransformConstraintData = TransformConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var Triangulator = (function () {\r\n        function Triangulator() {\r\n            this.convexPolygons = new Array();\r\n            this.convexPolygonsIndices = new Array();\r\n            this.indicesArray = new Array();\r\n            this.isConcaveArray = new Array();\r\n            this.triangles = new Array();\r\n            this.polygonPool = new spine.Pool(function () {\r\n                return new Array();\r\n            });\r\n            this.polygonIndicesPool = new spine.Pool(function () {\r\n                return new Array();\r\n            });\r\n        }\r\n        Triangulator.prototype.triangulate = function (verticesArray) {\r\n            var vertices = verticesArray;\r\n            var vertexCount = verticesArray.length >> 1;\r\n            var indices = this.indicesArray;\r\n            indices.length = 0;\r\n            for (var i = 0; i < vertexCount; i++)\r\n                indices[i] = i;\r\n            var isConcave = this.isConcaveArray;\r\n            isConcave.length = 0;\r\n            for (var i = 0, n = vertexCount; i < n; ++i)\r\n                isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n            var triangles = this.triangles;\r\n            triangles.length = 0;\r\n            while (vertexCount > 3) {\r\n                var previous = vertexCount - 1, i = 0, next = 1;\r\n                while (true) {\r\n                    outer: if (!isConcave[i]) {\r\n                        var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n                        var p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n                        var p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n                        var p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n                        for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n                            if (!isConcave[ii])\r\n                                continue;\r\n                            var v = indices[ii] << 1;\r\n                            var vx = vertices[v], vy = vertices[v + 1];\r\n                            if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n                                if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n                                    if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n                                        break outer;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (next == 0) {\r\n                        do {\r\n                            if (!isConcave[i])\r\n                                break;\r\n                            i--;\r\n                        } while (i > 0);\r\n                        break;\r\n                    }\r\n                    previous = i;\r\n                    i = next;\r\n                    next = (next + 1) % vertexCount;\r\n                }\r\n                triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n                triangles.push(indices[i]);\r\n                triangles.push(indices[(i + 1) % vertexCount]);\r\n                indices.splice(i, 1);\r\n                isConcave.splice(i, 1);\r\n                vertexCount--;\r\n                var previousIndex = (vertexCount + i - 1) % vertexCount;\r\n                var nextIndex = i == vertexCount ? 0 : i;\r\n                isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n                isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n            }\r\n            if (vertexCount == 3) {\r\n                triangles.push(indices[2]);\r\n                triangles.push(indices[0]);\r\n                triangles.push(indices[1]);\r\n            }\r\n            return triangles;\r\n        };\r\n        Triangulator.prototype.decompose = function (verticesArray, triangles) {\r\n            var vertices = verticesArray;\r\n            var convexPolygons = this.convexPolygons;\r\n            this.polygonPool.freeAll(convexPolygons);\r\n            convexPolygons.length = 0;\r\n            var convexPolygonsIndices = this.convexPolygonsIndices;\r\n            this.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n            convexPolygonsIndices.length = 0;\r\n            var polygonIndices = this.polygonIndicesPool.obtain();\r\n            polygonIndices.length = 0;\r\n            var polygon = this.polygonPool.obtain();\r\n            polygon.length = 0;\r\n            var fanBaseIndex = -1, lastWinding = 0;\r\n            for (var i = 0, n = triangles.length; i < n; i += 3) {\r\n                var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n                var x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n                var x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n                var x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n                var merged = false;\r\n                if (fanBaseIndex == t1) {\r\n                    var o = polygon.length - 4;\r\n                    var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n                    var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n                    if (winding1 == lastWinding && winding2 == lastWinding) {\r\n                        polygon.push(x3);\r\n                        polygon.push(y3);\r\n                        polygonIndices.push(t3);\r\n                        merged = true;\r\n                    }\r\n                }\r\n                if (!merged) {\r\n                    if (polygon.length > 0) {\r\n                        convexPolygons.push(polygon);\r\n                        convexPolygonsIndices.push(polygonIndices);\r\n                    }\r\n                    else {\r\n                        this.polygonPool.free(polygon);\r\n                        this.polygonIndicesPool.free(polygonIndices);\r\n                    }\r\n                    polygon = this.polygonPool.obtain();\r\n                    polygon.length = 0;\r\n                    polygon.push(x1);\r\n                    polygon.push(y1);\r\n                    polygon.push(x2);\r\n                    polygon.push(y2);\r\n                    polygon.push(x3);\r\n                    polygon.push(y3);\r\n                    polygonIndices = this.polygonIndicesPool.obtain();\r\n                    polygonIndices.length = 0;\r\n                    polygonIndices.push(t1);\r\n                    polygonIndices.push(t2);\r\n                    polygonIndices.push(t3);\r\n                    lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n                    fanBaseIndex = t1;\r\n                }\r\n            }\r\n            if (polygon.length > 0) {\r\n                convexPolygons.push(polygon);\r\n                convexPolygonsIndices.push(polygonIndices);\r\n            }\r\n            for (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n                polygonIndices = convexPolygonsIndices[i];\r\n                if (polygonIndices.length == 0)\r\n                    continue;\r\n                var firstIndex = polygonIndices[0];\r\n                var lastIndex = polygonIndices[polygonIndices.length - 1];\r\n                polygon = convexPolygons[i];\r\n                var o = polygon.length - 4;\r\n                var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n                var prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n                var firstX = polygon[0], firstY = polygon[1];\r\n                var secondX = polygon[2], secondY = polygon[3];\r\n                var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n                for (var ii = 0; ii < n; ii++) {\r\n                    if (ii == i)\r\n                        continue;\r\n                    var otherIndices = convexPolygonsIndices[ii];\r\n                    if (otherIndices.length != 3)\r\n                        continue;\r\n                    var otherFirstIndex = otherIndices[0];\r\n                    var otherSecondIndex = otherIndices[1];\r\n                    var otherLastIndex = otherIndices[2];\r\n                    var otherPoly = convexPolygons[ii];\r\n                    var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n                    if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n                        continue;\r\n                    var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n                    var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n                    if (winding1 == winding && winding2 == winding) {\r\n                        otherPoly.length = 0;\r\n                        otherIndices.length = 0;\r\n                        polygon.push(x3);\r\n                        polygon.push(y3);\r\n                        polygonIndices.push(otherLastIndex);\r\n                        prevPrevX = prevX;\r\n                        prevPrevY = prevY;\r\n                        prevX = x3;\r\n                        prevY = y3;\r\n                        ii = 0;\r\n                    }\r\n                }\r\n            }\r\n            for (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n                polygon = convexPolygons[i];\r\n                if (polygon.length == 0) {\r\n                    convexPolygons.splice(i, 1);\r\n                    this.polygonPool.free(polygon);\r\n                    polygonIndices = convexPolygonsIndices[i];\r\n                    convexPolygonsIndices.splice(i, 1);\r\n                    this.polygonIndicesPool.free(polygonIndices);\r\n                }\r\n            }\r\n            return convexPolygons;\r\n        };\r\n        Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n            var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n            var current = indices[index] << 1;\r\n            var next = indices[(index + 1) % vertexCount] << 1;\r\n            return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n        };\r\n        Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n            return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n        };\r\n        Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n            var px = p2x - p1x, py = p2y - p1y;\r\n            return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n        };\r\n        return Triangulator;\r\n    }());\r\n    spine.Triangulator = Triangulator;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var IntSet = (function () {\r\n        function IntSet() {\r\n            this.array = new Array();\r\n        }\r\n        IntSet.prototype.add = function (value) {\r\n            var contains = this.contains(value);\r\n            this.array[value | 0] = value | 0;\r\n            return !contains;\r\n        };\r\n        IntSet.prototype.contains = function (value) {\r\n            return this.array[value | 0] != undefined;\r\n        };\r\n        IntSet.prototype.remove = function (value) {\r\n            this.array[value | 0] = undefined;\r\n        };\r\n        IntSet.prototype.clear = function () {\r\n            this.array.length = 0;\r\n        };\r\n        return IntSet;\r\n    }());\r\n    spine.IntSet = IntSet;\r\n    var Color = (function () {\r\n        function Color(r, g, b, a) {\r\n            if (r === void 0) { r = 0; }\r\n            if (g === void 0) { g = 0; }\r\n            if (b === void 0) { b = 0; }\r\n            if (a === void 0) { a = 0; }\r\n            this.r = r;\r\n            this.g = g;\r\n            this.b = b;\r\n            this.a = a;\r\n        }\r\n        Color.prototype.set = function (r, g, b, a) {\r\n            this.r = r;\r\n            this.g = g;\r\n            this.b = b;\r\n            this.a = a;\r\n            this.clamp();\r\n            return this;\r\n        };\r\n        Color.prototype.setFromColor = function (c) {\r\n            this.r = c.r;\r\n            this.g = c.g;\r\n            this.b = c.b;\r\n            this.a = c.a;\r\n            return this;\r\n        };\r\n        Color.prototype.setFromString = function (hex) {\r\n            hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n            this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n            this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n            this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n            this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n            return this;\r\n        };\r\n        Color.prototype.add = function (r, g, b, a) {\r\n            this.r += r;\r\n            this.g += g;\r\n            this.b += b;\r\n            this.a += a;\r\n            this.clamp();\r\n            return this;\r\n        };\r\n        Color.prototype.clamp = function () {\r\n            if (this.r < 0)\r\n                this.r = 0;\r\n            else if (this.r > 1)\r\n                this.r = 1;\r\n            if (this.g < 0)\r\n                this.g = 0;\r\n            else if (this.g > 1)\r\n                this.g = 1;\r\n            if (this.b < 0)\r\n                this.b = 0;\r\n            else if (this.b > 1)\r\n                this.b = 1;\r\n            if (this.a < 0)\r\n                this.a = 0;\r\n            else if (this.a > 1)\r\n                this.a = 1;\r\n            return this;\r\n        };\r\n        Color.rgba8888ToColor = function (color, value) {\r\n            color.r = ((value & 0xff000000) >>> 24) / 255;\r\n            color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n            color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n            color.a = ((value & 0x000000ff)) / 255;\r\n        };\r\n        Color.rgb888ToColor = function (color, value) {\r\n            color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n            color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n            color.b = ((value & 0x000000ff)) / 255;\r\n        };\r\n        Color.WHITE = new Color(1, 1, 1, 1);\r\n        Color.RED = new Color(1, 0, 0, 1);\r\n        Color.GREEN = new Color(0, 1, 0, 1);\r\n        Color.BLUE = new Color(0, 0, 1, 1);\r\n        Color.MAGENTA = new Color(1, 0, 1, 1);\r\n        return Color;\r\n    }());\r\n    spine.Color = Color;\r\n    var MathUtils = (function () {\r\n        function MathUtils() {\r\n        }\r\n        MathUtils.clamp = function (value, min, max) {\r\n            if (value < min)\r\n                return min;\r\n            if (value > max)\r\n                return max;\r\n            return value;\r\n        };\r\n        MathUtils.cosDeg = function (degrees) {\r\n            return Math.cos(degrees * MathUtils.degRad);\r\n        };\r\n        MathUtils.sinDeg = function (degrees) {\r\n            return Math.sin(degrees * MathUtils.degRad);\r\n        };\r\n        MathUtils.signum = function (value) {\r\n            return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n        };\r\n        MathUtils.toInt = function (x) {\r\n            return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n        };\r\n        MathUtils.cbrt = function (x) {\r\n            var y = Math.pow(Math.abs(x), 1 / 3);\r\n            return x < 0 ? -y : y;\r\n        };\r\n        MathUtils.randomTriangular = function (min, max) {\r\n            return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n        };\r\n        MathUtils.randomTriangularWith = function (min, max, mode) {\r\n            var u = Math.random();\r\n            var d = max - min;\r\n            if (u <= (mode - min) / d)\r\n                return min + Math.sqrt(u * d * (mode - min));\r\n            return max - Math.sqrt((1 - u) * d * (max - mode));\r\n        };\r\n        MathUtils.PI = 3.1415927;\r\n        MathUtils.PI2 = MathUtils.PI * 2;\r\n        MathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n        MathUtils.radDeg = MathUtils.radiansToDegrees;\r\n        MathUtils.degreesToRadians = MathUtils.PI / 180;\r\n        MathUtils.degRad = MathUtils.degreesToRadians;\r\n        return MathUtils;\r\n    }());\r\n    spine.MathUtils = MathUtils;\r\n    var Interpolation = (function () {\r\n        function Interpolation() {\r\n        }\r\n        Interpolation.prototype.apply = function (start, end, a) {\r\n            return start + (end - start) * this.applyInternal(a);\r\n        };\r\n        return Interpolation;\r\n    }());\r\n    spine.Interpolation = Interpolation;\r\n    var Pow = (function (_super) {\r\n        __extends(Pow, _super);\r\n        function Pow(power) {\r\n            var _this = _super.call(this) || this;\r\n            _this.power = 2;\r\n            _this.power = power;\r\n            return _this;\r\n        }\r\n        Pow.prototype.applyInternal = function (a) {\r\n            if (a <= 0.5)\r\n                return Math.pow(a * 2, this.power) / 2;\r\n            return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n        };\r\n        return Pow;\r\n    }(Interpolation));\r\n    spine.Pow = Pow;\r\n    var PowOut = (function (_super) {\r\n        __extends(PowOut, _super);\r\n        function PowOut(power) {\r\n            return _super.call(this, power) || this;\r\n        }\r\n        PowOut.prototype.applyInternal = function (a) {\r\n            return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n        };\r\n        return PowOut;\r\n    }(Pow));\r\n    spine.PowOut = PowOut;\r\n    var Utils = (function () {\r\n        function Utils() {\r\n        }\r\n        Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n            for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n                dest[j] = source[i];\r\n            }\r\n        };\r\n        Utils.setArraySize = function (array, size, value) {\r\n            if (value === void 0) { value = 0; }\r\n            var oldSize = array.length;\r\n            if (oldSize == size)\r\n                return array;\r\n            array.length = size;\r\n            if (oldSize < size) {\r\n                for (var i = oldSize; i < size; i++)\r\n                    array[i] = value;\r\n            }\r\n            return array;\r\n        };\r\n        Utils.ensureArrayCapacity = function (array, size, value) {\r\n            if (value === void 0) { value = 0; }\r\n            if (array.length >= size)\r\n                return array;\r\n            return Utils.setArraySize(array, size, value);\r\n        };\r\n        Utils.newArray = function (size, defaultValue) {\r\n            var array = new Array(size);\r\n            for (var i = 0; i < size; i++)\r\n                array[i] = defaultValue;\r\n            return array;\r\n        };\r\n        Utils.newFloatArray = function (size) {\r\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                return new Float32Array(size);\r\n            }\r\n            else {\r\n                var array = new Array(size);\r\n                for (var i = 0; i < array.length; i++)\r\n                    array[i] = 0;\r\n                return array;\r\n            }\r\n        };\r\n        Utils.newShortArray = function (size) {\r\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n                return new Int16Array(size);\r\n            }\r\n            else {\r\n                var array = new Array(size);\r\n                for (var i = 0; i < array.length; i++)\r\n                    array[i] = 0;\r\n                return array;\r\n            }\r\n        };\r\n        Utils.toFloatArray = function (array) {\r\n            return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n        };\r\n        Utils.toSinglePrecision = function (value) {\r\n            return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n        };\r\n        Utils.webkit602BugfixHelper = function (alpha, blend) {\r\n        };\r\n        Utils.contains = function (array, element, identity) {\r\n            if (identity === void 0) { identity = true; }\r\n            for (var i = 0; i < array.length; i++) {\r\n                if (array[i] == element)\r\n                    return true;\r\n            }\r\n            return false;\r\n        };\r\n        Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n        return Utils;\r\n    }());\r\n    spine.Utils = Utils;\r\n    var DebugUtils = (function () {\r\n        function DebugUtils() {\r\n        }\r\n        DebugUtils.logBones = function (skeleton) {\r\n            for (var i = 0; i < skeleton.bones.length; i++) {\r\n                var bone = skeleton.bones[i];\r\n                console.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\r\n            }\r\n        };\r\n        return DebugUtils;\r\n    }());\r\n    spine.DebugUtils = DebugUtils;\r\n    var Pool = (function () {\r\n        function Pool(instantiator) {\r\n            this.items = new Array();\r\n            this.instantiator = instantiator;\r\n        }\r\n        Pool.prototype.obtain = function () {\r\n            return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n        };\r\n        Pool.prototype.free = function (item) {\r\n            if (item.reset)\r\n                item.reset();\r\n            this.items.push(item);\r\n        };\r\n        Pool.prototype.freeAll = function (items) {\r\n            for (var i = 0; i < items.length; i++) {\r\n                if (items[i].reset)\r\n                    items[i].reset();\r\n                this.items[i] = items[i];\r\n            }\r\n        };\r\n        Pool.prototype.clear = function () {\r\n            this.items.length = 0;\r\n        };\r\n        return Pool;\r\n    }());\r\n    spine.Pool = Pool;\r\n    var Vector2 = (function () {\r\n        function Vector2(x, y) {\r\n            if (x === void 0) { x = 0; }\r\n            if (y === void 0) { y = 0; }\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        Vector2.prototype.set = function (x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.length = function () {\r\n            var x = this.x;\r\n            var y = this.y;\r\n            return Math.sqrt(x * x + y * y);\r\n        };\r\n        Vector2.prototype.normalize = function () {\r\n            var len = this.length();\r\n            if (len != 0) {\r\n                this.x /= len;\r\n                this.y /= len;\r\n            }\r\n            return this;\r\n        };\r\n        return Vector2;\r\n    }());\r\n    spine.Vector2 = Vector2;\r\n    var TimeKeeper = (function () {\r\n        function TimeKeeper() {\r\n            this.maxDelta = 0.064;\r\n            this.framesPerSecond = 0;\r\n            this.delta = 0;\r\n            this.totalTime = 0;\r\n            this.lastTime = Date.now() / 1000;\r\n            this.frameCount = 0;\r\n            this.frameTime = 0;\r\n        }\r\n        TimeKeeper.prototype.update = function () {\r\n            var now = Date.now() / 1000;\r\n            this.delta = now - this.lastTime;\r\n            this.frameTime += this.delta;\r\n            this.totalTime += this.delta;\r\n            if (this.delta > this.maxDelta)\r\n                this.delta = this.maxDelta;\r\n            this.lastTime = now;\r\n            this.frameCount++;\r\n            if (this.frameTime > 1) {\r\n                this.framesPerSecond = this.frameCount / this.frameTime;\r\n                this.frameTime = 0;\r\n                this.frameCount = 0;\r\n            }\r\n        };\r\n        return TimeKeeper;\r\n    }());\r\n    spine.TimeKeeper = TimeKeeper;\r\n    var WindowedMean = (function () {\r\n        function WindowedMean(windowSize) {\r\n            if (windowSize === void 0) { windowSize = 32; }\r\n            this.addedValues = 0;\r\n            this.lastValue = 0;\r\n            this.mean = 0;\r\n            this.dirty = true;\r\n            this.values = new Array(windowSize);\r\n        }\r\n        WindowedMean.prototype.hasEnoughData = function () {\r\n            return this.addedValues >= this.values.length;\r\n        };\r\n        WindowedMean.prototype.addValue = function (value) {\r\n            if (this.addedValues < this.values.length)\r\n                this.addedValues++;\r\n            this.values[this.lastValue++] = value;\r\n            if (this.lastValue > this.values.length - 1)\r\n                this.lastValue = 0;\r\n            this.dirty = true;\r\n        };\r\n        WindowedMean.prototype.getMean = function () {\r\n            if (this.hasEnoughData()) {\r\n                if (this.dirty) {\r\n                    var mean = 0;\r\n                    for (var i = 0; i < this.values.length; i++) {\r\n                        mean += this.values[i];\r\n                    }\r\n                    this.mean = mean / this.values.length;\r\n                    this.dirty = false;\r\n                }\r\n                return this.mean;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        };\r\n        return WindowedMean;\r\n    }());\r\n    spine.WindowedMean = WindowedMean;\r\n})(spine || (spine = {}));\r\n(function () {\r\n    if (!Math.fround) {\r\n        Math.fround = (function (array) {\r\n            return function (x) {\r\n                return array[0] = x, array[0];\r\n            };\r\n        })(new Float32Array(1));\r\n    }\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n    var Attachment = (function () {\r\n        function Attachment(name) {\r\n            if (name == null)\r\n                throw new Error(\"name cannot be null.\");\r\n            this.name = name;\r\n        }\r\n        return Attachment;\r\n    }());\r\n    spine.Attachment = Attachment;\r\n    var VertexAttachment = (function (_super) {\r\n        __extends(VertexAttachment, _super);\r\n        function VertexAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n            _this.worldVerticesLength = 0;\r\n            _this.deformAttachment = _this;\r\n            return _this;\r\n        }\r\n        VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n            count = offset + (count >> 1) * stride;\r\n            var skeleton = slot.bone.skeleton;\r\n            var deformArray = slot.deform;\r\n            var vertices = this.vertices;\r\n            var bones = this.bones;\r\n            if (bones == null) {\r\n                if (deformArray.length > 0)\r\n                    vertices = deformArray;\r\n                var bone = slot.bone;\r\n                var x = bone.worldX;\r\n                var y = bone.worldY;\r\n                var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n                for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n                    var vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n                    worldVertices[w] = vx * a + vy * b + x;\r\n                    worldVertices[w + 1] = vx * c + vy * d + y;\r\n                }\r\n                return;\r\n            }\r\n            var v = 0, skip = 0;\r\n            for (var i = 0; i < start; i += 2) {\r\n                var n = bones[v];\r\n                v += n + 1;\r\n                skip += n;\r\n            }\r\n            var skeletonBones = skeleton.bones;\r\n            if (deformArray.length == 0) {\r\n                for (var w = offset, b = skip * 3; w < count; w += stride) {\r\n                    var wx = 0, wy = 0;\r\n                    var n = bones[v++];\r\n                    n += v;\r\n                    for (; v < n; v++, b += 3) {\r\n                        var bone = skeletonBones[bones[v]];\r\n                        var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n                    }\r\n                    worldVertices[w] = wx;\r\n                    worldVertices[w + 1] = wy;\r\n                }\r\n            }\r\n            else {\r\n                var deform = deformArray;\r\n                for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                    var wx = 0, wy = 0;\r\n                    var n = bones[v++];\r\n                    n += v;\r\n                    for (; v < n; v++, b += 3, f += 2) {\r\n                        var bone = skeletonBones[bones[v]];\r\n                        var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n                    }\r\n                    worldVertices[w] = wx;\r\n                    worldVertices[w + 1] = wy;\r\n                }\r\n            }\r\n        };\r\n        VertexAttachment.prototype.copyTo = function (attachment) {\r\n            if (this.bones != null) {\r\n                attachment.bones = new Array(this.bones.length);\r\n                spine.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n            }\r\n            else\r\n                attachment.bones = null;\r\n            if (this.vertices != null) {\r\n                attachment.vertices = spine.Utils.newFloatArray(this.vertices.length);\r\n                spine.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n            }\r\n            else\r\n                attachment.vertices = null;\r\n            attachment.worldVerticesLength = this.worldVerticesLength;\r\n            attachment.deformAttachment = this.deformAttachment;\r\n        };\r\n        VertexAttachment.nextID = 0;\r\n        return VertexAttachment;\r\n    }(Attachment));\r\n    spine.VertexAttachment = VertexAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var AttachmentType;\r\n    (function (AttachmentType) {\r\n        AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n        AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n        AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n        AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n        AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n        AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n        AttachmentType[AttachmentType[\"Clipping\"] = 6] = \"Clipping\";\r\n    })(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var BoundingBoxAttachment = (function (_super) {\r\n        __extends(BoundingBoxAttachment, _super);\r\n        function BoundingBoxAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.color = new spine.Color(1, 1, 1, 1);\r\n            return _this;\r\n        }\r\n        BoundingBoxAttachment.prototype.copy = function () {\r\n            var copy = new BoundingBoxAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        };\r\n        return BoundingBoxAttachment;\r\n    }(spine.VertexAttachment));\r\n    spine.BoundingBoxAttachment = BoundingBoxAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var ClippingAttachment = (function (_super) {\r\n        __extends(ClippingAttachment, _super);\r\n        function ClippingAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\r\n            return _this;\r\n        }\r\n        ClippingAttachment.prototype.copy = function () {\r\n            var copy = new ClippingAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.endSlot = this.endSlot;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        };\r\n        return ClippingAttachment;\r\n    }(spine.VertexAttachment));\r\n    spine.ClippingAttachment = ClippingAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var MeshAttachment = (function (_super) {\r\n        __extends(MeshAttachment, _super);\r\n        function MeshAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.color = new spine.Color(1, 1, 1, 1);\r\n            _this.tempColor = new spine.Color(0, 0, 0, 0);\r\n            return _this;\r\n        }\r\n        MeshAttachment.prototype.updateUVs = function () {\r\n            var regionUVs = this.regionUVs;\r\n            if (this.uvs == null || this.uvs.length != regionUVs.length)\r\n                this.uvs = spine.Utils.newFloatArray(regionUVs.length);\r\n            var uvs = this.uvs;\r\n            var n = this.uvs.length;\r\n            var u = this.region.u, v = this.region.v, width = 0, height = 0;\r\n            if (this.region instanceof spine.TextureAtlasRegion) {\r\n                var region = this.region;\r\n                var textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;\r\n                switch (region.degrees) {\r\n                    case 90:\r\n                        u -= (region.originalHeight - region.offsetY - region.height) / textureWidth;\r\n                        v -= (region.originalWidth - region.offsetX - region.width) / textureHeight;\r\n                        width = region.originalHeight / textureWidth;\r\n                        height = region.originalWidth / textureHeight;\r\n                        for (var i = 0; i < n; i += 2) {\r\n                            uvs[i] = u + regionUVs[i + 1] * width;\r\n                            uvs[i + 1] = v + (1 - regionUVs[i]) * height;\r\n                        }\r\n                        return;\r\n                    case 180:\r\n                        u -= (region.originalWidth - region.offsetX - region.width) / textureWidth;\r\n                        v -= region.offsetY / textureHeight;\r\n                        width = region.originalWidth / textureWidth;\r\n                        height = region.originalHeight / textureHeight;\r\n                        for (var i = 0; i < n; i += 2) {\r\n                            uvs[i] = u + (1 - regionUVs[i]) * width;\r\n                            uvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;\r\n                        }\r\n                        return;\r\n                    case 270:\r\n                        u -= region.offsetY / textureWidth;\r\n                        v -= region.offsetX / textureHeight;\r\n                        width = region.originalHeight / textureWidth;\r\n                        height = region.originalWidth / textureHeight;\r\n                        for (var i = 0; i < n; i += 2) {\r\n                            uvs[i] = u + (1 - regionUVs[i + 1]) * width;\r\n                            uvs[i + 1] = v + regionUVs[i] * height;\r\n                        }\r\n                        return;\r\n                }\r\n                u -= region.offsetX / textureWidth;\r\n                v -= (region.originalHeight - region.offsetY - region.height) / textureHeight;\r\n                width = region.originalWidth / textureWidth;\r\n                height = region.originalHeight / textureHeight;\r\n            }\r\n            else if (this.region == null) {\r\n                u = v = 0;\r\n                width = height = 1;\r\n            }\r\n            else {\r\n                width = this.region.u2 - u;\r\n                height = this.region.v2 - v;\r\n            }\r\n            for (var i = 0; i < n; i += 2) {\r\n                uvs[i] = u + regionUVs[i] * width;\r\n                uvs[i + 1] = v + regionUVs[i + 1] * height;\r\n            }\r\n        };\r\n        MeshAttachment.prototype.getParentMesh = function () {\r\n            return this.parentMesh;\r\n        };\r\n        MeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n            this.parentMesh = parentMesh;\r\n            if (parentMesh != null) {\r\n                this.bones = parentMesh.bones;\r\n                this.vertices = parentMesh.vertices;\r\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                this.regionUVs = parentMesh.regionUVs;\r\n                this.triangles = parentMesh.triangles;\r\n                this.hullLength = parentMesh.hullLength;\r\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            }\r\n        };\r\n        MeshAttachment.prototype.copy = function () {\r\n            if (this.parentMesh != null)\r\n                return this.newLinkedMesh();\r\n            var copy = new MeshAttachment(this.name);\r\n            copy.region = this.region;\r\n            copy.path = this.path;\r\n            copy.color.setFromColor(this.color);\r\n            this.copyTo(copy);\r\n            copy.regionUVs = new Array(this.regionUVs.length);\r\n            spine.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n            copy.uvs = new Array(this.uvs.length);\r\n            spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\r\n            copy.triangles = new Array(this.triangles.length);\r\n            spine.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n            copy.hullLength = this.hullLength;\r\n            if (this.edges != null) {\r\n                copy.edges = new Array(this.edges.length);\r\n                spine.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n            }\r\n            copy.width = this.width;\r\n            copy.height = this.height;\r\n            return copy;\r\n        };\r\n        MeshAttachment.prototype.newLinkedMesh = function () {\r\n            var copy = new MeshAttachment(this.name);\r\n            copy.region = this.region;\r\n            copy.path = this.path;\r\n            copy.color.setFromColor(this.color);\r\n            copy.deformAttachment = this.deformAttachment;\r\n            copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n            copy.updateUVs();\r\n            return copy;\r\n        };\r\n        return MeshAttachment;\r\n    }(spine.VertexAttachment));\r\n    spine.MeshAttachment = MeshAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var PathAttachment = (function (_super) {\r\n        __extends(PathAttachment, _super);\r\n        function PathAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.closed = false;\r\n            _this.constantSpeed = false;\r\n            _this.color = new spine.Color(1, 1, 1, 1);\r\n            return _this;\r\n        }\r\n        PathAttachment.prototype.copy = function () {\r\n            var copy = new PathAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.lengths = new Array(this.lengths.length);\r\n            spine.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n            copy.closed = closed;\r\n            copy.constantSpeed = this.constantSpeed;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        };\r\n        return PathAttachment;\r\n    }(spine.VertexAttachment));\r\n    spine.PathAttachment = PathAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var PointAttachment = (function (_super) {\r\n        __extends(PointAttachment, _super);\r\n        function PointAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.color = new spine.Color(0.38, 0.94, 0, 1);\r\n            return _this;\r\n        }\r\n        PointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n            point.x = this.x * bone.a + this.y * bone.b + bone.worldX;\r\n            point.y = this.x * bone.c + this.y * bone.d + bone.worldY;\r\n            return point;\r\n        };\r\n        PointAttachment.prototype.computeWorldRotation = function (bone) {\r\n            var cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\r\n            var x = cos * bone.a + sin * bone.b;\r\n            var y = cos * bone.c + sin * bone.d;\r\n            return Math.atan2(y, x) * spine.MathUtils.radDeg;\r\n        };\r\n        PointAttachment.prototype.copy = function () {\r\n            var copy = new PointAttachment(name);\r\n            copy.x = this.x;\r\n            copy.y = this.y;\r\n            copy.rotation = this.rotation;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        };\r\n        return PointAttachment;\r\n    }(spine.VertexAttachment));\r\n    spine.PointAttachment = PointAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var RegionAttachment = (function (_super) {\r\n        __extends(RegionAttachment, _super);\r\n        function RegionAttachment(name) {\r\n            var _this = _super.call(this, name) || this;\r\n            _this.x = 0;\r\n            _this.y = 0;\r\n            _this.scaleX = 1;\r\n            _this.scaleY = 1;\r\n            _this.rotation = 0;\r\n            _this.width = 0;\r\n            _this.height = 0;\r\n            _this.color = new spine.Color(1, 1, 1, 1);\r\n            _this.offset = spine.Utils.newFloatArray(8);\r\n            _this.uvs = spine.Utils.newFloatArray(8);\r\n            _this.tempColor = new spine.Color(1, 1, 1, 1);\r\n            return _this;\r\n        }\r\n        RegionAttachment.prototype.updateOffset = function () {\r\n            var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n            var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n            var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n            var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n            var localX2 = localX + this.region.width * regionScaleX;\r\n            var localY2 = localY + this.region.height * regionScaleY;\r\n            var radians = this.rotation * Math.PI / 180;\r\n            var cos = Math.cos(radians);\r\n            var sin = Math.sin(radians);\r\n            var localXCos = localX * cos + this.x;\r\n            var localXSin = localX * sin;\r\n            var localYCos = localY * cos + this.y;\r\n            var localYSin = localY * sin;\r\n            var localX2Cos = localX2 * cos + this.x;\r\n            var localX2Sin = localX2 * sin;\r\n            var localY2Cos = localY2 * cos + this.y;\r\n            var localY2Sin = localY2 * sin;\r\n            var offset = this.offset;\r\n            offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n            offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n            offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n            offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n            offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n            offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n            offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n            offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n        };\r\n        RegionAttachment.prototype.setRegion = function (region) {\r\n            this.region = region;\r\n            var uvs = this.uvs;\r\n            if (region.rotate) {\r\n                uvs[2] = region.u;\r\n                uvs[3] = region.v2;\r\n                uvs[4] = region.u;\r\n                uvs[5] = region.v;\r\n                uvs[6] = region.u2;\r\n                uvs[7] = region.v;\r\n                uvs[0] = region.u2;\r\n                uvs[1] = region.v2;\r\n            }\r\n            else {\r\n                uvs[0] = region.u;\r\n                uvs[1] = region.v2;\r\n                uvs[2] = region.u;\r\n                uvs[3] = region.v;\r\n                uvs[4] = region.u2;\r\n                uvs[5] = region.v;\r\n                uvs[6] = region.u2;\r\n                uvs[7] = region.v2;\r\n            }\r\n        };\r\n        RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n            var vertexOffset = this.offset;\r\n            var x = bone.worldX, y = bone.worldY;\r\n            var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n            var offsetX = 0, offsetY = 0;\r\n            offsetX = vertexOffset[RegionAttachment.OX1];\r\n            offsetY = vertexOffset[RegionAttachment.OY1];\r\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n            offset += stride;\r\n            offsetX = vertexOffset[RegionAttachment.OX2];\r\n            offsetY = vertexOffset[RegionAttachment.OY2];\r\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n            offset += stride;\r\n            offsetX = vertexOffset[RegionAttachment.OX3];\r\n            offsetY = vertexOffset[RegionAttachment.OY3];\r\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n            offset += stride;\r\n            offsetX = vertexOffset[RegionAttachment.OX4];\r\n            offsetY = vertexOffset[RegionAttachment.OY4];\r\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\r\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        };\r\n        RegionAttachment.prototype.copy = function () {\r\n            var copy = new RegionAttachment(name);\r\n            copy.region = this.region;\r\n            copy.rendererObject = this.rendererObject;\r\n            copy.path = this.path;\r\n            copy.x = this.x;\r\n            copy.y = this.y;\r\n            copy.scaleX = this.scaleX;\r\n            copy.scaleY = this.scaleY;\r\n            copy.rotation = this.rotation;\r\n            copy.width = this.width;\r\n            copy.height = this.height;\r\n            spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n            spine.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        };\r\n        RegionAttachment.OX1 = 0;\r\n        RegionAttachment.OY1 = 1;\r\n        RegionAttachment.OX2 = 2;\r\n        RegionAttachment.OY2 = 3;\r\n        RegionAttachment.OX3 = 4;\r\n        RegionAttachment.OY3 = 5;\r\n        RegionAttachment.OX4 = 6;\r\n        RegionAttachment.OY4 = 7;\r\n        RegionAttachment.X1 = 0;\r\n        RegionAttachment.Y1 = 1;\r\n        RegionAttachment.C1R = 2;\r\n        RegionAttachment.C1G = 3;\r\n        RegionAttachment.C1B = 4;\r\n        RegionAttachment.C1A = 5;\r\n        RegionAttachment.U1 = 6;\r\n        RegionAttachment.V1 = 7;\r\n        RegionAttachment.X2 = 8;\r\n        RegionAttachment.Y2 = 9;\r\n        RegionAttachment.C2R = 10;\r\n        RegionAttachment.C2G = 11;\r\n        RegionAttachment.C2B = 12;\r\n        RegionAttachment.C2A = 13;\r\n        RegionAttachment.U2 = 14;\r\n        RegionAttachment.V2 = 15;\r\n        RegionAttachment.X3 = 16;\r\n        RegionAttachment.Y3 = 17;\r\n        RegionAttachment.C3R = 18;\r\n        RegionAttachment.C3G = 19;\r\n        RegionAttachment.C3B = 20;\r\n        RegionAttachment.C3A = 21;\r\n        RegionAttachment.U3 = 22;\r\n        RegionAttachment.V3 = 23;\r\n        RegionAttachment.X4 = 24;\r\n        RegionAttachment.Y4 = 25;\r\n        RegionAttachment.C4R = 26;\r\n        RegionAttachment.C4G = 27;\r\n        RegionAttachment.C4B = 28;\r\n        RegionAttachment.C4A = 29;\r\n        RegionAttachment.U4 = 30;\r\n        RegionAttachment.V4 = 31;\r\n        return RegionAttachment;\r\n    }(spine.Attachment));\r\n    spine.RegionAttachment = RegionAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var JitterEffect = (function () {\r\n        function JitterEffect(jitterX, jitterY) {\r\n            this.jitterX = 0;\r\n            this.jitterY = 0;\r\n            this.jitterX = jitterX;\r\n            this.jitterY = jitterY;\r\n        }\r\n        JitterEffect.prototype.begin = function (skeleton) {\r\n        };\r\n        JitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n            position.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n            position.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n        };\r\n        JitterEffect.prototype.end = function () {\r\n        };\r\n        return JitterEffect;\r\n    }());\r\n    spine.JitterEffect = JitterEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var SwirlEffect = (function () {\r\n        function SwirlEffect(radius) {\r\n            this.centerX = 0;\r\n            this.centerY = 0;\r\n            this.radius = 0;\r\n            this.angle = 0;\r\n            this.worldX = 0;\r\n            this.worldY = 0;\r\n            this.radius = radius;\r\n        }\r\n        SwirlEffect.prototype.begin = function (skeleton) {\r\n            this.worldX = skeleton.x + this.centerX;\r\n            this.worldY = skeleton.y + this.centerY;\r\n        };\r\n        SwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n            var radAngle = this.angle * spine.MathUtils.degreesToRadians;\r\n            var x = position.x - this.worldX;\r\n            var y = position.y - this.worldY;\r\n            var dist = Math.sqrt(x * x + y * y);\r\n            if (dist < this.radius) {\r\n                var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n                var cos = Math.cos(theta);\r\n                var sin = Math.sin(theta);\r\n                position.x = cos * x - sin * y + this.worldX;\r\n                position.y = sin * x + cos * y + this.worldY;\r\n            }\r\n        };\r\n        SwirlEffect.prototype.end = function () {\r\n        };\r\n        SwirlEffect.interpolation = new spine.PowOut(2);\r\n        return SwirlEffect;\r\n    }());\r\n    spine.SwirlEffect = SwirlEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var canvas;\r\n    (function (canvas) {\r\n        var AssetManager = (function (_super) {\r\n            __extends(AssetManager, _super);\r\n            function AssetManager(pathPrefix) {\r\n                if (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n                return _super.call(this, function (image) { return new spine.canvas.CanvasTexture(image); }, pathPrefix) || this;\r\n            }\r\n            return AssetManager;\r\n        }(spine.AssetManager));\r\n        canvas.AssetManager = AssetManager;\r\n    })(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var canvas;\r\n    (function (canvas) {\r\n        var CanvasTexture = (function (_super) {\r\n            __extends(CanvasTexture, _super);\r\n            function CanvasTexture(image) {\r\n                return _super.call(this, image) || this;\r\n            }\r\n            CanvasTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n            CanvasTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n            CanvasTexture.prototype.dispose = function () { };\r\n            return CanvasTexture;\r\n        }(spine.Texture));\r\n        canvas.CanvasTexture = CanvasTexture;\r\n    })(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var canvas;\r\n    (function (canvas) {\r\n        var SkeletonRenderer = (function () {\r\n            function SkeletonRenderer(context) {\r\n                this.triangleRendering = false;\r\n                this.debugRendering = false;\r\n                this.vertices = spine.Utils.newFloatArray(8 * 1024);\r\n                this.tempColor = new spine.Color();\r\n                this.ctx = context;\r\n            }\r\n            SkeletonRenderer.prototype.draw = function (skeleton) {\r\n                if (this.triangleRendering)\r\n                    this.drawTriangles(skeleton);\r\n                else\r\n                    this.drawImages(skeleton);\r\n            };\r\n            SkeletonRenderer.prototype.drawImages = function (skeleton) {\r\n                var ctx = this.ctx;\r\n                var drawOrder = skeleton.drawOrder;\r\n                if (this.debugRendering)\r\n                    ctx.strokeStyle = \"green\";\r\n                ctx.save();\r\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                    var slot = drawOrder[i];\r\n                    if (!slot.bone.active)\r\n                        continue;\r\n                    var attachment = slot.getAttachment();\r\n                    var regionAttachment = null;\r\n                    var region = null;\r\n                    var image = null;\r\n                    if (attachment instanceof spine.RegionAttachment) {\r\n                        regionAttachment = attachment;\r\n                        region = regionAttachment.region;\r\n                        image = region.texture.getImage();\r\n                    }\r\n                    else\r\n                        continue;\r\n                    var skeleton_1 = slot.bone.skeleton;\r\n                    var skeletonColor = skeleton_1.color;\r\n                    var slotColor = slot.color;\r\n                    var regionColor = regionAttachment.color;\r\n                    var alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n                    var color = this.tempColor;\r\n                    color.set(skeletonColor.r * slotColor.r * regionColor.r, skeletonColor.g * slotColor.g * regionColor.g, skeletonColor.b * slotColor.b * regionColor.b, alpha);\r\n                    var att = attachment;\r\n                    var bone = slot.bone;\r\n                    var w = region.width;\r\n                    var h = region.height;\r\n                    ctx.save();\r\n                    ctx.transform(bone.a, bone.c, bone.b, bone.d, bone.worldX, bone.worldY);\r\n                    ctx.translate(attachment.offset[0], attachment.offset[1]);\r\n                    ctx.rotate(attachment.rotation * Math.PI / 180);\r\n                    var atlasScale = att.width / w;\r\n                    ctx.scale(atlasScale * attachment.scaleX, atlasScale * attachment.scaleY);\r\n                    ctx.translate(w / 2, h / 2);\r\n                    if (attachment.region.rotate) {\r\n                        var t = w;\r\n                        w = h;\r\n                        h = t;\r\n                        ctx.rotate(-Math.PI / 2);\r\n                    }\r\n                    ctx.scale(1, -1);\r\n                    ctx.translate(-w / 2, -h / 2);\r\n                    if (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n                        ctx.globalAlpha = color.a;\r\n                    }\r\n                    ctx.drawImage(image, region.x, region.y, w, h, 0, 0, w, h);\r\n                    if (this.debugRendering)\r\n                        ctx.strokeRect(0, 0, w, h);\r\n                    ctx.restore();\r\n                }\r\n                ctx.restore();\r\n            };\r\n            SkeletonRenderer.prototype.drawTriangles = function (skeleton) {\r\n                var blendMode = null;\r\n                var vertices = this.vertices;\r\n                var triangles = null;\r\n                var drawOrder = skeleton.drawOrder;\r\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                    var slot = drawOrder[i];\r\n                    var attachment = slot.getAttachment();\r\n                    var texture = null;\r\n                    var region = null;\r\n                    if (attachment instanceof spine.RegionAttachment) {\r\n                        var regionAttachment = attachment;\r\n                        vertices = this.computeRegionVertices(slot, regionAttachment, false);\r\n                        triangles = SkeletonRenderer.QUAD_TRIANGLES;\r\n                        region = regionAttachment.region;\r\n                        texture = region.texture.getImage();\r\n                    }\r\n                    else if (attachment instanceof spine.MeshAttachment) {\r\n                        var mesh = attachment;\r\n                        vertices = this.computeMeshVertices(slot, mesh, false);\r\n                        triangles = mesh.triangles;\r\n                        texture = mesh.region.renderObject.texture.getImage();\r\n                    }\r\n                    else\r\n                        continue;\r\n                    if (texture != null) {\r\n                        var slotBlendMode = slot.data.blendMode;\r\n                        if (slotBlendMode != blendMode) {\r\n                            blendMode = slotBlendMode;\r\n                        }\r\n                        var skeleton_2 = slot.bone.skeleton;\r\n                        var skeletonColor = skeleton_2.color;\r\n                        var slotColor = slot.color;\r\n                        var attachmentColor = attachment.color;\r\n                        var alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n                        var color = this.tempColor;\r\n                        color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);\r\n                        var ctx = this.ctx;\r\n                        if (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n                            ctx.globalAlpha = color.a;\r\n                        }\r\n                        for (var j = 0; j < triangles.length; j += 3) {\r\n                            var t1 = triangles[j] * 8, t2 = triangles[j + 1] * 8, t3 = triangles[j + 2] * 8;\r\n                            var x0 = vertices[t1], y0 = vertices[t1 + 1], u0 = vertices[t1 + 6], v0 = vertices[t1 + 7];\r\n                            var x1 = vertices[t2], y1 = vertices[t2 + 1], u1 = vertices[t2 + 6], v1 = vertices[t2 + 7];\r\n                            var x2 = vertices[t3], y2 = vertices[t3 + 1], u2 = vertices[t3 + 6], v2 = vertices[t3 + 7];\r\n                            this.drawTriangle(texture, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2);\r\n                            if (this.debugRendering) {\r\n                                ctx.strokeStyle = \"green\";\r\n                                ctx.beginPath();\r\n                                ctx.moveTo(x0, y0);\r\n                                ctx.lineTo(x1, y1);\r\n                                ctx.lineTo(x2, y2);\r\n                                ctx.lineTo(x0, y0);\r\n                                ctx.stroke();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.ctx.globalAlpha = 1;\r\n            };\r\n            SkeletonRenderer.prototype.drawTriangle = function (img, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2) {\r\n                var ctx = this.ctx;\r\n                u0 *= img.width;\r\n                v0 *= img.height;\r\n                u1 *= img.width;\r\n                v1 *= img.height;\r\n                u2 *= img.width;\r\n                v2 *= img.height;\r\n                ctx.beginPath();\r\n                ctx.moveTo(x0, y0);\r\n                ctx.lineTo(x1, y1);\r\n                ctx.lineTo(x2, y2);\r\n                ctx.closePath();\r\n                x1 -= x0;\r\n                y1 -= y0;\r\n                x2 -= x0;\r\n                y2 -= y0;\r\n                u1 -= u0;\r\n                v1 -= v0;\r\n                u2 -= u0;\r\n                v2 -= v0;\r\n                var det = 1 / (u1 * v2 - u2 * v1), a = (v2 * x1 - v1 * x2) * det, b = (v2 * y1 - v1 * y2) * det, c = (u1 * x2 - u2 * x1) * det, d = (u1 * y2 - u2 * y1) * det, e = x0 - a * u0 - c * v0, f = y0 - b * u0 - d * v0;\r\n                ctx.save();\r\n                ctx.transform(a, b, c, d, e, f);\r\n                ctx.clip();\r\n                ctx.drawImage(img, 0, 0);\r\n                ctx.restore();\r\n            };\r\n            SkeletonRenderer.prototype.computeRegionVertices = function (slot, region, pma) {\r\n                var skeleton = slot.bone.skeleton;\r\n                var skeletonColor = skeleton.color;\r\n                var slotColor = slot.color;\r\n                var regionColor = region.color;\r\n                var alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n                var multiplier = pma ? alpha : 1;\r\n                var color = this.tempColor;\r\n                color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n                region.computeWorldVertices(slot.bone, this.vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n                var vertices = this.vertices;\r\n                var uvs = region.uvs;\r\n                vertices[spine.RegionAttachment.C1R] = color.r;\r\n                vertices[spine.RegionAttachment.C1G] = color.g;\r\n                vertices[spine.RegionAttachment.C1B] = color.b;\r\n                vertices[spine.RegionAttachment.C1A] = color.a;\r\n                vertices[spine.RegionAttachment.U1] = uvs[0];\r\n                vertices[spine.RegionAttachment.V1] = uvs[1];\r\n                vertices[spine.RegionAttachment.C2R] = color.r;\r\n                vertices[spine.RegionAttachment.C2G] = color.g;\r\n                vertices[spine.RegionAttachment.C2B] = color.b;\r\n                vertices[spine.RegionAttachment.C2A] = color.a;\r\n                vertices[spine.RegionAttachment.U2] = uvs[2];\r\n                vertices[spine.RegionAttachment.V2] = uvs[3];\r\n                vertices[spine.RegionAttachment.C3R] = color.r;\r\n                vertices[spine.RegionAttachment.C3G] = color.g;\r\n                vertices[spine.RegionAttachment.C3B] = color.b;\r\n                vertices[spine.RegionAttachment.C3A] = color.a;\r\n                vertices[spine.RegionAttachment.U3] = uvs[4];\r\n                vertices[spine.RegionAttachment.V3] = uvs[5];\r\n                vertices[spine.RegionAttachment.C4R] = color.r;\r\n                vertices[spine.RegionAttachment.C4G] = color.g;\r\n                vertices[spine.RegionAttachment.C4B] = color.b;\r\n                vertices[spine.RegionAttachment.C4A] = color.a;\r\n                vertices[spine.RegionAttachment.U4] = uvs[6];\r\n                vertices[spine.RegionAttachment.V4] = uvs[7];\r\n                return vertices;\r\n            };\r\n            SkeletonRenderer.prototype.computeMeshVertices = function (slot, mesh, pma) {\r\n                var skeleton = slot.bone.skeleton;\r\n                var skeletonColor = skeleton.color;\r\n                var slotColor = slot.color;\r\n                var regionColor = mesh.color;\r\n                var alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n                var multiplier = pma ? alpha : 1;\r\n                var color = this.tempColor;\r\n                color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n                var numVertices = mesh.worldVerticesLength / 2;\r\n                if (this.vertices.length < mesh.worldVerticesLength) {\r\n                    this.vertices = spine.Utils.newFloatArray(mesh.worldVerticesLength);\r\n                }\r\n                var vertices = this.vertices;\r\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n                var uvs = mesh.uvs;\r\n                for (var i = 0, n = numVertices, u = 0, v = 2; i < n; i++) {\r\n                    vertices[v++] = color.r;\r\n                    vertices[v++] = color.g;\r\n                    vertices[v++] = color.b;\r\n                    vertices[v++] = color.a;\r\n                    vertices[v++] = uvs[u++];\r\n                    vertices[v++] = uvs[u++];\r\n                    v += 2;\r\n                }\r\n                return vertices;\r\n            };\r\n            SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n            SkeletonRenderer.VERTEX_SIZE = 2 + 2 + 4;\r\n            return SkeletonRenderer;\r\n        }());\r\n        canvas.SkeletonRenderer = SkeletonRenderer;\r\n    })(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var AssetManager = (function (_super) {\r\n            __extends(AssetManager, _super);\r\n            function AssetManager(context, pathPrefix) {\r\n                if (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n                return _super.call(this, function (image) {\r\n                    return new spine.webgl.GLTexture(context, image);\r\n                }, pathPrefix) || this;\r\n            }\r\n            return AssetManager;\r\n        }(spine.AssetManager));\r\n        webgl.AssetManager = AssetManager;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var OrthoCamera = (function () {\r\n            function OrthoCamera(viewportWidth, viewportHeight) {\r\n                this.position = new webgl.Vector3(0, 0, 0);\r\n                this.direction = new webgl.Vector3(0, 0, -1);\r\n                this.up = new webgl.Vector3(0, 1, 0);\r\n                this.near = 0;\r\n                this.far = 100;\r\n                this.zoom = 1;\r\n                this.viewportWidth = 0;\r\n                this.viewportHeight = 0;\r\n                this.projectionView = new webgl.Matrix4();\r\n                this.inverseProjectionView = new webgl.Matrix4();\r\n                this.projection = new webgl.Matrix4();\r\n                this.view = new webgl.Matrix4();\r\n                this.tmp = new webgl.Vector3();\r\n                this.viewportWidth = viewportWidth;\r\n                this.viewportHeight = viewportHeight;\r\n                this.update();\r\n            }\r\n            OrthoCamera.prototype.update = function () {\r\n                var projection = this.projection;\r\n                var view = this.view;\r\n                var projectionView = this.projectionView;\r\n                var inverseProjectionView = this.inverseProjectionView;\r\n                var zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;\r\n                projection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);\r\n                view.lookAt(this.position, this.direction, this.up);\r\n                projectionView.set(projection.values);\r\n                projectionView.multiply(view);\r\n                inverseProjectionView.set(projectionView.values).invert();\r\n            };\r\n            OrthoCamera.prototype.screenToWorld = function (screenCoords, screenWidth, screenHeight) {\r\n                var x = screenCoords.x, y = screenHeight - screenCoords.y - 1;\r\n                var tmp = this.tmp;\r\n                tmp.x = (2 * x) / screenWidth - 1;\r\n                tmp.y = (2 * y) / screenHeight - 1;\r\n                tmp.z = (2 * screenCoords.z) - 1;\r\n                tmp.project(this.inverseProjectionView);\r\n                screenCoords.set(tmp.x, tmp.y, tmp.z);\r\n                return screenCoords;\r\n            };\r\n            OrthoCamera.prototype.setViewport = function (viewportWidth, viewportHeight) {\r\n                this.viewportWidth = viewportWidth;\r\n                this.viewportHeight = viewportHeight;\r\n            };\r\n            return OrthoCamera;\r\n        }());\r\n        webgl.OrthoCamera = OrthoCamera;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var GLTexture = (function (_super) {\r\n            __extends(GLTexture, _super);\r\n            function GLTexture(context, image, useMipMaps) {\r\n                if (useMipMaps === void 0) { useMipMaps = false; }\r\n                var _this = _super.call(this, image) || this;\r\n                _this.texture = null;\r\n                _this.boundUnit = 0;\r\n                _this.useMipMaps = false;\r\n                _this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                _this.useMipMaps = useMipMaps;\r\n                _this.restore();\r\n                _this.context.addRestorable(_this);\r\n                return _this;\r\n            }\r\n            GLTexture.prototype.setFilters = function (minFilter, magFilter) {\r\n                var gl = this.context.gl;\r\n                this.bind();\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, GLTexture.validateMagFilter(magFilter));\r\n            };\r\n            GLTexture.validateMagFilter = function (magFilter) {\r\n                switch (magFilter) {\r\n                    case spine.TextureFilter.MipMap:\r\n                    case spine.TextureFilter.MipMapLinearLinear:\r\n                    case spine.TextureFilter.MipMapLinearNearest:\r\n                    case spine.TextureFilter.MipMapNearestLinear:\r\n                    case spine.TextureFilter.MipMapNearestNearest:\r\n                        return spine.TextureFilter.Linear;\r\n                    default:\r\n                        return magFilter;\r\n                }\r\n            };\r\n            GLTexture.prototype.setWraps = function (uWrap, vWrap) {\r\n                var gl = this.context.gl;\r\n                this.bind();\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);\r\n            };\r\n            GLTexture.prototype.update = function (useMipMaps) {\r\n                var gl = this.context.gl;\r\n                if (!this.texture) {\r\n                    this.texture = this.context.gl.createTexture();\r\n                }\r\n                this.bind();\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n                if (useMipMaps)\r\n                    gl.generateMipmap(gl.TEXTURE_2D);\r\n            };\r\n            GLTexture.prototype.restore = function () {\r\n                this.texture = null;\r\n                this.update(this.useMipMaps);\r\n            };\r\n            GLTexture.prototype.bind = function (unit) {\r\n                if (unit === void 0) { unit = 0; }\r\n                var gl = this.context.gl;\r\n                this.boundUnit = unit;\r\n                gl.activeTexture(gl.TEXTURE0 + unit);\r\n                gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n            };\r\n            GLTexture.prototype.unbind = function () {\r\n                var gl = this.context.gl;\r\n                gl.activeTexture(gl.TEXTURE0 + this.boundUnit);\r\n                gl.bindTexture(gl.TEXTURE_2D, null);\r\n            };\r\n            GLTexture.prototype.dispose = function () {\r\n                this.context.removeRestorable(this);\r\n                var gl = this.context.gl;\r\n                gl.deleteTexture(this.texture);\r\n            };\r\n            return GLTexture;\r\n        }(spine.Texture));\r\n        webgl.GLTexture = GLTexture;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        webgl.M00 = 0;\r\n        webgl.M01 = 4;\r\n        webgl.M02 = 8;\r\n        webgl.M03 = 12;\r\n        webgl.M10 = 1;\r\n        webgl.M11 = 5;\r\n        webgl.M12 = 9;\r\n        webgl.M13 = 13;\r\n        webgl.M20 = 2;\r\n        webgl.M21 = 6;\r\n        webgl.M22 = 10;\r\n        webgl.M23 = 14;\r\n        webgl.M30 = 3;\r\n        webgl.M31 = 7;\r\n        webgl.M32 = 11;\r\n        webgl.M33 = 15;\r\n        var Matrix4 = (function () {\r\n            function Matrix4() {\r\n                this.temp = new Float32Array(16);\r\n                this.values = new Float32Array(16);\r\n                var v = this.values;\r\n                v[webgl.M00] = 1;\r\n                v[webgl.M11] = 1;\r\n                v[webgl.M22] = 1;\r\n                v[webgl.M33] = 1;\r\n            }\r\n            Matrix4.prototype.set = function (values) {\r\n                this.values.set(values);\r\n                return this;\r\n            };\r\n            Matrix4.prototype.transpose = function () {\r\n                var t = this.temp;\r\n                var v = this.values;\r\n                t[webgl.M00] = v[webgl.M00];\r\n                t[webgl.M01] = v[webgl.M10];\r\n                t[webgl.M02] = v[webgl.M20];\r\n                t[webgl.M03] = v[webgl.M30];\r\n                t[webgl.M10] = v[webgl.M01];\r\n                t[webgl.M11] = v[webgl.M11];\r\n                t[webgl.M12] = v[webgl.M21];\r\n                t[webgl.M13] = v[webgl.M31];\r\n                t[webgl.M20] = v[webgl.M02];\r\n                t[webgl.M21] = v[webgl.M12];\r\n                t[webgl.M22] = v[webgl.M22];\r\n                t[webgl.M23] = v[webgl.M32];\r\n                t[webgl.M30] = v[webgl.M03];\r\n                t[webgl.M31] = v[webgl.M13];\r\n                t[webgl.M32] = v[webgl.M23];\r\n                t[webgl.M33] = v[webgl.M33];\r\n                return this.set(t);\r\n            };\r\n            Matrix4.prototype.identity = function () {\r\n                var v = this.values;\r\n                v[webgl.M00] = 1;\r\n                v[webgl.M01] = 0;\r\n                v[webgl.M02] = 0;\r\n                v[webgl.M03] = 0;\r\n                v[webgl.M10] = 0;\r\n                v[webgl.M11] = 1;\r\n                v[webgl.M12] = 0;\r\n                v[webgl.M13] = 0;\r\n                v[webgl.M20] = 0;\r\n                v[webgl.M21] = 0;\r\n                v[webgl.M22] = 1;\r\n                v[webgl.M23] = 0;\r\n                v[webgl.M30] = 0;\r\n                v[webgl.M31] = 0;\r\n                v[webgl.M32] = 0;\r\n                v[webgl.M33] = 1;\r\n                return this;\r\n            };\r\n            Matrix4.prototype.invert = function () {\r\n                var v = this.values;\r\n                var t = this.temp;\r\n                var l_det = v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\r\n                    + v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\r\n                    - v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\r\n                    - v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\r\n                    + v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\r\n                    + v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\r\n                    - v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\r\n                    - v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n                if (l_det == 0)\r\n                    throw new Error(\"non-invertible matrix\");\r\n                var inv_det = 1.0 / l_det;\r\n                t[webgl.M00] = v[webgl.M12] * v[webgl.M23] * v[webgl.M31] - v[webgl.M13] * v[webgl.M22] * v[webgl.M31] + v[webgl.M13] * v[webgl.M21] * v[webgl.M32]\r\n                    - v[webgl.M11] * v[webgl.M23] * v[webgl.M32] - v[webgl.M12] * v[webgl.M21] * v[webgl.M33] + v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n                t[webgl.M01] = v[webgl.M03] * v[webgl.M22] * v[webgl.M31] - v[webgl.M02] * v[webgl.M23] * v[webgl.M31] - v[webgl.M03] * v[webgl.M21] * v[webgl.M32]\r\n                    + v[webgl.M01] * v[webgl.M23] * v[webgl.M32] + v[webgl.M02] * v[webgl.M21] * v[webgl.M33] - v[webgl.M01] * v[webgl.M22] * v[webgl.M33];\r\n                t[webgl.M02] = v[webgl.M02] * v[webgl.M13] * v[webgl.M31] - v[webgl.M03] * v[webgl.M12] * v[webgl.M31] + v[webgl.M03] * v[webgl.M11] * v[webgl.M32]\r\n                    - v[webgl.M01] * v[webgl.M13] * v[webgl.M32] - v[webgl.M02] * v[webgl.M11] * v[webgl.M33] + v[webgl.M01] * v[webgl.M12] * v[webgl.M33];\r\n                t[webgl.M03] = v[webgl.M03] * v[webgl.M12] * v[webgl.M21] - v[webgl.M02] * v[webgl.M13] * v[webgl.M21] - v[webgl.M03] * v[webgl.M11] * v[webgl.M22]\r\n                    + v[webgl.M01] * v[webgl.M13] * v[webgl.M22] + v[webgl.M02] * v[webgl.M11] * v[webgl.M23] - v[webgl.M01] * v[webgl.M12] * v[webgl.M23];\r\n                t[webgl.M10] = v[webgl.M13] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M20] * v[webgl.M32]\r\n                    + v[webgl.M10] * v[webgl.M23] * v[webgl.M32] + v[webgl.M12] * v[webgl.M20] * v[webgl.M33] - v[webgl.M10] * v[webgl.M22] * v[webgl.M33];\r\n                t[webgl.M11] = v[webgl.M02] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M22] * v[webgl.M30] + v[webgl.M03] * v[webgl.M20] * v[webgl.M32]\r\n                    - v[webgl.M00] * v[webgl.M23] * v[webgl.M32] - v[webgl.M02] * v[webgl.M20] * v[webgl.M33] + v[webgl.M00] * v[webgl.M22] * v[webgl.M33];\r\n                t[webgl.M12] = v[webgl.M03] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M10] * v[webgl.M32]\r\n                    + v[webgl.M00] * v[webgl.M13] * v[webgl.M32] + v[webgl.M02] * v[webgl.M10] * v[webgl.M33] - v[webgl.M00] * v[webgl.M12] * v[webgl.M33];\r\n                t[webgl.M13] = v[webgl.M02] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M12] * v[webgl.M20] + v[webgl.M03] * v[webgl.M10] * v[webgl.M22]\r\n                    - v[webgl.M00] * v[webgl.M13] * v[webgl.M22] - v[webgl.M02] * v[webgl.M10] * v[webgl.M23] + v[webgl.M00] * v[webgl.M12] * v[webgl.M23];\r\n                t[webgl.M20] = v[webgl.M11] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M21] * v[webgl.M30] + v[webgl.M13] * v[webgl.M20] * v[webgl.M31]\r\n                    - v[webgl.M10] * v[webgl.M23] * v[webgl.M31] - v[webgl.M11] * v[webgl.M20] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M33];\r\n                t[webgl.M21] = v[webgl.M03] * v[webgl.M21] * v[webgl.M30] - v[webgl.M01] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M20] * v[webgl.M31]\r\n                    + v[webgl.M00] * v[webgl.M23] * v[webgl.M31] + v[webgl.M01] * v[webgl.M20] * v[webgl.M33] - v[webgl.M00] * v[webgl.M21] * v[webgl.M33];\r\n                t[webgl.M22] = v[webgl.M01] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M11] * v[webgl.M30] + v[webgl.M03] * v[webgl.M10] * v[webgl.M31]\r\n                    - v[webgl.M00] * v[webgl.M13] * v[webgl.M31] - v[webgl.M01] * v[webgl.M10] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M33];\r\n                t[webgl.M23] = v[webgl.M03] * v[webgl.M11] * v[webgl.M20] - v[webgl.M01] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M10] * v[webgl.M21]\r\n                    + v[webgl.M00] * v[webgl.M13] * v[webgl.M21] + v[webgl.M01] * v[webgl.M10] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M23];\r\n                t[webgl.M30] = v[webgl.M12] * v[webgl.M21] * v[webgl.M30] - v[webgl.M11] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M20] * v[webgl.M31]\r\n                    + v[webgl.M10] * v[webgl.M22] * v[webgl.M31] + v[webgl.M11] * v[webgl.M20] * v[webgl.M32] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32];\r\n                t[webgl.M31] = v[webgl.M01] * v[webgl.M22] * v[webgl.M30] - v[webgl.M02] * v[webgl.M21] * v[webgl.M30] + v[webgl.M02] * v[webgl.M20] * v[webgl.M31]\r\n                    - v[webgl.M00] * v[webgl.M22] * v[webgl.M31] - v[webgl.M01] * v[webgl.M20] * v[webgl.M32] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32];\r\n                t[webgl.M32] = v[webgl.M02] * v[webgl.M11] * v[webgl.M30] - v[webgl.M01] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M10] * v[webgl.M31]\r\n                    + v[webgl.M00] * v[webgl.M12] * v[webgl.M31] + v[webgl.M01] * v[webgl.M10] * v[webgl.M32] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32];\r\n                t[webgl.M33] = v[webgl.M01] * v[webgl.M12] * v[webgl.M20] - v[webgl.M02] * v[webgl.M11] * v[webgl.M20] + v[webgl.M02] * v[webgl.M10] * v[webgl.M21]\r\n                    - v[webgl.M00] * v[webgl.M12] * v[webgl.M21] - v[webgl.M01] * v[webgl.M10] * v[webgl.M22] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22];\r\n                v[webgl.M00] = t[webgl.M00] * inv_det;\r\n                v[webgl.M01] = t[webgl.M01] * inv_det;\r\n                v[webgl.M02] = t[webgl.M02] * inv_det;\r\n                v[webgl.M03] = t[webgl.M03] * inv_det;\r\n                v[webgl.M10] = t[webgl.M10] * inv_det;\r\n                v[webgl.M11] = t[webgl.M11] * inv_det;\r\n                v[webgl.M12] = t[webgl.M12] * inv_det;\r\n                v[webgl.M13] = t[webgl.M13] * inv_det;\r\n                v[webgl.M20] = t[webgl.M20] * inv_det;\r\n                v[webgl.M21] = t[webgl.M21] * inv_det;\r\n                v[webgl.M22] = t[webgl.M22] * inv_det;\r\n                v[webgl.M23] = t[webgl.M23] * inv_det;\r\n                v[webgl.M30] = t[webgl.M30] * inv_det;\r\n                v[webgl.M31] = t[webgl.M31] * inv_det;\r\n                v[webgl.M32] = t[webgl.M32] * inv_det;\r\n                v[webgl.M33] = t[webgl.M33] * inv_det;\r\n                return this;\r\n            };\r\n            Matrix4.prototype.determinant = function () {\r\n                var v = this.values;\r\n                return v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\r\n                    + v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\r\n                    - v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\r\n                    - v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\r\n                    + v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\r\n                    + v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\r\n                    - v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\r\n                    - v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\r\n            };\r\n            Matrix4.prototype.translate = function (x, y, z) {\r\n                var v = this.values;\r\n                v[webgl.M03] += x;\r\n                v[webgl.M13] += y;\r\n                v[webgl.M23] += z;\r\n                return this;\r\n            };\r\n            Matrix4.prototype.copy = function () {\r\n                return new Matrix4().set(this.values);\r\n            };\r\n            Matrix4.prototype.projection = function (near, far, fovy, aspectRatio) {\r\n                this.identity();\r\n                var l_fd = (1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));\r\n                var l_a1 = (far + near) / (near - far);\r\n                var l_a2 = (2 * far * near) / (near - far);\r\n                var v = this.values;\r\n                v[webgl.M00] = l_fd / aspectRatio;\r\n                v[webgl.M10] = 0;\r\n                v[webgl.M20] = 0;\r\n                v[webgl.M30] = 0;\r\n                v[webgl.M01] = 0;\r\n                v[webgl.M11] = l_fd;\r\n                v[webgl.M21] = 0;\r\n                v[webgl.M31] = 0;\r\n                v[webgl.M02] = 0;\r\n                v[webgl.M12] = 0;\r\n                v[webgl.M22] = l_a1;\r\n                v[webgl.M32] = -1;\r\n                v[webgl.M03] = 0;\r\n                v[webgl.M13] = 0;\r\n                v[webgl.M23] = l_a2;\r\n                v[webgl.M33] = 0;\r\n                return this;\r\n            };\r\n            Matrix4.prototype.ortho2d = function (x, y, width, height) {\r\n                return this.ortho(x, x + width, y, y + height, 0, 1);\r\n            };\r\n            Matrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\r\n                this.identity();\r\n                var x_orth = 2 / (right - left);\r\n                var y_orth = 2 / (top - bottom);\r\n                var z_orth = -2 / (far - near);\r\n                var tx = -(right + left) / (right - left);\r\n                var ty = -(top + bottom) / (top - bottom);\r\n                var tz = -(far + near) / (far - near);\r\n                var v = this.values;\r\n                v[webgl.M00] = x_orth;\r\n                v[webgl.M10] = 0;\r\n                v[webgl.M20] = 0;\r\n                v[webgl.M30] = 0;\r\n                v[webgl.M01] = 0;\r\n                v[webgl.M11] = y_orth;\r\n                v[webgl.M21] = 0;\r\n                v[webgl.M31] = 0;\r\n                v[webgl.M02] = 0;\r\n                v[webgl.M12] = 0;\r\n                v[webgl.M22] = z_orth;\r\n                v[webgl.M32] = 0;\r\n                v[webgl.M03] = tx;\r\n                v[webgl.M13] = ty;\r\n                v[webgl.M23] = tz;\r\n                v[webgl.M33] = 1;\r\n                return this;\r\n            };\r\n            Matrix4.prototype.multiply = function (matrix) {\r\n                var t = this.temp;\r\n                var v = this.values;\r\n                var m = matrix.values;\r\n                t[webgl.M00] = v[webgl.M00] * m[webgl.M00] + v[webgl.M01] * m[webgl.M10] + v[webgl.M02] * m[webgl.M20] + v[webgl.M03] * m[webgl.M30];\r\n                t[webgl.M01] = v[webgl.M00] * m[webgl.M01] + v[webgl.M01] * m[webgl.M11] + v[webgl.M02] * m[webgl.M21] + v[webgl.M03] * m[webgl.M31];\r\n                t[webgl.M02] = v[webgl.M00] * m[webgl.M02] + v[webgl.M01] * m[webgl.M12] + v[webgl.M02] * m[webgl.M22] + v[webgl.M03] * m[webgl.M32];\r\n                t[webgl.M03] = v[webgl.M00] * m[webgl.M03] + v[webgl.M01] * m[webgl.M13] + v[webgl.M02] * m[webgl.M23] + v[webgl.M03] * m[webgl.M33];\r\n                t[webgl.M10] = v[webgl.M10] * m[webgl.M00] + v[webgl.M11] * m[webgl.M10] + v[webgl.M12] * m[webgl.M20] + v[webgl.M13] * m[webgl.M30];\r\n                t[webgl.M11] = v[webgl.M10] * m[webgl.M01] + v[webgl.M11] * m[webgl.M11] + v[webgl.M12] * m[webgl.M21] + v[webgl.M13] * m[webgl.M31];\r\n                t[webgl.M12] = v[webgl.M10] * m[webgl.M02] + v[webgl.M11] * m[webgl.M12] + v[webgl.M12] * m[webgl.M22] + v[webgl.M13] * m[webgl.M32];\r\n                t[webgl.M13] = v[webgl.M10] * m[webgl.M03] + v[webgl.M11] * m[webgl.M13] + v[webgl.M12] * m[webgl.M23] + v[webgl.M13] * m[webgl.M33];\r\n                t[webgl.M20] = v[webgl.M20] * m[webgl.M00] + v[webgl.M21] * m[webgl.M10] + v[webgl.M22] * m[webgl.M20] + v[webgl.M23] * m[webgl.M30];\r\n                t[webgl.M21] = v[webgl.M20] * m[webgl.M01] + v[webgl.M21] * m[webgl.M11] + v[webgl.M22] * m[webgl.M21] + v[webgl.M23] * m[webgl.M31];\r\n                t[webgl.M22] = v[webgl.M20] * m[webgl.M02] + v[webgl.M21] * m[webgl.M12] + v[webgl.M22] * m[webgl.M22] + v[webgl.M23] * m[webgl.M32];\r\n                t[webgl.M23] = v[webgl.M20] * m[webgl.M03] + v[webgl.M21] * m[webgl.M13] + v[webgl.M22] * m[webgl.M23] + v[webgl.M23] * m[webgl.M33];\r\n                t[webgl.M30] = v[webgl.M30] * m[webgl.M00] + v[webgl.M31] * m[webgl.M10] + v[webgl.M32] * m[webgl.M20] + v[webgl.M33] * m[webgl.M30];\r\n                t[webgl.M31] = v[webgl.M30] * m[webgl.M01] + v[webgl.M31] * m[webgl.M11] + v[webgl.M32] * m[webgl.M21] + v[webgl.M33] * m[webgl.M31];\r\n                t[webgl.M32] = v[webgl.M30] * m[webgl.M02] + v[webgl.M31] * m[webgl.M12] + v[webgl.M32] * m[webgl.M22] + v[webgl.M33] * m[webgl.M32];\r\n                t[webgl.M33] = v[webgl.M30] * m[webgl.M03] + v[webgl.M31] * m[webgl.M13] + v[webgl.M32] * m[webgl.M23] + v[webgl.M33] * m[webgl.M33];\r\n                return this.set(this.temp);\r\n            };\r\n            Matrix4.prototype.multiplyLeft = function (matrix) {\r\n                var t = this.temp;\r\n                var v = this.values;\r\n                var m = matrix.values;\r\n                t[webgl.M00] = m[webgl.M00] * v[webgl.M00] + m[webgl.M01] * v[webgl.M10] + m[webgl.M02] * v[webgl.M20] + m[webgl.M03] * v[webgl.M30];\r\n                t[webgl.M01] = m[webgl.M00] * v[webgl.M01] + m[webgl.M01] * v[webgl.M11] + m[webgl.M02] * v[webgl.M21] + m[webgl.M03] * v[webgl.M31];\r\n                t[webgl.M02] = m[webgl.M00] * v[webgl.M02] + m[webgl.M01] * v[webgl.M12] + m[webgl.M02] * v[webgl.M22] + m[webgl.M03] * v[webgl.M32];\r\n                t[webgl.M03] = m[webgl.M00] * v[webgl.M03] + m[webgl.M01] * v[webgl.M13] + m[webgl.M02] * v[webgl.M23] + m[webgl.M03] * v[webgl.M33];\r\n                t[webgl.M10] = m[webgl.M10] * v[webgl.M00] + m[webgl.M11] * v[webgl.M10] + m[webgl.M12] * v[webgl.M20] + m[webgl.M13] * v[webgl.M30];\r\n                t[webgl.M11] = m[webgl.M10] * v[webgl.M01] + m[webgl.M11] * v[webgl.M11] + m[webgl.M12] * v[webgl.M21] + m[webgl.M13] * v[webgl.M31];\r\n                t[webgl.M12] = m[webgl.M10] * v[webgl.M02] + m[webgl.M11] * v[webgl.M12] + m[webgl.M12] * v[webgl.M22] + m[webgl.M13] * v[webgl.M32];\r\n                t[webgl.M13] = m[webgl.M10] * v[webgl.M03] + m[webgl.M11] * v[webgl.M13] + m[webgl.M12] * v[webgl.M23] + m[webgl.M13] * v[webgl.M33];\r\n                t[webgl.M20] = m[webgl.M20] * v[webgl.M00] + m[webgl.M21] * v[webgl.M10] + m[webgl.M22] * v[webgl.M20] + m[webgl.M23] * v[webgl.M30];\r\n                t[webgl.M21] = m[webgl.M20] * v[webgl.M01] + m[webgl.M21] * v[webgl.M11] + m[webgl.M22] * v[webgl.M21] + m[webgl.M23] * v[webgl.M31];\r\n                t[webgl.M22] = m[webgl.M20] * v[webgl.M02] + m[webgl.M21] * v[webgl.M12] + m[webgl.M22] * v[webgl.M22] + m[webgl.M23] * v[webgl.M32];\r\n                t[webgl.M23] = m[webgl.M20] * v[webgl.M03] + m[webgl.M21] * v[webgl.M13] + m[webgl.M22] * v[webgl.M23] + m[webgl.M23] * v[webgl.M33];\r\n                t[webgl.M30] = m[webgl.M30] * v[webgl.M00] + m[webgl.M31] * v[webgl.M10] + m[webgl.M32] * v[webgl.M20] + m[webgl.M33] * v[webgl.M30];\r\n                t[webgl.M31] = m[webgl.M30] * v[webgl.M01] + m[webgl.M31] * v[webgl.M11] + m[webgl.M32] * v[webgl.M21] + m[webgl.M33] * v[webgl.M31];\r\n                t[webgl.M32] = m[webgl.M30] * v[webgl.M02] + m[webgl.M31] * v[webgl.M12] + m[webgl.M32] * v[webgl.M22] + m[webgl.M33] * v[webgl.M32];\r\n                t[webgl.M33] = m[webgl.M30] * v[webgl.M03] + m[webgl.M31] * v[webgl.M13] + m[webgl.M32] * v[webgl.M23] + m[webgl.M33] * v[webgl.M33];\r\n                return this.set(this.temp);\r\n            };\r\n            Matrix4.prototype.lookAt = function (position, direction, up) {\r\n                Matrix4.initTemps();\r\n                var xAxis = Matrix4.xAxis, yAxis = Matrix4.yAxis, zAxis = Matrix4.zAxis;\r\n                zAxis.setFrom(direction).normalize();\r\n                xAxis.setFrom(direction).normalize();\r\n                xAxis.cross(up).normalize();\r\n                yAxis.setFrom(xAxis).cross(zAxis).normalize();\r\n                this.identity();\r\n                var val = this.values;\r\n                val[webgl.M00] = xAxis.x;\r\n                val[webgl.M01] = xAxis.y;\r\n                val[webgl.M02] = xAxis.z;\r\n                val[webgl.M10] = yAxis.x;\r\n                val[webgl.M11] = yAxis.y;\r\n                val[webgl.M12] = yAxis.z;\r\n                val[webgl.M20] = -zAxis.x;\r\n                val[webgl.M21] = -zAxis.y;\r\n                val[webgl.M22] = -zAxis.z;\r\n                Matrix4.tmpMatrix.identity();\r\n                Matrix4.tmpMatrix.values[webgl.M03] = -position.x;\r\n                Matrix4.tmpMatrix.values[webgl.M13] = -position.y;\r\n                Matrix4.tmpMatrix.values[webgl.M23] = -position.z;\r\n                this.multiply(Matrix4.tmpMatrix);\r\n                return this;\r\n            };\r\n            Matrix4.initTemps = function () {\r\n                if (Matrix4.xAxis === null)\r\n                    Matrix4.xAxis = new webgl.Vector3();\r\n                if (Matrix4.yAxis === null)\r\n                    Matrix4.yAxis = new webgl.Vector3();\r\n                if (Matrix4.zAxis === null)\r\n                    Matrix4.zAxis = new webgl.Vector3();\r\n            };\r\n            Matrix4.xAxis = null;\r\n            Matrix4.yAxis = null;\r\n            Matrix4.zAxis = null;\r\n            Matrix4.tmpMatrix = new Matrix4();\r\n            return Matrix4;\r\n        }());\r\n        webgl.Matrix4 = Matrix4;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var Mesh = (function () {\r\n            function Mesh(context, attributes, maxVertices, maxIndices) {\r\n                this.attributes = attributes;\r\n                this.verticesLength = 0;\r\n                this.dirtyVertices = false;\r\n                this.indicesLength = 0;\r\n                this.dirtyIndices = false;\r\n                this.elementsPerVertex = 0;\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                this.elementsPerVertex = 0;\r\n                for (var i = 0; i < attributes.length; i++) {\r\n                    this.elementsPerVertex += attributes[i].numElements;\r\n                }\r\n                this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\r\n                this.indices = new Uint16Array(maxIndices);\r\n                this.context.addRestorable(this);\r\n            }\r\n            Mesh.prototype.getAttributes = function () { return this.attributes; };\r\n            Mesh.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex; };\r\n            Mesh.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex; };\r\n            Mesh.prototype.setVerticesLength = function (length) {\r\n                this.dirtyVertices = true;\r\n                this.verticesLength = length;\r\n            };\r\n            Mesh.prototype.getVertices = function () { return this.vertices; };\r\n            Mesh.prototype.maxIndices = function () { return this.indices.length; };\r\n            Mesh.prototype.numIndices = function () { return this.indicesLength; };\r\n            Mesh.prototype.setIndicesLength = function (length) {\r\n                this.dirtyIndices = true;\r\n                this.indicesLength = length;\r\n            };\r\n            Mesh.prototype.getIndices = function () { return this.indices; };\r\n            ;\r\n            Mesh.prototype.getVertexSizeInFloats = function () {\r\n                var size = 0;\r\n                for (var i = 0; i < this.attributes.length; i++) {\r\n                    var attribute = this.attributes[i];\r\n                    size += attribute.numElements;\r\n                }\r\n                return size;\r\n            };\r\n            Mesh.prototype.setVertices = function (vertices) {\r\n                this.dirtyVertices = true;\r\n                if (vertices.length > this.vertices.length)\r\n                    throw Error(\"Mesh can't store more than \" + this.maxVertices() + \" vertices\");\r\n                this.vertices.set(vertices, 0);\r\n                this.verticesLength = vertices.length;\r\n            };\r\n            Mesh.prototype.setIndices = function (indices) {\r\n                this.dirtyIndices = true;\r\n                if (indices.length > this.indices.length)\r\n                    throw Error(\"Mesh can't store more than \" + this.maxIndices() + \" indices\");\r\n                this.indices.set(indices, 0);\r\n                this.indicesLength = indices.length;\r\n            };\r\n            Mesh.prototype.draw = function (shader, primitiveType) {\r\n                this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\r\n            };\r\n            Mesh.prototype.drawWithOffset = function (shader, primitiveType, offset, count) {\r\n                var gl = this.context.gl;\r\n                if (this.dirtyVertices || this.dirtyIndices)\r\n                    this.update();\r\n                this.bind(shader);\r\n                if (this.indicesLength > 0) {\r\n                    gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\r\n                }\r\n                else {\r\n                    gl.drawArrays(primitiveType, offset, count);\r\n                }\r\n                this.unbind(shader);\r\n            };\r\n            Mesh.prototype.bind = function (shader) {\r\n                var gl = this.context.gl;\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n                var offset = 0;\r\n                for (var i = 0; i < this.attributes.length; i++) {\r\n                    var attrib = this.attributes[i];\r\n                    var location_1 = shader.getAttributeLocation(attrib.name);\r\n                    gl.enableVertexAttribArray(location_1);\r\n                    gl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\r\n                    offset += attrib.numElements;\r\n                }\r\n                if (this.indicesLength > 0)\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n            };\r\n            Mesh.prototype.unbind = function (shader) {\r\n                var gl = this.context.gl;\r\n                for (var i = 0; i < this.attributes.length; i++) {\r\n                    var attrib = this.attributes[i];\r\n                    var location_2 = shader.getAttributeLocation(attrib.name);\r\n                    gl.disableVertexAttribArray(location_2);\r\n                }\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n                if (this.indicesLength > 0)\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n            };\r\n            Mesh.prototype.update = function () {\r\n                var gl = this.context.gl;\r\n                if (this.dirtyVertices) {\r\n                    if (!this.verticesBuffer) {\r\n                        this.verticesBuffer = gl.createBuffer();\r\n                    }\r\n                    gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\r\n                    gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\r\n                    this.dirtyVertices = false;\r\n                }\r\n                if (this.dirtyIndices) {\r\n                    if (!this.indicesBuffer) {\r\n                        this.indicesBuffer = gl.createBuffer();\r\n                    }\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\r\n                    this.dirtyIndices = false;\r\n                }\r\n            };\r\n            Mesh.prototype.restore = function () {\r\n                this.verticesBuffer = null;\r\n                this.indicesBuffer = null;\r\n                this.update();\r\n            };\r\n            Mesh.prototype.dispose = function () {\r\n                this.context.removeRestorable(this);\r\n                var gl = this.context.gl;\r\n                gl.deleteBuffer(this.verticesBuffer);\r\n                gl.deleteBuffer(this.indicesBuffer);\r\n            };\r\n            return Mesh;\r\n        }());\r\n        webgl.Mesh = Mesh;\r\n        var VertexAttribute = (function () {\r\n            function VertexAttribute(name, type, numElements) {\r\n                this.name = name;\r\n                this.type = type;\r\n                this.numElements = numElements;\r\n            }\r\n            return VertexAttribute;\r\n        }());\r\n        webgl.VertexAttribute = VertexAttribute;\r\n        var Position2Attribute = (function (_super) {\r\n            __extends(Position2Attribute, _super);\r\n            function Position2Attribute() {\r\n                return _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 2) || this;\r\n            }\r\n            return Position2Attribute;\r\n        }(VertexAttribute));\r\n        webgl.Position2Attribute = Position2Attribute;\r\n        var Position3Attribute = (function (_super) {\r\n            __extends(Position3Attribute, _super);\r\n            function Position3Attribute() {\r\n                return _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 3) || this;\r\n            }\r\n            return Position3Attribute;\r\n        }(VertexAttribute));\r\n        webgl.Position3Attribute = Position3Attribute;\r\n        var TexCoordAttribute = (function (_super) {\r\n            __extends(TexCoordAttribute, _super);\r\n            function TexCoordAttribute(unit) {\r\n                if (unit === void 0) { unit = 0; }\r\n                return _super.call(this, webgl.Shader.TEXCOORDS + (unit == 0 ? \"\" : unit), VertexAttributeType.Float, 2) || this;\r\n            }\r\n            return TexCoordAttribute;\r\n        }(VertexAttribute));\r\n        webgl.TexCoordAttribute = TexCoordAttribute;\r\n        var ColorAttribute = (function (_super) {\r\n            __extends(ColorAttribute, _super);\r\n            function ColorAttribute() {\r\n                return _super.call(this, webgl.Shader.COLOR, VertexAttributeType.Float, 4) || this;\r\n            }\r\n            return ColorAttribute;\r\n        }(VertexAttribute));\r\n        webgl.ColorAttribute = ColorAttribute;\r\n        var Color2Attribute = (function (_super) {\r\n            __extends(Color2Attribute, _super);\r\n            function Color2Attribute() {\r\n                return _super.call(this, webgl.Shader.COLOR2, VertexAttributeType.Float, 4) || this;\r\n            }\r\n            return Color2Attribute;\r\n        }(VertexAttribute));\r\n        webgl.Color2Attribute = Color2Attribute;\r\n        var VertexAttributeType;\r\n        (function (VertexAttributeType) {\r\n            VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\r\n        })(VertexAttributeType = webgl.VertexAttributeType || (webgl.VertexAttributeType = {}));\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var PolygonBatcher = (function () {\r\n            function PolygonBatcher(context, twoColorTint, maxVertices) {\r\n                if (twoColorTint === void 0) { twoColorTint = true; }\r\n                if (maxVertices === void 0) { maxVertices = 10920; }\r\n                this.isDrawing = false;\r\n                this.shader = null;\r\n                this.lastTexture = null;\r\n                this.verticesLength = 0;\r\n                this.indicesLength = 0;\r\n                if (maxVertices > 10920)\r\n                    throw new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                var attributes = twoColorTint ?\r\n                    [new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute(), new webgl.Color2Attribute()] :\r\n                    [new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute()];\r\n                this.mesh = new webgl.Mesh(context, attributes, maxVertices, maxVertices * 3);\r\n                this.srcBlend = this.context.gl.SRC_ALPHA;\r\n                this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\r\n            }\r\n            PolygonBatcher.prototype.begin = function (shader) {\r\n                var gl = this.context.gl;\r\n                if (this.isDrawing)\r\n                    throw new Error(\"PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()\");\r\n                this.drawCalls = 0;\r\n                this.shader = shader;\r\n                this.lastTexture = null;\r\n                this.isDrawing = true;\r\n                gl.enable(gl.BLEND);\r\n                gl.blendFunc(this.srcBlend, this.dstBlend);\r\n            };\r\n            PolygonBatcher.prototype.setBlendMode = function (srcBlend, dstBlend) {\r\n                var gl = this.context.gl;\r\n                this.srcBlend = srcBlend;\r\n                this.dstBlend = dstBlend;\r\n                if (this.isDrawing) {\r\n                    this.flush();\r\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\r\n                }\r\n            };\r\n            PolygonBatcher.prototype.draw = function (texture, vertices, indices) {\r\n                if (texture != this.lastTexture) {\r\n                    this.flush();\r\n                    this.lastTexture = texture;\r\n                }\r\n                else if (this.verticesLength + vertices.length > this.mesh.getVertices().length ||\r\n                    this.indicesLength + indices.length > this.mesh.getIndices().length) {\r\n                    this.flush();\r\n                }\r\n                var indexStart = this.mesh.numVertices();\r\n                this.mesh.getVertices().set(vertices, this.verticesLength);\r\n                this.verticesLength += vertices.length;\r\n                this.mesh.setVerticesLength(this.verticesLength);\r\n                var indicesArray = this.mesh.getIndices();\r\n                for (var i = this.indicesLength, j = 0; j < indices.length; i++, j++)\r\n                    indicesArray[i] = indices[j] + indexStart;\r\n                this.indicesLength += indices.length;\r\n                this.mesh.setIndicesLength(this.indicesLength);\r\n            };\r\n            PolygonBatcher.prototype.flush = function () {\r\n                var gl = this.context.gl;\r\n                if (this.verticesLength == 0)\r\n                    return;\r\n                this.lastTexture.bind();\r\n                this.mesh.draw(this.shader, gl.TRIANGLES);\r\n                this.verticesLength = 0;\r\n                this.indicesLength = 0;\r\n                this.mesh.setVerticesLength(0);\r\n                this.mesh.setIndicesLength(0);\r\n                this.drawCalls++;\r\n            };\r\n            PolygonBatcher.prototype.end = function () {\r\n                var gl = this.context.gl;\r\n                if (!this.isDrawing)\r\n                    throw new Error(\"PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()\");\r\n                if (this.verticesLength > 0 || this.indicesLength > 0)\r\n                    this.flush();\r\n                this.shader = null;\r\n                this.lastTexture = null;\r\n                this.isDrawing = false;\r\n                gl.disable(gl.BLEND);\r\n            };\r\n            PolygonBatcher.prototype.getDrawCalls = function () { return this.drawCalls; };\r\n            PolygonBatcher.prototype.dispose = function () {\r\n                this.mesh.dispose();\r\n            };\r\n            return PolygonBatcher;\r\n        }());\r\n        webgl.PolygonBatcher = PolygonBatcher;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var SceneRenderer = (function () {\r\n            function SceneRenderer(canvas, context, twoColorTint) {\r\n                if (twoColorTint === void 0) { twoColorTint = true; }\r\n                this.twoColorTint = false;\r\n                this.activeRenderer = null;\r\n                this.QUAD = [\r\n                    0, 0, 1, 1, 1, 1, 0, 0,\r\n                    0, 0, 1, 1, 1, 1, 0, 0,\r\n                    0, 0, 1, 1, 1, 1, 0, 0,\r\n                    0, 0, 1, 1, 1, 1, 0, 0,\r\n                ];\r\n                this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n                this.WHITE = new spine.Color(1, 1, 1, 1);\r\n                this.canvas = canvas;\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                this.twoColorTint = twoColorTint;\r\n                this.camera = new webgl.OrthoCamera(canvas.width, canvas.height);\r\n                this.batcherShader = twoColorTint ? webgl.Shader.newTwoColoredTextured(this.context) : webgl.Shader.newColoredTextured(this.context);\r\n                this.batcher = new webgl.PolygonBatcher(this.context, twoColorTint);\r\n                this.shapesShader = webgl.Shader.newColored(this.context);\r\n                this.shapes = new webgl.ShapeRenderer(this.context);\r\n                this.skeletonRenderer = new webgl.SkeletonRenderer(this.context, twoColorTint);\r\n                this.skeletonDebugRenderer = new webgl.SkeletonDebugRenderer(this.context);\r\n            }\r\n            SceneRenderer.prototype.begin = function () {\r\n                this.camera.update();\r\n                this.enableRenderer(this.batcher);\r\n            };\r\n            SceneRenderer.prototype.drawSkeleton = function (skeleton, premultipliedAlpha, slotRangeStart, slotRangeEnd) {\r\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n                if (slotRangeStart === void 0) { slotRangeStart = -1; }\r\n                if (slotRangeEnd === void 0) { slotRangeEnd = -1; }\r\n                this.enableRenderer(this.batcher);\r\n                this.skeletonRenderer.premultipliedAlpha = premultipliedAlpha;\r\n                this.skeletonRenderer.draw(this.batcher, skeleton, slotRangeStart, slotRangeEnd);\r\n            };\r\n            SceneRenderer.prototype.drawSkeletonDebug = function (skeleton, premultipliedAlpha, ignoredBones) {\r\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n                if (ignoredBones === void 0) { ignoredBones = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha;\r\n                this.skeletonDebugRenderer.draw(this.shapes, skeleton, ignoredBones);\r\n            };\r\n            SceneRenderer.prototype.drawTexture = function (texture, x, y, width, height, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.batcher);\r\n                if (color === null)\r\n                    color = this.WHITE;\r\n                var quad = this.QUAD;\r\n                var i = 0;\r\n                quad[i++] = x;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 0;\r\n                quad[i++] = 1;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 1;\r\n                quad[i++] = 1;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 1;\r\n                quad[i++] = 0;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 0;\r\n                quad[i++] = 0;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n            };\r\n            SceneRenderer.prototype.drawTextureUV = function (texture, x, y, width, height, u, v, u2, v2, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.batcher);\r\n                if (color === null)\r\n                    color = this.WHITE;\r\n                var quad = this.QUAD;\r\n                var i = 0;\r\n                quad[i++] = x;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = u;\r\n                quad[i++] = v;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = u2;\r\n                quad[i++] = v;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = u2;\r\n                quad[i++] = v2;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = u;\r\n                quad[i++] = v2;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n            };\r\n            SceneRenderer.prototype.drawTextureRotated = function (texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {\r\n                if (color === void 0) { color = null; }\r\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n                this.enableRenderer(this.batcher);\r\n                if (color === null)\r\n                    color = this.WHITE;\r\n                var quad = this.QUAD;\r\n                var worldOriginX = x + pivotX;\r\n                var worldOriginY = y + pivotY;\r\n                var fx = -pivotX;\r\n                var fy = -pivotY;\r\n                var fx2 = width - pivotX;\r\n                var fy2 = height - pivotY;\r\n                var p1x = fx;\r\n                var p1y = fy;\r\n                var p2x = fx;\r\n                var p2y = fy2;\r\n                var p3x = fx2;\r\n                var p3y = fy2;\r\n                var p4x = fx2;\r\n                var p4y = fy;\r\n                var x1 = 0;\r\n                var y1 = 0;\r\n                var x2 = 0;\r\n                var y2 = 0;\r\n                var x3 = 0;\r\n                var y3 = 0;\r\n                var x4 = 0;\r\n                var y4 = 0;\r\n                if (angle != 0) {\r\n                    var cos = spine.MathUtils.cosDeg(angle);\r\n                    var sin = spine.MathUtils.sinDeg(angle);\r\n                    x1 = cos * p1x - sin * p1y;\r\n                    y1 = sin * p1x + cos * p1y;\r\n                    x4 = cos * p2x - sin * p2y;\r\n                    y4 = sin * p2x + cos * p2y;\r\n                    x3 = cos * p3x - sin * p3y;\r\n                    y3 = sin * p3x + cos * p3y;\r\n                    x2 = x3 + (x1 - x4);\r\n                    y2 = y3 + (y1 - y4);\r\n                }\r\n                else {\r\n                    x1 = p1x;\r\n                    y1 = p1y;\r\n                    x4 = p2x;\r\n                    y4 = p2y;\r\n                    x3 = p3x;\r\n                    y3 = p3y;\r\n                    x2 = p4x;\r\n                    y2 = p4y;\r\n                }\r\n                x1 += worldOriginX;\r\n                y1 += worldOriginY;\r\n                x2 += worldOriginX;\r\n                y2 += worldOriginY;\r\n                x3 += worldOriginX;\r\n                y3 += worldOriginY;\r\n                x4 += worldOriginX;\r\n                y4 += worldOriginY;\r\n                var i = 0;\r\n                quad[i++] = x1;\r\n                quad[i++] = y1;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 0;\r\n                quad[i++] = 1;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x2;\r\n                quad[i++] = y2;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 1;\r\n                quad[i++] = 1;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x3;\r\n                quad[i++] = y3;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 1;\r\n                quad[i++] = 0;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x4;\r\n                quad[i++] = y4;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = 0;\r\n                quad[i++] = 0;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\r\n            };\r\n            SceneRenderer.prototype.drawRegion = function (region, x, y, width, height, color, premultipliedAlpha) {\r\n                if (color === void 0) { color = null; }\r\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n                this.enableRenderer(this.batcher);\r\n                if (color === null)\r\n                    color = this.WHITE;\r\n                var quad = this.QUAD;\r\n                var i = 0;\r\n                quad[i++] = x;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = region.u;\r\n                quad[i++] = region.v2;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = region.u2;\r\n                quad[i++] = region.v2;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x + width;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = region.u2;\r\n                quad[i++] = region.v;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                quad[i++] = x;\r\n                quad[i++] = y + height;\r\n                quad[i++] = color.r;\r\n                quad[i++] = color.g;\r\n                quad[i++] = color.b;\r\n                quad[i++] = color.a;\r\n                quad[i++] = region.u;\r\n                quad[i++] = region.v;\r\n                if (this.twoColorTint) {\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                    quad[i++] = 0;\r\n                }\r\n                this.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);\r\n            };\r\n            SceneRenderer.prototype.line = function (x, y, x2, y2, color, color2) {\r\n                if (color === void 0) { color = null; }\r\n                if (color2 === void 0) { color2 = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.line(x, y, x2, y2, color);\r\n            };\r\n            SceneRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\r\n                if (color === void 0) { color = null; }\r\n                if (color2 === void 0) { color2 = null; }\r\n                if (color3 === void 0) { color3 = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);\r\n            };\r\n            SceneRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\r\n                if (color === void 0) { color = null; }\r\n                if (color2 === void 0) { color2 = null; }\r\n                if (color3 === void 0) { color3 = null; }\r\n                if (color4 === void 0) { color4 = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);\r\n            };\r\n            SceneRenderer.prototype.rect = function (filled, x, y, width, height, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.rect(filled, x, y, width, height, color);\r\n            };\r\n            SceneRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.rectLine(filled, x1, y1, x2, y2, width, color);\r\n            };\r\n            SceneRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.polygon(polygonVertices, offset, count, color);\r\n            };\r\n            SceneRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\r\n                if (color === void 0) { color = null; }\r\n                if (segments === void 0) { segments = 0; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.circle(filled, x, y, radius, color, segments);\r\n            };\r\n            SceneRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.enableRenderer(this.shapes);\r\n                this.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);\r\n            };\r\n            SceneRenderer.prototype.end = function () {\r\n                if (this.activeRenderer === this.batcher)\r\n                    this.batcher.end();\r\n                else if (this.activeRenderer === this.shapes)\r\n                    this.shapes.end();\r\n                this.activeRenderer = null;\r\n            };\r\n            SceneRenderer.prototype.resize = function (resizeMode) {\r\n                var canvas = this.canvas;\r\n                var w = canvas.clientWidth;\r\n                var h = canvas.clientHeight;\r\n                if (canvas.width != w || canvas.height != h) {\r\n                    canvas.width = w;\r\n                    canvas.height = h;\r\n                }\r\n                this.context.gl.viewport(0, 0, canvas.width, canvas.height);\r\n                if (resizeMode === ResizeMode.Stretch) {\r\n                }\r\n                else if (resizeMode === ResizeMode.Expand) {\r\n                    this.camera.setViewport(w, h);\r\n                }\r\n                else if (resizeMode === ResizeMode.Fit) {\r\n                    var sourceWidth = canvas.width, sourceHeight = canvas.height;\r\n                    var targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight;\r\n                    var targetRatio = targetHeight / targetWidth;\r\n                    var sourceRatio = sourceHeight / sourceWidth;\r\n                    var scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;\r\n                    this.camera.viewportWidth = sourceWidth * scale;\r\n                    this.camera.viewportHeight = sourceHeight * scale;\r\n                }\r\n                this.camera.update();\r\n            };\r\n            SceneRenderer.prototype.enableRenderer = function (renderer) {\r\n                if (this.activeRenderer === renderer)\r\n                    return;\r\n                this.end();\r\n                if (renderer instanceof webgl.PolygonBatcher) {\r\n                    this.batcherShader.bind();\r\n                    this.batcherShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\r\n                    this.batcherShader.setUniformi(\"u_texture\", 0);\r\n                    this.batcher.begin(this.batcherShader);\r\n                    this.activeRenderer = this.batcher;\r\n                }\r\n                else if (renderer instanceof webgl.ShapeRenderer) {\r\n                    this.shapesShader.bind();\r\n                    this.shapesShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\r\n                    this.shapes.begin(this.shapesShader);\r\n                    this.activeRenderer = this.shapes;\r\n                }\r\n                else {\r\n                    this.activeRenderer = this.skeletonDebugRenderer;\r\n                }\r\n            };\r\n            SceneRenderer.prototype.dispose = function () {\r\n                this.batcher.dispose();\r\n                this.batcherShader.dispose();\r\n                this.shapes.dispose();\r\n                this.shapesShader.dispose();\r\n                this.skeletonDebugRenderer.dispose();\r\n            };\r\n            return SceneRenderer;\r\n        }());\r\n        webgl.SceneRenderer = SceneRenderer;\r\n        var ResizeMode;\r\n        (function (ResizeMode) {\r\n            ResizeMode[ResizeMode[\"Stretch\"] = 0] = \"Stretch\";\r\n            ResizeMode[ResizeMode[\"Expand\"] = 1] = \"Expand\";\r\n            ResizeMode[ResizeMode[\"Fit\"] = 2] = \"Fit\";\r\n        })(ResizeMode = webgl.ResizeMode || (webgl.ResizeMode = {}));\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var Shader = (function () {\r\n            function Shader(context, vertexShader, fragmentShader) {\r\n                this.vertexShader = vertexShader;\r\n                this.fragmentShader = fragmentShader;\r\n                this.vs = null;\r\n                this.fs = null;\r\n                this.program = null;\r\n                this.tmp2x2 = new Float32Array(2 * 2);\r\n                this.tmp3x3 = new Float32Array(3 * 3);\r\n                this.tmp4x4 = new Float32Array(4 * 4);\r\n                this.vsSource = vertexShader;\r\n                this.fsSource = fragmentShader;\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                this.context.addRestorable(this);\r\n                this.compile();\r\n            }\r\n            Shader.prototype.getProgram = function () { return this.program; };\r\n            Shader.prototype.getVertexShader = function () { return this.vertexShader; };\r\n            Shader.prototype.getFragmentShader = function () { return this.fragmentShader; };\r\n            Shader.prototype.getVertexShaderSource = function () { return this.vsSource; };\r\n            Shader.prototype.getFragmentSource = function () { return this.fsSource; };\r\n            Shader.prototype.compile = function () {\r\n                var gl = this.context.gl;\r\n                try {\r\n                    this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\r\n                    this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\r\n                    this.program = this.compileProgram(this.vs, this.fs);\r\n                }\r\n                catch (e) {\r\n                    this.dispose();\r\n                    throw e;\r\n                }\r\n            };\r\n            Shader.prototype.compileShader = function (type, source) {\r\n                var gl = this.context.gl;\r\n                var shader = gl.createShader(type);\r\n                gl.shaderSource(shader, source);\r\n                gl.compileShader(shader);\r\n                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n                    var error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\r\n                    gl.deleteShader(shader);\r\n                    if (!gl.isContextLost())\r\n                        throw new Error(error);\r\n                }\r\n                return shader;\r\n            };\r\n            Shader.prototype.compileProgram = function (vs, fs) {\r\n                var gl = this.context.gl;\r\n                var program = gl.createProgram();\r\n                gl.attachShader(program, vs);\r\n                gl.attachShader(program, fs);\r\n                gl.linkProgram(program);\r\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n                    var error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\r\n                    gl.deleteProgram(program);\r\n                    if (!gl.isContextLost())\r\n                        throw new Error(error);\r\n                }\r\n                return program;\r\n            };\r\n            Shader.prototype.restore = function () {\r\n                this.compile();\r\n            };\r\n            Shader.prototype.bind = function () {\r\n                this.context.gl.useProgram(this.program);\r\n            };\r\n            Shader.prototype.unbind = function () {\r\n                this.context.gl.useProgram(null);\r\n            };\r\n            Shader.prototype.setUniformi = function (uniform, value) {\r\n                this.context.gl.uniform1i(this.getUniformLocation(uniform), value);\r\n            };\r\n            Shader.prototype.setUniformf = function (uniform, value) {\r\n                this.context.gl.uniform1f(this.getUniformLocation(uniform), value);\r\n            };\r\n            Shader.prototype.setUniform2f = function (uniform, value, value2) {\r\n                this.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);\r\n            };\r\n            Shader.prototype.setUniform3f = function (uniform, value, value2, value3) {\r\n                this.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\r\n            };\r\n            Shader.prototype.setUniform4f = function (uniform, value, value2, value3, value4) {\r\n                this.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\r\n            };\r\n            Shader.prototype.setUniform2x2f = function (uniform, value) {\r\n                var gl = this.context.gl;\r\n                this.tmp2x2.set(value);\r\n                gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\r\n            };\r\n            Shader.prototype.setUniform3x3f = function (uniform, value) {\r\n                var gl = this.context.gl;\r\n                this.tmp3x3.set(value);\r\n                gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\r\n            };\r\n            Shader.prototype.setUniform4x4f = function (uniform, value) {\r\n                var gl = this.context.gl;\r\n                this.tmp4x4.set(value);\r\n                gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\r\n            };\r\n            Shader.prototype.getUniformLocation = function (uniform) {\r\n                var gl = this.context.gl;\r\n                var location = gl.getUniformLocation(this.program, uniform);\r\n                if (!location && !gl.isContextLost())\r\n                    throw new Error(\"Couldn't find location for uniform \" + uniform);\r\n                return location;\r\n            };\r\n            Shader.prototype.getAttributeLocation = function (attribute) {\r\n                var gl = this.context.gl;\r\n                var location = gl.getAttribLocation(this.program, attribute);\r\n                if (location == -1 && !gl.isContextLost())\r\n                    throw new Error(\"Couldn't find location for attribute \" + attribute);\r\n                return location;\r\n            };\r\n            Shader.prototype.dispose = function () {\r\n                this.context.removeRestorable(this);\r\n                var gl = this.context.gl;\r\n                if (this.vs) {\r\n                    gl.deleteShader(this.vs);\r\n                    this.vs = null;\r\n                }\r\n                if (this.fs) {\r\n                    gl.deleteShader(this.fs);\r\n                    this.fs = null;\r\n                }\r\n                if (this.program) {\r\n                    gl.deleteProgram(this.program);\r\n                    this.program = null;\r\n                }\r\n            };\r\n            Shader.newColoredTextured = function (context) {\r\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                return new Shader(context, vs, fs);\r\n            };\r\n            Shader.newTwoColoredTextured = function (context) {\r\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_light;\\n\\t\\t\\t\\tvarying vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_light = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_dark = \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_light;\\n\\t\\t\\t\\tvarying LOWP vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tvec4 texColor = texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t\\tgl_FragColor.a = texColor.a * v_light.a;\\n\\t\\t\\t\\t\\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                return new Shader(context, vs, fs);\r\n            };\r\n            Shader.newColored = function (context) {\r\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\r\n                return new Shader(context, vs, fs);\r\n            };\r\n            Shader.MVP_MATRIX = \"u_projTrans\";\r\n            Shader.POSITION = \"a_position\";\r\n            Shader.COLOR = \"a_color\";\r\n            Shader.COLOR2 = \"a_color2\";\r\n            Shader.TEXCOORDS = \"a_texCoords\";\r\n            Shader.SAMPLER = \"u_texture\";\r\n            return Shader;\r\n        }());\r\n        webgl.Shader = Shader;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var ShapeRenderer = (function () {\r\n            function ShapeRenderer(context, maxVertices) {\r\n                if (maxVertices === void 0) { maxVertices = 10920; }\r\n                this.isDrawing = false;\r\n                this.shapeType = ShapeType.Filled;\r\n                this.color = new spine.Color(1, 1, 1, 1);\r\n                this.vertexIndex = 0;\r\n                this.tmp = new spine.Vector2();\r\n                if (maxVertices > 10920)\r\n                    throw new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n                this.mesh = new webgl.Mesh(context, [new webgl.Position2Attribute(), new webgl.ColorAttribute()], maxVertices, 0);\r\n                this.srcBlend = this.context.gl.SRC_ALPHA;\r\n                this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\r\n            }\r\n            ShapeRenderer.prototype.begin = function (shader) {\r\n                if (this.isDrawing)\r\n                    throw new Error(\"ShapeRenderer.begin() has already been called\");\r\n                this.shader = shader;\r\n                this.vertexIndex = 0;\r\n                this.isDrawing = true;\r\n                var gl = this.context.gl;\r\n                gl.enable(gl.BLEND);\r\n                gl.blendFunc(this.srcBlend, this.dstBlend);\r\n            };\r\n            ShapeRenderer.prototype.setBlendMode = function (srcBlend, dstBlend) {\r\n                var gl = this.context.gl;\r\n                this.srcBlend = srcBlend;\r\n                this.dstBlend = dstBlend;\r\n                if (this.isDrawing) {\r\n                    this.flush();\r\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.setColor = function (color) {\r\n                this.color.setFromColor(color);\r\n            };\r\n            ShapeRenderer.prototype.setColorWith = function (r, g, b, a) {\r\n                this.color.set(r, g, b, a);\r\n            };\r\n            ShapeRenderer.prototype.point = function (x, y, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.check(ShapeType.Point, 1);\r\n                if (color === null)\r\n                    color = this.color;\r\n                this.vertex(x, y, color);\r\n            };\r\n            ShapeRenderer.prototype.line = function (x, y, x2, y2, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.check(ShapeType.Line, 2);\r\n                var vertices = this.mesh.getVertices();\r\n                var idx = this.vertexIndex;\r\n                if (color === null)\r\n                    color = this.color;\r\n                this.vertex(x, y, color);\r\n                this.vertex(x2, y2, color);\r\n            };\r\n            ShapeRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\r\n                if (color === void 0) { color = null; }\r\n                if (color2 === void 0) { color2 = null; }\r\n                if (color3 === void 0) { color3 = null; }\r\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\r\n                var vertices = this.mesh.getVertices();\r\n                var idx = this.vertexIndex;\r\n                if (color === null)\r\n                    color = this.color;\r\n                if (color2 === null)\r\n                    color2 = this.color;\r\n                if (color3 === null)\r\n                    color3 = this.color;\r\n                if (filled) {\r\n                    this.vertex(x, y, color);\r\n                    this.vertex(x2, y2, color2);\r\n                    this.vertex(x3, y3, color3);\r\n                }\r\n                else {\r\n                    this.vertex(x, y, color);\r\n                    this.vertex(x2, y2, color2);\r\n                    this.vertex(x2, y2, color);\r\n                    this.vertex(x3, y3, color2);\r\n                    this.vertex(x3, y3, color);\r\n                    this.vertex(x, y, color2);\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\r\n                if (color === void 0) { color = null; }\r\n                if (color2 === void 0) { color2 = null; }\r\n                if (color3 === void 0) { color3 = null; }\r\n                if (color4 === void 0) { color4 = null; }\r\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\r\n                var vertices = this.mesh.getVertices();\r\n                var idx = this.vertexIndex;\r\n                if (color === null)\r\n                    color = this.color;\r\n                if (color2 === null)\r\n                    color2 = this.color;\r\n                if (color3 === null)\r\n                    color3 = this.color;\r\n                if (color4 === null)\r\n                    color4 = this.color;\r\n                if (filled) {\r\n                    this.vertex(x, y, color);\r\n                    this.vertex(x2, y2, color2);\r\n                    this.vertex(x3, y3, color3);\r\n                    this.vertex(x3, y3, color3);\r\n                    this.vertex(x4, y4, color4);\r\n                    this.vertex(x, y, color);\r\n                }\r\n                else {\r\n                    this.vertex(x, y, color);\r\n                    this.vertex(x2, y2, color2);\r\n                    this.vertex(x2, y2, color2);\r\n                    this.vertex(x3, y3, color3);\r\n                    this.vertex(x3, y3, color3);\r\n                    this.vertex(x4, y4, color4);\r\n                    this.vertex(x4, y4, color4);\r\n                    this.vertex(x, y, color);\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.rect = function (filled, x, y, width, height, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);\r\n            };\r\n            ShapeRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 8);\r\n                if (color === null)\r\n                    color = this.color;\r\n                var t = this.tmp.set(y2 - y1, x1 - x2);\r\n                t.normalize();\r\n                width *= 0.5;\r\n                var tx = t.x * width;\r\n                var ty = t.y * width;\r\n                if (!filled) {\r\n                    this.vertex(x1 + tx, y1 + ty, color);\r\n                    this.vertex(x1 - tx, y1 - ty, color);\r\n                    this.vertex(x2 + tx, y2 + ty, color);\r\n                    this.vertex(x2 - tx, y2 - ty, color);\r\n                    this.vertex(x2 + tx, y2 + ty, color);\r\n                    this.vertex(x1 + tx, y1 + ty, color);\r\n                    this.vertex(x2 - tx, y2 - ty, color);\r\n                    this.vertex(x1 - tx, y1 - ty, color);\r\n                }\r\n                else {\r\n                    this.vertex(x1 + tx, y1 + ty, color);\r\n                    this.vertex(x1 - tx, y1 - ty, color);\r\n                    this.vertex(x2 + tx, y2 + ty, color);\r\n                    this.vertex(x2 - tx, y2 - ty, color);\r\n                    this.vertex(x2 + tx, y2 + ty, color);\r\n                    this.vertex(x1 - tx, y1 - ty, color);\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.x = function (x, y, size) {\r\n                this.line(x - size, y - size, x + size, y + size);\r\n                this.line(x - size, y + size, x + size, y - size);\r\n            };\r\n            ShapeRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\r\n                if (color === void 0) { color = null; }\r\n                if (count < 3)\r\n                    throw new Error(\"Polygon must contain at least 3 vertices\");\r\n                this.check(ShapeType.Line, count * 2);\r\n                if (color === null)\r\n                    color = this.color;\r\n                var vertices = this.mesh.getVertices();\r\n                var idx = this.vertexIndex;\r\n                offset <<= 1;\r\n                count <<= 1;\r\n                var firstX = polygonVertices[offset];\r\n                var firstY = polygonVertices[offset + 1];\r\n                var last = offset + count;\r\n                for (var i = offset, n = offset + count - 2; i < n; i += 2) {\r\n                    var x1 = polygonVertices[i];\r\n                    var y1 = polygonVertices[i + 1];\r\n                    var x2 = 0;\r\n                    var y2 = 0;\r\n                    if (i + 2 >= last) {\r\n                        x2 = firstX;\r\n                        y2 = firstY;\r\n                    }\r\n                    else {\r\n                        x2 = polygonVertices[i + 2];\r\n                        y2 = polygonVertices[i + 3];\r\n                    }\r\n                    this.vertex(x1, y1, color);\r\n                    this.vertex(x2, y2, color);\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\r\n                if (color === void 0) { color = null; }\r\n                if (segments === void 0) { segments = 0; }\r\n                if (segments === 0)\r\n                    segments = Math.max(1, (6 * spine.MathUtils.cbrt(radius)) | 0);\r\n                if (segments <= 0)\r\n                    throw new Error(\"segments must be > 0.\");\r\n                if (color === null)\r\n                    color = this.color;\r\n                var angle = 2 * spine.MathUtils.PI / segments;\r\n                var cos = Math.cos(angle);\r\n                var sin = Math.sin(angle);\r\n                var cx = radius, cy = 0;\r\n                if (!filled) {\r\n                    this.check(ShapeType.Line, segments * 2 + 2);\r\n                    for (var i = 0; i < segments; i++) {\r\n                        this.vertex(x + cx, y + cy, color);\r\n                        var temp_1 = cx;\r\n                        cx = cos * cx - sin * cy;\r\n                        cy = sin * temp_1 + cos * cy;\r\n                        this.vertex(x + cx, y + cy, color);\r\n                    }\r\n                    this.vertex(x + cx, y + cy, color);\r\n                }\r\n                else {\r\n                    this.check(ShapeType.Filled, segments * 3 + 3);\r\n                    segments--;\r\n                    for (var i = 0; i < segments; i++) {\r\n                        this.vertex(x, y, color);\r\n                        this.vertex(x + cx, y + cy, color);\r\n                        var temp_2 = cx;\r\n                        cx = cos * cx - sin * cy;\r\n                        cy = sin * temp_2 + cos * cy;\r\n                        this.vertex(x + cx, y + cy, color);\r\n                    }\r\n                    this.vertex(x, y, color);\r\n                    this.vertex(x + cx, y + cy, color);\r\n                }\r\n                var temp = cx;\r\n                cx = radius;\r\n                cy = 0;\r\n                this.vertex(x + cx, y + cy, color);\r\n            };\r\n            ShapeRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\r\n                if (color === void 0) { color = null; }\r\n                this.check(ShapeType.Line, segments * 2 + 2);\r\n                if (color === null)\r\n                    color = this.color;\r\n                var subdiv_step = 1 / segments;\r\n                var subdiv_step2 = subdiv_step * subdiv_step;\r\n                var subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\r\n                var pre1 = 3 * subdiv_step;\r\n                var pre2 = 3 * subdiv_step2;\r\n                var pre4 = 6 * subdiv_step2;\r\n                var pre5 = 6 * subdiv_step3;\r\n                var tmp1x = x1 - cx1 * 2 + cx2;\r\n                var tmp1y = y1 - cy1 * 2 + cy2;\r\n                var tmp2x = (cx1 - cx2) * 3 - x1 + x2;\r\n                var tmp2y = (cy1 - cy2) * 3 - y1 + y2;\r\n                var fx = x1;\r\n                var fy = y1;\r\n                var dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\r\n                var dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\r\n                var ddfx = tmp1x * pre4 + tmp2x * pre5;\r\n                var ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n                var dddfx = tmp2x * pre5;\r\n                var dddfy = tmp2y * pre5;\r\n                while (segments-- > 0) {\r\n                    this.vertex(fx, fy, color);\r\n                    fx += dfx;\r\n                    fy += dfy;\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    this.vertex(fx, fy, color);\r\n                }\r\n                this.vertex(fx, fy, color);\r\n                this.vertex(x2, y2, color);\r\n            };\r\n            ShapeRenderer.prototype.vertex = function (x, y, color) {\r\n                var idx = this.vertexIndex;\r\n                var vertices = this.mesh.getVertices();\r\n                vertices[idx++] = x;\r\n                vertices[idx++] = y;\r\n                vertices[idx++] = color.r;\r\n                vertices[idx++] = color.g;\r\n                vertices[idx++] = color.b;\r\n                vertices[idx++] = color.a;\r\n                this.vertexIndex = idx;\r\n            };\r\n            ShapeRenderer.prototype.end = function () {\r\n                if (!this.isDrawing)\r\n                    throw new Error(\"ShapeRenderer.begin() has not been called\");\r\n                this.flush();\r\n                this.context.gl.disable(this.context.gl.BLEND);\r\n                this.isDrawing = false;\r\n            };\r\n            ShapeRenderer.prototype.flush = function () {\r\n                if (this.vertexIndex == 0)\r\n                    return;\r\n                this.mesh.setVerticesLength(this.vertexIndex);\r\n                this.mesh.draw(this.shader, this.shapeType);\r\n                this.vertexIndex = 0;\r\n            };\r\n            ShapeRenderer.prototype.check = function (shapeType, numVertices) {\r\n                if (!this.isDrawing)\r\n                    throw new Error(\"ShapeRenderer.begin() has not been called\");\r\n                if (this.shapeType == shapeType) {\r\n                    if (this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)\r\n                        this.flush();\r\n                    else\r\n                        return;\r\n                }\r\n                else {\r\n                    this.flush();\r\n                    this.shapeType = shapeType;\r\n                }\r\n            };\r\n            ShapeRenderer.prototype.dispose = function () {\r\n                this.mesh.dispose();\r\n            };\r\n            return ShapeRenderer;\r\n        }());\r\n        webgl.ShapeRenderer = ShapeRenderer;\r\n        var ShapeType;\r\n        (function (ShapeType) {\r\n            ShapeType[ShapeType[\"Point\"] = 0] = \"Point\";\r\n            ShapeType[ShapeType[\"Line\"] = 1] = \"Line\";\r\n            ShapeType[ShapeType[\"Filled\"] = 4] = \"Filled\";\r\n        })(ShapeType = webgl.ShapeType || (webgl.ShapeType = {}));\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var SkeletonDebugRenderer = (function () {\r\n            function SkeletonDebugRenderer(context) {\r\n                this.boneLineColor = new spine.Color(1, 0, 0, 1);\r\n                this.boneOriginColor = new spine.Color(0, 1, 0, 1);\r\n                this.attachmentLineColor = new spine.Color(0, 0, 1, 0.5);\r\n                this.triangleLineColor = new spine.Color(1, 0.64, 0, 0.5);\r\n                this.pathColor = new spine.Color().setFromString(\"FF7F00\");\r\n                this.clipColor = new spine.Color(0.8, 0, 0, 2);\r\n                this.aabbColor = new spine.Color(0, 1, 0, 0.5);\r\n                this.drawBones = true;\r\n                this.drawRegionAttachments = true;\r\n                this.drawBoundingBoxes = true;\r\n                this.drawMeshHull = true;\r\n                this.drawMeshTriangles = true;\r\n                this.drawPaths = true;\r\n                this.drawSkeletonXY = false;\r\n                this.drawClipping = true;\r\n                this.premultipliedAlpha = false;\r\n                this.scale = 1;\r\n                this.boneWidth = 2;\r\n                this.bounds = new spine.SkeletonBounds();\r\n                this.temp = new Array();\r\n                this.vertices = spine.Utils.newFloatArray(2 * 1024);\r\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\r\n            }\r\n            SkeletonDebugRenderer.prototype.draw = function (shapes, skeleton, ignoredBones) {\r\n                if (ignoredBones === void 0) { ignoredBones = null; }\r\n                var skeletonX = skeleton.x;\r\n                var skeletonY = skeleton.y;\r\n                var gl = this.context.gl;\r\n                var srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;\r\n                shapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);\r\n                var bones = skeleton.bones;\r\n                if (this.drawBones) {\r\n                    shapes.setColor(this.boneLineColor);\r\n                    for (var i = 0, n = bones.length; i < n; i++) {\r\n                        var bone = bones[i];\r\n                        if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\r\n                            continue;\r\n                        if (bone.parent == null)\r\n                            continue;\r\n                        var x = skeletonX + bone.data.length * bone.a + bone.worldX;\r\n                        var y = skeletonY + bone.data.length * bone.c + bone.worldY;\r\n                        shapes.rectLine(true, skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, this.boneWidth * this.scale);\r\n                    }\r\n                    if (this.drawSkeletonXY)\r\n                        shapes.x(skeletonX, skeletonY, 4 * this.scale);\r\n                }\r\n                if (this.drawRegionAttachments) {\r\n                    shapes.setColor(this.attachmentLineColor);\r\n                    var slots = skeleton.slots;\r\n                    for (var i = 0, n = slots.length; i < n; i++) {\r\n                        var slot = slots[i];\r\n                        var attachment = slot.getAttachment();\r\n                        if (attachment instanceof spine.RegionAttachment) {\r\n                            var regionAttachment = attachment;\r\n                            var vertices = this.vertices;\r\n                            regionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n                            shapes.line(vertices[0], vertices[1], vertices[2], vertices[3]);\r\n                            shapes.line(vertices[2], vertices[3], vertices[4], vertices[5]);\r\n                            shapes.line(vertices[4], vertices[5], vertices[6], vertices[7]);\r\n                            shapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);\r\n                        }\r\n                    }\r\n                }\r\n                if (this.drawMeshHull || this.drawMeshTriangles) {\r\n                    var slots = skeleton.slots;\r\n                    for (var i = 0, n = slots.length; i < n; i++) {\r\n                        var slot = slots[i];\r\n                        if (!slot.bone.active)\r\n                            continue;\r\n                        var attachment = slot.getAttachment();\r\n                        if (!(attachment instanceof spine.MeshAttachment))\r\n                            continue;\r\n                        var mesh = attachment;\r\n                        var vertices = this.vertices;\r\n                        mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);\r\n                        var triangles = mesh.triangles;\r\n                        var hullLength = mesh.hullLength;\r\n                        if (this.drawMeshTriangles) {\r\n                            shapes.setColor(this.triangleLineColor);\r\n                            for (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {\r\n                                var v1 = triangles[ii] * 2, v2 = triangles[ii + 1] * 2, v3 = triangles[ii + 2] * 2;\r\n                                shapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);\r\n                            }\r\n                        }\r\n                        if (this.drawMeshHull && hullLength > 0) {\r\n                            shapes.setColor(this.attachmentLineColor);\r\n                            hullLength = (hullLength >> 1) * 2;\r\n                            var lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];\r\n                            for (var ii = 0, nn = hullLength; ii < nn; ii += 2) {\r\n                                var x = vertices[ii], y = vertices[ii + 1];\r\n                                shapes.line(x, y, lastX, lastY);\r\n                                lastX = x;\r\n                                lastY = y;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this.drawBoundingBoxes) {\r\n                    var bounds = this.bounds;\r\n                    bounds.update(skeleton, true);\r\n                    shapes.setColor(this.aabbColor);\r\n                    shapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\r\n                    var polygons = bounds.polygons;\r\n                    var boxes = bounds.boundingBoxes;\r\n                    for (var i = 0, n = polygons.length; i < n; i++) {\r\n                        var polygon = polygons[i];\r\n                        shapes.setColor(boxes[i].color);\r\n                        shapes.polygon(polygon, 0, polygon.length);\r\n                    }\r\n                }\r\n                if (this.drawPaths) {\r\n                    var slots = skeleton.slots;\r\n                    for (var i = 0, n = slots.length; i < n; i++) {\r\n                        var slot = slots[i];\r\n                        if (!slot.bone.active)\r\n                            continue;\r\n                        var attachment = slot.getAttachment();\r\n                        if (!(attachment instanceof spine.PathAttachment))\r\n                            continue;\r\n                        var path = attachment;\r\n                        var nn = path.worldVerticesLength;\r\n                        var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\r\n                        path.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n                        var color = this.pathColor;\r\n                        var x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;\r\n                        if (path.closed) {\r\n                            shapes.setColor(color);\r\n                            var cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];\r\n                            x2 = world[nn - 4];\r\n                            y2 = world[nn - 3];\r\n                            shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\r\n                            shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\r\n                            shapes.line(x1, y1, cx1, cy1);\r\n                            shapes.line(x2, y2, cx2, cy2);\r\n                        }\r\n                        nn -= 4;\r\n                        for (var ii = 4; ii < nn; ii += 6) {\r\n                            var cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];\r\n                            x2 = world[ii + 4];\r\n                            y2 = world[ii + 5];\r\n                            shapes.setColor(color);\r\n                            shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\r\n                            shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\r\n                            shapes.line(x1, y1, cx1, cy1);\r\n                            shapes.line(x2, y2, cx2, cy2);\r\n                            x1 = x2;\r\n                            y1 = y2;\r\n                        }\r\n                    }\r\n                }\r\n                if (this.drawBones) {\r\n                    shapes.setColor(this.boneOriginColor);\r\n                    for (var i = 0, n = bones.length; i < n; i++) {\r\n                        var bone = bones[i];\r\n                        if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\r\n                            continue;\r\n                        shapes.circle(true, skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer.GREEN, 8);\r\n                    }\r\n                }\r\n                if (this.drawClipping) {\r\n                    var slots = skeleton.slots;\r\n                    shapes.setColor(this.clipColor);\r\n                    for (var i = 0, n = slots.length; i < n; i++) {\r\n                        var slot = slots[i];\r\n                        if (!slot.bone.active)\r\n                            continue;\r\n                        var attachment = slot.getAttachment();\r\n                        if (!(attachment instanceof spine.ClippingAttachment))\r\n                            continue;\r\n                        var clip = attachment;\r\n                        var nn = clip.worldVerticesLength;\r\n                        var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\r\n                        clip.computeWorldVertices(slot, 0, nn, world, 0, 2);\r\n                        for (var i_16 = 0, n_2 = world.length; i_16 < n_2; i_16 += 2) {\r\n                            var x = world[i_16];\r\n                            var y = world[i_16 + 1];\r\n                            var x2 = world[(i_16 + 2) % world.length];\r\n                            var y2 = world[(i_16 + 3) % world.length];\r\n                            shapes.line(x, y, x2, y2);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            SkeletonDebugRenderer.prototype.dispose = function () {\r\n            };\r\n            SkeletonDebugRenderer.LIGHT_GRAY = new spine.Color(192 / 255, 192 / 255, 192 / 255, 1);\r\n            SkeletonDebugRenderer.GREEN = new spine.Color(0, 1, 0, 1);\r\n            return SkeletonDebugRenderer;\r\n        }());\r\n        webgl.SkeletonDebugRenderer = SkeletonDebugRenderer;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var Renderable = (function () {\r\n            function Renderable(vertices, numVertices, numFloats) {\r\n                this.vertices = vertices;\r\n                this.numVertices = numVertices;\r\n                this.numFloats = numFloats;\r\n            }\r\n            return Renderable;\r\n        }());\r\n        ;\r\n        var SkeletonRenderer = (function () {\r\n            function SkeletonRenderer(context, twoColorTint) {\r\n                if (twoColorTint === void 0) { twoColorTint = true; }\r\n                this.premultipliedAlpha = false;\r\n                this.vertexEffect = null;\r\n                this.tempColor = new spine.Color();\r\n                this.tempColor2 = new spine.Color();\r\n                this.vertexSize = 2 + 2 + 4;\r\n                this.twoColorTint = false;\r\n                this.renderable = new Renderable(null, 0, 0);\r\n                this.clipper = new spine.SkeletonClipping();\r\n                this.temp = new spine.Vector2();\r\n                this.temp2 = new spine.Vector2();\r\n                this.temp3 = new spine.Color();\r\n                this.temp4 = new spine.Color();\r\n                this.twoColorTint = twoColorTint;\r\n                if (twoColorTint)\r\n                    this.vertexSize += 4;\r\n                this.vertices = spine.Utils.newFloatArray(this.vertexSize * 1024);\r\n            }\r\n            SkeletonRenderer.prototype.draw = function (batcher, skeleton, slotRangeStart, slotRangeEnd) {\r\n                if (slotRangeStart === void 0) { slotRangeStart = -1; }\r\n                if (slotRangeEnd === void 0) { slotRangeEnd = -1; }\r\n                var clipper = this.clipper;\r\n                var premultipliedAlpha = this.premultipliedAlpha;\r\n                var twoColorTint = this.twoColorTint;\r\n                var blendMode = null;\r\n                var tempPos = this.temp;\r\n                var tempUv = this.temp2;\r\n                var tempLight = this.temp3;\r\n                var tempDark = this.temp4;\r\n                var renderable = this.renderable;\r\n                var uvs = null;\r\n                var triangles = null;\r\n                var drawOrder = skeleton.drawOrder;\r\n                var attachmentColor = null;\r\n                var skeletonColor = skeleton.color;\r\n                var vertexSize = twoColorTint ? 12 : 8;\r\n                var inRange = false;\r\n                if (slotRangeStart == -1)\r\n                    inRange = true;\r\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\r\n                    var clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\r\n                    var slot = drawOrder[i];\r\n                    if (!slot.bone.active) {\r\n                        clipper.clipEndWithSlot(slot);\r\n                        continue;\r\n                    }\r\n                    if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\r\n                        inRange = true;\r\n                    }\r\n                    if (!inRange) {\r\n                        clipper.clipEndWithSlot(slot);\r\n                        continue;\r\n                    }\r\n                    if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\r\n                        inRange = false;\r\n                    }\r\n                    var attachment = slot.getAttachment();\r\n                    var texture = null;\r\n                    if (attachment instanceof spine.RegionAttachment) {\r\n                        var region = attachment;\r\n                        renderable.vertices = this.vertices;\r\n                        renderable.numVertices = 4;\r\n                        renderable.numFloats = clippedVertexSize << 2;\r\n                        region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\r\n                        triangles = SkeletonRenderer.QUAD_TRIANGLES;\r\n                        uvs = region.uvs;\r\n                        texture = region.region.renderObject.texture;\r\n                        attachmentColor = region.color;\r\n                    }\r\n                    else if (attachment instanceof spine.MeshAttachment) {\r\n                        var mesh = attachment;\r\n                        renderable.vertices = this.vertices;\r\n                        renderable.numVertices = (mesh.worldVerticesLength >> 1);\r\n                        renderable.numFloats = renderable.numVertices * clippedVertexSize;\r\n                        if (renderable.numFloats > renderable.vertices.length) {\r\n                            renderable.vertices = this.vertices = spine.Utils.newFloatArray(renderable.numFloats);\r\n                        }\r\n                        mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\r\n                        triangles = mesh.triangles;\r\n                        texture = mesh.region.renderObject.texture;\r\n                        uvs = mesh.uvs;\r\n                        attachmentColor = mesh.color;\r\n                    }\r\n                    else if (attachment instanceof spine.ClippingAttachment) {\r\n                        var clip = (attachment);\r\n                        clipper.clipStart(slot, clip);\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        clipper.clipEndWithSlot(slot);\r\n                        continue;\r\n                    }\r\n                    if (texture != null) {\r\n                        var slotColor = slot.color;\r\n                        var finalColor = this.tempColor;\r\n                        finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\r\n                        finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\r\n                        finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\r\n                        finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n                        if (premultipliedAlpha) {\r\n                            finalColor.r *= finalColor.a;\r\n                            finalColor.g *= finalColor.a;\r\n                            finalColor.b *= finalColor.a;\r\n                        }\r\n                        var darkColor = this.tempColor2;\r\n                        if (slot.darkColor == null)\r\n                            darkColor.set(0, 0, 0, 1.0);\r\n                        else {\r\n                            if (premultipliedAlpha) {\r\n                                darkColor.r = slot.darkColor.r * finalColor.a;\r\n                                darkColor.g = slot.darkColor.g * finalColor.a;\r\n                                darkColor.b = slot.darkColor.b * finalColor.a;\r\n                            }\r\n                            else {\r\n                                darkColor.setFromColor(slot.darkColor);\r\n                            }\r\n                            darkColor.a = premultipliedAlpha ? 1.0 : 0.0;\r\n                        }\r\n                        var slotBlendMode = slot.data.blendMode;\r\n                        if (slotBlendMode != blendMode) {\r\n                            blendMode = slotBlendMode;\r\n                            batcher.setBlendMode(webgl.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl.WebGLBlendModeConverter.getDestGLBlendMode(blendMode));\r\n                        }\r\n                        if (clipper.isClipping()) {\r\n                            clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);\r\n                            var clippedVertices = new Float32Array(clipper.clippedVertices);\r\n                            var clippedTriangles = clipper.clippedTriangles;\r\n                            if (this.vertexEffect != null) {\r\n                                var vertexEffect = this.vertexEffect;\r\n                                var verts = clippedVertices;\r\n                                if (!twoColorTint) {\r\n                                    for (var v = 0, n_3 = clippedVertices.length; v < n_3; v += vertexSize) {\r\n                                        tempPos.x = verts[v];\r\n                                        tempPos.y = verts[v + 1];\r\n                                        tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n                                        tempUv.x = verts[v + 6];\r\n                                        tempUv.y = verts[v + 7];\r\n                                        tempDark.set(0, 0, 0, 0);\r\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                        verts[v] = tempPos.x;\r\n                                        verts[v + 1] = tempPos.y;\r\n                                        verts[v + 2] = tempLight.r;\r\n                                        verts[v + 3] = tempLight.g;\r\n                                        verts[v + 4] = tempLight.b;\r\n                                        verts[v + 5] = tempLight.a;\r\n                                        verts[v + 6] = tempUv.x;\r\n                                        verts[v + 7] = tempUv.y;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var v = 0, n_4 = clippedVertices.length; v < n_4; v += vertexSize) {\r\n                                        tempPos.x = verts[v];\r\n                                        tempPos.y = verts[v + 1];\r\n                                        tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n                                        tempUv.x = verts[v + 6];\r\n                                        tempUv.y = verts[v + 7];\r\n                                        tempDark.set(verts[v + 8], verts[v + 9], verts[v + 10], verts[v + 11]);\r\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                        verts[v] = tempPos.x;\r\n                                        verts[v + 1] = tempPos.y;\r\n                                        verts[v + 2] = tempLight.r;\r\n                                        verts[v + 3] = tempLight.g;\r\n                                        verts[v + 4] = tempLight.b;\r\n                                        verts[v + 5] = tempLight.a;\r\n                                        verts[v + 6] = tempUv.x;\r\n                                        verts[v + 7] = tempUv.y;\r\n                                        verts[v + 8] = tempDark.r;\r\n                                        verts[v + 9] = tempDark.g;\r\n                                        verts[v + 10] = tempDark.b;\r\n                                        verts[v + 11] = tempDark.a;\r\n                                    }\r\n                                }\r\n                            }\r\n                            batcher.draw(texture, clippedVertices, clippedTriangles);\r\n                        }\r\n                        else {\r\n                            var verts = renderable.vertices;\r\n                            if (this.vertexEffect != null) {\r\n                                var vertexEffect = this.vertexEffect;\r\n                                if (!twoColorTint) {\r\n                                    for (var v = 0, u = 0, n_5 = renderable.numFloats; v < n_5; v += vertexSize, u += 2) {\r\n                                        tempPos.x = verts[v];\r\n                                        tempPos.y = verts[v + 1];\r\n                                        tempUv.x = uvs[u];\r\n                                        tempUv.y = uvs[u + 1];\r\n                                        tempLight.setFromColor(finalColor);\r\n                                        tempDark.set(0, 0, 0, 0);\r\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                        verts[v] = tempPos.x;\r\n                                        verts[v + 1] = tempPos.y;\r\n                                        verts[v + 2] = tempLight.r;\r\n                                        verts[v + 3] = tempLight.g;\r\n                                        verts[v + 4] = tempLight.b;\r\n                                        verts[v + 5] = tempLight.a;\r\n                                        verts[v + 6] = tempUv.x;\r\n                                        verts[v + 7] = tempUv.y;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var v = 0, u = 0, n_6 = renderable.numFloats; v < n_6; v += vertexSize, u += 2) {\r\n                                        tempPos.x = verts[v];\r\n                                        tempPos.y = verts[v + 1];\r\n                                        tempUv.x = uvs[u];\r\n                                        tempUv.y = uvs[u + 1];\r\n                                        tempLight.setFromColor(finalColor);\r\n                                        tempDark.setFromColor(darkColor);\r\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                        verts[v] = tempPos.x;\r\n                                        verts[v + 1] = tempPos.y;\r\n                                        verts[v + 2] = tempLight.r;\r\n                                        verts[v + 3] = tempLight.g;\r\n                                        verts[v + 4] = tempLight.b;\r\n                                        verts[v + 5] = tempLight.a;\r\n                                        verts[v + 6] = tempUv.x;\r\n                                        verts[v + 7] = tempUv.y;\r\n                                        verts[v + 8] = tempDark.r;\r\n                                        verts[v + 9] = tempDark.g;\r\n                                        verts[v + 10] = tempDark.b;\r\n                                        verts[v + 11] = tempDark.a;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (!twoColorTint) {\r\n                                    for (var v = 2, u = 0, n_7 = renderable.numFloats; v < n_7; v += vertexSize, u += 2) {\r\n                                        verts[v] = finalColor.r;\r\n                                        verts[v + 1] = finalColor.g;\r\n                                        verts[v + 2] = finalColor.b;\r\n                                        verts[v + 3] = finalColor.a;\r\n                                        verts[v + 4] = uvs[u];\r\n                                        verts[v + 5] = uvs[u + 1];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    for (var v = 2, u = 0, n_8 = renderable.numFloats; v < n_8; v += vertexSize, u += 2) {\r\n                                        verts[v] = finalColor.r;\r\n                                        verts[v + 1] = finalColor.g;\r\n                                        verts[v + 2] = finalColor.b;\r\n                                        verts[v + 3] = finalColor.a;\r\n                                        verts[v + 4] = uvs[u];\r\n                                        verts[v + 5] = uvs[u + 1];\r\n                                        verts[v + 6] = darkColor.r;\r\n                                        verts[v + 7] = darkColor.g;\r\n                                        verts[v + 8] = darkColor.b;\r\n                                        verts[v + 9] = darkColor.a;\r\n                                    }\r\n                                }\r\n                            }\r\n                            var view = renderable.vertices.subarray(0, renderable.numFloats);\r\n                            batcher.draw(texture, view, triangles);\r\n                        }\r\n                    }\r\n                    clipper.clipEndWithSlot(slot);\r\n                }\r\n                clipper.clipEnd();\r\n            };\r\n            SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n            return SkeletonRenderer;\r\n        }());\r\n        webgl.SkeletonRenderer = SkeletonRenderer;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var Vector3 = (function () {\r\n            function Vector3(x, y, z) {\r\n                if (x === void 0) { x = 0; }\r\n                if (y === void 0) { y = 0; }\r\n                if (z === void 0) { z = 0; }\r\n                this.x = 0;\r\n                this.y = 0;\r\n                this.z = 0;\r\n                this.x = x;\r\n                this.y = y;\r\n                this.z = z;\r\n            }\r\n            Vector3.prototype.setFrom = function (v) {\r\n                this.x = v.x;\r\n                this.y = v.y;\r\n                this.z = v.z;\r\n                return this;\r\n            };\r\n            Vector3.prototype.set = function (x, y, z) {\r\n                this.x = x;\r\n                this.y = y;\r\n                this.z = z;\r\n                return this;\r\n            };\r\n            Vector3.prototype.add = function (v) {\r\n                this.x += v.x;\r\n                this.y += v.y;\r\n                this.z += v.z;\r\n                return this;\r\n            };\r\n            Vector3.prototype.sub = function (v) {\r\n                this.x -= v.x;\r\n                this.y -= v.y;\r\n                this.z -= v.z;\r\n                return this;\r\n            };\r\n            Vector3.prototype.scale = function (s) {\r\n                this.x *= s;\r\n                this.y *= s;\r\n                this.z *= s;\r\n                return this;\r\n            };\r\n            Vector3.prototype.normalize = function () {\r\n                var len = this.length();\r\n                if (len == 0)\r\n                    return this;\r\n                len = 1 / len;\r\n                this.x *= len;\r\n                this.y *= len;\r\n                this.z *= len;\r\n                return this;\r\n            };\r\n            Vector3.prototype.cross = function (v) {\r\n                return this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\r\n            };\r\n            Vector3.prototype.multiply = function (matrix) {\r\n                var l_mat = matrix.values;\r\n                return this.set(this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03], this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13], this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]);\r\n            };\r\n            Vector3.prototype.project = function (matrix) {\r\n                var l_mat = matrix.values;\r\n                var l_w = 1 / (this.x * l_mat[webgl.M30] + this.y * l_mat[webgl.M31] + this.z * l_mat[webgl.M32] + l_mat[webgl.M33]);\r\n                return this.set((this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03]) * l_w, (this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13]) * l_w, (this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]) * l_w);\r\n            };\r\n            Vector3.prototype.dot = function (v) {\r\n                return this.x * v.x + this.y * v.y + this.z * v.z;\r\n            };\r\n            Vector3.prototype.length = function () {\r\n                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n            };\r\n            Vector3.prototype.distance = function (v) {\r\n                var a = v.x - this.x;\r\n                var b = v.y - this.y;\r\n                var c = v.z - this.z;\r\n                return Math.sqrt(a * a + b * b + c * c);\r\n            };\r\n            return Vector3;\r\n        }());\r\n        webgl.Vector3 = Vector3;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n    var webgl;\r\n    (function (webgl) {\r\n        var ManagedWebGLRenderingContext = (function () {\r\n            function ManagedWebGLRenderingContext(canvasOrContext, contextConfig) {\r\n                var _this = this;\r\n                if (contextConfig === void 0) { contextConfig = { alpha: \"true\" }; }\r\n                this.restorables = new Array();\r\n                if (canvasOrContext instanceof HTMLCanvasElement) {\r\n                    var canvas_1 = canvasOrContext;\r\n                    this.gl = (canvas_1.getContext(\"webgl2\", contextConfig) || canvas_1.getContext(\"webgl\", contextConfig));\r\n                    this.canvas = canvas_1;\r\n                    canvas_1.addEventListener(\"webglcontextlost\", function (e) {\r\n                        var event = e;\r\n                        if (e) {\r\n                            e.preventDefault();\r\n                        }\r\n                    });\r\n                    canvas_1.addEventListener(\"webglcontextrestored\", function (e) {\r\n                        for (var i = 0, n = _this.restorables.length; i < n; i++) {\r\n                            _this.restorables[i].restore();\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    this.gl = canvasOrContext;\r\n                    this.canvas = this.gl.canvas;\r\n                }\r\n            }\r\n            ManagedWebGLRenderingContext.prototype.addRestorable = function (restorable) {\r\n                this.restorables.push(restorable);\r\n            };\r\n            ManagedWebGLRenderingContext.prototype.removeRestorable = function (restorable) {\r\n                var index = this.restorables.indexOf(restorable);\r\n                if (index > -1)\r\n                    this.restorables.splice(index, 1);\r\n            };\r\n            return ManagedWebGLRenderingContext;\r\n        }());\r\n        webgl.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;\r\n        var WebGLBlendModeConverter = (function () {\r\n            function WebGLBlendModeConverter() {\r\n            }\r\n            WebGLBlendModeConverter.getDestGLBlendMode = function (blendMode) {\r\n                switch (blendMode) {\r\n                    case spine.BlendMode.Normal: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n                    case spine.BlendMode.Additive: return WebGLBlendModeConverter.ONE;\r\n                    case spine.BlendMode.Multiply: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n                    case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\r\n                    default: throw new Error(\"Unknown blend mode: \" + blendMode);\r\n                }\r\n            };\r\n            WebGLBlendModeConverter.getSourceGLBlendMode = function (blendMode, premultipliedAlpha) {\r\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\r\n                switch (blendMode) {\r\n                    case spine.BlendMode.Normal: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\r\n                    case spine.BlendMode.Additive: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\r\n                    case spine.BlendMode.Multiply: return WebGLBlendModeConverter.DST_COLOR;\r\n                    case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE;\r\n                    default: throw new Error(\"Unknown blend mode: \" + blendMode);\r\n                }\r\n            };\r\n            WebGLBlendModeConverter.ZERO = 0;\r\n            WebGLBlendModeConverter.ONE = 1;\r\n            WebGLBlendModeConverter.SRC_COLOR = 0x0300;\r\n            WebGLBlendModeConverter.ONE_MINUS_SRC_COLOR = 0x0301;\r\n            WebGLBlendModeConverter.SRC_ALPHA = 0x0302;\r\n            WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA = 0x0303;\r\n            WebGLBlendModeConverter.DST_ALPHA = 0x0304;\r\n            WebGLBlendModeConverter.ONE_MINUS_DST_ALPHA = 0x0305;\r\n            WebGLBlendModeConverter.DST_COLOR = 0x0306;\r\n            return WebGLBlendModeConverter;\r\n        }());\r\n        webgl.WebGLBlendModeConverter = WebGLBlendModeConverter;\r\n    })(webgl = spine.webgl || (spine.webgl = {}));\r\n})(spine || (spine = {}));\r\n//# sourceMappingURL=spine-both.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = spine;\n}.call(window));"],"sourceRoot":""}