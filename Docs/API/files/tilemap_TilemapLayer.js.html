<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>tilemap\TilemapLayer.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AnimationManager.html">AnimationManager</a></li>
            
                <li><a href="../classes/AssetLoader.html">AssetLoader</a></li>
            
                <li><a href="../classes/BaseTexture.html">BaseTexture</a></li>
            
                <li><a href="../classes/BitmapFontLoader.html">BitmapFontLoader</a></li>
            
                <li><a href="../classes/BitmapText.html">BitmapText</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/CanvasGraphics.html">CanvasGraphics</a></li>
            
                <li><a href="../classes/CanvasRenderer.html">CanvasRenderer</a></li>
            
                <li><a href="../classes/Circle.html">Circle</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/CustomRenderable.html">CustomRenderable</a></li>
            
                <li><a href="../classes/DebugUtils.html">DebugUtils</a></li>
            
                <li><a href="../classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="../classes/DisplayObjectContainer.html">DisplayObjectContainer</a></li>
            
                <li><a href="../classes/Ellipse.html">Ellipse</a></li>
            
                <li><a href="../classes/EventTarget.html">EventTarget</a></li>
            
                <li><a href="../classes/Frame.html">Frame</a></li>
            
                <li><a href="../classes/FrameData.html">FrameData</a></li>
            
                <li><a href="../classes/Graphics.html">Graphics</a></li>
            
                <li><a href="../classes/ImageLoader.html">ImageLoader</a></li>
            
                <li><a href="../classes/JsonLoader.html">JsonLoader</a></li>
            
                <li><a href="../classes/MovieClip.html">MovieClip</a></li>
            
                <li><a href="../classes/Phaser.Animation.html">Phaser.Animation</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Polygon.html">Polygon</a></li>
            
                <li><a href="../classes/PolyK._convex.html">PolyK._convex</a></li>
            
                <li><a href="../classes/PolyK._PointInTriangle.html">PolyK._PointInTriangle</a></li>
            
                <li><a href="../classes/PolyK.AjaxRequest.html">PolyK.AjaxRequest</a></li>
            
                <li><a href="../classes/PolyK.InteractionData.html">PolyK.InteractionData</a></li>
            
                <li><a href="../classes/PolyK.InteractionManager.html">PolyK.InteractionManager</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/RenderTexture.html">RenderTexture</a></li>
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/SoundManager.html">SoundManager</a></li>
            
                <li><a href="../classes/Spine.html">Spine</a></li>
            
                <li><a href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a href="../classes/SpriteSheetLoader.html">SpriteSheetLoader</a></li>
            
                <li><a href="../classes/Stage.html">Stage</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/TilingSprite.html">TilingSprite</a></li>
            
                <li><a href="../classes/Time.html">Time</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/WebGLBatch.html">WebGLBatch</a></li>
            
                <li><a href="../classes/WebGLRenderer.html">WebGLRenderer</a></li>
            
                <li><a href="../classes/World.html">World</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Phaser.html">Phaser</a></li>
            
                <li><a href="../modules/Phaser.Animation.html">Phaser.Animation</a></li>
            
                <li><a href="../modules/Phaser.Animation.FrameData.html">Phaser.Animation.FrameData</a></li>
            
                <li><a href="../modules/Phaser.Button.html">Phaser.Button</a></li>
            
                <li><a href="../modules/Phaser.Camera.html">Phaser.Camera</a></li>
            
                <li><a href="../modules/Phaser.Canvas.html">Phaser.Canvas</a></li>
            
                <li><a href="../modules/Phaser.Stage.html">Phaser.Stage</a></li>
            
                <li><a href="../modules/Phaser.Time.html">Phaser.Time</a></li>
            
                <li><a href="../modules/Phaser.Utils.html">Phaser.Utils</a></li>
            
                <li><a href="../modules/Phaser.World.html">Phaser.World</a></li>
            
                <li><a href="../modules/PIXI.html">PIXI</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: tilemap\TilemapLayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Phaser - TilemapLayer
*
* A Tilemap Layer. Tiled format maps can have multiple overlapping layers.
*/

/**
* TilemapLayer constructor
* Create a new &lt;code&gt;TilemapLayer&lt;/code&gt;.
*
* @param parent {Tilemap} The tilemap that contains this layer.
* @param id {number} The ID of this layer within the Tilemap array.
* @param key {string} Asset key for this map.
* @param mapFormat {number} Format of this map data, available: Tilemap.CSV or Tilemap.JSON.
* @param name {string} Name of this layer, so you can get this layer by its name.
* @param tileWidth {number} Width of tiles in this map.
* @param tileHeight {number} Height of tiles in this map.
*/
Phaser.TilemapLayer = function (parent, id, key, mapFormat, name, tileWidth, tileHeight) {

    /**
    * Controls whether update() and draw() are automatically called.
    * @type {bool}
    */
    this.exists = true;

    /**
    * Controls whether draw() are automatically called.
    * @type {bool}
    */
    this.visible = true;

    /**
    * How many tiles in each row.
    * Read-only variable, do NOT recommend changing after the map is loaded!
    * @type {number}
    */
    this.widthInTiles = 0;

    /**
    * How many tiles in each column.
    * Read-only variable, do NOT recommend changing after the map is loaded!
    * @type {number}
    */
    this.heightInTiles = 0;

    /**
    * Read-only variable, do NOT recommend changing after the map is loaded!
    * @type {number}
    */
    this.widthInPixels = 0;

    /**
    * Read-only variable, do NOT recommend changing after the map is loaded!
    * @type {number}
    */
    this.heightInPixels = 0;

    /**
    * Distance between REAL tiles to the tileset texture bound.
    * @type {number}
    */
    this.tileMargin = 0;

    /**
    * Distance between every 2 neighbor tile in the tileset texture.
    * @type {number}
    */
    this.tileSpacing = 0;

    this.parent = parent;
    this.game = parent.game;
    this.ID = id;
    this.name = name;
    this.key = key;
    this.type = Phaser.TILEMAPLAYER;

    this.mapFormat = mapFormat;
    this.tileWidth = tileWidth;
    this.tileHeight = tileHeight;

    this.boundsInTiles = new Phaser.Rectangle();

    var map = this.game.cache.getTilemap(key);

    this.tileset = map.data;

    this._alpha = 1;

    this.canvas = null;
    this.context = null;
    this.baseTexture = null;
    this.texture = null;
    this.sprite = null;

    this.mapData = [];
    this._tempTileBlock = [];
    this._tempBlockResults = [];

};

Phaser.TilemapLayer.prototype = {

	/**
    * Set a specific tile with its x and y in tiles.
    * @param x {number} X position of this tile in world coordinates.
    * @param y {number} Y position of this tile in world coordinates.
    * @param index {number} The index of this tile type in the core map data.
    */
    putTileWorldXY: function (x, y, index) {

        x = this.game.math.snapToFloor(x, this.tileWidth) / this.tileWidth;
        y = this.game.math.snapToFloor(y, this.tileHeight) / this.tileHeight;

        if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length)
        {
            if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length)
            {
                this.mapData[y][x] = index;
            }
        }

    },

	/**
    * Set a specific tile with its x and y in tiles.
    * @param x {number} X position of this tile.
    * @param y {number} Y position of this tile.
    * @param index {number} The index of this tile type in the core map data.
    */
    putTile: function (x, y, index) {

        if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length)
        {
            if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length)
            {
                this.mapData[y][x] = index;
            }
        }

    },

	/**
    * Swap tiles with 2 kinds of indexes.
    * @param tileA {number} First tile index.
    * @param tileB {number} Second tile index.
    * @param [x] {number} specify a Rectangle of tiles to operate. The x position in tiles of Rectangle&#x27;s left-top corner.
    * @param [y] {number} specify a Rectangle of tiles to operate. The y position in tiles of Rectangle&#x27;s left-top corner.
    * @param [width] {number} specify a Rectangle of tiles to operate. The width in tiles.
    * @param [height] {number} specify a Rectangle of tiles to operate. The height in tiles.
    */
    swapTile: function (tileA, tileB, x, y, width, height) {

        x = x || 0;
        y = y || 0;
        width = width || this.widthInTiles;
        height = height || this.heightInTiles;
        
        this.getTempBlock(x, y, width, height);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            //  First sweep marking tileA as needing a new index
            if (this._tempTileBlock[r].tile.index == tileA)
            {
                this._tempTileBlock[r].newIndex = true;
            }

            //  In the same pass we can swap tileB to tileA
            if (this._tempTileBlock[r].tile.index == tileB)
            {
                this.mapData[this._tempTileBlock[r].y][this._tempTileBlock[r].x] = tileA;
            }
        }

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            //  And now swap our newIndex tiles for tileB
            if (this._tempTileBlock[r].newIndex == true)
            {
                this.mapData[this._tempTileBlock[r].y][this._tempTileBlock[r].x] = tileB;
            }
        }

    },

	/**
    * Fill a tile block with a specific tile index.
    * @param index {number} Index of tiles you want to fill with.
    * @param [x] {number} x position (in tiles) of block&#x27;s left-top corner.
    * @param [y] {number} y position (in tiles) of block&#x27;s left-top corner.
    * @param [width] {number} width of block.
    * @param [height] {number} height of block.
    */
    fillTile: function (index, x, y, width, height) {

        x = x || 0;
        y = y || 0;
        width = width || this.widthInTiles;
        height = height || this.heightInTiles;

        this.getTempBlock(x, y, width, height);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            this.mapData[this._tempTileBlock[r].y][this._tempTileBlock[r].x] = index;
        }

    },

	/**
    * Set random tiles to a specific tile block.
    * @param tiles {number[]} Tiles with indexes in this array will be randomly set to the given block.
    * @param [x] {number} x position (in tiles) of block&#x27;s left-top corner.
    * @param [y] {number} y position (in tiles) of block&#x27;s left-top corner.
    * @param [width] {number} width of block.
    * @param [height] {number} height of block.
    */
    randomiseTiles: function (tiles, x, y, width, height) {

        x = x || 0;
        y = y || 0;
        width = width || this.widthInTiles;
        height = height || this.heightInTiles;

        this.getTempBlock(x, y, width, height);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            this.mapData[this._tempTileBlock[r].y][this._tempTileBlock[r].x] = this.game.math.getRandom(tiles);
        }

    },

	/**
    * Replace one kind of tiles to another kind.
    * @param tileA {number} Index of tiles you want to replace.
    * @param tileB {number} Index of tiles you want to set.
    * @param [x] {number} x position (in tiles) of block&#x27;s left-top corner.
    * @param [y] {number} y position (in tiles) of block&#x27;s left-top corner.
    * @param [width] {number} width of block.
    * @param [height] {number} height of block.
    */
    replaceTile: function (tileA, tileB, x, y, width, height) {

        x = x || 0;
        y = y || 0;
        width = width || this.widthInTiles;
        height = height || this.heightInTiles;

        this.getTempBlock(x, y, width, height);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            if (this._tempTileBlock[r].tile.index == tileA)
            {
                this.mapData[this._tempTileBlock[r].y][this._tempTileBlock[r].x] = tileB;
            }
        }

    },

	/**
    * Get a tile block with specific position and size.(both are in tiles)
    * @param x {number} X position of block&#x27;s left-top corner.
    * @param y {number} Y position of block&#x27;s left-top corner.
    * @param width {number} Width of block.
    * @param height {number} Height of block.
    */
    getTileBlock: function (x, y, width, height) {

        var output = [];

        this.getTempBlock(x, y, width, height);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            output.push({
                x: this._tempTileBlock[r].x,
                y: this._tempTileBlock[r].y,
                tile: this._tempTileBlock[r].tile
            });
        }

        return output;

    },

	/**
    * Get a tile with specific position (in world coordinate). (thus you give a position of a point which is within the tile)
    * @param x {number} X position of the point in target tile.
    * @param x {number} Y position of the point in target tile.
    */
    getTileFromWorldXY: function (x, y) {

        x = Phaser.Math.snapToFloor(x, this.tileWidth) / this.tileWidth;
        y = Phaser.Math.snapToFloor(y, this.tileHeight) / this.tileHeight;

        return this.getTileIndex(x, y);

    },

	/**
    * Get tiles overlaps the given object.
    * @param object {GameObject} Tiles you want to get that overlaps this.
    * @return {array} Array with tiles informations. (Each contains x, y and the tile.)
    */
    getTileOverlaps: function (object) {

        this._tempBlockResults.length = 0;

        //  If the object is outside of the world coordinates then abort the check (tilemap has to exist within world bounds)
        if (object.body.x &lt; 0 || object.body.x &gt; this.widthInPixels || object.body.y &lt; 0 || object.body.bottom &gt; this.heightInPixels)
        {
            return this._tempBlockResults;
        }

        //  What tiles do we need to check against?
        this._tempTileX = this.game.math.snapToFloor(object.body.x, this.tileWidth) / this.tileWidth;
        this._tempTileY = this.game.math.snapToFloor(object.body.y, this.tileHeight) / this.tileHeight;
        this._tempTileW = (this.game.math.snapToCeil(object.body.width, this.tileWidth) + this.tileWidth) / this.tileWidth;
        this._tempTileH = (this.game.math.snapToCeil(object.body.height, this.tileHeight) + this.tileHeight) / this.tileHeight;

        //  Loop through the tiles we&#x27;ve got and check overlaps accordingly (the results are stored in this._tempTileBlock)
        this.getTempBlock(this._tempTileX, this._tempTileY, this._tempTileW, this._tempTileH, true);

        for (var r = 0; r &lt; this._tempTileBlock.length; r++)
        {
            //  separateTile: function (object, x, y, width, height, mass, collideLeft, collideRight, collideUp, collideDown, separateX, separateY)            
            if (this.game.physics.separateTile(object, this._tempTileBlock[r].x * this.tileWidth, this._tempTileBlock[r].y * this.tileHeight, this.tileWidth, this.tileHeight, this._tempTileBlock[r].tile.mass, this._tempTileBlock[r].tile.collideLeft, this._tempTileBlock[r].tile.collideRight, this._tempTileBlock[r].tile.collideUp, this._tempTileBlock[r].tile.collideDown, this._tempTileBlock[r].tile.separateX, this._tempTileBlock[r].tile.separateY))
            {
                this._tempBlockResults.push({ x: this._tempTileBlock[r].x, y: this._tempTileBlock[r].y, tile: this._tempTileBlock[r].tile });
            }
        }

        return this._tempBlockResults;

    },

	/**
    * Get a tile block with its position and size. (This method does not return, it&#x27;ll set result to _tempTileBlock)
    * @param x {number} X position of block&#x27;s left-top corner.
    * @param y {number} Y position of block&#x27;s left-top corner.
    * @param width {number} Width of block.
    * @param height {number} Height of block.
    * @param collisionOnly {bool} Whethor or not ONLY return tiles which will collide (its allowCollisions value is not Collision.NONE).
    */
    getTempBlock: function (x, y, width, height, collisionOnly) {

        if (typeof collisionOnly === &quot;undefined&quot;) { collisionOnly = false; }

        if (x &lt; 0)
        {
            x = 0;
        }

        if (y &lt; 0)
        {
            y = 0;
        }

        if (width &gt; this.widthInTiles)
        {
            width = this.widthInTiles;
        }

        if (height &gt; this.heightInTiles)
        {
            height = this.heightInTiles;
        }

        this._tempTileBlock = [];

        for (var ty = y; ty &lt; y + height; ty++)
        {
            for (var tx = x; tx &lt; x + width; tx++)
            {
                if (collisionOnly)
                {
                    //  We only want to consider the tile for checking if you can actually collide with it
                    if (this.mapData[ty] &amp;&amp; this.mapData[ty][tx] &amp;&amp; this.parent.tiles[this.mapData[ty][tx]].collideNone == false)
                    {
                        this._tempTileBlock.push({
                            x: tx,
                            y: ty,
                            tile: this.parent.tiles[this.mapData[ty][tx]]
                        });
                    }
                }
                else
                {
                    if (this.mapData[ty] &amp;&amp; this.mapData[ty][tx])
                    {
                        this._tempTileBlock.push({
                            x: tx,
                            y: ty,
                            tile: this.parent.tiles[this.mapData[ty][tx]]
                        });
                    }
                }
            }
        }
    },

	/**
    * Get the tile index of specific position (in tiles).
    * @param x {number} X position of the tile.
    * @param y {number} Y position of the tile.
    * @return {number} Index of the tile at that position. Return null if there isn&#x27;t a tile there.
    */
    getTileIndex: function (x, y) {

        if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length)
        {
            if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length)
            {
                return this.mapData[y][x];
            }
        }

        return null;

    },

	/**
    * Add a column of tiles into the layer.
    * @param column {string[]/number[]} An array of tile indexes to be added.
    */
    addColumn: function (column) {

        var data = [];

        for (var c = 0; c &lt; column.length; c++)
        {
            data[c] = parseInt(column[c]);
        }

        if (this.widthInTiles == 0)
        {
            this.widthInTiles = data.length;
            this.widthInPixels = this.widthInTiles * this.tileWidth;
        }

        this.mapData.push(data);

        this.heightInTiles++;
        this.heightInPixels += this.tileHeight;

    },

    createCanvas: function () {

        var width = this.game.width;
        var height = this.game.height;

        if (this.widthInPixels &lt; width)
        {
            width = this.widthInPixels;
        }

        if (this.heightInPixels &lt; height)
        {
            height = this.heightInPixels;
        }

        this.canvas = Phaser.Canvas.create(width, height);
        this.context = this.canvas.getContext(&#x27;2d&#x27;);

        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.sprite = new PIXI.Sprite(this.texture);

        this.parent.addChild(this.sprite);

    },

	/**
    * Update boundsInTiles with widthInTiles and heightInTiles.
    */
    updateBounds: function () {

        this.boundsInTiles.setTo(0, 0, this.widthInTiles, this.heightInTiles);

    },

	/**
    * Parse tile offsets from map data.
    * Basically this creates a large array of objects that contain the x/y coordinates to grab each tile from
    * for the entire map. Yes we could calculate this at run-time by using the tile index and some math, but we&#x27;re
    * trading a quite small bit of memory here to not have to process that in our main render loop.
    * @return {number} length of tileOffsets array.
    */
    parseTileOffsets: function () {

        this.tileOffsets = [];

        var i = 0;

        if (this.mapFormat == Phaser.Tilemap.JSON)
        {
            //  For some reason Tiled counts from 1 not 0
            this.tileOffsets[0] = null;
            i = 1;
        }

        for (var ty = this.tileMargin; ty &lt; this.tileset.height; ty += (this.tileHeight + this.tileSpacing))
        {
            for (var tx = this.tileMargin; tx &lt; this.tileset.width; tx += (this.tileWidth + this.tileSpacing))
            {
                this.tileOffsets[i] = {
                    x: tx,
                    y: ty
                };
                i++;
            }
        }

        return this.tileOffsets.length;

    }

};

Object.defineProperty(Phaser.TilemapLayer.prototype, &#x27;alpha&#x27;, {

    get: function() {
        return this._alpha;
    },

    set: function(value) {

        if (this.sprite)
        {
            this.sprite.alpha = value;
        }
        
        this._alpha = value;
    }

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
