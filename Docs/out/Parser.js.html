<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Phaser Source: animation/Parser.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top navbar-inverse">
		<div class="navbar-inner">
			<a class="brand" href="index.html">Phaser</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="module-Phaser.html">Phaser</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="Phaser.Animation.html">Animation</a>
						</li>
						
						<li>
							<a href="Phaser.Animation.Frame.html">Frame</a>
						</li>
						
						<li>
							<a href="Phaser.Animation.FrameData.html">FrameData</a>
						</li>
						
						<li>
							<a href="Phaser.Animation.Parser.html">Parser</a>
						</li>
						
						<li>
							<a href="Phaser.AnimationManager.html">AnimationManager</a>
						</li>
						
						<li>
							<a href="Phaser.Cache.html">Cache</a>
						</li>
						
						<li>
							<a href="Phaser.Camera.html">Camera</a>
						</li>
						
						<li>
							<a href="Phaser.Circle.html">Circle</a>
						</li>
						
						<li>
							<a href="Phaser.Game.html">Game</a>
						</li>
						
						<li>
							<a href="Phaser.Group.html">Group</a>
						</li>
						
						<li>
							<a href="Phaser.Input.html">Input</a>
						</li>
						
						<li>
							<a href="Phaser.InputHandler.html">InputHandler</a>
						</li>
						
						<li>
							<a href="Phaser.Key.html">Key</a>
						</li>
						
						<li>
							<a href="Phaser.Keyboard.html">Keyboard</a>
						</li>
						
						<li>
							<a href="Phaser.LinkedList.html">LinkedList</a>
						</li>
						
						<li>
							<a href="Phaser.Loader.html">Loader</a>
						</li>
						
						<li>
							<a href="Phaser.Loader.Parser.html">Parser</a>
						</li>
						
						<li>
							<a href="Phaser.Math.html">Math</a>
						</li>
						
						<li>
							<a href="Phaser.Mouse.html">Mouse</a>
						</li>
						
						<li>
							<a href="Phaser.MSPointer.html">MSPointer</a>
						</li>
						
						<li>
							<a href="Phaser.Plugin.html">Plugin</a>
						</li>
						
						<li>
							<a href="Phaser.PluginManager.html">PluginManager</a>
						</li>
						
						<li>
							<a href="Phaser.Point.html">Point</a>
						</li>
						
						<li>
							<a href="Phaser.Pointer.html">Pointer</a>
						</li>
						
						<li>
							<a href="Phaser.QuadTree.html">QuadTree</a>
						</li>
						
						<li>
							<a href="Phaser.RandomDataGenerator.html">RandomDataGenerator</a>
						</li>
						
						<li>
							<a href="Phaser.Rectangle.html">Rectangle</a>
						</li>
						
						<li>
							<a href="Phaser.Signal.html">Signal</a>
						</li>
						
						<li>
							<a href="Phaser.Stage.html">Stage</a>
						</li>
						
						<li>
							<a href="Phaser.State.html">State</a>
						</li>
						
						<li>
							<a href="Phaser.StateManager.html">StateManager</a>
						</li>
						
						<li>
							<a href="Phaser.Touch.html">Touch</a>
						</li>
						
						<li>
							<a href="Phaser.World.html">World</a>
						</li>
						
						<li>
							<a href="SignalBinding.html">SignalBinding</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: animation/Parser.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">/**
* @author       Richard Davey &lt;rich@photonstorm.com>
* @copyright    2013 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.
*
* @class Phaser.Animation.Parser
*/
Phaser.Animation.Parser = {

    /**
    * Parse a Sprite Sheet and extract the animation frame data from it.
    *
    * @method Phaser.Animation.Parser.spriteSheet
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {string} key - The Game.Cache asset key of the Sprite Sheet image.
    * @param {number} frameWidth - The fixed width of each frame of the animation.
    * @param {number} frameHeight - The fixed height of each frame of the animation.
    * @param {number} [frameMax=-1] - The total number of animation frames to extact from the Sprite Sheet. The default value of -1 means "extract all frames".
    * @return {Phaser.Animation.FrameData} A FrameData object containing the parsed frames.
    */
    spriteSheet: function (game, key, frameWidth, frameHeight, frameMax) {

        //  How big is our image?
        var img = game.cache.getImage(key);

        if (img == null)
        {
            return null;
        }

        var width = img.width;
        var height = img.height;

        if (frameWidth &lt;= 0)
        {
            frameWidth = Math.floor(-width / Math.min(-1, frameWidth));
        }

        if (frameHeight &lt;= 0)
        {
            frameHeight = Math.floor(-height / Math.min(-1, frameHeight));
        }

        var row = Math.round(width / frameWidth);
        var column = Math.round(height / frameHeight);
        var total = row * column;
        
        if (frameMax !== -1)
        {
            total = frameMax;
        }

        //  Zero or smaller than frame sizes?
        if (width == 0 || height == 0 || width &lt; frameWidth || height &lt; frameHeight || total === 0)
        {
            console.warn("Phaser.Animation.Parser.spriteSheet: width/height zero or width/height &lt; given frameWidth/frameHeight");
            return null;
        }

        //  Let's create some frames then
        var data = new Phaser.Animation.FrameData();
        var x = 0;
        var y = 0;

        for (var i = 0; i &lt; total; i++)
        {
            var uuid = game.rnd.uuid();

            data.addFrame(new Phaser.Animation.Frame(i, x, y, frameWidth, frameHeight, '', uuid));

            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                x: x,
                y: y,
                width: frameWidth,
                height: frameHeight
            });

            x += frameWidth;

            if (x === width)
            {
                x = 0;
                y += frameHeight;
            }
        }

        return data;

    },

    /**
    * Parse the JSON data and extract the animation frame data from it.
    *
    * @method Phaser.Animation.Parser.JSONData
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {Object} json - The JSON data from the Texture Atlas. Must be in Array format.
    * @param {string} cacheKey - The Game.Cache asset key of the texture image.
    * @return {Phaser.Animation.FrameData} A FrameData object containing the parsed frames.
    */
    JSONData: function (game, json, cacheKey) {

        //  Malformed?
        if (!json['frames'])
        {
            console.warn("Phaser.Animation.Parser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
            console.log(json);
            return;
        }

        //  Let's create some frames then
        var data = new Phaser.Animation.FrameData();
        
        //  By this stage frames is a fully parsed array
        var frames = json['frames'];
        var newFrame;
        
        for (var i = 0; i &lt; frames.length; i++)
        {
            var uuid = game.rnd.uuid();

            newFrame = data.addFrame(new Phaser.Animation.Frame(
                i,
            	frames[i].frame.x, 
            	frames[i].frame.y, 
            	frames[i].frame.w, 
            	frames[i].frame.h, 
            	frames[i].filename,
                uuid
			));

            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                x: frames[i].frame.x,
                y: frames[i].frame.y,
                width: frames[i].frame.w,
                height: frames[i].frame.h
            });

            if (frames[i].trimmed)
            {
                newFrame.setTrim(
                    frames[i].trimmed, 
                    frames[i].sourceSize.w, 
                    frames[i].sourceSize.h, 
                    frames[i].spriteSourceSize.x, 
                    frames[i].spriteSourceSize.y, 
                    frames[i].spriteSourceSize.w, 
                    frames[i].spriteSourceSize.h
                );

                //  We had to hack Pixi to get this to work :(
                PIXI.TextureCache[uuid].trimmed = true;
                PIXI.TextureCache[uuid].trim.x = frames[i].spriteSourceSize.x;
                PIXI.TextureCache[uuid].trim.y = frames[i].spriteSourceSize.y;

            }
        }

        return data;

    },

    /**
    * Parse the JSON data and extract the animation frame data from it.
    *
    * @method Phaser.Animation.Parser.JSONDataHash
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {Object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.
    * @param {string} cacheKey - The Game.Cache asset key of the texture image.
    * @return {Phaser.Animation.FrameData} A FrameData object containing the parsed frames.
    */
    JSONDataHash: function (game, json, cacheKey) {

        //  Malformed?
        if (!json['frames'])
        {
            console.warn("Phaser.Animation.Parser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
            console.log(json);
            return;
        }
            
        //  Let's create some frames then
        var data = new Phaser.Animation.FrameData();

        //  By this stage frames is a fully parsed array
        var frames = json['frames'];
        var newFrame;
        var i = 0;
        
        for (var key in frames)
        {
            var uuid = game.rnd.uuid();

            newFrame = data.addFrame(new Phaser.Animation.Frame(
                i,
                frames[key].frame.x, 
                frames[key].frame.y, 
                frames[key].frame.w, 
                frames[key].frame.h, 
                key,
                uuid
            ));

            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                x: frames[key].frame.x,
                y: frames[key].frame.y,
                width: frames[key].frame.w,
                height: frames[key].frame.h
            });

            if (frames[key].trimmed)
            {
                newFrame.setTrim(
                    frames[key].trimmed, 
                    frames[key].sourceSize.w, 
                    frames[key].sourceSize.h, 
                    frames[key].spriteSourceSize.x, 
                    frames[key].spriteSourceSize.y, 
                    frames[key].spriteSourceSize.w, 
                    frames[key].spriteSourceSize.h
                );

                //  We had to hack Pixi to get this to work :(
                PIXI.TextureCache[uuid].trimmed = true;
                PIXI.TextureCache[uuid].trim.x = frames[key].spriteSourceSize.x;
                PIXI.TextureCache[uuid].trim.y = frames[key].spriteSourceSize.y;

            }

            i++;
        }

        return data;

    },

    /**
    * Parse the XML data and extract the animation frame data from it.
    *
    * @method Phaser.Animation.Parser.XMLData
    * @param {Phaser.Game} game - A reference to the currently running game.
    * @param {Object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.
    * @param {string} cacheKey - The Game.Cache asset key of the texture image.
    * @return {Phaser.Animation.FrameData} A FrameData object containing the parsed frames.
    */
    XMLData: function (game, xml, cacheKey) {

        //  Malformed?
        if (!xml.getElementsByTagName('TextureAtlas'))
        {
            console.warn("Phaser.Animation.Parser.XMLData: Invalid Texture Atlas XML given, missing &lt;TextureAtlas> tag");
            return;
        }

        //  Let's create some frames then
        var data = new Phaser.Animation.FrameData();
        var frames = xml.getElementsByTagName('SubTexture');
        var newFrame;
        
        for (var i = 0; i &lt; frames.length; i++)
        {
            var uuid = game.rnd.uuid();

            var frame = frames[i].attributes;

            newFrame = data.addFrame(new Phaser.Animation.Frame(
                i,
            	frame.x.nodeValue, 
            	frame.y.nodeValue, 
            	frame.width.nodeValue, 
            	frame.height.nodeValue, 
            	frame.name.nodeValue,
                uuid
            ));

            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                x: frame.x.nodeValue,
                y: frame.y.nodeValue,
                width: frame.width.nodeValue,
                height: frame.height.nodeValue
            });

            //  Trimmed?
            if (frame.frameX.nodeValue != '-0' || frame.frameY.nodeValue != '-0')
            {
                newFrame.setTrim(
                	true, 
                	frame.width.nodeValue, 
                	frame.height.nodeValue, 
                	Math.abs(frame.frameX.nodeValue), 
                	Math.abs(frame.frameY.nodeValue), 
                	frame.frameWidth.nodeValue, 
                	frame.frameHeight.nodeValue
                );

                PIXI.TextureCache[uuid].realSize = {
                    x: Math.abs(frame.frameX.nodeValue),
                    y: Math.abs(frame.frameY.nodeValue),
                    w: frame.frameWidth.nodeValue,
                    h: frame.frameHeight.nodeValue
                };

                //  We had to hack Pixi to get this to work :(
                PIXI.TextureCache[uuid].trimmed = true;
                PIXI.TextureCache[uuid].trim.x = Math.abs(frame.frameX.nodeValue);
                PIXI.TextureCache[uuid].trim.y = Math.abs(frame.frameY.nodeValue);

            }
        }

        return data;

    }

};
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		Phaser Copyright © 2012-2013 Photon Storm Ltd.
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a>
		on Wed Oct 02 2013 15:04:47 GMT+0100 (BST) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
