module.exports = [
    '#define SHADER_NAME GRADIENT_FS',
    '#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))',
    '#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))',
    '#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)',
    'precision mediump float;',
    'uniform sampler2D uMainSampler;',
    'uniform vec2 positionFrom;',
    'uniform vec2 positionTo;',
    'uniform vec3 color1;',
    'uniform vec3 color2;',
    'uniform float alpha;',
    'uniform int size;',
    'varying vec2 outTexCoord;',
    'float gradientNoise(in vec2 uv)',
    '{',
    '    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);',
    '    return fract(magic.z * fract(dot(uv, magic.xy)));',
    '}',
    'float stepped (in float s, in float scale, in int steps)',
    '{',
    '    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / float(steps - 1) : s;',
    '}',
    'void main ()',
    '{',
    '    vec2 a = positionFrom;',
    '    vec2 b = positionTo;',
    '    vec2 ba = b - a;',
    '    float d = dot(outTexCoord - a, ba) / dot(ba, ba);',
    '    float t = size > 0 ? stepped(d, 1.0, size) : d;',
    '    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));',
    '    vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);',
    '    color = LINEAR_TO_SRGB(color);',
    '    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 255.0);',
    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',
    '    gl_FragColor = vec4(mix(color.rgb, texture.rgb, alpha), 1.0) * texture.a;',
    '}',
].join('\n');
